■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
환경
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■



# 1. 자바 버전

C:\Users\ljkoy>java -version

openjdk version "17.0.11" 2024-04-16
OpenJDK Runtime Environment Temurin-17.0.11+9 (build 17.0.11+9)
OpenJDK 64-Bit Server VM Temurin-17.0.11+9 (build 17.0.11+9, mixed mode, sharing)






■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
vcpkg 설치
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


# 짜잘한 설명 없이. 간략하게 정리합니다.


# vcpkg 다운로드

cd C:\Users\ljkoy\Desktop\Github_clone\antlr4_test
git clone https://github.com/microsoft/vcpkg.git

# 부트스트랩 실행

cd vcpkg
.\bootstrap-vcpkg.bat






## 2. SqlParserLib 프로젝트 설정 확인 (⚠️ 중요)

**Visual Studio 설정 경로:**
`프로젝트` → `속성` → `구성 속성` → `C/C++` → `코드 생성(Code Generation)` → `런타임 라이브러리(Runtime Library)`

### 런타임 라이브러리 설정 비교표
# 현재 SqlParserLib 프로젝트는 /MDd 방식 채택중

| **다중 스레드 DLL (/MD, /MDd)** | MFC 기본값. DLL 공유 사용     | `x64-windows` (또는 `x86-windows`) |
| **다중 스레드 (/MT, /MTd)**     | Static Link. 실행 파일에 포함 | `x64-windows-static` |



#### Case A: 프로젝트가 /MD (DLL) 설정인 경우 (권장) ( 노트북에서 실행 시, 시간 매우 오래걸렸음 )

.\vcpkg install antlr4:x64-windows


#### Case B: 프로젝트가 /MT (Static) 설정인 경우

.\vcpkg install antlr4:x64-windows-static



### 3.2 Visual Studio 통합 (Integrate)
# Visual Studio가 설치된 라이브러리를 자동으로 인식하도록 연결합니다. (최초 1회만 수행)

.\vcpkg integrate install


**성공 메시지:**
# Applied user-wide integration for this vcpkg root.











### 4.1 SQLParserLib MFC 프로젝트 포함 디렉터리 설정 (Include Path)
# `프로젝트 속성` → `C/C++` → `일반` → `추가 포함 디렉터리`

[vcpkg설치경로]\installed\x64-windows\include\antlr4-runtime
예) $(SolutionDir)vcpkg\installed\x64-windows\include\antlr4-runtime



### 4.2 C++ 언어 표준 설정
# 프로젝트 속성` → `C/C++` → `언어` → `C++ 언어 표준`

**값 변경:**
 ISO C++17 표준(/std:c++17)


 
### 4.3 Windows 매크로 충돌 해결 (코드 수정)

Windows/MFC의 `min`, `max`, `ERROR` 매크로가 ANTLR와 충돌하므로, ANTLR 헤더를 포함하기 전에 반드시 해제해야 합니다.

**사용 예시 (Dlg.cpp 또는 Proxy Header):**

# cpp 에 추가 

#include "pch.h"

# ... MFC 관련 헤더들 ...
# [중요] ANTLR 헤더 포함 전 매크로 해제

#undef min
#undef max
#undef ERROR
#undef NO_ERROR

#include <antlr4-runtime.h>  // 또는 <antlr4-runtime/antlr4-runtime.h>


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
Grammer 를 사용하여 cpp, h 파일 생성
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

# 3. grammer.f4 파일 다운로드 

Lexer와 Parser 둘 다 필요합니다: 
대부분의 SQL 문법은 파일이 두 개(xxxLexer.g4, xxxParser.g4)로 나뉘어 있습니다.
하나만 있으면 안 되니 꼭 두 파일 모두 다운로드하세요.

# 공통 사용 경로 
# /antlr/grammars-v4/tree/master/sql

Oracle (PL/SQL) 👉 https://github.com/antlr/grammars-v4/tree/master/sql/plsql

다운로드 대상: PlSqlLexer.g4, PlSqlParser.g4 (둘 다 받으세요)

MS SQL Server (T-SQL) 👉 https://github.com/antlr/grammars-v4/tree/master/sql/tsql

다운로드 대상: TSqlLexer.g4, TSqlParser.g4

MySQL 👉 https://github.com/antlr/grammars-v4/tree/master/sql/mysql


주의: 이 폴더 안에 들어가면 Oracle 버전과 Positive-Technologies 버전 폴더가 또 있습니다. 보통 Oracle 폴더 안에 있는 것이 공식에 가깝습니다.

https://github.com/antlr/grammars-v4/tree/master/sql/mysql/Oracle


PostgreSQL 👉 https://github.com/antlr/grammars-v4/tree/master/sql/postgresql

다운로드 대상: PostgreSQLLexer.g4, PostgreSQLParser.g4




 
# 4. grammer.g4 파일을 이용한 빌드 



DB 종류,지원 여부,사용할 파일 (.g4),설명

Oracle,     ✅ 완벽,    plsql,가장 활발히 관리됨. 거의 완벽 지원.
SQL Server, ✅ 완벽,    tsql,Microsoft T-SQL 문법. 매우 잘 되어 있음.
MySQL,      ✅ 완벽,    mysql,Oracle MySQL 버전 기준.
PostgreSQL, ✅ 완벽,    postgresql,매우 상세하게 구현되어 있음.
Tibero,     ⚠️ 대체,    plsql (Oracle),티베로는 오라클 호환성이 목표인 DB라 plsql 문법을 쓰면 95% 이상 파싱됩니다.
Sybase ASE, ⚠️ 대체,    tsql (MSSQL),Sybase와 MSSQL은 뿌리가 같습니다. tsql 문법을 쓰면 대부분 호환됩니다.
Vertica,    ⚠️ 대체,    postgresql,Vertica는 포스트그레 기반입니다. postgresql 문법을 수정해서 써야 합니다.
Sybase IQ,  ❌ 없음,    tsql + 수정,ASE와 달리 분석형이라 문법이 조금 다릅니다. tsql을 기반으로 수정이 필요합니다.
DB2,        ❌ 없음,    (직접 구현),의외로 공개된 완벽한 ANTLR4 문법이 없습니다. (부분적인 자료만 존재)
Altibase,   ❌ 없음,    (직접 구현),국산 DB라 해외 리포지토리에 없습니다. 표준 SQL 문법을 기반으로 만들어야 합니다.







# 1. 파라미터,의미,상세 설명

-Dlanguage=Cpp, 
대상 언어 설정,ANTLR4는 기본적으로 Java 코드를 생성합니다. C++ 프로젝트에서 사용하기 위해 타겟 언어를 **C++**로 지정하는 핵심 옵션입니다.

-package
네임스페이스 설정,C++에서는 이 옵션에 지정된 이름(antlrcpptest)이 **namespace**로 사용됩니다. 생성된 클래스들이 이 네임스페이스 안에 묶이게 됩니다.

-no-listener
리스너 생성 제외,기본적으로 생성되는 Listener(구문 트리를 자동 탐색하며 진입/퇴출 이벤트를 발생시키는 방식) 파일을 만들지 않겠다는 뜻입니다.

-visitor
비지터 생성 활성화,Visitor(개발자가 직접 트리의 노드를 방문하는 순서를 제어하는 방식) 인터페이스와 기본 클래스를 생성합니다. 보통 C++에서는 리스너보다 비지터를 
선호합니다.

-o
출력 디렉터리,"생성된 파일(.h, .cpp, .tokens 등)이 저장될 폴더를 지정합니다. 여기서는 mysql_gen 폴더에 모이게 됩니다."


# 2. 추가로 사용할 수 있는 유용한 파라미터
상황에 따라 빌드 스크립트에 추가하면 유용한 옵션들입니다.

-lib <directory>: 분리된 문법 파일(.g4)이나 .tokens 파일이 다른 폴더에 있을 때 해당 경로를 알려줍니다. (Lexer와 Parser를 별도 폴더에서 관리할 때 필수)

-atn: 문법의 상태 머신인 ATN을 시각화할 수 있는 .dot 파일을 생성합니다. (문법이 왜 꼬이는지 디버깅할 때 유용합니다.)

-encoding <encoding>: 문법 파일의 인코딩을 지정합니다. (기본값은 UTF-8입니다.)

-Werror: 경고(Warning)가 발생하면 에러로 간주하고 파일을 생성하지 않습니다. 코드 품질을 엄격하게 관리할 때 사용합니다.

-depend: 빌드 도구(Make, CMake 등)에서 사용할 수 있도록 문법 파일 간의 의존성 관계를 출력합니다.

-Xlog: ANTLR 툴이 실행되는 동안의 상세한 로그를 남깁니다. (내부 오류 발생 시 확인용)






# 일괄 생성 예제코드 

cd H:\Source\GithubDesktop\antlr4_test\Grammer
h:

cd C:\Users\ljkoy\Desktop\Github_clone\antlr4_test\Grammer




java -jar antlr-4.13.2-complete.jar -Dlanguage=Cpp  -package antlrcpp_oracle -no-listener -visitor -o oracle_gen PlSqlLexer.g4
java -jar antlr-4.13.2-complete.jar -Dlanguage=Cpp  -package antlrcpp_oracle -no-listener -visitor -o oracle_gen PlSqlParser.g4

		  
java -jar antlr-4.13.2-complete.jar -Dlanguage=Cpp --package antlrcpp_sqlserver no-listener -visitor -o sqlserver_gen TSqlLexer.g4
java -jar antlr-4.13.2-complete.jar -Dlanguage=Cpp -package antlrcpp_sqlserver -no-listener -visitor -o sqlserver_gen TSqlParser.g4
		  		  
		  
java -jar antlr-4.13.2-complete.jar -Dlanguage=Cpp -package antlrcpp_mysql -no-listener -visitor -o mysql_gen MySQLLexer.g4
java -jar antlr-4.13.2-complete.jar -Dlanguage=Cpp -package antlrcpp_mysql -no-listener -visitor -o mysql_gen MySQLParser.g4
		  
		  
java -jar antlr-4.13.2-complete.jar -Dlanguage=Cpp -package antlrcpp_postgresql -no-listener -visitor -o postgres_gen PostgreSQLLexer.g4
java -jar antlr-4.13.2-complete.jar -Dlanguage=Cpp -package antlrcpp_postgresql -no-listener -visitor -o postgres_gen PostgreSQLParser.g4






■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
SQLParserLib 빌드 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


# 2. 구현 가이드 (Step-by-Step)


1단계: 파서 전용 프로젝트 ( SQLParserLib ) 만들기

- 구성속성 -> 일반 -> 구성 형식 ( 정적 라이브러리(.lib) ) 
- 구성속성 -> 일반 -> C++ 언어표준 ( C++ 17 )
- C/C++ -> 미리 컴파일된 헤더 -> 미리 컴파일된 헤더 ( 체크 해제 )
- C/C++ -> 코드 생성 -> 다중 스레드 디버그 DLL(/MDd) , 다중 스레드 DLL(/MD)
- C/C++ -> 일반 -> 추가 포함 디렉터리

# 아래 잘 참고해서 추가 하세요

# ⚠️ 중요 옵션 추가: PL/SQL 파서가 너무 커서 컴파일러가 뻗을 수 있습니다.
C/C++ -> 명령줄(Command Line) -> 추가 옵션에 아래 입력   (이거 안 하면 C1128 에러 남)
/bigobj


<AdditionalIncludeDirectories>
$(ProjectDir)Source\Oracle;
$(ProjectDir)Source\SQLServer;
$(ProjectDir)Source\MySQL;
$(ProjectDir)Source\PostgreSQL;
$(SolutionDir)vcpkg\installed\x64-windows\include\antlr4-runtime
</AdditionalIncludeDirectories>

2단계: 생성된 파일 옮기기

1단계 에서 설정한 파일들 ( (Oracle, TSQL, MySQL, PG)의 .h, .cpp 파일들 ) 
몽땅 SqlParserLib 프로젝트 폴더로 옮기고 추가합니다.


* 구현된 파일은 아래 명령어로 생성한 cpp ,h 파일과 
Github 에서 제공하는 각 DB별 base 파일이 추가로 필요합니다. 




# 아래 명령으로 생성된 파일 , Github 에서 가져온 파일들을 SQLParserLib 프로젝트 내에 MySQL 용으로 Merge 하여야 합니다. 


# Github 에서 제공되는 Base 파일들 ( MySQL ) 

C:\Users\ljkoy\Downloads\antlr4 빌드를 위한 베이스코드\mysql\Oracle\Cpp>tree /f
p31 nvme 1tb 볼륨에 대한 폴더 경로의 목록입니다.
볼륨 일련 번호는 6A55-4636입니다.
C:.
    MySQLLexerBase.cpp
    MySQLLexerBase.h
    MySQLParserBase.cpp
    MySQLParserBase.h
    SqlMode.h
    SqlModes.cpp
    SqlModes.h
    transformGrammar.py

# 그외 다른 DB base 코드 위치 (예시)
# sqlserver (tsql) 은 CPP용 타겟파일 없었음 

C:\Users\ljkoy\Downloads\antlr4 빌드를 위한 베이스코드\plsql\Cpp
C:\Users\ljkoy\Downloads\antlr4 빌드를 위한 베이스코드\tsql\
C:\Users\ljkoy\Downloads\antlr4 빌드를 위한 베이스코드\mysql\Oracle\Cpp>
C:\Users\ljkoy\Downloads\antlr4 빌드를 위한 베이스코드\postgresql\Cpp







# jar 파일로 생성되는 파일들  ( MySQL ) 

java -jar antlr-4.13.2-complete.jar ....
java -jar antlr-4.13.2-complete.jar ....


C:\Users\ljkoy\Desktop\Github_clone\antlr4_test\Grammer\mysql_gen>tree /f
p31 nvme 1tb 볼륨에 대한 폴더 경로의 목록입니다.
볼륨 일련 번호는 6A55-4636입니다.
C:.
    MySQLLexer.cpp
    MySQLLexer.h
    MySQLLexer.interp
    MySQLLexer.tokens
    MySQLParser.cpp
    MySQLParser.h
    MySQLParser.interp
    MySQLParser.tokens
    MySQLParserBaseVisitor.cpp
    MySQLParserBaseVisitor.h
    MySQLParserVisitor.cpp
    MySQLParserVisitor.h


# 그외 jar 파일로 생성되는 파일들 ( 예시 ) 

C:\Users\ljkoy\Desktop\Github_clone\antlr4_test\Grammer\oracle_gen>
C:\Users\ljkoy\Desktop\Github_clone\antlr4_test\Grammer\sqlserver_gen>
C:\Users\ljkoy\Desktop\Github_clone\antlr4_test\Grammer\mysql_gen>
C:\Users\ljkoy\Desktop\Github_clone\antlr4_test\Grammer\postgresql_gen>



 
# 실제로 필요한 파일들 전부 ( MySQL ) 

C:\Users\ljkoy\Desktop\Github_clone\antlr4_test\SqlParserLib\Source\MySQL>tree /f
p31 nvme 1tb 볼륨에 대한 폴더 경로의 목록입니다.
볼륨 일련 번호는 6A55-4636입니다.
C:.
    MySQLLexer.cpp
    MySQLLexer.h
    MySQLLexer.interp
    MySQLLexer.tokens
    MySQLLexerBase.cpp
    MySQLLexerBase.h
    MySQLParser.cpp
    MySQLParser.h
    MySQLParser.interp
    MySQLParser.tokens
    MySQLParserBase.cpp
    MySQLParserBase.h
    MySQLParserBaseVisitor.cpp
    MySQLParserBaseVisitor.h
    MySQLParserVisitor.cpp
    MySQLParserVisitor.h
    SqlMode.h
    SqlModes.cpp
    SqlModes.h
    transformGrammar.py


# 일부 코드 수정 
 - Lexer,  Parser등 프로젝트에서 base.h 를 따로 인클루드 해줘야 할수있음 
   
  예)  #include "PlSqlLexerBase.h"
class  PlSqlLexer : public PlSqlLexerBase {

 - this. 으로 처리되었는데 CPP 에서는 this-> 으로 변경해주어야 사용가능


# package 옵션 사용시 일부 소스 코드에 아래 처리 추가해야 합니다.

# 1. 최상단을 namespace로 묶기
namespace antlrcpp_mysql {
}

# 2. 소스코드 부분에 using namespace antlrcpp_mysql; 선언하기


 using namespace antlrcpp_oracle; 선언하기
  using namespace antlrcpp_sqlserver; 선언하기
   using namespace antlrcpp_mysql; 선언하기
    using namespace antlrcpp_postgresql; 선언하기


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
메인 MFC 대화상자 프로젝트 ( ANTLR4TEST 프로젝트 ) 설정
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


# ANTLR4TEST 프로젝트 속성 설정 


- C/C++ -> 일반 -> 추가 포함 디렉터리

# 예전꺼
$(SolutionDir)SqlParserLib\Source;$(SolutionDir)vcpkg\installed\x64-windows\include\antlr4-runtime;








# (공통 사용 헤더파일인 ) antlrproxy.h 에 아래내용 추가 ( MySQL 만 작업된 상태인 경우 )  

#pragma once

// 1. Windows 매크로 충돌 방지
#undef min
#undef max
#undef ERROR
#undef NO_ERROR

// 2. ANTLR 런타임 헤더
#include <antlr4-runtime.h>

// 3. 부모 클래스들 (Base 클래스)
#include "MySQL/MySQLLexerBase.h"
#include "MySQL/MySQLParserBase.h"

// 4. 렉서와 파서 (반드시 Parser가 Visitor보다 먼저!)
#include "MySQL/MySQLLexer.h"
#include "MySQL/MySQLParser.h"

// 5. 비지터 (필요한 경우에만 Parser 뒤에 위치)
// 주의: Parser.h가 완전히 정의된 후에만 Visitor를 포함해야 합니다.
#include "MySQL/MySQLParserVisitor.h"
#include "MySQL/MySQLParserBaseVisitor.h"


# 1. CPP 에 코드 추가 

// 모든 ANTLR 관련 설정은 이 하나로 끝냅니다.
#include "../Common/Include/AntlrProxy.h"

// 네임스페이스 사용
using namespace antlr4;
using namespace antlrcpptest;



# 1.2 임의 테스트 코드 ( 미완성  )

void CANTLR4TESTDlg::OnBnClickedButtonParse()
{
	// 1. UI에서 SQL 가져오기

	CString strInput;
	GetDlgItemText(IDC_EDIT_SQL, strInput);

	// CString -> std::string 변환 (ANTLR는 std::string을 씁니다)
	std::string sqlQuery = CT2A(strInput);

	if (sqlQuery.empty()) {
		AfxMessageBox(_T("SQL을 입력해주세요."));
		return;
	}

	try {
		// 2. ANTLR 파이프라인 구축
		ANTLRInputStream input(sqlQuery);

		// Lexer (토큰 분리)
		MySQLLexer lexer(&input);
		CommonTokenStream tokens(&lexer);

		// Parser (구조 분석)
		MySQLParser parser(&tokens);

		// [중요] 에러 리스너 설정 (콘솔 에러 방지)
		parser.removeErrorListeners();
		// 필요하면 커스텀 에러 리스너를 추가할 수 있습니다.

		// 3. 파싱 시작 (MySQL 문법의 최상위 규칙 호출)
		// 보통 'query', 'root', 'sqlStatements' 등이 최상위입니다.
		// MySQLParser.h를 열어보면 최상위 함수를 알 수 있습니다. 
		// 여기서는 예시로 'query()' 또는 'root()'를 가정합니다.

		// ★ .g4 파일 확인 결과 MySQL 최상위는 보통 'query' 또는 'sqlStatements' 입니다.
		// 자동완성으로 parser. 치고 나오는 함수 중 가장 그럴싸한 것을 고르세요.
		MySQLParser::QueryContext* tree = parser.query();

		// 4. 결과 확인
		size_t errorCount = parser.getNumberOfSyntaxErrors();

		if (errorCount == 0)
		{
			std::string s = tree->toStringTree(&parser);
			CStringA sTraceA = s.c_str();
			CString sTrace = (CString)sTraceA;

			AddTraceLog(sTrace);
		}
		else
		{
			std::string s = tree->toStringTree(&parser);
			CStringA sTraceA = s.c_str();

			CString sTrace;
			sTrace.Format(_T("파싱 실패..\n오류 개수: %d"), errorCount);
			AddTraceLog(sTrace);
		}
	}
	catch (const std::exception& e) {
		// C++ 표준 예외 처리
		CString msg;
		msg.Format(_T("Exception 발생: %s"), CString(e.what()));
		AfxMessageBox(msg);
	}
	catch (...) {
		AfxMessageBox(_T("알 수 없는 에러 발생"));
	}
}

void CANTLR4TESTDlg::AddTraceLog(LPCTSTR lpszFormat, ...)
{
	// 1. 가변 인자 문자열 구성
	CString strLog;
	va_list args;
	va_start(args, lpszFormat);
	strLog.FormatV(lpszFormat, args);
	va_end(args);

	strLog += _T("\r\n");

	// 2. 컨트롤 포인터 가져오기 및 안전성 검사
	CEdit* pEditTrace = (CEdit*)GetDlgItem(IDC_EDIT_TRACE);
	if (pEditTrace == nullptr) return; // 컨트롤을 찾을 수 없으면 중단

	// 3. 커서를 마지막 위치로 이동
	int nLength = pEditTrace->GetWindowTextLength();
	pEditTrace->SetSel(nLength, nLength);

	// 4. 선택 영역에 텍스트 삽입
	pEditTrace->ReplaceSel(strLog);

	// 5. 스크롤을 마지막으로 이동 (WM_ 추가)
	pEditTrace->SendMessage(WM_VSCROLL, SB_BOTTOM, NULL);
}




