
// Generated from PlSqlParser.g4 by ANTLR 4.13.2

#pragma once


#include "antlr4-runtime.h"




class  PlSqlParser : public PlSqlParserBase {
public:
  enum {
    ABORT = 1, ABS = 2, ABSENT = 3, ACCESS = 4, ACCESSED = 5, ACCESSIBLE = 6, 
    ACCOUNT = 7, ACL = 8, ACOS = 9, ACROSS = 10, ACTION = 11, ACTIONS = 12, 
    ACTIVATE = 13, ACTIVE = 14, ACTIVE_COMPONENT = 15, ACTIVE_DATA = 16, 
    ACTIVE_FUNCTION = 17, ACTIVE_TAG = 18, ACTIVITY = 19, ADAPTIVE_PLAN = 20, 
    ADD = 21, ADD_COLUMN = 22, ADD_GROUP = 23, ADD_MONTHS = 24, ADJ_DATE = 25, 
    ADMIN = 26, ADMINISTER = 27, ADMINISTRATOR = 28, ADVANCED = 29, ADVISE = 30, 
    ADVISOR = 31, AFD_DISKSTRING = 32, AFTER = 33, AGENT = 34, AGGREGATE = 35, 
    A_LETTER = 36, ALIAS = 37, ALL = 38, ALLOCATE = 39, ALLOW = 40, ALL_ROWS = 41, 
    ALTER = 42, ALTERNATE = 43, ALWAYS = 44, ANALYTIC = 45, ANALYZE = 46, 
    ANCESTOR = 47, ANCILLARY = 48, AND = 49, AND_EQUAL = 50, ANNOTATIONS = 51, 
    ANOMALY = 52, ANSI_REARCH = 53, ANTIJOIN = 54, ANY = 55, ANYSCHEMA = 56, 
    APPEND = 57, APPENDCHILDXML = 58, APPEND_VALUES = 59, APPLICATION = 60, 
    APPLY = 61, APPROX_COUNT_DISTINCT = 62, ARCHIVAL = 63, ARCHIVE = 64, 
    ARCHIVED = 65, ARCHIVELOG = 66, ARE = 67, ARRAY = 68, AS = 69, ASC = 70, 
    ASCII = 71, ASCIISTR = 72, ASIN = 73, ASIS = 74, ASSEMBLY = 75, ASSIGN = 76, 
    ASSOCIATE = 77, ASYNC = 78, ASYNCHRONOUS = 79, ATAN2 = 80, ATAN = 81, 
    AT = 82, ATTRIBUTE = 83, ATTRIBUTES = 84, AUDIT = 85, AUTHENTICATED = 86, 
    AUTHENTICATION = 87, AUTHID = 88, AUTHORIZATION = 89, AUTOALLOCATE = 90, 
    AUTO = 91, AUTOBACKUP = 92, AUTOEXTEND = 93, AUTO_LOGIN = 94, AUTOMATIC = 95, 
    AUTONOMOUS_TRANSACTION = 96, AUTO_REOPTIMIZE = 97, AVAILABILITY = 98, 
    AVRO = 99, BACKGROUND = 100, BACKINGFILE = 101, BACKUP = 102, BACKUPS = 103, 
    BACKUPSET = 104, BADFILE = 105, BASIC = 106, BASICFILE = 107, BATCH = 108, 
    BATCHSIZE = 109, BATCH_TABLE_ACCESS_BY_ROWID = 110, BECOME = 111, BEFORE = 112, 
    BEGIN = 113, BEGINNING = 114, BEGIN_OUTLINE_DATA = 115, BEHALF = 116, 
    BEQUEATH = 117, BETWEEN = 118, BFILE = 119, BFILENAME = 120, BIG = 121, 
    BIGFILE = 122, BIGINT = 123, BINARY = 124, BINARY_DOUBLE = 125, BINARY_DOUBLE_INFINITY = 126, 
    BINARY_DOUBLE_NAN = 127, BINARY_FLOAT = 128, BINARY_FLOAT_INFINITY = 129, 
    BINARY_FLOAT_NAN = 130, BINARY_INTEGER = 131, BIND_AWARE = 132, BINDING = 133, 
    BIN_TO_NUM = 134, BITAND = 135, BITMAP_AND = 136, BITMAP = 137, BITMAPS = 138, 
    BITMAP_TREE = 139, BITS = 140, BLANKS = 141, BLOB = 142, BLOCK = 143, 
    BLOCK_RANGE = 144, BLOCKS = 145, BLOCKSIZE = 146, BODY = 147, BOOLEAN = 148, 
    BOTH = 149, BOUND = 150, BRANCH = 151, BREADTH = 152, BROADCAST = 153, 
    BSON = 154, BUFFER = 155, BUFFER_CACHE = 156, BUFFER_POOL = 157, BUILD = 158, 
    BULK = 159, BY = 160, BYPASS_RECURSIVE_CHECK = 161, BYPASS_UJVC = 162, 
    BYTE = 163, BYTES = 164, BYTEORDERMARK = 165, CACHE = 166, CACHE_CB = 167, 
    CACHE_INSTANCES = 168, CACHE_TEMP_TABLE = 169, CACHING = 170, CALCULATED = 171, 
    CALLBACK = 172, CALL = 173, CANCEL = 174, CANONICAL = 175, CAPACITY = 176, 
    CAPTION = 177, CARDINALITY = 178, CASCADE = 179, CASE = 180, CAST = 181, 
    CASESENSITIVE = 182, CATEGORY = 183, CDBDEFAULT = 184, CEIL = 185, CELL_FLASH_CACHE = 186, 
    CERTIFICATE = 187, CFILE = 188, CHAINED = 189, CHANGE = 190, CHANGETRACKING = 191, 
    CHANGE_DUPKEY_ERROR_INDEX = 192, CHARACTER = 193, CHARACTERS = 194, 
    CHARACTERSET = 195, CHAR = 196, CHAR_CS = 197, CHARTOROWID = 198, CHECK_ACL_REWRITE = 199, 
    CHECK = 200, CHECKPOINT = 201, CHILD = 202, CHOOSE = 203, CHR = 204, 
    CHUNK = 205, CLASS = 206, CLASSIFICATION = 207, CLASSIFIER = 208, CLAUSE = 209, 
    CLEAN = 210, CLEANUP = 211, CLEAR = 212, C_LETTER = 213, CLIENT = 214, 
    CLOB = 215, CLONE = 216, CLOSE_CACHED_OPEN_CURSORS = 217, CLOSE = 218, 
    CLUSTER_BY_ROWID = 219, CLUSTER = 220, CLUSTER_DETAILS = 221, CLUSTER_DISTANCE = 222, 
    CLUSTER_ID = 223, CLUSTERING = 224, CLUSTERING_FACTOR = 225, CLUSTER_PROBABILITY = 226, 
    CLUSTER_SET = 227, COALESCE = 228, COALESCE_SQ = 229, COARSE = 230, 
    CO_AUTH_IND = 231, COLD = 232, COLLECT = 233, COLLECTION = 234, COLUMNAR = 235, 
    COLUMN_AUTH_INDICATOR = 236, COLUMN = 237, COLUMNS = 238, COLUMN_STATS = 239, 
    COLUMN_VALUE = 240, COMMENT = 241, COMMIT = 242, COMMITTED = 243, COMMON = 244, 
    COMMON_DATA = 245, COMPACT = 246, COMPATIBLE = 247, COMPATIBILITY = 248, 
    COMPILE = 249, COMPLETE = 250, COMPLIANCE = 251, COMPONENT = 252, COMPONENTS = 253, 
    COMPOSE = 254, COMPOSITE = 255, COMPOSITE_LIMIT = 256, COMPOUND = 257, 
    COMPRESS = 258, COMPRESSION = 259, COMPUTE = 260, CONCAT = 261, CON_DBID_TO_ID = 262, 
    CONDITIONAL = 263, CONDITION = 264, CONFIRM = 265, CONFORMING = 266, 
    CON_GUID_TO_ID = 267, CON_ID = 268, CON_NAME_TO_ID = 269, CONNECT_BY_CB_WHR_ONLY = 270, 
    CONNECT_BY_COMBINE_SW = 271, CONNECT_BY_COST_BASED = 272, CONNECT_BY_ELIM_DUPS = 273, 
    CONNECT_BY_FILTERING = 274, CONNECT_BY_ISCYCLE = 275, CONNECT_BY_ISLEAF = 276, 
    CONNECT_BY_ROOT = 277, CONNECT = 278, CONNECT_TIME = 279, CONSIDER = 280, 
    CONSISTENT = 281, CONSTANT = 282, CONST = 283, CONSTRAINT = 284, CONSTRAINTS = 285, 
    CONSTRUCTOR = 286, CONTAINER = 287, CONTAINERS = 288, CONTAINERS_DEFAULT = 289, 
    CONTAINER_DATA = 290, CONTAINER_MAP = 291, CONTENT = 292, CONTENTS = 293, 
    CONTEXT = 294, CONTINUE = 295, CONTROLFILE = 296, CON_UID_TO_ID = 297, 
    CONVERT = 298, CONVERSION = 299, COOKIE = 300, COPY = 301, CORR_K = 302, 
    CORR_S = 303, CORRUPTION = 304, CORRUPT_XID_ALL = 305, CORRUPT_XID = 306, 
    COS = 307, COSH = 308, COST = 309, COST_XML_QUERY_REWRITE = 310, COUNT = 311, 
    COUNTED = 312, COVAR_POP = 313, COVAR_SAMP = 314, CPU_COSTING = 315, 
    CPU_PER_CALL = 316, CPU_PER_SESSION = 317, CRASH = 318, CREATE = 319, 
    CREATE_FILE_DEST = 320, CREATE_STORED_OUTLINES = 321, CREATION = 322, 
    CREDENTIAL = 323, CRITICAL = 324, CROSS = 325, CROSSEDITION = 326, CSCONVERT = 327, 
    CSV = 328, CUBE_AJ = 329, CUBE = 330, CUBE_GB = 331, CUBE_SJ = 332, 
    CUME_DISTM = 333, CURRENT = 334, CURRENT_DATE = 335, CURRENT_SCHEMA = 336, 
    CURRENT_TIME = 337, CURRENT_TIMESTAMP = 338, CURRENT_USER = 339, CURRENTV = 340, 
    CURSOR = 341, CURSOR_SHARING_EXACT = 342, CURSOR_SPECIFIC_SEGMENT = 343, 
    CUSTOMDATUM = 344, CV = 345, CYCLE = 346, DANGLING = 347, DATABASE = 348, 
    DATA = 349, DATAFILE = 350, DATAFILES = 351, DATAGUARDCONFIG = 352, 
    DATAMOVEMENT = 353, DATAOBJNO = 354, DATAOBJ_TO_MAT_PARTITION = 355, 
    DATAOBJ_TO_PARTITION = 356, DATAPUMP = 357, DATA_SECURITY_REWRITE_LIMIT = 358, 
    DATE = 359, DATE_CACHE = 360, DATE_FORMAT = 361, DATE_MODE = 362, DAY = 363, 
    DAYS = 364, DAY_TO_SECOND = 365, DBA = 366, DBA_RECYCLEBIN = 367, DBLINK = 368, 
    DBMS_STATS = 369, DB_ROLE_CHANGE = 370, DBTIMEZONE = 371, DB_UNIQUE_NAME = 372, 
    DB_VERSION = 373, DDL = 374, DEALLOCATE = 375, DEBUG = 376, DEBUGGER = 377, 
    DEC = 378, DECIMAL = 379, DECLARE = 380, DECOMPOSE = 381, DECORRELATE = 382, 
    DECR = 383, DECREMENT = 384, DECRYPT = 385, DEDUPLICATE = 386, DEFAULT = 387, 
    DEFAULTIF = 388, DEFAULTS = 389, DEFAULT_COLLATION = 390, DEFAULT_CREDENTIAL = 391, 
    DEFERRABLE = 392, DEFERRED = 393, DEFINED = 394, DEFINE = 395, DEFINER = 396, 
    DEGREE = 397, DELAY = 398, DELEGATE = 399, DELETE_ALL = 400, DELETE = 401, 
    DELETEXML = 402, DELIMITED = 403, DEMAND = 404, DENSE_RANKM = 405, DEPENDENT = 406, 
    DEPRECATE = 407, DEPTH = 408, DEQUEUE = 409, DEREF = 410, DEREF_NO_REWRITE = 411, 
    DESC = 412, DESCRIPTION = 413, DESTROY = 414, DETACHED = 415, DETECTED = 416, 
    DETERMINES = 417, DETERMINISTIC = 418, DICTIONARY = 419, DIMENSION = 420, 
    DIMENSIONS = 421, DIRECTIO = 422, DIRECT_LOAD = 423, DIRECTORY = 424, 
    DIRECT_PATH = 425, DISABLE_ALL = 426, DISABLE = 427, DISABLED = 428, 
    DISABLE_DIRECTORY_LINK_CHECK = 429, DISABLE_PARALLEL_DML = 430, DISABLE_PRESET = 431, 
    DISABLE_RPKE = 432, DISALLOW = 433, DISASSOCIATE = 434, DISCARD = 435, 
    DISCARDFILE = 436, DISCONNECT = 437, DISK = 438, DISKGROUP = 439, DISKGROUP_PLUS = 440, 
    DISKS = 441, DISMOUNT = 442, DISTINCT = 443, DISTINGUISHED = 444, DISTRIBUTED = 445, 
    DISTRIBUTE = 446, DML = 447, DML_UPDATE = 448, DNFS_DISABLE = 449, DNFS_ENABLE = 450, 
    DNFS_READBUFFERS = 451, DOCFIDELITY = 452, DOCUMENT = 453, DOLLAR_ELSE = 454, 
    DOLLAR_ELSIF = 455, DOLLAR_END = 456, DOLLAR_ERROR = 457, DOLLAR_IF = 458, 
    DOLLAR_THEN = 459, DOMAIN_INDEX_FILTER = 460, DOMAIN_INDEX_NO_SORT = 461, 
    DOMAIN_INDEX_SORT = 462, DOUBLE = 463, DOWNGRADE = 464, DRIVING_SITE = 465, 
    DROP_COLUMN = 466, DROP = 467, DROP_GROUP = 468, DSINTERVAL_UNCONSTRAINED = 469, 
    DST_UPGRADE_INSERT_CONV = 470, DUMP = 471, DUMPSET = 472, DUPLICATE = 473, 
    DV = 474, DYNAMIC = 475, DYNAMIC_SAMPLING = 476, DYNAMIC_SAMPLING_EST_CDN = 477, 
    E_LETTER = 478, EACH = 479, EDITIONABLE = 480, EDITION = 481, EDITIONING = 482, 
    EDITIONS = 483, ELEMENT = 484, ELIM_GROUPBY = 485, ELIMINATE_JOIN = 486, 
    ELIMINATE_OBY = 487, ELIMINATE_OUTER_JOIN = 488, ELSE = 489, ELSIF = 490, 
    EM = 491, EMBEDDED = 492, EMPTY_BLOB = 493, EMPTY_CLOB = 494, EMPTY_ = 495, 
    ENABLE_ALL = 496, ENABLE = 497, ENABLED = 498, ENABLE_PARALLEL_DML = 499, 
    ENABLE_PRESET = 500, ENCLOSED = 501, ENCODING = 502, ENCRYPT = 503, 
    ENCRYPTION = 504, ENCRYPTPASSWORDISNULL = 505, END = 506, END_OUTLINE_DATA = 507, 
    ENDIAN = 508, ENFORCED = 509, ENFORCE = 510, ENQUEUE = 511, ENTERPRISE = 512, 
    ENTITYESCAPING = 513, ENTRY = 514, EQUIPART = 515, ERR = 516, ERROR_ARGUMENT = 517, 
    ERROR = 518, ERROR_ON_OVERLAP_TIME = 519, ERRORS = 520, ERROR_INDEX = 521, 
    ERROR_CODE = 522, ESCAPE = 523, ESCAPED = 524, ESTIMATE = 525, EVAL = 526, 
    EVALNAME = 527, EVALUATE = 528, EVALUATION = 529, EVENTS = 530, EVERY = 531, 
    EXCEPT = 532, EXCEPTION = 533, EXCEPTION_INIT = 534, EXCEPTIONS = 535, 
    EXCHANGE = 536, EXCLUDE = 537, EXCLUDING = 538, EXCLUSIVE = 539, EXECUTE = 540, 
    EXEMPT = 541, EXISTING = 542, EXISTS = 543, EXISTSNODE = 544, EXIT = 545, 
    EXPAND_GSET_TO_UNION = 546, EXPAND_TABLE = 547, EXP = 548, EXPIRE = 549, 
    EXPLAIN = 550, EXPLOSION = 551, EXPORT = 552, EXPR_CORR_CHECK = 553, 
    EXPRESS = 554, EXTENDS = 555, EXTENT = 556, EXTENTS = 557, EXTERNAL = 558, 
    EXTERNALLY = 559, EXTRACTCLOBXML = 560, EXTRACT = 561, EXTRACTVALUE = 562, 
    EXTRA = 563, FACILITY = 564, FACT = 565, FACTOR = 566, FACTORIZE_JOIN = 567, 
    FAILED = 568, FAILED_LOGIN_ATTEMPTS = 569, FAILGROUP = 570, FAILOVER = 571, 
    FAILURE = 572, FALSE = 573, FAMILY = 574, FAR = 575, FAST = 576, FASTSTART = 577, 
    FBTSCAN = 578, FEATURE = 579, FEATURE_DETAILS = 580, FEATURE_ID = 581, 
    FEATURE_SET = 582, FEATURE_VALUE = 583, FETCH = 584, FIELD = 585, FIELDS = 586, 
    FILE = 587, FILE_NAME_CONVERT = 588, FILEGROUP = 589, FILESTORE = 590, 
    FILESYSTEM_LIKE_LOGGING = 591, FILTER = 592, FINAL = 593, FINE = 594, 
    FINISH = 595, FIRST = 596, FIRSTM = 597, FIRST_ROWS = 598, FIRST_VALUE = 599, 
    FIXED = 600, FIXED_VIEW_DATA = 601, FLAGGER = 602, FLASHBACK = 603, 
    FLASH_CACHE = 604, FLOAT = 605, FLOB = 606, FLEX = 607, FLOOR = 608, 
    FLUSH = 609, FOLDER = 610, FOLLOWING = 611, FOLLOWS = 612, FORALL = 613, 
    FORCE = 614, FORCE_XML_QUERY_REWRITE = 615, FOREIGN = 616, FOREVER = 617, 
    FOR = 618, FORMAT = 619, FORWARD = 620, FRAGMENT_NUMBER = 621, FREELIST = 622, 
    FREELISTS = 623, FREEPOOLS = 624, FRESH = 625, FROM = 626, FROM_TZ = 627, 
    FULL = 628, FULL_OUTER_JOIN_TO_OUTER = 629, FUNCTION = 630, FUNCTIONS = 631, 
    FTP = 632, G_LETTER = 633, GATHER_OPTIMIZER_STATISTICS = 634, GATHER_PLAN_STATISTICS = 635, 
    GBY_CONC_ROLLUP = 636, GBY_PUSHDOWN = 637, GENERATED = 638, GET = 639, 
    GLOBAL = 640, GLOBALLY = 641, GLOBAL_NAME = 642, GLOBAL_TOPIC_ENABLED = 643, 
    GOTO = 644, GRANT = 645, GROUP_BY = 646, GROUP = 647, GROUP_ID = 648, 
    GROUPING = 649, GROUPING_ID = 650, GROUPS = 651, GUARANTEED = 652, GUARANTEE = 653, 
    GUARD = 654, HADOOP_TRAILERS = 655, HALF_YEARS = 656, HASH_AJ = 657, 
    HASH = 658, HASHKEYS = 659, HASH_SJ = 660, HAVING = 661, HEADER = 662, 
    HEAP = 663, HELP = 664, HEXTORAW = 665, HEXTOREF = 666, HIDDEN_KEYWORD = 667, 
    HIDE = 668, HIER_ORDER = 669, HIERARCHICAL = 670, HIERARCHIES = 671, 
    HIERARCHY = 672, HIGH = 673, HINTSET_BEGIN = 674, HINTSET_END = 675, 
    HOT = 676, HOUR = 677, HOURS = 678, HTTP = 679, HWM_BROKERED = 680, 
    HYBRID = 681, H_LETTER = 682, IDENTIFIED = 683, IDENTIFIER = 684, IDENTITY = 685, 
    IDGENERATORS = 686, ID = 687, IDLE_TIME = 688, IF = 689, IGNORE = 690, 
    IGNORE_CHARS_AFTER_EOR = 691, IGNORE_OPTIM_EMBEDDED_HINTS = 692, IGNORE_ROW_ON_DUPKEY_INDEX = 693, 
    IGNORE_WHERE_CLAUSE = 694, ILM = 695, IMMEDIATE = 696, IMPACT = 697, 
    IMPORT = 698, INACTIVE = 699, INACTIVE_ACCOUNT_TIME = 700, INCLUDE = 701, 
    INCLUDE_VERSION = 702, INCLUDING = 703, INCREMENTAL = 704, INCREMENT = 705, 
    INCR = 706, INDENT = 707, INDEX_ASC = 708, INDEX_COMBINE = 709, INDEX_DESC = 710, 
    INDEXED = 711, INDEXES = 712, INDEX_FFS = 713, INDEX_FILTER = 714, INDEX = 715, 
    INDEXING = 716, INDEX_JOIN = 717, INDEX_ROWS = 718, INDEX_RRS = 719, 
    INDEX_RS_ASC = 720, INDEX_RS_DESC = 721, INDEX_RS = 722, INDEX_SCAN = 723, 
    INDEX_SKIP_SCAN = 724, INDEX_SS_ASC = 725, INDEX_SS_DESC = 726, INDEX_SS = 727, 
    INDEX_STATS = 728, INDEXTYPE = 729, INDEXTYPES = 730, INDICATOR = 731, 
    INDICES = 732, INFINITE = 733, INFORMATIONAL = 734, INHERIT = 735, IN = 736, 
    INITCAP = 737, INITIAL = 738, INITIALIZED = 739, INITIALLY = 740, INITRANS = 741, 
    INLINE = 742, INLINE_XMLTYPE_NT = 743, INMEMORY = 744, IN_MEMORY_METADATA = 745, 
    INMEMORY_PRUNING = 746, INNER = 747, INOUT = 748, INPLACE = 749, INPUTFORMAT = 750, 
    INSERTCHILDXMLAFTER = 751, INSERTCHILDXMLBEFORE = 752, INSERTCHILDXML = 753, 
    INSERT = 754, INSERTXMLAFTER = 755, INSERTXMLBEFORE = 756, INSTANCE = 757, 
    INSTANCES = 758, INSTANTIABLE = 759, INSTANTLY = 760, INSTEAD = 761, 
    INSTR2 = 762, INSTR4 = 763, INSTRB = 764, INSTRC = 765, INSTR = 766, 
    INTEGER = 767, INTERLEAVED = 768, INTERMEDIATE = 769, INTERNAL_CONVERT = 770, 
    INTERNAL_USE = 771, INTERPRETED = 772, INTERSECT = 773, INTERVAL = 774, 
    INT = 775, INTERNAL = 776, INTO = 777, INVALIDATE = 778, INVALIDATION = 779, 
    INVISIBLE = 780, IN_XQUERY = 781, IO_OPTIONS = 782, IS = 783, IS_LEAF = 784, 
    ISOLATION = 785, ISOLATION_LEVEL = 786, ITEMS = 787, ITERATE = 788, 
    ITERATION_NUMBER = 789, JAVA = 790, JOB = 791, JOIN = 792, JSON_ARRAYAGG = 793, 
    JSON_ARRAY = 794, JSON_EQUAL = 795, JSON_EXISTS2 = 796, JSON_EXISTS = 797, 
    JSONGET = 798, JSON = 799, JSON_OBJECTAGG = 800, JSON_OBJECT = 801, 
    JSONPARSE = 802, JSON_QUERY = 803, JSON_SERIALIZE = 804, JSON_TABLE = 805, 
    JSON_TEXTCONTAINS2 = 806, JSON_TEXTCONTAINS = 807, JSON_TRANSFORM = 808, 
    JSON_VALUE = 809, K_LETTER = 810, KEEP_DUPLICATES = 811, KEEP = 812, 
    KERBEROS = 813, KEY = 814, KEY_LENGTH = 815, KEYSIZE = 816, KEYS = 817, 
    KEYSTORE = 818, KILL = 819, LABEL = 820, LANGUAGE = 821, LAST_DAY = 822, 
    LAST = 823, LAST_VALUE = 824, LATERAL = 825, LATEST = 826, LAX = 827, 
    LAYER = 828, LDAP_REGISTRATION_ENABLED = 829, LDAP_REGISTRATION = 830, 
    LDAP_REG_SYNC_INTERVAL = 831, LDRTRIM = 832, LEAF = 833, LEAD_CDB = 834, 
    LEAD_CDB_URI = 835, LEADING = 836, LEFT = 837, LENGTH2 = 838, LENGTH4 = 839, 
    LENGTHB = 840, LENGTHC = 841, LENGTH = 842, LESS = 843, LEVEL = 844, 
    LEVEL_NAME = 845, LEVELS = 846, LIBRARY = 847, LIFECYCLE = 848, LIFE = 849, 
    LIFETIME = 850, LIKE2 = 851, LIKE4 = 852, LIKEC = 853, LIKE_EXPAND = 854, 
    LIKE = 855, LIMIT = 856, LINEAR = 857, LINES = 858, LINK = 859, LIST = 860, 
    LITTLE = 861, LLS = 862, LN = 863, LNNVL = 864, LOAD = 865, LOB = 866, 
    LOBFILE = 867, LOBNVL = 868, LOBS = 869, LOCAL_INDEXES = 870, LOCAL = 871, 
    LOCALTIME = 872, LOCALTIMESTAMP = 873, LOCATION = 874, LOCATOR = 875, 
    LOCKDOWN = 876, LOCKED = 877, LOCKING = 878, LOCK = 879, LOGFILE = 880, 
    LOGFILES = 881, LOGGING = 882, LOGICAL = 883, LOGICAL_READS_PER_CALL = 884, 
    LOGICAL_READS_PER_SESSION = 885, LOG = 886, LOGMINING = 887, LOGOFF = 888, 
    LOGON = 889, LOG_READ_ONLY_VIOLATIONS = 890, LONG = 891, LOOP = 892, 
    LOST = 893, LOWER = 894, LOW = 895, LPAD = 896, LRTRIM = 897, LTRIM = 898, 
    M_LETTER = 899, MAIN = 900, MAKE_REF = 901, MANAGED = 902, MANAGE = 903, 
    MANAGEMENT = 904, MANAGER = 905, MANDATORY = 906, MANUAL = 907, MAP = 908, 
    MAPPING = 909, MASK = 910, MASTER = 911, MATCHED = 912, MATCHES = 913, 
    MATCH = 914, MATCH_NUMBER = 915, MATCH_RECOGNIZE = 916, MATERIALIZED = 917, 
    MATERIALIZE = 918, MAXARCHLOGS = 919, MAXDATAFILES = 920, MAXEXTENTS = 921, 
    MAXIMIZE = 922, MAXINSTANCES = 923, MAXLOGFILES = 924, MAXLOGHISTORY = 925, 
    MAXLOGMEMBERS = 926, MAX_SHARED_TEMP_SIZE = 927, MAXSIZE = 928, MAXTRANS = 929, 
    MAXVALUE = 930, MEASURE = 931, MEASURES = 932, MEDIUM = 933, MEMBER = 934, 
    MEMBER_CAPTION = 935, MEMBER_DESCRIPTION = 936, MEMBER_NAME = 937, MEMBER_UNIQUE_NAME = 938, 
    MEMCOMPRESS = 939, MEMORY = 940, MERGEACTIONS = 941, MERGE_AJ = 942, 
    MERGE_CONST_ON = 943, MERGE = 944, MERGE_SJ = 945, METADATA = 946, METHOD = 947, 
    MIGRATE = 948, MIGRATION = 949, MINEXTENTS = 950, MINIMIZE = 951, MINIMUM = 952, 
    MINING = 953, MINUS = 954, MINUS_NULL = 955, MINUTE = 956, MINUTES = 957, 
    MINVALUE = 958, MIRRORCOLD = 959, MIRRORHOT = 960, MIRROR = 961, MISSING = 962, 
    MISMATCH = 963, MLSLABEL = 964, MODEL_COMPILE_SUBQUERY = 965, MODEL_DONTVERIFY_UNIQUENESS = 966, 
    MODEL_DYNAMIC_SUBQUERY = 967, MODEL_MIN_ANALYSIS = 968, MODEL = 969, 
    MODEL_NB = 970, MODEL_NO_ANALYSIS = 971, MODEL_PBY = 972, MODEL_PUSH_REF = 973, 
    MODEL_SV = 974, MODE = 975, MODIFICATION = 976, MODIFY_COLUMN_TYPE = 977, 
    MODIFY = 978, MOD = 979, MODULE = 980, MONITORING = 981, MONITOR = 982, 
    MONTH = 983, MONTHS_BETWEEN = 984, MONTHS = 985, MOUNT = 986, MOUNTPATH = 987, 
    MOUNTPOINT = 988, MOVEMENT = 989, MOVE = 990, MULTIDIMENSIONAL = 991, 
    MULTISET = 992, MV_MERGE = 993, NAMED = 994, NAME = 995, NAMESPACE = 996, 
    NAN_ = 997, NANVL = 998, NATIONAL = 999, NATIVE_FULL_OUTER_JOIN = 1000, 
    NATIVE = 1001, NATURAL = 1002, NATURALN = 1003, NAV = 1004, NCHAR_CS = 1005, 
    NCHAR = 1006, NCHR = 1007, NCLOB = 1008, NEEDED = 1009, NEG = 1010, 
    NESTED = 1011, NESTED_TABLE_FAST_INSERT = 1012, NESTED_TABLE_GET_REFS = 1013, 
    NESTED_TABLE_ID = 1014, NESTED_TABLE_SET_REFS = 1015, NESTED_TABLE_SET_SETID = 1016, 
    NETWORK = 1017, NEVER = 1018, NEW = 1019, NEWLINE_ = 1020, NEW_TIME = 1021, 
    NEXT_DAY = 1022, NEXT = 1023, NL_AJ = 1024, NLJ_BATCHING = 1025, NLJ_INDEX_FILTER = 1026, 
    NLJ_INDEX_SCAN = 1027, NLJ_PREFETCH = 1028, NLS_CALENDAR = 1029, NLS_CHARACTERSET = 1030, 
    NLS_CHARSET_DECL_LEN = 1031, NLS_CHARSET_ID = 1032, NLS_CHARSET_NAME = 1033, 
    NLS_COMP = 1034, NLS_CURRENCY = 1035, NLS_DATE_FORMAT = 1036, NLS_DATE_LANGUAGE = 1037, 
    NLS_INITCAP = 1038, NLS_ISO_CURRENCY = 1039, NL_SJ = 1040, NLS_LANG = 1041, 
    NLS_LANGUAGE = 1042, NLS_LENGTH_SEMANTICS = 1043, NLS_LOWER = 1044, 
    NLS_NCHAR_CONV_EXCP = 1045, NLS_NUMERIC_CHARACTERS = 1046, NLS_SORT = 1047, 
    NLSSORT = 1048, NLS_SPECIAL_CHARS = 1049, NLS_TERRITORY = 1050, NLS_UPPER = 1051, 
    NO_ACCESS = 1052, NO_ADAPTIVE_PLAN = 1053, NO_ANSI_REARCH = 1054, NOAPPEND = 1055, 
    NOARCHIVELOG = 1056, NOAUDIT = 1057, NOBADFILE = 1058, NO_AUTO_REOPTIMIZE = 1059, 
    NO_BASETABLE_MULTIMV_REWRITE = 1060, NO_BATCH_TABLE_ACCESS_BY_ROWID = 1061, 
    NO_BIND_AWARE = 1062, NO_BUFFER = 1063, NOCACHE = 1064, NOCHECK = 1065, 
    NO_CARTESIAN = 1066, NO_CHECK_ACL_REWRITE = 1067, NO_CLUSTER_BY_ROWID = 1068, 
    NO_CLUSTERING = 1069, NO_COALESCE_SQ = 1070, NO_COMMON_DATA = 1071, 
    NOCOMPRESS = 1072, NO_CONNECT_BY_CB_WHR_ONLY = 1073, NO_CONNECT_BY_COMBINE_SW = 1074, 
    NO_CONNECT_BY_COST_BASED = 1075, NO_CONNECT_BY_ELIM_DUPS = 1076, NO_CONNECT_BY_FILTERING = 1077, 
    NOCOPY = 1078, NO_COST_XML_QUERY_REWRITE = 1079, NO_CPU_COSTING = 1080, 
    NOCPU_COSTING = 1081, NOCYCLE = 1082, NO_DATA_SECURITY_REWRITE = 1083, 
    NO_DECORRELATE = 1084, NODELAY = 1085, NODIRECTIO = 1086, NODISCARDFILE = 1087, 
    NO_DOMAIN_INDEX_FILTER = 1088, NO_DST_UPGRADE_INSERT_CONV = 1089, NO_ELIM_GROUPBY = 1090, 
    NO_ELIMINATE_JOIN = 1091, NO_ELIMINATE_OBY = 1092, NO_ELIMINATE_OUTER_JOIN = 1093, 
    NOENTITYESCAPING = 1094, NO_EXPAND_GSET_TO_UNION = 1095, NO_EXPAND = 1096, 
    NO_EXPAND_TABLE = 1097, NOEXTEND = 1098, NO_FACT = 1099, NO_FACTORIZE_JOIN = 1100, 
    NO_FILTERING = 1101, NOFORCE = 1102, NO_FULL_OUTER_JOIN_TO_OUTER = 1103, 
    NO_GATHER_OPTIMIZER_STATISTICS = 1104, NO_GBY_PUSHDOWN = 1105, NOGUARANTEE = 1106, 
    NO_INDEX_FFS = 1107, NO_INDEX = 1108, NO_INDEX_SS = 1109, NO_INMEMORY = 1110, 
    NO_INMEMORY_PRUNING = 1111, NOKEEP = 1112, NO_LOAD = 1113, NOLOCAL = 1114, 
    NOLOG = 1115, NOLOGFILE = 1116, NOLOGGING = 1117, NOMAPPING = 1118, 
    NOMAXVALUE = 1119, NO_MERGE = 1120, NOMINIMIZE = 1121, NOMINVALUE = 1122, 
    NO_MODEL_PUSH_REF = 1123, NO_MONITORING = 1124, NOMONITORING = 1125, 
    NO_MONITOR = 1126, NO_MULTIMV_REWRITE = 1127, NO_NATIVE_FULL_OUTER_JOIN = 1128, 
    NONBLOCKING = 1129, NONEDITIONABLE = 1130, NONE = 1131, NONULLIF = 1132, 
    NO_NLJ_BATCHING = 1133, NO_NLJ_PREFETCH = 1134, NO = 1135, NONSCHEMA = 1136, 
    NO_OBJECT_LINK = 1137, NOORDER = 1138, NO_ORDER_ROLLUPS = 1139, NO_OUTER_JOIN_TO_ANTI = 1140, 
    NO_OUTER_JOIN_TO_INNER = 1141, NOOVERRIDE = 1142, NO_PARALLEL_INDEX = 1143, 
    NOPARALLEL_INDEX = 1144, NO_PARALLEL = 1145, NOPARALLEL = 1146, NO_PARTIAL_COMMIT = 1147, 
    NO_PARTIAL_JOIN = 1148, NO_PARTIAL_ROLLUP_PUSHDOWN = 1149, NOPARTITION = 1150, 
    NO_PLACE_DISTINCT = 1151, NO_PLACE_GROUP_BY = 1152, NO_PQ_CONCURRENT_UNION = 1153, 
    NO_PQ_MAP = 1154, NOPROMPT = 1155, NO_PQ_REPLICATE = 1156, NO_PQ_SKEW = 1157, 
    NO_PRUNE_GSETS = 1158, NO_PULL_PRED = 1159, NO_PUSH_PRED = 1160, NO_PUSH_SUBQ = 1161, 
    NO_PX_FAULT_TOLERANCE = 1162, NO_PX_JOIN_FILTER = 1163, NO_QKN_BUFF = 1164, 
    NO_QUERY_TRANSFORMATION = 1165, NO_REF_CASCADE = 1166, NORELOCATE = 1167, 
    NORELY = 1168, NOREPAIR = 1169, NOREPLAY = 1170, NORESETLOGS = 1171, 
    NO_RESULT_CACHE = 1172, NOREVERSE = 1173, NO_REWRITE = 1174, NOREWRITE = 1175, 
    NORMAL = 1176, NO_ROOT_SW_FOR_LOCAL = 1177, NOROWDEPENDENCIES = 1178, 
    NOSCALE = 1179, NOSCHEMACHECK = 1180, NOSEGMENT = 1181, NO_SEMIJOIN = 1182, 
    NO_SEMI_TO_INNER = 1183, NO_SET_TO_JOIN = 1184, NOSHARD = 1185, NOSORT = 1186, 
    NO_SQL_TRANSLATION = 1187, NO_SQL_TUNE = 1188, NO_STAR_TRANSFORMATION = 1189, 
    NO_STATEMENT_QUEUING = 1190, NO_STATS_GSETS = 1191, NOSTRICT = 1192, 
    NO_SUBQUERY_PRUNING = 1193, NO_SUBSTRB_PAD = 1194, NO_SWAP_JOIN_INPUTS = 1195, 
    NOSWITCH = 1196, NO_TABLE_LOOKUP_BY_NL = 1197, NO_TEMP_TABLE = 1198, 
    NOTHING = 1199, NOTIFICATION = 1200, NOTRIM = 1201, NOT = 1202, NO_TRANSFORM_DISTINCT_AGG = 1203, 
    NO_UNNEST = 1204, NO_USE_CUBE = 1205, NO_USE_HASH_AGGREGATION = 1206, 
    NO_USE_HASH_GBY_FOR_PUSHDOWN = 1207, NO_USE_HASH = 1208, NO_USE_INVISIBLE_INDEXES = 1209, 
    NO_USE_MERGE = 1210, NO_USE_NL = 1211, NO_USE_VECTOR_AGGREGATION = 1212, 
    NOVALIDATE = 1213, NO_VECTOR_TRANSFORM_DIMS = 1214, NO_VECTOR_TRANSFORM_FACT = 1215, 
    NO_VECTOR_TRANSFORM = 1216, NOWAIT = 1217, NO_XDB_FASTPATH_INSERT = 1218, 
    NO_XML_DML_REWRITE = 1219, NO_XMLINDEX_REWRITE_IN_SELECT = 1220, NO_XMLINDEX_REWRITE = 1221, 
    NO_XML_QUERY_REWRITE = 1222, NO_ZONEMAP = 1223, NTH_VALUE = 1224, NULLIF = 1225, 
    NULL_ = 1226, NULLS = 1227, NUMBER = 1228, NUMERIC = 1229, NUM_INDEX_KEYS = 1230, 
    NUMTODSINTERVAL = 1231, NUMTOYMINTERVAL = 1232, NVARCHAR2 = 1233, NVL2 = 1234, 
    OBJECT2XML = 1235, OBJECT = 1236, OBJ_ID = 1237, OBJNO = 1238, OBJNO_REUSE = 1239, 
    OCCURENCES = 1240, OFFLINE = 1241, OFF = 1242, OFFSET = 1243, OF = 1244, 
    OIDINDEX = 1245, OID = 1246, OLAP = 1247, OLD = 1248, OLD_PUSH_PRED = 1249, 
    OLS = 1250, OLTP = 1251, OMIT = 1252, ONE = 1253, ONLINE = 1254, ONLINELOG = 1255, 
    ONLY = 1256, ON = 1257, OPAQUE = 1258, OPAQUE_TRANSFORM = 1259, OPAQUE_XCANONICAL = 1260, 
    OPCODE = 1261, OPEN = 1262, OPERATIONS = 1263, OPERATOR = 1264, OPT_ESTIMATE = 1265, 
    OPTIMAL = 1266, OPTIMIZE = 1267, OPTIMIZER_FEATURES_ENABLE = 1268, OPTIMIZER_GOAL = 1269, 
    OPTION = 1270, OPTIONALLY = 1271, OPT_PARAM = 1272, ORA_BRANCH = 1273, 
    ORA_CHECK_ACL = 1274, ORA_CHECK_PRIVILEGE = 1275, ORA_CLUSTERING = 1276, 
    ORADATA = 1277, ORC = 1278, ORACLE_DATE = 1279, ORACLE_NUMBER = 1280, 
    ORADEBUG = 1281, ORA_DST_AFFECTED = 1282, ORA_DST_CONVERT = 1283, ORA_DST_ERROR = 1284, 
    ORA_GET_ACLIDS = 1285, ORA_GET_PRIVILEGES = 1286, ORA_HASH = 1287, ORA_INVOKING_USERID = 1288, 
    ORA_INVOKING_USER = 1289, ORA_INVOKING_XS_USER_GUID = 1290, ORA_INVOKING_XS_USER = 1291, 
    ORA_RAWCOMPARE = 1292, ORA_RAWCONCAT = 1293, ORA_ROWSCN = 1294, ORA_ROWSCN_RAW = 1295, 
    ORA_ROWVERSION = 1296, ORA_TABVERSION = 1297, ORA_WRITE_TIME = 1298, 
    ORDERED = 1299, ORDERED_PREDICATES = 1300, ORDER = 1301, ORDINALITY = 1302, 
    OR_EXPAND = 1303, ORGANIZATION = 1304, OR = 1305, OR_PREDICATES = 1306, 
    OSERROR = 1307, OTHER = 1308, OUTER_JOIN_TO_ANTI = 1309, OUTER_JOIN_TO_INNER = 1310, 
    OUTER = 1311, OUTLINE_LEAF = 1312, OUTLINE = 1313, OUTPUTFORMAT = 1314, 
    OUT_OF_LINE = 1315, OUT = 1316, OVERFLOW_NOMOVE = 1317, OVERFLOW_ = 1318, 
    OVERLAPS = 1319, OVER = 1320, OVERRIDE = 1321, OVERRIDING = 1322, OWNER = 1323, 
    OWNERSHIP = 1324, OWN = 1325, P_LETTER = 1326, PACKAGE = 1327, PACKAGES = 1328, 
    PARALLEL_ENABLE = 1329, PARALLEL_INDEX = 1330, PARALLEL = 1331, PARAMETERFILE = 1332, 
    PARAMETERS = 1333, PARAM = 1334, PARENT = 1335, PARENT_LEVEL_NAME = 1336, 
    PARENT_UNIQUE_NAME = 1337, PARITY = 1338, PARQUET = 1339, PARTIAL_JOIN = 1340, 
    PARTIALLY = 1341, PARTIAL = 1342, PARTIAL_ROLLUP_PUSHDOWN = 1343, PARTITION_HASH = 1344, 
    PARTITION_LIST = 1345, PARTITION = 1346, PARTITION_RANGE = 1347, PARTITIONS = 1348, 
    PARTNUMINST = 1349, PASSING = 1350, PASSWORD_GRACE_TIME = 1351, PASSWORD_LIFE_TIME = 1352, 
    PASSWORD_LOCK_TIME = 1353, PASSWORD = 1354, PASSWORD_REUSE_MAX = 1355, 
    PASSWORD_REUSE_TIME = 1356, PASSWORD_ROLLOVER_TIME = 1357, PASSWORD_VERIFY_FUNCTION = 1358, 
    PAST = 1359, PATCH = 1360, PATH = 1361, PATH_PREFIX = 1362, PATHS = 1363, 
    PATTERN = 1364, PBL_HS_BEGIN = 1365, PBL_HS_END = 1366, PCTFREE = 1367, 
    PCTINCREASE = 1368, PCTTHRESHOLD = 1369, PCTUSED = 1370, PCTVERSION = 1371, 
    PENDING = 1372, PERCENT_FOUND = 1373, PERCENT_ISOPEN = 1374, PERCENT_NOTFOUND = 1375, 
    PERCENT_KEYWORD = 1376, PERCENT_RANKM = 1377, PERCENT_ROWCOUNT = 1378, 
    PERCENT_ROWTYPE = 1379, PERCENT_TYPE = 1380, PERCENT_BULK_EXCEPTIONS = 1381, 
    PERCENT_BULK_ROWCOUNT = 1382, PERFORMANCE = 1383, PERIOD_KEYWORD = 1384, 
    PERMANENT = 1385, PERMISSION = 1386, PERMUTE = 1387, PER = 1388, PFILE = 1389, 
    PHYSICAL = 1390, PIKEY = 1391, PIPELINED = 1392, PIPE = 1393, PIV_GB = 1394, 
    PIVOT = 1395, PIV_SSF = 1396, PLACE_DISTINCT = 1397, PLACE_GROUP_BY = 1398, 
    PLAN = 1399, PLSCOPE_SETTINGS = 1400, PLS_INTEGER = 1401, PLSQL_CCFLAGS = 1402, 
    PLSQL_CODE_TYPE = 1403, PLSQL_DEBUG = 1404, PLSQL_OPTIMIZE_LEVEL = 1405, 
    PLSQL_WARNINGS = 1406, PLUGGABLE = 1407, PMEM = 1408, POINT = 1409, 
    POLICY = 1410, POOL_16K = 1411, POOL_2K = 1412, POOL_32K = 1413, POOL_4K = 1414, 
    POOL_8K = 1415, POSITION = 1416, POSITIVEN = 1417, POSITIVE = 1418, 
    POST_TRANSACTION = 1419, POWERMULTISET_BY_CARDINALITY = 1420, POWERMULTISET = 1421, 
    POWER = 1422, PQ_CONCURRENT_UNION = 1423, PQ_DISTRIBUTE = 1424, PQ_DISTRIBUTE_WINDOW = 1425, 
    PQ_FILTER = 1426, PQ_MAP = 1427, PQ_NOMAP = 1428, PQ_REPLICATE = 1429, 
    PQ_SKEW = 1430, PRAGMA = 1431, PREBUILT = 1432, PRECEDES = 1433, PRECEDING = 1434, 
    PRECISION = 1435, PRECOMPUTE_SUBQUERY = 1436, PREDICATE_REORDERS = 1437, 
    PRELOAD = 1438, PREPARE = 1439, PREPROCESSOR = 1440, PRESENTNNV = 1441, 
    PRESENT = 1442, PRESENTV = 1443, PRESERVE_OID = 1444, PRESERVE = 1445, 
    PRETTY = 1446, PREVIOUS = 1447, PREV = 1448, PRIMARY = 1449, PRINTBLOBTOCLOB = 1450, 
    PRIORITY = 1451, PRIOR = 1452, PRIVATE = 1453, PRIVATE_SGA = 1454, PRIVILEGED = 1455, 
    PRIVILEGE = 1456, PRIVILEGES = 1457, PROCEDURAL = 1458, PROCEDURE = 1459, 
    PROCESS = 1460, PROFILE = 1461, PROGRAM = 1462, PROJECT = 1463, PROPAGATE = 1464, 
    PROPERTY = 1465, PROTECTED = 1466, PROTECTION = 1467, PROTOCOL = 1468, 
    PROXY = 1469, PRUNING = 1470, PUBLIC = 1471, PULL_PRED = 1472, PURGE = 1473, 
    PUSH_PRED = 1474, PUSH_SUBQ = 1475, PX_FAULT_TOLERANCE = 1476, PX_GRANULE = 1477, 
    PX_JOIN_FILTER = 1478, QB_NAME = 1479, QUARTERS = 1480, QUERY_BLOCK = 1481, 
    QUERY = 1482, QUEUE_CURR = 1483, QUEUE = 1484, QUEUE_ROWP = 1485, QUIESCE = 1486, 
    QUORUM = 1487, QUOTA = 1488, QUOTAGROUP = 1489, RAISE = 1490, RANDOM_LOCAL = 1491, 
    RANDOM = 1492, RANGE = 1493, RANKM = 1494, RAPIDLY = 1495, RAW = 1496, 
    RAWTOHEX = 1497, RAWTONHEX = 1498, RBA = 1499, RBO_OUTLINE = 1500, RCFILE = 1501, 
    RDBA = 1502, READ = 1503, READS = 1504, READSIZE = 1505, REALM = 1506, 
    REAL = 1507, REBALANCE = 1508, REBUILD = 1509, RECORD = 1510, RECORDS = 1511, 
    RECORDS_PER_BLOCK = 1512, RECOVERABLE = 1513, RECOVER = 1514, RECOVERY = 1515, 
    RECYCLEBIN = 1516, RECYCLE = 1517, REDACTION = 1518, REDEFINE = 1519, 
    REDO = 1520, REDUCED = 1521, REDUNDANCY = 1522, REF_CASCADE_CURSOR = 1523, 
    REFERENCED = 1524, REFERENCE = 1525, REFERENCES = 1526, REFERENCING = 1527, 
    REF = 1528, REFRESH = 1529, REFTOHEX = 1530, REGEXP_COUNT = 1531, REGEXP_INSTR = 1532, 
    REGEXP_LIKE = 1533, REGEXP_REPLACE = 1534, REGEXP_SUBSTR = 1535, REGISTER = 1536, 
    REGR_AVGX = 1537, REGR_AVGY = 1538, REGR_COUNT = 1539, REGR_INTERCEPT = 1540, 
    REGR_R2 = 1541, REGR_SLOPE = 1542, REGR_SXX = 1543, REGR_SXY = 1544, 
    REGR_SYY = 1545, REGULAR = 1546, REJECT = 1547, REKEY = 1548, RELATIONAL = 1549, 
    RELIES_ON = 1550, RELOCATE = 1551, RELY = 1552, REMAINDER = 1553, REMOTE = 1554, 
    REMOTE_MAPPED = 1555, REMOVE = 1556, RENAME = 1557, REPAIR = 1558, REPEAT = 1559, 
    REPLACE = 1560, REPLICATION = 1561, REQUIRED = 1562, RESETLOGS = 1563, 
    RESET = 1564, RESIZE = 1565, RESOLVE = 1566, RESOLVER = 1567, RESOURCE = 1568, 
    RESPECT = 1569, RESTART = 1570, RESTORE_AS_INTERVALS = 1571, RESTORE = 1572, 
    RESTRICT_ALL_REF_CONS = 1573, RESTRICTED = 1574, RESTRICT_REFERENCES = 1575, 
    RESTRICT = 1576, RESULT_CACHE = 1577, RESULT = 1578, RESUMABLE = 1579, 
    RESUME = 1580, RETENTION = 1581, RETRY_ON_ROW_CHANGE = 1582, RETURNING = 1583, 
    RETURN = 1584, REUSE = 1585, REVERSE = 1586, REVOKE = 1587, REWRITE_OR_ERROR = 1588, 
    REWRITE = 1589, RIGHT = 1590, ROLE = 1591, ROLESET = 1592, ROLES = 1593, 
    ROLLBACK = 1594, ROLLING = 1595, ROLLUP = 1596, ROWDEPENDENCIES = 1597, 
    ROWID_MAPPING_TABLE = 1598, ROWID = 1599, ROWIDTOCHAR = 1600, ROWIDTONCHAR = 1601, 
    ROW_LENGTH = 1602, ROWNUM = 1603, ROW = 1604, ROWS = 1605, RPAD = 1606, 
    RTRIM = 1607, RULE = 1608, RULES = 1609, RUNNING = 1610, SALT = 1611, 
    SAMPLE = 1612, SAVE_AS_INTERVALS = 1613, SAVEPOINT = 1614, SAVE = 1615, 
    SB4 = 1616, SCALE_ROWS = 1617, SCALE = 1618, SCAN_INSTANCES = 1619, 
    SCAN = 1620, SCHEDULER = 1621, SCHEMACHECK = 1622, SCHEMA = 1623, SCN_ASCENDING = 1624, 
    SCN = 1625, SCOPE = 1626, SCRUB = 1627, SD_ALL = 1628, SD_INHIBIT = 1629, 
    SDO_GEOM_MBR = 1630, SDO_GEOMETRY = 1631, SD_SHOW = 1632, SEARCH = 1633, 
    SECOND = 1634, SECONDS = 1635, SECRET = 1636, SECUREFILE_DBA = 1637, 
    SECUREFILE = 1638, SECURITY = 1639, SEED = 1640, SEG_BLOCK = 1641, SEG_FILE = 1642, 
    SEGMENT = 1643, SELECTIVITY = 1644, SELECT = 1645, SELF = 1646, SEMIJOIN_DRIVER = 1647, 
    SEMIJOIN = 1648, SEMI_TO_INNER = 1649, SEQUENCED = 1650, SEQUENCE = 1651, 
    SEQUENCEFILE = 1652, SEQUENTIAL = 1653, SEQ = 1654, SERDE = 1655, SERDEPROPERTIES = 1656, 
    SERIALIZABLE = 1657, SERIALLY_REUSABLE = 1658, SERIAL = 1659, SERVERERROR = 1660, 
    SERVICE_NAME_CONVERT = 1661, SERVICE = 1662, SERVICES = 1663, SESSION_CACHED_CURSORS = 1664, 
    SESSION = 1665, SESSIONS_PER_USER = 1666, SESSIONTIMEZONE = 1667, SESSIONTZNAME = 1668, 
    SET = 1669, SETS = 1670, SETTINGS = 1671, SET_TO_JOIN = 1672, SEVERE = 1673, 
    SHARD = 1674, SHARDSPACE = 1675, SHARED_POOL = 1676, SHARED = 1677, 
    SHARE = 1678, SHARING = 1679, SHELFLIFE = 1680, SHOW = 1681, SHRINK = 1682, 
    SHUTDOWN = 1683, SIBLINGS = 1684, SID = 1685, SITE = 1686, SIGNAL_COMPONENT = 1687, 
    SIGNAL_FUNCTION = 1688, SIGN = 1689, SIGNTYPE = 1690, SIMPLE_INTEGER = 1691, 
    SIMPLE = 1692, SINGLE = 1693, SINGLETASK = 1694, SINH = 1695, SIN = 1696, 
    SIZE = 1697, SIZES = 1698, SKIP_EXT_OPTIMIZER = 1699, SKIP_ = 1700, 
    SKIP_UNQ_UNUSABLE_IDX = 1701, SKIP_UNUSABLE_INDEXES = 1702, SMALLFILE = 1703, 
    SMALLINT = 1704, SNAPSHOT = 1705, SOME = 1706, SORT = 1707, SOUNDEX = 1708, 
    SOURCE_FILE_DIRECTORY = 1709, SOURCE_FILE_NAME_CONVERT = 1710, SOURCE = 1711, 
    SPACE_KEYWORD = 1712, SPECIFICATION = 1713, SPFILE = 1714, SPLIT = 1715, 
    SPREADSHEET = 1716, SQLDATA = 1717, SQLERROR = 1718, SQLLDR = 1719, 
    SQL = 1720, FILE_EXT = 1721, SQL_MACRO = 1722, SQL_TRACE = 1723, SQL_TRANSLATION_PROFILE = 1724, 
    SQRT = 1725, STALE = 1726, STANDALONE = 1727, STANDARD = 1728, STANDARD_HASH = 1729, 
    STANDBY_MAX_DATA_DELAY = 1730, STANDBYS = 1731, STANDBY = 1732, STAR = 1733, 
    STAR_TRANSFORMATION = 1734, START = 1735, STARTOF = 1736, STARTUP = 1737, 
    STATEMENT_ID = 1738, STATEMENT_QUEUING = 1739, STATEMENTS = 1740, STATEMENT = 1741, 
    STATE = 1742, STATIC = 1743, STATISTICS = 1744, STATS_BINOMIAL_TEST = 1745, 
    STATS_CROSSTAB = 1746, STATS_F_TEST = 1747, STATS_KS_TEST = 1748, STATS_MODE = 1749, 
    STATS_MW_TEST = 1750, STATS_ONE_WAY_ANOVA = 1751, STATS_T_TEST_INDEP = 1752, 
    STATS_T_TEST_INDEPU = 1753, STATS_T_TEST_ONE = 1754, STATS_T_TEST_PAIRED = 1755, 
    STATS_WSR_TEST = 1756, STDDEV_POP = 1757, STDDEV_SAMP = 1758, STOP = 1759, 
    STORAGE = 1760, STORE = 1761, STREAMS = 1762, STREAM = 1763, STRICT = 1764, 
    STRING = 1765, STRIPE_COLUMNS = 1766, STRIPE_WIDTH = 1767, STRIP = 1768, 
    STRUCTURE = 1769, SUBMULTISET = 1770, SUBPARTITION_REL = 1771, SUBPARTITIONS = 1772, 
    SUBPARTITION = 1773, SUBQUERIES = 1774, SUBQUERY_PRUNING = 1775, SUBSCRIBE = 1776, 
    SUBSET = 1777, SUBSTITUTABLE = 1778, SUBSTR2 = 1779, SUBSTR4 = 1780, 
    SUBSTRB = 1781, SUBSTRC = 1782, SUBTYPE = 1783, SUCCESSFUL = 1784, SUCCESS = 1785, 
    SUMMARY = 1786, SUPPLEMENTAL = 1787, SUSPEND = 1788, SWAP_JOIN_INPUTS = 1789, 
    SWITCHOVER = 1790, SWITCH = 1791, SYNCHRONOUS = 1792, SYNC = 1793, SYNONYM = 1794, 
    SYS = 1795, SYSASM = 1796, SYS_AUDIT = 1797, SYSAUX = 1798, SYSBACKUP = 1799, 
    SYS_CHECKACL = 1800, SYS_CHECK_PRIVILEGE = 1801, SYS_CONNECT_BY_PATH = 1802, 
    SYS_CONTEXT = 1803, SYSDATE = 1804, SYSDBA = 1805, SYS_DBURIGEN = 1806, 
    SYSDG = 1807, SYS_DL_CURSOR = 1808, SYS_DM_RXFORM_CHR = 1809, SYS_DM_RXFORM_NUM = 1810, 
    SYS_DOM_COMPARE = 1811, SYS_DST_PRIM2SEC = 1812, SYS_DST_SEC2PRIM = 1813, 
    SYS_ET_BFILE_TO_RAW = 1814, SYS_ET_BLOB_TO_IMAGE = 1815, SYS_ET_IMAGE_TO_BLOB = 1816, 
    SYS_ET_RAW_TO_BFILE = 1817, SYS_EXTPDTXT = 1818, SYS_EXTRACT_UTC = 1819, 
    SYS_FBT_INSDEL = 1820, SYS_FILTER_ACLS = 1821, SYS_FNMATCHES = 1822, 
    SYS_FNREPLACE = 1823, SYS_GET_ACLIDS = 1824, SYS_GET_COL_ACLIDS = 1825, 
    SYS_GET_PRIVILEGES = 1826, SYS_GETTOKENID = 1827, SYS_GETXTIVAL = 1828, 
    SYS_GUID = 1829, SYSGUID = 1830, SYSKM = 1831, SYS_MAKE_XMLNODEID = 1832, 
    SYS_MAKEXML = 1833, SYS_MKXMLATTR = 1834, SYS_MKXTI = 1835, SYSOBJ = 1836, 
    SYS_OP_ADT2BIN = 1837, SYS_OP_ADTCONS = 1838, SYS_OP_ALSCRVAL = 1839, 
    SYS_OP_ATG = 1840, SYS_OP_BIN2ADT = 1841, SYS_OP_BITVEC = 1842, SYS_OP_BL2R = 1843, 
    SYS_OP_BLOOM_FILTER_LIST = 1844, SYS_OP_BLOOM_FILTER = 1845, SYS_OP_C2C = 1846, 
    SYS_OP_CAST = 1847, SYS_OP_CEG = 1848, SYS_OP_CL2C = 1849, SYS_OP_COMBINED_HASH = 1850, 
    SYS_OP_COMP = 1851, SYS_OP_CONVERT = 1852, SYS_OP_COUNTCHG = 1853, SYS_OP_CSCONV = 1854, 
    SYS_OP_CSCONVTEST = 1855, SYS_OP_CSR = 1856, SYS_OP_CSX_PATCH = 1857, 
    SYS_OP_CYCLED_SEQ = 1858, SYS_OP_DECOMP = 1859, SYS_OP_DESCEND = 1860, 
    SYS_OP_DISTINCT = 1861, SYS_OP_DRA = 1862, SYS_OP_DUMP = 1863, SYS_OP_DV_CHECK = 1864, 
    SYS_OP_ENFORCE_NOT_NULL = 1865, SYSOPER = 1866, SYS_OP_EXTRACT = 1867, 
    SYS_OP_GROUPING = 1868, SYS_OP_GUID = 1869, SYS_OP_HASH = 1870, SYS_OP_IIX = 1871, 
    SYS_OP_ITR = 1872, SYS_OP_KEY_VECTOR_CREATE = 1873, SYS_OP_KEY_VECTOR_FILTER_LIST = 1874, 
    SYS_OP_KEY_VECTOR_FILTER = 1875, SYS_OP_KEY_VECTOR_SUCCEEDED = 1876, 
    SYS_OP_KEY_VECTOR_USE = 1877, SYS_OP_LBID = 1878, SYS_OP_LOBLOC2BLOB = 1879, 
    SYS_OP_LOBLOC2CLOB = 1880, SYS_OP_LOBLOC2ID = 1881, SYS_OP_LOBLOC2NCLOB = 1882, 
    SYS_OP_LOBLOC2TYP = 1883, SYS_OP_LSVI = 1884, SYS_OP_LVL = 1885, SYS_OP_MAKEOID = 1886, 
    SYS_OP_MAP_NONNULL = 1887, SYS_OP_MSR = 1888, SYS_OP_NICOMBINE = 1889, 
    SYS_OP_NIEXTRACT = 1890, SYS_OP_NII = 1891, SYS_OP_NIX = 1892, SYS_OP_NOEXPAND = 1893, 
    SYS_OP_NTCIMG = 1894, SYS_OP_NUMTORAW = 1895, SYS_OP_OIDVALUE = 1896, 
    SYS_OP_OPNSIZE = 1897, SYS_OP_PAR_1 = 1898, SYS_OP_PARGID_1 = 1899, 
    SYS_OP_PARGID = 1900, SYS_OP_PAR = 1901, SYS_OP_PART_ID = 1902, SYS_OP_PIVOT = 1903, 
    SYS_OP_R2O = 1904, SYS_OP_RAWTONUM = 1905, SYS_OP_RDTM = 1906, SYS_OP_REF = 1907, 
    SYS_OP_RMTD = 1908, SYS_OP_ROWIDTOOBJ = 1909, SYS_OP_RPB = 1910, SYS_OPTLOBPRBSC = 1911, 
    SYS_OP_TOSETID = 1912, SYS_OP_TPR = 1913, SYS_OP_TRTB = 1914, SYS_OPTXICMP = 1915, 
    SYS_OPTXQCASTASNQ = 1916, SYS_OP_UNDESCEND = 1917, SYS_OP_VECAND = 1918, 
    SYS_OP_VECBIT = 1919, SYS_OP_VECOR = 1920, SYS_OP_VECXOR = 1921, SYS_OP_VERSION = 1922, 
    SYS_OP_VREF = 1923, SYS_OP_VVD = 1924, SYS_OP_XMLCONS_FOR_CSX = 1925, 
    SYS_OP_XPTHATG = 1926, SYS_OP_XPTHIDX = 1927, SYS_OP_XPTHOP = 1928, 
    SYS_OP_XTXT2SQLT = 1929, SYS_OP_ZONE_ID = 1930, SYS_ORDERKEY_DEPTH = 1931, 
    SYS_ORDERKEY_MAXCHILD = 1932, SYS_ORDERKEY_PARENT = 1933, SYS_PARALLEL_TXN = 1934, 
    SYS_PATHID_IS_ATTR = 1935, SYS_PATHID_IS_NMSPC = 1936, SYS_PATHID_LASTNAME = 1937, 
    SYS_PATHID_LASTNMSPC = 1938, SYS_PATH_REVERSE = 1939, SYS_PXQEXTRACT = 1940, 
    SYS_RAW_TO_XSID = 1941, SYS_RID_ORDER = 1942, SYS_ROW_DELTA = 1943, 
    SYS_SC_2_XMLT = 1944, SYS_SYNRCIREDO = 1945, SYSTEM_DEFINED = 1946, 
    SYSTEM = 1947, SYSTIMESTAMP = 1948, SYS_TYPEID = 1949, SYS_UMAKEXML = 1950, 
    SYS_XMLANALYZE = 1951, SYS_XMLCONTAINS = 1952, SYS_XMLCONV = 1953, SYS_XMLEXNSURI = 1954, 
    SYS_XMLGEN = 1955, SYS_XMLI_LOC_ISNODE = 1956, SYS_XMLI_LOC_ISTEXT = 1957, 
    SYS_XMLINSTR = 1958, SYS_XMLLOCATOR_GETSVAL = 1959, SYS_XMLNODEID_GETCID = 1960, 
    SYS_XMLNODEID_GETLOCATOR = 1961, SYS_XMLNODEID_GETOKEY = 1962, SYS_XMLNODEID_GETPATHID = 1963, 
    SYS_XMLNODEID_GETPTRID = 1964, SYS_XMLNODEID_GETRID = 1965, SYS_XMLNODEID_GETSVAL = 1966, 
    SYS_XMLNODEID_GETTID = 1967, SYS_XMLNODEID = 1968, SYS_XMLT_2_SC = 1969, 
    SYS_XMLTRANSLATE = 1970, SYS_XMLTYPE2SQL = 1971, SYS_XQ_ASQLCNV = 1972, 
    SYS_XQ_ATOMCNVCHK = 1973, SYS_XQBASEURI = 1974, SYS_XQCASTABLEERRH = 1975, 
    SYS_XQCODEP2STR = 1976, SYS_XQCODEPEQ = 1977, SYS_XQCON2SEQ = 1978, 
    SYS_XQCONCAT = 1979, SYS_XQDELETE = 1980, SYS_XQDFLTCOLATION = 1981, 
    SYS_XQDOC = 1982, SYS_XQDOCURI = 1983, SYS_XQDURDIV = 1984, SYS_XQED4URI = 1985, 
    SYS_XQENDSWITH = 1986, SYS_XQERRH = 1987, SYS_XQERR = 1988, SYS_XQESHTMLURI = 1989, 
    SYS_XQEXLOBVAL = 1990, SYS_XQEXSTWRP = 1991, SYS_XQEXTRACT = 1992, SYS_XQEXTRREF = 1993, 
    SYS_XQEXVAL = 1994, SYS_XQFB2STR = 1995, SYS_XQFNBOOL = 1996, SYS_XQFNCMP = 1997, 
    SYS_XQFNDATIM = 1998, SYS_XQFNLNAME = 1999, SYS_XQFNNM = 2000, SYS_XQFNNSURI = 2001, 
    SYS_XQFNPREDTRUTH = 2002, SYS_XQFNQNM = 2003, SYS_XQFNROOT = 2004, SYS_XQFORMATNUM = 2005, 
    SYS_XQFTCONTAIN = 2006, SYS_XQFUNCR = 2007, SYS_XQGETCONTENT = 2008, 
    SYS_XQINDXOF = 2009, SYS_XQINSERT = 2010, SYS_XQINSPFX = 2011, SYS_XQIRI2URI = 2012, 
    SYS_XQLANG = 2013, SYS_XQLLNMFRMQNM = 2014, SYS_XQMKNODEREF = 2015, 
    SYS_XQNILLED = 2016, SYS_XQNODENAME = 2017, SYS_XQNORMSPACE = 2018, 
    SYS_XQNORMUCODE = 2019, SYS_XQ_NRNG = 2020, SYS_XQNSP4PFX = 2021, SYS_XQNSPFRMQNM = 2022, 
    SYS_XQPFXFRMQNM = 2023, SYS_XQ_PKSQL2XML = 2024, SYS_XQPOLYABS = 2025, 
    SYS_XQPOLYADD = 2026, SYS_XQPOLYCEL = 2027, SYS_XQPOLYCSTBL = 2028, 
    SYS_XQPOLYCST = 2029, SYS_XQPOLYDIV = 2030, SYS_XQPOLYFLR = 2031, SYS_XQPOLYMOD = 2032, 
    SYS_XQPOLYMUL = 2033, SYS_XQPOLYRND = 2034, SYS_XQPOLYSQRT = 2035, SYS_XQPOLYSUB = 2036, 
    SYS_XQPOLYUMUS = 2037, SYS_XQPOLYUPLS = 2038, SYS_XQPOLYVEQ = 2039, 
    SYS_XQPOLYVGE = 2040, SYS_XQPOLYVGT = 2041, SYS_XQPOLYVLE = 2042, SYS_XQPOLYVLT = 2043, 
    SYS_XQPOLYVNE = 2044, SYS_XQREF2VAL = 2045, SYS_XQRENAME = 2046, SYS_XQREPLACE = 2047, 
    SYS_XQRESVURI = 2048, SYS_XQRNDHALF2EVN = 2049, SYS_XQRSLVQNM = 2050, 
    SYS_XQRYENVPGET = 2051, SYS_XQRYVARGET = 2052, SYS_XQRYWRP = 2053, SYS_XQSEQ2CON4XC = 2054, 
    SYS_XQSEQ2CON = 2055, SYS_XQSEQDEEPEQ = 2056, SYS_XQSEQINSB = 2057, 
    SYS_XQSEQRM = 2058, SYS_XQSEQRVS = 2059, SYS_XQSEQSUB = 2060, SYS_XQSEQTYPMATCH = 2061, 
    SYS_XQSTARTSWITH = 2062, SYS_XQSTATBURI = 2063, SYS_XQSTR2CODEP = 2064, 
    SYS_XQSTRJOIN = 2065, SYS_XQSUBSTRAFT = 2066, SYS_XQSUBSTRBEF = 2067, 
    SYS_XQTOKENIZE = 2068, SYS_XQTREATAS = 2069, SYS_XQ_UPKXML2SQL = 2070, 
    SYS_XQXFORM = 2071, SYS_XSID_TO_RAW = 2072, SYS_ZMAP_FILTER = 2073, 
    SYS_ZMAP_REFRESH = 2074, T_LETTER = 2075, TABLE_LOOKUP_BY_NL = 2076, 
    TABLESPACE_NO = 2077, TABLESPACE = 2078, TABLES = 2079, TABLE_STATS = 2080, 
    TABLE = 2081, TABNO = 2082, TAG = 2083, TANH = 2084, TAN = 2085, TBLORIDXPARTNUM = 2086, 
    TEMPFILE = 2087, TEMPLATE = 2088, TEMPLATE_TABLE = 2089, TEMPORARY = 2090, 
    TEMP_TABLE = 2091, TERMINATED = 2092, TEST = 2093, TEXT = 2094, TEXTFILE = 2095, 
    THAN = 2096, THEN = 2097, THE = 2098, THESE = 2099, THREAD = 2100, THROUGH = 2101, 
    TIER = 2102, TIES = 2103, TIMEOUT = 2104, TIMESTAMP_LTZ_UNCONSTRAINED = 2105, 
    TIMESTAMP = 2106, TIMESTAMP_TZ_UNCONSTRAINED = 2107, TIMESTAMP_UNCONSTRAINED = 2108, 
    TIMES = 2109, TIME = 2110, TIMEZONE = 2111, TIMEZONE_ABBR = 2112, TIMEZONE_HOUR = 2113, 
    TIMEZONE_MINUTE = 2114, TIMEZONE_OFFSET = 2115, TIMEZONE_REGION = 2116, 
    TIME_ZONE = 2117, TIMING = 2118, TINYINT = 2119, TIV_GB = 2120, TIV_SSF = 2121, 
    TO_ACLID = 2122, TO_BINARY_DOUBLE = 2123, TO_BINARY_FLOAT = 2124, TO_BLOB = 2125, 
    TO_CLOB = 2126, TO_DSINTERVAL = 2127, TO_LOB = 2128, TO_MULTI_BYTE = 2129, 
    TO_NCHAR = 2130, TO_NCLOB = 2131, TO_NUMBER = 2132, TOPLEVEL = 2133, 
    TO_SINGLE_BYTE = 2134, TO_TIMESTAMP = 2135, TO_TIMESTAMP_TZ = 2136, 
    TO_TIME = 2137, TO_TIME_TZ = 2138, TO = 2139, TO_YMINTERVAL = 2140, 
    TRACE = 2141, TRACING = 2142, TRACKING = 2143, TRAILING = 2144, TRANSACTION = 2145, 
    TRANSFORM = 2146, TRANSFORMS = 2147, TRANSFORM_DISTINCT_AGG = 2148, 
    TRANSITIONAL = 2149, TRANSITION = 2150, TRANSLATE = 2151, TRANSLATION = 2152, 
    TREAT = 2153, TRIGGERS = 2154, TRIGGER = 2155, TRUE = 2156, TRUNCATE = 2157, 
    TRUNC = 2158, TRUSTED = 2159, TRUST = 2160, TUNING = 2161, TX = 2162, 
    TYPES = 2163, TYPE = 2164, TZ_OFFSET = 2165, UB2 = 2166, UBA = 2167, 
    UCS2 = 2168, UDF = 2169, UID = 2170, UNARCHIVED = 2171, UNBOUNDED = 2172, 
    UNBOUND = 2173, UNCONDITIONAL = 2174, UNDER = 2175, UNDO = 2176, UNDROP = 2177, 
    UNIFORM = 2178, UNION = 2179, UNIONTYPE = 2180, UNIQUE = 2181, UNISTR = 2182, 
    UNLIMITED = 2183, UNLOAD = 2184, UNLOCK = 2185, UNMATCHED = 2186, UNNEST_INNERJ_DISTINCT_VIEW = 2187, 
    UNNEST_NOSEMIJ_NODISTINCTVIEW = 2188, UNNEST_SEMIJ_VIEW = 2189, UNNEST = 2190, 
    UNPACKED = 2191, UNPIVOT = 2192, UNPLUG = 2193, UNPROTECTED = 2194, 
    UNQUIESCE = 2195, UNRECOVERABLE = 2196, UNRESTRICTED = 2197, UNSIGNED = 2198, 
    UNSUBSCRIBE = 2199, UNTIL = 2200, UNUSABLE = 2201, UNUSED = 2202, UPDATABLE = 2203, 
    UPDATED = 2204, UPDATE = 2205, UPDATEXML = 2206, UPD_INDEXES = 2207, 
    UPD_JOININDEX = 2208, UPGRADE = 2209, UPPER = 2210, UPSERT = 2211, UROWID = 2212, 
    USABLE = 2213, USAGE = 2214, USE_ANTI = 2215, USE_CONCAT = 2216, USE_CUBE = 2217, 
    USE_HASH_AGGREGATION = 2218, USE_HASH_GBY_FOR_PUSHDOWN = 2219, USE_HASH = 2220, 
    USE_HIDDEN_PARTITIONS = 2221, USE_INVISIBLE_INDEXES = 2222, USE_MERGE_CARTESIAN = 2223, 
    USE_MERGE = 2224, USE_NL = 2225, USE_NL_WITH_INDEX = 2226, USE_PRIVATE_OUTLINES = 2227, 
    USER_DATA = 2228, USER_DEFINED = 2229, USERENV = 2230, USERGROUP = 2231, 
    USER_RECYCLEBIN = 2232, USERS = 2233, USER_TABLESPACES = 2234, USER = 2235, 
    USE_SEMI = 2236, USE_STORED_OUTLINES = 2237, USE_TTT_FOR_GSETS = 2238, 
    USE = 2239, USE_VECTOR_AGGREGATION = 2240, USE_WEAK_NAME_RESL = 2241, 
    USING_NO_EXPAND = 2242, USING_NLS_COMP = 2243, USING = 2244, UTF16BE = 2245, 
    UTF16LE = 2246, UTF32 = 2247, UTF8 = 2248, V1 = 2249, V2 = 2250, VALIDATE = 2251, 
    VALIDATE_CONVERSION = 2252, VALIDATION = 2253, VALID_TIME_END = 2254, 
    VALUES = 2255, VALUE = 2256, VARCHAR2 = 2257, VARCHAR = 2258, VARCHARC = 2259, 
    VARIABLE = 2260, VARRAW = 2261, VARRAWC = 2262, VAR_POP = 2263, VARRAYS = 2264, 
    VARRAY = 2265, VAR_SAMP = 2266, VARYING = 2267, VECTOR_READ_TRACE = 2268, 
    VECTOR_READ = 2269, VECTOR_TRANSFORM_DIMS = 2270, VECTOR_TRANSFORM_FACT = 2271, 
    VECTOR_TRANSFORM = 2272, VERIFIER = 2273, VERIFY = 2274, VERSIONING = 2275, 
    VERSIONS_ENDSCN = 2276, VERSIONS_ENDTIME = 2277, VERSIONS_OPERATION = 2278, 
    VERSIONS_STARTSCN = 2279, VERSIONS_STARTTIME = 2280, VERSIONS = 2281, 
    VERSIONS_XID = 2282, VERSION = 2283, VIEW = 2284, VIOLATION = 2285, 
    VIRTUAL = 2286, VISIBILITY = 2287, VISIBLE = 2288, VOLUME = 2289, VSIZE = 2290, 
    WAIT = 2291, WALLET = 2292, WARNING = 2293, WEEKS = 2294, WEEK = 2295, 
    WELLFORMED = 2296, WHENEVER = 2297, WHEN = 2298, WHERE = 2299, WHILE = 2300, 
    WHITESPACE = 2301, WIDTH_BUCKET = 2302, WITHIN = 2303, WITHOUT = 2304, 
    WITH_PLSQL = 2305, WITH = 2306, WORK = 2307, WORKERID = 2308, WRAPPED = 2309, 
    WRAPPER = 2310, WRITE = 2311, XDB_FASTPATH_INSERT = 2312, XDB = 2313, 
    X_DYN_PRUNE = 2314, XID = 2315, XML2OBJECT = 2316, XMLAGG = 2317, XMLATTRIBUTES = 2318, 
    XMLCAST = 2319, XMLCDATA = 2320, XMLCOLATTVAL = 2321, XMLCOMMENT = 2322, 
    XMLCONCAT = 2323, XMLDIFF = 2324, XML_DML_RWT_STMT = 2325, XMLELEMENT = 2326, 
    XMLEXISTS2 = 2327, XMLEXISTS = 2328, XMLFOREST = 2329, XMLINDEX = 2330, 
    XMLINDEX_REWRITE_IN_SELECT = 2331, XMLINDEX_REWRITE = 2332, XMLINDEX_SEL_IDX_TBL = 2333, 
    XMLISNODE = 2334, XMLISVALID = 2335, XMLNAMESPACES = 2336, XMLPARSE = 2337, 
    XMLPATCH = 2338, XMLPI = 2339, XMLQUERYVAL = 2340, XMLQUERY = 2341, 
    XMLROOT = 2342, XMLSCHEMA = 2343, XMLSERIALIZE = 2344, XMLTABLE = 2345, 
    XMLTAG = 2346, XMLTRANSFORMBLOB = 2347, XMLTRANSFORM = 2348, XMLTYPE = 2349, 
    XML = 2350, XPATHTABLE = 2351, XS_SYS_CONTEXT = 2352, XS = 2353, XTRANSPORT = 2354, 
    YEARS = 2355, YEAR = 2356, YEAR_TO_MONTH = 2357, YES = 2358, YMINTERVAL_UNCONSTRAINED = 2359, 
    ZONEMAP = 2360, ZONE = 2361, ZONED = 2362, PREDICTION = 2363, PREDICTION_BOUNDS = 2364, 
    PREDICTION_COST = 2365, PREDICTION_DETAILS = 2366, PREDICTION_PROBABILITY = 2367, 
    PREDICTION_SET = 2368, BLOCKCHAIN = 2369, COLLATE = 2370, COLLATION = 2371, 
    DEFINITION = 2372, DUPLICATED = 2373, EXTENDED = 2374, HASHING = 2375, 
    IDLE = 2376, IMMUTABLE = 2377, ORACLE_DATAPUMP = 2378, ORACLE_HDFS = 2379, 
    ORACLE_HIVE = 2380, ORACLE_LOADER = 2381, SHA2_512_Q = 2382, SHARDED = 2383, 
    V1_Q = 2384, ISOLATE = 2385, ROOT = 2386, UNITE = 2387, ALGORITHM = 2388, 
    CUME_DIST = 2389, DENSE_RANK = 2390, LISTAGG = 2391, PERCENT_RANK = 2392, 
    PERCENTILE_CONT = 2393, PERCENTILE_DISC = 2394, RANK = 2395, AVG = 2396, 
    CORR = 2397, COVAR_ = 2398, DECODE = 2399, LAG = 2400, LAG_DIFF = 2401, 
    LAG_DIFF_PERCENT = 2402, LEAD = 2403, MAX = 2404, MEDIAN = 2405, MEMOPTIMIZE = 2406, 
    MIN = 2407, NTILE = 2408, NVL = 2409, RATIO_TO_REPORT = 2410, REGR_ = 2411, 
    ROUND = 2412, ROW_NUMBER = 2413, SUBSTR = 2414, TO_CHAR = 2415, TRIM = 2416, 
    SUM = 2417, STDDEV = 2418, VAR_ = 2419, VARIANCE = 2420, LEAST = 2421, 
    GREATEST = 2422, TO_DATE = 2423, CHARSETID = 2424, CHARSETFORM = 2425, 
    DURATION = 2426, EXTEND = 2427, MAXLEN = 2428, PERSISTABLE = 2429, POLYMORPHIC = 2430, 
    STRUCT = 2431, TDO = 2432, WM_CONCAT = 2433, NATIONAL_CHAR_STRING_LIT = 2434, 
    BIT_STRING_LIT = 2435, HEX_STRING_LIT = 2436, DOUBLE_PERIOD = 2437, 
    PERIOD = 2438, UNSIGNED_INTEGER = 2439, APPROXIMATE_NUM_LIT = 2440, 
    CHAR_STRING = 2441, DELIMITED_ID = 2442, PERCENT = 2443, AMPERSAND = 2444, 
    LEFT_PAREN = 2445, RIGHT_PAREN = 2446, DOUBLE_ASTERISK = 2447, ASTERISK = 2448, 
    PLUS_SIGN = 2449, MINUS_SIGN = 2450, COMMA = 2451, SOLIDUS = 2452, AT_SIGN = 2453, 
    ASSIGN_OP = 2454, HASH_OP = 2455, LEFT_CURLY_PAREN = 2456, RIGHT_CURLY_PAREN = 2457, 
    SQ = 2458, BINDVAR = 2459, NOT_EQUAL_OP = 2460, CARRET_OPERATOR_PART = 2461, 
    TILDE_OPERATOR_PART = 2462, EXCLAMATION_OPERATOR_PART = 2463, GREATER_THAN_OP = 2464, 
    LESS_THAN_OP = 2465, COLON = 2466, SEMICOLON = 2467, BAR = 2468, EQUALS_OP = 2469, 
    LEFT_BRACKET = 2470, RIGHT_BRACKET = 2471, INTRODUCER = 2472, SINGLE_LINE_COMMENT = 2473, 
    MULTI_LINE_COMMENT = 2474, REMARK_COMMENT = 2475, PROMPT_MESSAGE = 2476, 
    START_CMD = 2477, REGULAR_ID = 2478, INQUIRY_DIRECTIVE = 2479, SPACES = 2480
  };

  enum {
    RuleSql_script = 0, RuleUnit_statement = 1, RuleAlter_diskgroup = 2, 
    RuleAdd_disk_clause = 3, RuleDrop_disk_clause = 4, RuleResize_disk_clause = 5, 
    RuleReplace_disk_clause = 6, RuleWait_nowait = 7, RuleRename_disk_clause = 8, 
    RuleDisk_online_clause = 9, RuleDisk_offline_clause = 10, RuleTimeout_clause = 11, 
    RuleRebalance_diskgroup_clause = 12, RulePhase = 13, RuleCheck_diskgroup_clause = 14, 
    RuleDiskgroup_template_clauses = 15, RuleQualified_template_clause = 16, 
    RuleRedundancy_clause = 17, RuleStriping_clause = 18, RuleForce_noforce = 19, 
    RuleDiskgroup_directory_clauses = 20, RuleDir_name = 21, RuleDiskgroup_alias_clauses = 22, 
    RuleDiskgroup_volume_clauses = 23, RuleAdd_volume_clause = 24, RuleModify_volume_clause = 25, 
    RuleDiskgroup_attributes = 26, RuleDrop_diskgroup_file_clause = 27, 
    RuleConvert_redundancy_clause = 28, RuleUsergroup_clauses = 29, RuleUser_clauses = 30, 
    RuleFile_permissions_clause = 31, RuleFile_owner_clause = 32, RuleScrub_clause = 33, 
    RuleQuotagroup_clauses = 34, RuleProperty_name = 35, RuleProperty_value = 36, 
    RuleFilegroup_clauses = 37, RuleAdd_filegroup_clause = 38, RuleModify_filegroup_clause = 39, 
    RuleMove_to_filegroup_clause = 40, RuleDrop_filegroup_clause = 41, RuleQuorum_regular = 42, 
    RuleUndrop_disk_clause = 43, RuleDiskgroup_availability = 44, RuleEnable_disable_volume = 45, 
    RuleDrop_function = 46, RuleAlter_flashback_archive = 47, RuleAlter_hierarchy = 48, 
    RuleAlter_function = 49, RuleAlter_java = 50, RuleMatch_string = 51, 
    RuleCreate_function_body = 52, RuleSql_macro_body = 53, RuleParallel_enable_clause = 54, 
    RulePartition_by_clause = 55, RuleResult_cache_clause = 56, RuleAccessible_by_clause = 57, 
    RuleDefault_collation_clause = 58, RuleAggregate_clause = 59, RulePipelined_using_clause = 60, 
    RuleAccessor = 61, RuleRelies_on_part = 62, RuleStreaming_clause = 63, 
    RuleAlter_outline = 64, RuleOutline_options = 65, RuleAlter_lockdown_profile = 66, 
    RuleLockdown_feature = 67, RuleLockdown_options = 68, RuleLockdown_statements = 69, 
    RuleStatement_clauses = 70, RuleClause_options = 71, RuleOption_values = 72, 
    RuleString_list = 73, RuleDisable_enable = 74, RuleDrop_lockdown_profile = 75, 
    RuleDrop_package = 76, RuleAlter_package = 77, RuleCreate_package = 78, 
    RuleCreate_package_body = 79, RulePackage_obj_spec = 80, RuleProcedure_spec = 81, 
    RuleFunction_spec = 82, RulePackage_obj_body = 83, RuleAlter_pmem_filestore = 84, 
    RuleDrop_pmem_filestore = 85, RuleDrop_procedure = 86, RuleAlter_procedure = 87, 
    RuleFunction_body = 88, RuleProcedure_body = 89, RuleCreate_procedure_body = 90, 
    RuleAlter_resource_cost = 91, RuleDrop_outline = 92, RuleAlter_rollback_segment = 93, 
    RuleDrop_restore_point = 94, RuleDrop_rollback_segment = 95, RuleDrop_role = 96, 
    RuleCreate_pmem_filestore = 97, RulePmem_filestore_options = 98, RuleFile_path = 99, 
    RuleCreate_rollback_segment = 100, RuleDrop_trigger = 101, RuleAlter_trigger = 102, 
    RuleCreate_trigger = 103, RuleTrigger_follows_clause = 104, RuleTrigger_when_clause = 105, 
    RuleSimple_dml_trigger = 106, RuleFor_each_row = 107, RuleCompound_dml_trigger = 108, 
    RuleNon_dml_trigger = 109, RuleTrigger_body = 110, RuleCompound_trigger_block = 111, 
    RuleTiming_point_section = 112, RuleNon_dml_event = 113, RuleDml_event_clause = 114, 
    RuleDml_event_element = 115, RuleDml_event_nested_clause = 116, RuleReferencing_clause = 117, 
    RuleReferencing_element = 118, RuleDrop_type = 119, RuleAlter_type = 120, 
    RuleCompile_type_clause = 121, RuleReplace_type_clause = 122, RuleAlter_method_spec = 123, 
    RuleAlter_method_element = 124, RuleAlter_collection_clauses = 125, 
    RuleDependent_handling_clause = 126, RuleDependent_exceptions_part = 127, 
    RuleCreate_type = 128, RuleType_definition = 129, RuleObject_type_def = 130, 
    RuleObject_as_part = 131, RuleObject_under_part = 132, RuleNested_table_type_def = 133, 
    RuleSqlj_object_type = 134, RuleType_body = 135, RuleType_body_elements = 136, 
    RuleMap_order_func_declaration = 137, RuleSubprog_decl_in_type = 138, 
    RuleProc_decl_in_type = 139, RuleFunc_decl_in_type = 140, RuleConstructor_declaration = 141, 
    RuleModifier_clause = 142, RuleObject_member_spec = 143, RuleSqlj_object_type_attr = 144, 
    RuleElement_spec = 145, RuleElement_spec_options = 146, RuleSubprogram_spec = 147, 
    RuleOverriding_subprogram_spec = 148, RuleOverriding_function_spec = 149, 
    RuleOverriding_procedure_spec = 150, RuleType_procedure_spec = 151, 
    RuleType_function_spec = 152, RuleConstructor_spec = 153, RuleMap_order_function_spec = 154, 
    RulePragma_clause = 155, RulePragma_elements = 156, RuleType_elements_parameter = 157, 
    RuleDrop_sequence = 158, RuleAlter_sequence = 159, RuleAlter_session = 160, 
    RuleAlter_session_set_clause = 161, RuleCreate_sequence = 162, RuleSequence_spec = 163, 
    RuleSequence_start_clause = 164, RuleCreate_analytic_view = 165, RuleClassification_clause = 166, 
    RuleCaption_clause = 167, RuleDescription_clause = 168, RuleClassification_item = 169, 
    RuleLanguage = 170, RuleCav_using_clause = 171, RuleDim_by_clause = 172, 
    RuleDim_key = 173, RuleDim_ref = 174, RuleHier_ref = 175, RuleMeasures_clause = 176, 
    RuleAv_measure = 177, RuleBase_meas_clause = 178, RuleMeas_aggregate_clause = 179, 
    RuleCalc_meas_clause = 180, RuleDefault_measure_clause = 181, RuleDefault_aggregate_clause = 182, 
    RuleCache_clause = 183, RuleCache_specification = 184, RuleLevels_clause = 185, 
    RuleLevel_specification = 186, RuleLevel_group_type = 187, RuleFact_columns_clause = 188, 
    RuleQry_transform_clause = 189, RuleCreate_attribute_dimension = 190, 
    RuleAd_using_clause = 191, RuleSource_clause = 192, RuleJoin_path_clause = 193, 
    RuleJoin_condition = 194, RuleJoin_condition_item = 195, RuleAttributes_clause = 196, 
    RuleAd_attributes_clause = 197, RuleAd_level_clause = 198, RuleKey_clause = 199, 
    RuleAlternate_key_clause = 200, RuleDim_order_clause = 201, RuleAll_clause = 202, 
    RuleCreate_audit_policy = 203, RulePrivilege_audit_clause = 204, RuleAction_audit_clause = 205, 
    RuleSystem_actions = 206, RuleStandard_actions = 207, RuleActions_clause = 208, 
    RuleObject_action = 209, RuleSystem_action = 210, RuleComponent_actions = 211, 
    RuleComponent_action = 212, RuleRole_audit_clause = 213, RuleCreate_controlfile = 214, 
    RuleControlfile_options = 215, RuleLogfile_clause = 216, RuleCharacter_set_clause = 217, 
    RuleFile_specification = 218, RuleCreate_diskgroup = 219, RuleQualified_disk_clause = 220, 
    RuleCreate_edition = 221, RuleCreate_flashback_archive = 222, RuleFlashback_archive_quota = 223, 
    RuleFlashback_archive_retention = 224, RuleCreate_hierarchy = 225, RuleHier_using_clause = 226, 
    RuleLevel_hier_clause = 227, RuleHier_attrs_clause = 228, RuleHier_attr_clause = 229, 
    RuleHier_attr_name = 230, RuleCreate_index = 231, RuleCluster_index_clause = 232, 
    RuleCluster_name = 233, RuleTable_index_clause = 234, RuleBitmap_join_index_clause = 235, 
    RuleIndex_expr = 236, RuleIndex_properties = 237, RuleDomain_index_clause = 238, 
    RuleLocal_domain_index_clause = 239, RuleXmlindex_clause = 240, RuleLocal_xmlindex_clause = 241, 
    RuleGlobal_partitioned_index = 242, RuleIndex_partitioning_clause = 243, 
    RuleIndex_partitioning_values_list = 244, RuleLocal_partitioned_index = 245, 
    RuleOn_range_partitioned_table = 246, RuleOn_list_partitioned_table = 247, 
    RulePartitioned_table = 248, RuleOn_hash_partitioned_table = 249, RuleOn_hash_partitioned_clause = 250, 
    RuleOn_comp_partitioned_table = 251, RuleOn_comp_partitioned_clause = 252, 
    RuleIndex_subpartition_clause = 253, RuleIndex_subpartition_subclause = 254, 
    RuleOdci_parameters = 255, RuleIndextype = 256, RuleAlter_index = 257, 
    RuleAlter_index_ops_set1 = 258, RuleAlter_index_ops_set2 = 259, RuleVisible_or_invisible = 260, 
    RuleMonitoring_nomonitoring = 261, RuleRebuild_clause = 262, RuleAlter_index_partitioning = 263, 
    RuleModify_index_default_attrs = 264, RuleAdd_hash_index_partition = 265, 
    RuleCoalesce_index_partition = 266, RuleModify_index_partition = 267, 
    RuleModify_index_partitions_ops = 268, RuleRename_index_partition = 269, 
    RuleDrop_index_partition = 270, RuleSplit_index_partition = 271, RuleIndex_partition_description = 272, 
    RuleModify_index_subpartition = 273, RulePartition_name_old = 274, RuleNew_partition_name = 275, 
    RuleNew_index_name = 276, RuleAlter_inmemory_join_group = 277, RuleCreate_user = 278, 
    RuleAlter_user = 279, RuleDrop_user = 280, RuleAlter_identified_by = 281, 
    RuleIdentified_by = 282, RuleIdentified_other_clause = 283, RuleUser_tablespace_clause = 284, 
    RuleQuota_clause = 285, RuleProfile_clause = 286, RuleRole_clause = 287, 
    RuleUser_default_role_clause = 288, RulePassword_expire_clause = 289, 
    RuleUser_lock_clause = 290, RuleUser_editions_clause = 291, RuleAlter_user_editions_clause = 292, 
    RuleProxy_clause = 293, RuleContainer_names = 294, RuleSet_container_data = 295, 
    RuleAdd_rem_container_data = 296, RuleContainer_data_clause = 297, RuleAdminister_key_management = 298, 
    RuleKeystore_management_clauses = 299, RuleCreate_keystore = 300, RuleOpen_keystore = 301, 
    RuleForce_keystore = 302, RuleClose_keystore = 303, RuleBackup_keystore = 304, 
    RuleAlter_keystore_password = 305, RuleMerge_into_new_keystore = 306, 
    RuleMerge_into_existing_keystore = 307, RuleIsolate_keystore = 308, 
    RuleUnite_keystore = 309, RuleKey_management_clauses = 310, RuleSet_key = 311, 
    RuleCreate_key = 312, RuleMkid = 313, RuleMk = 314, RuleUse_key = 315, 
    RuleSet_key_tag = 316, RuleExport_keys = 317, RuleImport_keys = 318, 
    RuleMigrate_keys = 319, RuleReverse_migrate_keys = 320, RuleMove_keys = 321, 
    RuleIdentified_by_store = 322, RuleUsing_algorithm_clause = 323, RuleUsing_tag_clause = 324, 
    RuleSecret_management_clauses = 325, RuleAdd_update_secret = 326, RuleDelete_secret = 327, 
    RuleAdd_update_secret_seps = 328, RuleDelete_secret_seps = 329, RuleZero_downtime_software_patching_clauses = 330, 
    RuleWith_backup_clause = 331, RuleIdentified_by_password_clause = 332, 
    RuleKeystore_password = 333, RulePath = 334, RuleSecret = 335, RuleAnalyze = 336, 
    RulePartition_extention_clause = 337, RuleValidation_clauses = 338, 
    RuleCompute_clauses = 339, RuleFor_clause = 340, RuleOnline_or_offline = 341, 
    RuleInto_clause1 = 342, RulePartition_key_value = 343, RuleSubpartition_key_value = 344, 
    RuleAssociate_statistics = 345, RuleColumn_association = 346, RuleFunction_association = 347, 
    RuleIndextype_name = 348, RuleUsing_statistics_type = 349, RuleStatistics_type_name = 350, 
    RuleDefault_cost_clause = 351, RuleCpu_cost = 352, RuleIo_cost = 353, 
    RuleNetwork_cost = 354, RuleDefault_selectivity_clause = 355, RuleDefault_selectivity = 356, 
    RuleStorage_table_clause = 357, RuleUnified_auditing = 358, RulePolicy_name = 359, 
    RuleAudit_traditional = 360, RuleAudit_direct_path = 361, RuleAudit_container_clause = 362, 
    RuleAudit_operation_clause = 363, RuleAuditing_by_clause = 364, RuleAudit_user = 365, 
    RuleAudit_schema_object_clause = 366, RuleSql_operation = 367, RuleAuditing_on_clause = 368, 
    RuleModel_name = 369, RuleObject_name = 370, RuleProfile_name = 371, 
    RuleSql_statement_shortcut = 372, RuleDrop_index = 373, RuleDisassociate_statistics = 374, 
    RuleDrop_indextype = 375, RuleDrop_inmemory_join_group = 376, RuleFlashback_table = 377, 
    RuleRestore_point = 378, RulePurge_statement = 379, RuleNoaudit_statement = 380, 
    RuleRename_object = 381, RuleGrant_statement = 382, RuleContainer_clause = 383, 
    RuleRevoke_statement = 384, RuleRevoke_system_privilege = 385, RuleRevokee_clause = 386, 
    RuleRevoke_object_privileges = 387, RuleOn_object_clause = 388, RuleRevoke_roles_from_programs = 389, 
    RuleProgram_unit = 390, RuleCreate_dimension = 391, RuleCreate_directory = 392, 
    RuleDirectory_name = 393, RuleDirectory_path = 394, RuleCreate_inmemory_join_group = 395, 
    RuleDrop_hierarchy = 396, RuleAlter_library = 397, RuleDrop_java = 398, 
    RuleDrop_library = 399, RuleCreate_java = 400, RuleCreate_library = 401, 
    RulePlsql_library_source = 402, RuleCredential_name = 403, RuleLibrary_editionable = 404, 
    RuleLibrary_debug = 405, RuleCompiler_parameters_clause = 406, RuleParameter_value = 407, 
    RuleLibrary_name = 408, RuleAlter_dimension = 409, RuleLevel_clause = 410, 
    RuleHierarchy_clause = 411, RuleDimension_join_clause = 412, RuleAttribute_clause = 413, 
    RuleExtended_attribute_clause = 414, RuleColumn_one_or_more_sub_clause = 415, 
    RuleAlter_view = 416, RuleAlter_view_editionable = 417, RuleCreate_view = 418, 
    RuleEditioning_clause = 419, RuleView_options = 420, RuleView_alias_constraint = 421, 
    RuleObject_view_clause = 422, RuleInline_constraint = 423, RuleInline_ref_constraint = 424, 
    RuleOut_of_line_ref_constraint = 425, RuleOut_of_line_constraint = 426, 
    RuleConstraint_state = 427, RuleXmltype_view_clause = 428, RuleXml_schema_spec = 429, 
    RuleXml_schema_url = 430, RuleElement = 431, RuleAlter_tablespace = 432, 
    RuleDatafile_tempfile_clauses = 433, RuleTablespace_logging_clauses = 434, 
    RuleTablespace_group_clause = 435, RuleTablespace_group_name = 436, 
    RuleTablespace_state_clauses = 437, RuleFlashback_mode_clause = 438, 
    RuleNew_tablespace_name = 439, RuleCreate_tablespace = 440, RulePermanent_tablespace_clause = 441, 
    RuleTablespace_encryption_spec = 442, RuleLogging_clause = 443, RuleExtent_management_clause = 444, 
    RuleSegment_management_clause = 445, RuleTemporary_tablespace_clause = 446, 
    RuleUndo_tablespace_clause = 447, RuleTablespace_retention_clause = 448, 
    RuleCreate_tablespace_set = 449, RulePermanent_tablespace_attrs = 450, 
    RuleTablespace_encryption_clause = 451, RuleDefault_tablespace_params = 452, 
    RuleDefault_table_compression = 453, RuleLow_high = 454, RuleDefault_index_compression = 455, 
    RuleInmmemory_clause = 456, RuleDatafile_specification = 457, RuleTempfile_specification = 458, 
    RuleDatafile_tempfile_spec = 459, RuleRedo_log_file_spec = 460, RuleAutoextend_clause = 461, 
    RuleMaxsize_clause = 462, RuleBuild_clause = 463, RuleParallel_clause = 464, 
    RuleParallel_instances_clause = 465, RuleAlter_materialized_view = 466, 
    RuleAlter_mv_option1 = 467, RuleAlter_mv_refresh = 468, RuleRollback_segment = 469, 
    RuleModify_mv_column_clause = 470, RuleAlter_materialized_view_log = 471, 
    RuleAdd_mv_log_column_clause = 472, RuleMove_mv_log_clause = 473, RuleMv_log_augmentation = 474, 
    RuleCreate_materialized_view_log = 475, RuleNew_values_clause = 476, 
    RuleMv_log_purge_clause = 477, RuleCreate_materialized_zonemap = 478, 
    RuleAlter_materialized_zonemap = 479, RuleDrop_materialized_zonemap = 480, 
    RuleZonemap_refresh_clause = 481, RuleZonemap_attributes = 482, RuleZonemap_name = 483, 
    RuleOperator_name = 484, RuleOperator_function_name = 485, RuleCreate_zonemap_on_table = 486, 
    RuleCreate_zonemap_as_subquery = 487, RuleAlter_operator = 488, RuleDrop_operator = 489, 
    RuleCreate_operator = 490, RuleBinding_clause = 491, RuleAdd_binding_clause = 492, 
    RuleImplementation_clause = 493, RulePrimary_operator_list = 494, RulePrimary_operator_item = 495, 
    RuleOperator_context_clause = 496, RuleUsing_function_clause = 497, 
    RuleDrop_binding_clause = 498, RuleCreate_materialized_view = 499, RuleScoped_table_ref_constraint = 500, 
    RuleMv_column_alias = 501, RuleCreate_mv_refresh = 502, RuleDrop_materialized_view = 503, 
    RuleDrop_materialized_view_log = 504, RuleCreate_context = 505, RuleOracle_namespace = 506, 
    RuleCreate_cluster = 507, RuleCreate_profile = 508, RuleResource_parameters = 509, 
    RulePassword_parameters = 510, RuleCreate_lockdown_profile = 511, RuleStatic_base_profile = 512, 
    RuleDynamic_base_profile = 513, RuleCreate_outline = 514, RuleCreate_restore_point = 515, 
    RuleCreate_role = 516, RuleCreate_table = 517, RuleXmltype_table = 518, 
    RuleXmltype_virtual_columns = 519, RuleXmltype_column_properties = 520, 
    RuleXmltype_storage = 521, RuleXmlschema_spec = 522, RuleObject_table = 523, 
    RuleObject_type = 524, RuleOid_index_clause = 525, RuleOid_clause = 526, 
    RuleObject_properties = 527, RuleObject_table_substitution = 528, RuleRelational_table = 529, 
    RuleRelational_table_properties = 530, RuleRelational_table_property = 531, 
    RuleImmutable_table_clauses = 532, RuleImmutable_table_no_drop_clause = 533, 
    RuleImmutable_table_no_delete_clause = 534, RuleBlockchain_table_clauses = 535, 
    RuleBlockchain_drop_table_clause = 536, RuleBlockchain_row_retention_clause = 537, 
    RuleBlockchain_hash_and_data_format_clause = 538, RuleCollation_name = 539, 
    RuleTable_properties = 540, RuleRead_only_clause = 541, RuleIndexing_clause = 542, 
    RuleAttribute_clustering_clause = 543, RuleClustering_join = 544, RuleClustering_join_item = 545, 
    RuleEquijoin_condition = 546, RuleCluster_clause = 547, RuleClustering_columns = 548, 
    RuleClustering_column_group = 549, RuleYes_no = 550, RuleZonemap_clause = 551, 
    RuleLogical_replication_clause = 552, RuleTable_name = 553, RuleRelational_property = 554, 
    RuleTable_partitioning_clauses = 555, RuleRange_partitions = 556, RuleList_partitions = 557, 
    RuleHash_partitions = 558, RuleIndividual_hash_partitions = 559, RuleHash_partitions_by_quantity = 560, 
    RuleHash_partition_quantity = 561, RuleComposite_range_partitions = 562, 
    RuleComposite_list_partitions = 563, RuleComposite_hash_partitions = 564, 
    RuleReference_partitioning = 565, RuleReference_partition_desc = 566, 
    RuleSystem_partitioning = 567, RuleRange_partition_desc = 568, RuleList_partition_desc = 569, 
    RuleSubpartition_template = 570, RuleHash_subpartition_quantity = 571, 
    RuleSubpartition_by_range = 572, RuleSubpartition_by_list = 573, RuleSubpartition_by_hash = 574, 
    RuleSubpartition_name = 575, RuleRange_subpartition_desc = 576, RuleList_subpartition_desc = 577, 
    RuleIndividual_hash_subparts = 578, RuleHash_subparts_by_quantity = 579, 
    RuleRange_values_clause = 580, RuleRange_values_list = 581, RuleList_values_clause = 582, 
    RuleTable_partition_description = 583, RulePartitioning_storage_clause = 584, 
    RuleLob_partitioning_storage = 585, RuleSize_clause = 586, RuleTable_compression = 587, 
    RuleInmemory_table_clause = 588, RuleInmemory_attributes = 589, RuleInmemory_memcompress = 590, 
    RuleInmemory_priority = 591, RuleInmemory_distribute = 592, RuleInmemory_duplicate = 593, 
    RuleInmemory_column_clause = 594, RulePhysical_attributes_clause = 595, 
    RuleStorage_clause = 596, RuleDeferred_segment_creation = 597, RuleSegment_attributes_clause = 598, 
    RulePhysical_properties = 599, RuleIlm_clause = 600, RuleIlm_policy_clause = 601, 
    RuleIlm_compression_policy = 602, RuleIlm_tiering_policy = 603, RuleIlm_after_on = 604, 
    RuleSegment_group = 605, RuleIlm_inmemory_policy = 606, RuleIlm_time_period = 607, 
    RuleHeap_org_table_clause = 608, RuleExternal_table_clause = 609, RuleAccess_driver_type = 610, 
    RuleExternal_table_data_props = 611, RuleExternal_table_data_format = 612, 
    RuleExternal_table_transform = 613, RuleExternal_table_field = 614, 
    RuleExternal_table_field_list = 615, RuleExternal_table_fields_clause = 616, 
    RuleExternal_table_position_clause = 617, RuleExternal_table_datatype_clause = 618, 
    RuleExternal_table_delimit_clause = 619, RuleExternal_table_trim_clause = 620, 
    RuleExternal_table_date_format_clause = 621, RuleExternal_table_init_clause = 622, 
    RuleExternal_table_condition_clause = 623, RuleExternal_table_lls_clause = 624, 
    RuleExternal_table_records = 625, RuleExternal_table_record_options_clause = 626, 
    RuleExternal_table_output_files = 627, RuleExternal_table_fields = 628, 
    RuleExternal_table_datapump = 629, RuleExternal_table_hive = 630, RuleExternal_table_hive_parameter_map = 631, 
    RuleExternal_table_hive_parameter_map_entry = 632, RuleExternal_table_directory = 633, 
    RuleRow_movement_clause = 634, RuleFlashback_archive_clause = 635, RuleLog_grp = 636, 
    RuleSupplemental_table_logging = 637, RuleSupplemental_log_grp_clause = 638, 
    RuleSupplemental_id_key_clause = 639, RuleAllocate_extent_clause = 640, 
    RuleDeallocate_unused_clause = 641, RuleShrink_clause = 642, RuleRecords_per_block_clause = 643, 
    RuleUpgrade_table_clause = 644, RuleTruncate_table = 645, RuleDrop_table = 646, 
    RuleDrop_tablespace = 647, RuleDrop_tablespace_set = 648, RuleIncluding_contents_clause = 649, 
    RuleDrop_view = 650, RuleComment_on_column = 651, RuleEnable_or_disable = 652, 
    RuleAllow_or_disallow = 653, RuleAlter_synonym = 654, RuleCreate_synonym = 655, 
    RuleDrop_synonym = 656, RuleCreate_spfile = 657, RuleSpfile_name = 658, 
    RulePfile_name = 659, RuleComment_on_table = 660, RuleComment_on_materialized = 661, 
    RuleAlter_analytic_view = 662, RuleAlter_add_cache_clause = 663, RuleLevels_item = 664, 
    RuleMeasure_list = 665, RuleAlter_drop_cache_clause = 666, RuleAlter_attribute_dimension = 667, 
    RuleAlter_audit_policy = 668, RuleAlter_cluster = 669, RuleDrop_analytic_view = 670, 
    RuleDrop_attribute_dimension = 671, RuleDrop_audit_policy = 672, RuleDrop_flashback_archive = 673, 
    RuleDrop_cluster = 674, RuleDrop_context = 675, RuleDrop_directory = 676, 
    RuleDrop_diskgroup = 677, RuleDrop_edition = 678, RuleTruncate_cluster = 679, 
    RuleCache_or_nocache = 680, RuleDatabase_name = 681, RuleAlter_database = 682, 
    RuleDatabase_clause = 683, RuleStartup_clauses = 684, RuleResetlogs_or_noresetlogs = 685, 
    RuleUpgrade_or_downgrade = 686, RuleRecovery_clauses = 687, RuleBegin_or_end = 688, 
    RuleGeneral_recovery = 689, RuleFull_database_recovery = 690, RulePartial_database_recovery = 691, 
    RulePartial_database_recovery_10g = 692, RuleManaged_standby_recovery = 693, 
    RuleDb_name = 694, RuleDatabase_file_clauses = 695, RuleCreate_datafile_clause = 696, 
    RuleAlter_datafile_clause = 697, RuleAlter_tempfile_clause = 698, RuleMove_datafile_clause = 699, 
    RuleLogfile_clauses = 700, RuleAdd_logfile_clauses = 701, RuleGroup_redo_logfile = 702, 
    RuleDrop_logfile_clauses = 703, RuleSwitch_logfile_clause = 704, RuleSupplemental_db_logging = 705, 
    RuleAdd_or_drop = 706, RuleSupplemental_plsql_clause = 707, RuleLogfile_descriptor = 708, 
    RuleControlfile_clauses = 709, RuleTrace_file_clause = 710, RuleStandby_database_clauses = 711, 
    RuleActivate_standby_db_clause = 712, RuleMaximize_standby_db_clause = 713, 
    RuleRegister_logfile_clause = 714, RuleCommit_switchover_clause = 715, 
    RuleStart_standby_clause = 716, RuleStop_standby_clause = 717, RuleConvert_database_clause = 718, 
    RuleDefault_settings_clause = 719, RuleSet_time_zone_clause = 720, RuleInstance_clauses = 721, 
    RuleSecurity_clause = 722, RuleDomain = 723, RuleDatabase = 724, RuleEdition_name = 725, 
    RuleFilenumber = 726, RuleFilename = 727, RulePrepare_clause = 728, 
    RuleDrop_mirror_clause = 729, RuleLost_write_protection = 730, RuleCdb_fleet_clauses = 731, 
    RuleLead_cdb_clause = 732, RuleLead_cdb_uri_clause = 733, RuleProperty_clauses = 734, 
    RuleReplay_upgrade_clauses = 735, RuleAlter_database_link = 736, RulePassword_value = 737, 
    RuleLink_authentication = 738, RuleCreate_schema = 739, RuleCreate_database = 740, 
    RuleDatabase_logging_clauses = 741, RuleDatabase_logging_sub_clause = 742, 
    RuleTablespace_clauses = 743, RuleEnable_pluggable_database = 744, RuleFile_name_convert = 745, 
    RuleFilename_convert_sub_clause = 746, RuleTablespace_datafile_clauses = 747, 
    RuleUndo_mode_clause = 748, RuleDefault_tablespace = 749, RuleDefault_temp_tablespace = 750, 
    RuleUndo_tablespace = 751, RuleDrop_database = 752, RuleCreate_database_link = 753, 
    RuleDrop_database_link = 754, RuleAlter_tablespace_set = 755, RuleAlter_tablespace_attrs = 756, 
    RuleAlter_tablespace_encryption = 757, RuleTs_file_name_convert = 758, 
    RuleAlter_role = 759, RuleRole_identified_clause = 760, RuleAlter_table = 761, 
    RuleMemoptimize_read_write_clause = 762, RuleAlter_table_properties = 763, 
    RuleAlter_table_partitioning = 764, RuleAdd_table_partition = 765, RuleDrop_table_partition = 766, 
    RuleMerge_table_partition = 767, RuleModify_table_partition = 768, RuleSplit_table_partition = 769, 
    RuleTruncate_table_partition = 770, RuleExchange_table_partition = 771, 
    RuleCoalesce_table_partition = 772, RuleAlter_interval_partition = 773, 
    RuleMove_table_partition = 774, RuleFilter_condition = 775, RuleRename_table_partition = 776, 
    RulePartition_extended_names = 777, RuleSubpartition_extended_names = 778, 
    RuleAlter_table_properties_1 = 779, RuleAlter_iot_clauses = 780, RuleAlter_mapping_table_clause = 781, 
    RuleAlter_overflow_clause = 782, RuleAdd_overflow_clause = 783, RuleUpdate_index_clauses = 784, 
    RuleUpdate_global_index_clause = 785, RuleUpdate_all_indexes_clause = 786, 
    RuleUpdate_all_indexes_index_clause = 787, RuleUpdate_index_partition = 788, 
    RuleUpdate_index_subpartition = 789, RuleEnable_disable_clause = 790, 
    RuleUsing_index_clause = 791, RuleIndex_attributes = 792, RuleSort_or_nosort = 793, 
    RuleExceptions_clause = 794, RuleMove_table_clause = 795, RuleIndex_org_table_clause = 796, 
    RuleMapping_table_clause = 797, RuleKey_compression = 798, RuleIndex_org_overflow_clause = 799, 
    RuleColumn_clauses = 800, RuleModify_collection_retrieval = 801, RuleCollection_item = 802, 
    RuleRename_column_clause = 803, RuleOld_column_name = 804, RuleNew_column_name = 805, 
    RuleAdd_modify_drop_column_clauses = 806, RuleDrop_column_clause = 807, 
    RuleModify_column_clauses = 808, RuleModify_col_properties = 809, RuleModify_col_visibility = 810, 
    RuleModify_col_substitutable = 811, RuleAdd_column_clause = 812, RuleVarray_col_properties = 813, 
    RuleVarray_storage_clause = 814, RuleLob_segname = 815, RuleLob_item = 816, 
    RuleLob_storage_parameters = 817, RuleLob_storage_clause = 818, RuleModify_lob_storage_clause = 819, 
    RuleModify_lob_parameters = 820, RuleLob_parameters = 821, RuleLob_deduplicate_clause = 822, 
    RuleLob_compression_clause = 823, RuleLob_retention_clause = 824, RuleEncryption_spec = 825, 
    RuleTablespace = 826, RuleVarray_item = 827, RuleColumn_properties = 828, 
    RuleLob_partition_storage = 829, RulePeriod_definition = 830, RuleStart_time_column = 831, 
    RuleEnd_time_column = 832, RuleColumn_definition = 833, RuleColumn_collation_name = 834, 
    RuleIdentity_clause = 835, RuleIdentity_options_parentheses = 836, RuleIdentity_options = 837, 
    RuleVirtual_column_definition = 838, RuleVirtual_column_expression = 839, 
    RuleAutogenerated_sequence_definition = 840, RuleBy_user_for_statistics_clause = 841, 
    RuleEvaluation_edition_clause = 842, RuleNested_table_col_properties = 843, 
    RuleNested_item = 844, RuleSubstitutable_column_clause = 845, RulePartition_name = 846, 
    RuleSupplemental_logging_props = 847, RuleObject_type_col_properties = 848, 
    RuleConstraint_clauses = 849, RuleOld_constraint_name = 850, RuleNew_constraint_name = 851, 
    RuleDrop_constraint_clause = 852, RuleCheck_constraint = 853, RuleForeign_key_clause = 854, 
    RuleReferences_clause = 855, RuleOn_delete_clause = 856, RuleAnonymous_block = 857, 
    RuleInvoker_rights_clause = 858, RuleCall_spec = 859, RuleJava_spec = 860, 
    RuleC_spec = 861, RuleC_agent_in_clause = 862, RuleC_parameters_clause = 863, 
    RuleC_external_parameter = 864, RuleC_property = 865, RuleParameter = 866, 
    RuleDefault_value_part = 867, RuleSeq_of_declare_specs = 868, RuleDeclare_spec = 869, 
    RuleVariable_declaration = 870, RuleSubtype_declaration = 871, RuleCursor_declaration = 872, 
    RuleParameter_spec = 873, RuleException_declaration = 874, RulePragma_declaration = 875, 
    RuleRecord_type_def = 876, RuleField_spec = 877, RuleRef_cursor_type_def = 878, 
    RuleType_declaration = 879, RuleTable_type_def = 880, RuleTable_indexed_by_part = 881, 
    RuleVarray_type_def = 882, RuleSeq_of_statements = 883, RuleLabel_declaration = 884, 
    RuleStatement = 885, RuleAssignment_statement = 886, RuleContinue_statement = 887, 
    RuleExit_statement = 888, RuleGoto_statement = 889, RuleIf_statement = 890, 
    RuleElsif_part = 891, RuleElse_part = 892, RuleLoop_statement = 893, 
    RuleCursor_loop_param = 894, RuleForall_statement = 895, RuleBounds_clause = 896, 
    RuleBetween_bound = 897, RuleLower_bound = 898, RuleUpper_bound = 899, 
    RuleNull_statement = 900, RuleRaise_statement = 901, RuleReturn_statement = 902, 
    RuleCall_statement = 903, RulePipe_row_statement = 904, RuleSelection_directive = 905, 
    RuleError_directive = 906, RuleSelection_directive_body = 907, RuleBody = 908, 
    RuleException_handler = 909, RuleTrigger_block = 910, RuleTps_block = 911, 
    RuleBlock = 912, RuleSql_statement = 913, RuleExecute_immediate = 914, 
    RuleDynamic_returning_clause = 915, RuleData_manipulation_language_statements = 916, 
    RuleCursor_manipulation_statements = 917, RuleClose_statement = 918, 
    RuleOpen_statement = 919, RuleFetch_statement = 920, RuleVariable_or_collection = 921, 
    RuleOpen_for_statement = 922, RuleTransaction_control_statements = 923, 
    RuleSet_transaction_command = 924, RuleSet_constraint_command = 925, 
    RuleCommit_statement = 926, RuleWrite_clause = 927, RuleRollback_statement = 928, 
    RuleSavepoint_statement = 929, RuleCollection_method_call = 930, RuleExplain_statement = 931, 
    RuleSelect_only_statement = 932, RuleSelect_statement = 933, RuleWith_clause = 934, 
    RuleWith_factoring_clause = 935, RuleSubquery_factoring_clause = 936, 
    RuleSearch_clause = 937, RuleCycle_clause = 938, RuleSubav_factoring_clause = 939, 
    RuleSubav_clause = 940, RuleHierarchies_clause = 941, RuleFilter_clauses = 942, 
    RuleFilter_clause = 943, RuleAdd_calcs_clause = 944, RuleAdd_calc_meas_clause = 945, 
    RuleSubquery = 946, RuleSubquery_basic_elements = 947, RuleSubquery_operation_part = 948, 
    RuleQuery_block = 949, RuleSelected_list = 950, RuleFrom_clause = 951, 
    RuleSelect_list_elements = 952, RuleTable_ref_list = 953, RuleTable_ref = 954, 
    RuleTable_ref_aux = 955, RuleTable_ref_aux_internal = 956, RuleJoin_clause = 957, 
    RuleJoin_on_part = 958, RuleJoin_using_part = 959, RuleOuter_join_type = 960, 
    RuleQuery_partition_clause = 961, RuleFlashback_query_clause = 962, 
    RulePivot_clause = 963, RulePivot_element = 964, RulePivot_for_clause = 965, 
    RulePivot_in_clause = 966, RulePivot_in_clause_element = 967, RulePivot_in_clause_elements = 968, 
    RuleUnpivot_clause = 969, RuleUnpivot_in_clause = 970, RuleUnpivot_in_elements = 971, 
    RuleHierarchical_query_clause = 972, RuleStart_part = 973, RuleGroup_by_clause = 974, 
    RuleGroup_by_elements = 975, RuleRollup_cube_clause = 976, RuleGrouping_sets_clause = 977, 
    RuleGrouping_sets_elements = 978, RuleHaving_clause = 979, RuleModel_clause = 980, 
    RuleCell_reference_options = 981, RuleReturn_rows_clause = 982, RuleReference_model = 983, 
    RuleMain_model = 984, RuleModel_column_clauses = 985, RuleModel_column_partition_part = 986, 
    RuleModel_column_list = 987, RuleModel_column = 988, RuleModel_rules_clause = 989, 
    RuleModel_rules_part = 990, RuleModel_rules_element = 991, RuleCell_assignment = 992, 
    RuleModel_iterate_clause = 993, RuleUntil_part = 994, RuleOrder_by_clause = 995, 
    RuleOrder_by_elements = 996, RuleOffset_clause = 997, RuleFetch_clause = 998, 
    RuleFor_update_clause = 999, RuleFor_update_of_part = 1000, RuleFor_update_options = 1001, 
    RuleUpdate_statement = 1002, RuleUpdate_set_clause = 1003, RuleColumn_based_update_set_clause = 1004, 
    RuleDelete_statement = 1005, RuleInsert_statement = 1006, RuleSingle_table_insert = 1007, 
    RuleMulti_table_insert = 1008, RuleMulti_table_element = 1009, RuleConditional_insert_clause = 1010, 
    RuleConditional_insert_when_part = 1011, RuleConditional_insert_else_part = 1012, 
    RuleInsert_into_clause = 1013, RuleValues_clause = 1014, RuleMerge_statement = 1015, 
    RuleMerge_update_clause = 1016, RuleMerge_element = 1017, RuleMerge_update_delete_part = 1018, 
    RuleMerge_insert_clause = 1019, RuleSelected_tableview = 1020, RuleLock_table_statement = 1021, 
    RuleWait_nowait_part = 1022, RuleLock_table_element = 1023, RuleLock_mode = 1024, 
    RuleGeneral_table_ref = 1025, RuleStatic_returning_clause = 1026, RuleError_logging_clause = 1027, 
    RuleError_logging_into_part = 1028, RuleError_logging_reject_part = 1029, 
    RuleDml_table_expression_clause = 1030, RuleTable_collection_expression = 1031, 
    RuleSubquery_restriction_clause = 1032, RuleSample_clause = 1033, RuleSeed_part = 1034, 
    RuleCondition = 1035, RuleExpressions_ = 1036, RuleExpression = 1037, 
    RuleCursor_expression = 1038, RuleLogical_expression = 1039, RuleUnary_logical_expression = 1040, 
    RuleUnary_logical_operation = 1041, RuleLogical_operation = 1042, RuleMultiset_expression = 1043, 
    RuleRelational_expression = 1044, RuleCompound_expression = 1045, RuleRelational_operator = 1046, 
    RuleIn_elements = 1047, RuleBetween_elements = 1048, RuleConcatenation = 1049, 
    RuleInterval_expression = 1050, RuleModel_expression = 1051, RuleModel_expression_element = 1052, 
    RuleSingle_column_for_loop = 1053, RuleMulti_column_for_loop = 1054, 
    RuleUnary_expression = 1055, RuleImplicit_cursor_expression = 1056, 
    RuleCollection_expression = 1057, RuleCase_statement = 1058, RuleSimple_case_statement = 1059, 
    RuleSearched_case_statement = 1060, RuleCase_when_part_statement = 1061, 
    RuleCase_else_part_statement = 1062, RuleCase_expression = 1063, RuleSimple_case_expression = 1064, 
    RuleSearched_case_expression = 1065, RuleCase_when_part_expression = 1066, 
    RuleCase_else_part_expression = 1067, RuleAtom = 1068, RuleQuantified_expression = 1069, 
    RuleString_function = 1070, RuleStandard_function = 1071, RuleJson_function = 1072, 
    RuleJson_object_content = 1073, RuleJson_object_entry = 1074, RuleJson_table_clause = 1075, 
    RuleJson_array_element = 1076, RuleJson_on_null_clause = 1077, RuleJson_return_clause = 1078, 
    RuleJson_transform_op = 1079, RuleJson_column_clause = 1080, RuleJson_column_definition = 1081, 
    RuleJson_query_returning_clause = 1082, RuleJson_query_return_type = 1083, 
    RuleJson_query_wrapper_clause = 1084, RuleJson_query_on_error_clause = 1085, 
    RuleJson_query_on_empty_clause = 1086, RuleJson_value_return_clause = 1087, 
    RuleJson_value_return_type = 1088, RuleJson_value_on_mismatch_clause = 1089, 
    RuleLiteral = 1090, RuleNumeric_function_wrapper = 1091, RuleNumeric_function = 1092, 
    RuleListagg_overflow_clause = 1093, RuleOther_function = 1094, RuleOver_clause_keyword = 1095, 
    RuleWithin_or_over_clause_keyword = 1096, RuleStandard_prediction_function_keyword = 1097, 
    RuleOver_clause = 1098, RuleWindowing_clause = 1099, RuleWindowing_type = 1100, 
    RuleWindowing_elements = 1101, RuleUsing_clause = 1102, RuleUsing_element = 1103, 
    RuleAssignable_element = 1104, RuleCollect_order_by_part = 1105, RuleWithin_or_over_part = 1106, 
    RuleString_delimiter = 1107, RuleCost_matrix_clause = 1108, RuleXml_passing_clause = 1109, 
    RuleXml_attributes_clause = 1110, RuleXml_namespaces_clause = 1111, 
    RuleXml_table_column = 1112, RuleXml_general_default_part = 1113, RuleXml_multiuse_expression_element = 1114, 
    RuleXmlroot_param_version_part = 1115, RuleXmlroot_param_standalone_part = 1116, 
    RuleXmlserialize_param_enconding_part = 1117, RuleXmlserialize_param_version_part = 1118, 
    RuleXmlserialize_param_ident_part = 1119, RuleAnnotations_clause = 1120, 
    RuleAnnotations_list = 1121, RuleAnnotation = 1122, RuleSql_plus_command_no_semicolon = 1123, 
    RuleSql_plus_command = 1124, RuleStart_command = 1125, RuleWhenever_command = 1126, 
    RuleSet_command = 1127, RuleTiming_command = 1128, RuleClear_command = 1129, 
    RulePartition_extension_clause = 1130, RuleColumn_alias = 1131, RuleTable_alias = 1132, 
    RuleWhere_clause = 1133, RuleInto_clause = 1134, RuleXml_column_name = 1135, 
    RuleCost_class_name = 1136, RuleAttribute_name = 1137, RuleSavepoint_name = 1138, 
    RuleRollback_segment_name = 1139, RuleSchema_name = 1140, RuleRoutine_name = 1141, 
    RulePackage_name = 1142, RuleImplementation_type_name = 1143, RuleParameter_name = 1144, 
    RuleReference_model_name = 1145, RuleMain_model_name = 1146, RuleContainer_tableview_name = 1147, 
    RuleAggregate_function_name = 1148, RuleQuery_name = 1149, RuleGrantee_name = 1150, 
    RuleRole_name = 1151, RuleConstraint_name = 1152, RuleLabel_name = 1153, 
    RuleType_name = 1154, RuleSequence_name = 1155, RuleException_name = 1156, 
    RuleFunction_name = 1157, RuleProcedure_name = 1158, RuleTrigger_name = 1159, 
    RuleVariable_name = 1160, RuleIndex_name = 1161, RuleCursor_name = 1162, 
    RuleRecord_name = 1163, RuleLink_name = 1164, RuleLocal_link_name = 1165, 
    RuleConnection_qualifier = 1166, RuleColumn_name = 1167, RuleTableview_name = 1168, 
    RuleXmltable = 1169, RuleChar_set_name = 1170, RuleSynonym_name = 1171, 
    RuleSchema_object_name = 1172, RuleDir_object_name = 1173, RuleUser_object_name = 1174, 
    RuleGrant_object_name = 1175, RuleColumn_list = 1176, RuleParen_column_list = 1177, 
    RuleKeep_clause = 1178, RuleFunction_argument = 1179, RuleFunction_argument_analytic = 1180, 
    RuleFunction_argument_modeling = 1181, RuleRespect_or_ignore_nulls = 1182, 
    RuleArgument = 1183, RuleType_spec = 1184, RuleDatatype = 1185, RulePrecision_part = 1186, 
    RuleNative_datatype_element = 1187, RuleBind_variable = 1188, RuleGeneral_element = 1189, 
    RuleGeneral_element_part = 1190, RuleTable_element = 1191, RuleObject_privilege = 1192, 
    RuleSystem_privilege = 1193, RuleConstant = 1194, RuleNumeric = 1195, 
    RuleNumeric_negative = 1196, RuleQuoted_string = 1197, RuleIdentifier = 1198, 
    RuleId_expression = 1199, RuleInquiry_directive = 1200, RuleOuter_join_sign = 1201, 
    RuleRegular_id = 1202, RuleNon_reserved_keywords_in_18c = 1203, RuleNon_reserved_keywords_in_12c = 1204, 
    RuleNon_reserved_keywords_pre12c = 1205
  };

  explicit PlSqlParser(antlr4::TokenStream *input);

  PlSqlParser(antlr4::TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options);

  ~PlSqlParser() override;

  std::string getGrammarFileName() const override;

  const antlr4::atn::ATN& getATN() const override;

  const std::vector<std::string>& getRuleNames() const override;

  const antlr4::dfa::Vocabulary& getVocabulary() const override;

  antlr4::atn::SerializedATNView getSerializedATN() const override;


  class Sql_scriptContext;
  class Unit_statementContext;
  class Alter_diskgroupContext;
  class Add_disk_clauseContext;
  class Drop_disk_clauseContext;
  class Resize_disk_clauseContext;
  class Replace_disk_clauseContext;
  class Wait_nowaitContext;
  class Rename_disk_clauseContext;
  class Disk_online_clauseContext;
  class Disk_offline_clauseContext;
  class Timeout_clauseContext;
  class Rebalance_diskgroup_clauseContext;
  class PhaseContext;
  class Check_diskgroup_clauseContext;
  class Diskgroup_template_clausesContext;
  class Qualified_template_clauseContext;
  class Redundancy_clauseContext;
  class Striping_clauseContext;
  class Force_noforceContext;
  class Diskgroup_directory_clausesContext;
  class Dir_nameContext;
  class Diskgroup_alias_clausesContext;
  class Diskgroup_volume_clausesContext;
  class Add_volume_clauseContext;
  class Modify_volume_clauseContext;
  class Diskgroup_attributesContext;
  class Drop_diskgroup_file_clauseContext;
  class Convert_redundancy_clauseContext;
  class Usergroup_clausesContext;
  class User_clausesContext;
  class File_permissions_clauseContext;
  class File_owner_clauseContext;
  class Scrub_clauseContext;
  class Quotagroup_clausesContext;
  class Property_nameContext;
  class Property_valueContext;
  class Filegroup_clausesContext;
  class Add_filegroup_clauseContext;
  class Modify_filegroup_clauseContext;
  class Move_to_filegroup_clauseContext;
  class Drop_filegroup_clauseContext;
  class Quorum_regularContext;
  class Undrop_disk_clauseContext;
  class Diskgroup_availabilityContext;
  class Enable_disable_volumeContext;
  class Drop_functionContext;
  class Alter_flashback_archiveContext;
  class Alter_hierarchyContext;
  class Alter_functionContext;
  class Alter_javaContext;
  class Match_stringContext;
  class Create_function_bodyContext;
  class Sql_macro_bodyContext;
  class Parallel_enable_clauseContext;
  class Partition_by_clauseContext;
  class Result_cache_clauseContext;
  class Accessible_by_clauseContext;
  class Default_collation_clauseContext;
  class Aggregate_clauseContext;
  class Pipelined_using_clauseContext;
  class AccessorContext;
  class Relies_on_partContext;
  class Streaming_clauseContext;
  class Alter_outlineContext;
  class Outline_optionsContext;
  class Alter_lockdown_profileContext;
  class Lockdown_featureContext;
  class Lockdown_optionsContext;
  class Lockdown_statementsContext;
  class Statement_clausesContext;
  class Clause_optionsContext;
  class Option_valuesContext;
  class String_listContext;
  class Disable_enableContext;
  class Drop_lockdown_profileContext;
  class Drop_packageContext;
  class Alter_packageContext;
  class Create_packageContext;
  class Create_package_bodyContext;
  class Package_obj_specContext;
  class Procedure_specContext;
  class Function_specContext;
  class Package_obj_bodyContext;
  class Alter_pmem_filestoreContext;
  class Drop_pmem_filestoreContext;
  class Drop_procedureContext;
  class Alter_procedureContext;
  class Function_bodyContext;
  class Procedure_bodyContext;
  class Create_procedure_bodyContext;
  class Alter_resource_costContext;
  class Drop_outlineContext;
  class Alter_rollback_segmentContext;
  class Drop_restore_pointContext;
  class Drop_rollback_segmentContext;
  class Drop_roleContext;
  class Create_pmem_filestoreContext;
  class Pmem_filestore_optionsContext;
  class File_pathContext;
  class Create_rollback_segmentContext;
  class Drop_triggerContext;
  class Alter_triggerContext;
  class Create_triggerContext;
  class Trigger_follows_clauseContext;
  class Trigger_when_clauseContext;
  class Simple_dml_triggerContext;
  class For_each_rowContext;
  class Compound_dml_triggerContext;
  class Non_dml_triggerContext;
  class Trigger_bodyContext;
  class Compound_trigger_blockContext;
  class Timing_point_sectionContext;
  class Non_dml_eventContext;
  class Dml_event_clauseContext;
  class Dml_event_elementContext;
  class Dml_event_nested_clauseContext;
  class Referencing_clauseContext;
  class Referencing_elementContext;
  class Drop_typeContext;
  class Alter_typeContext;
  class Compile_type_clauseContext;
  class Replace_type_clauseContext;
  class Alter_method_specContext;
  class Alter_method_elementContext;
  class Alter_collection_clausesContext;
  class Dependent_handling_clauseContext;
  class Dependent_exceptions_partContext;
  class Create_typeContext;
  class Type_definitionContext;
  class Object_type_defContext;
  class Object_as_partContext;
  class Object_under_partContext;
  class Nested_table_type_defContext;
  class Sqlj_object_typeContext;
  class Type_bodyContext;
  class Type_body_elementsContext;
  class Map_order_func_declarationContext;
  class Subprog_decl_in_typeContext;
  class Proc_decl_in_typeContext;
  class Func_decl_in_typeContext;
  class Constructor_declarationContext;
  class Modifier_clauseContext;
  class Object_member_specContext;
  class Sqlj_object_type_attrContext;
  class Element_specContext;
  class Element_spec_optionsContext;
  class Subprogram_specContext;
  class Overriding_subprogram_specContext;
  class Overriding_function_specContext;
  class Overriding_procedure_specContext;
  class Type_procedure_specContext;
  class Type_function_specContext;
  class Constructor_specContext;
  class Map_order_function_specContext;
  class Pragma_clauseContext;
  class Pragma_elementsContext;
  class Type_elements_parameterContext;
  class Drop_sequenceContext;
  class Alter_sequenceContext;
  class Alter_sessionContext;
  class Alter_session_set_clauseContext;
  class Create_sequenceContext;
  class Sequence_specContext;
  class Sequence_start_clauseContext;
  class Create_analytic_viewContext;
  class Classification_clauseContext;
  class Caption_clauseContext;
  class Description_clauseContext;
  class Classification_itemContext;
  class LanguageContext;
  class Cav_using_clauseContext;
  class Dim_by_clauseContext;
  class Dim_keyContext;
  class Dim_refContext;
  class Hier_refContext;
  class Measures_clauseContext;
  class Av_measureContext;
  class Base_meas_clauseContext;
  class Meas_aggregate_clauseContext;
  class Calc_meas_clauseContext;
  class Default_measure_clauseContext;
  class Default_aggregate_clauseContext;
  class Cache_clauseContext;
  class Cache_specificationContext;
  class Levels_clauseContext;
  class Level_specificationContext;
  class Level_group_typeContext;
  class Fact_columns_clauseContext;
  class Qry_transform_clauseContext;
  class Create_attribute_dimensionContext;
  class Ad_using_clauseContext;
  class Source_clauseContext;
  class Join_path_clauseContext;
  class Join_conditionContext;
  class Join_condition_itemContext;
  class Attributes_clauseContext;
  class Ad_attributes_clauseContext;
  class Ad_level_clauseContext;
  class Key_clauseContext;
  class Alternate_key_clauseContext;
  class Dim_order_clauseContext;
  class All_clauseContext;
  class Create_audit_policyContext;
  class Privilege_audit_clauseContext;
  class Action_audit_clauseContext;
  class System_actionsContext;
  class Standard_actionsContext;
  class Actions_clauseContext;
  class Object_actionContext;
  class System_actionContext;
  class Component_actionsContext;
  class Component_actionContext;
  class Role_audit_clauseContext;
  class Create_controlfileContext;
  class Controlfile_optionsContext;
  class Logfile_clauseContext;
  class Character_set_clauseContext;
  class File_specificationContext;
  class Create_diskgroupContext;
  class Qualified_disk_clauseContext;
  class Create_editionContext;
  class Create_flashback_archiveContext;
  class Flashback_archive_quotaContext;
  class Flashback_archive_retentionContext;
  class Create_hierarchyContext;
  class Hier_using_clauseContext;
  class Level_hier_clauseContext;
  class Hier_attrs_clauseContext;
  class Hier_attr_clauseContext;
  class Hier_attr_nameContext;
  class Create_indexContext;
  class Cluster_index_clauseContext;
  class Cluster_nameContext;
  class Table_index_clauseContext;
  class Bitmap_join_index_clauseContext;
  class Index_exprContext;
  class Index_propertiesContext;
  class Domain_index_clauseContext;
  class Local_domain_index_clauseContext;
  class Xmlindex_clauseContext;
  class Local_xmlindex_clauseContext;
  class Global_partitioned_indexContext;
  class Index_partitioning_clauseContext;
  class Index_partitioning_values_listContext;
  class Local_partitioned_indexContext;
  class On_range_partitioned_tableContext;
  class On_list_partitioned_tableContext;
  class Partitioned_tableContext;
  class On_hash_partitioned_tableContext;
  class On_hash_partitioned_clauseContext;
  class On_comp_partitioned_tableContext;
  class On_comp_partitioned_clauseContext;
  class Index_subpartition_clauseContext;
  class Index_subpartition_subclauseContext;
  class Odci_parametersContext;
  class IndextypeContext;
  class Alter_indexContext;
  class Alter_index_ops_set1Context;
  class Alter_index_ops_set2Context;
  class Visible_or_invisibleContext;
  class Monitoring_nomonitoringContext;
  class Rebuild_clauseContext;
  class Alter_index_partitioningContext;
  class Modify_index_default_attrsContext;
  class Add_hash_index_partitionContext;
  class Coalesce_index_partitionContext;
  class Modify_index_partitionContext;
  class Modify_index_partitions_opsContext;
  class Rename_index_partitionContext;
  class Drop_index_partitionContext;
  class Split_index_partitionContext;
  class Index_partition_descriptionContext;
  class Modify_index_subpartitionContext;
  class Partition_name_oldContext;
  class New_partition_nameContext;
  class New_index_nameContext;
  class Alter_inmemory_join_groupContext;
  class Create_userContext;
  class Alter_userContext;
  class Drop_userContext;
  class Alter_identified_byContext;
  class Identified_byContext;
  class Identified_other_clauseContext;
  class User_tablespace_clauseContext;
  class Quota_clauseContext;
  class Profile_clauseContext;
  class Role_clauseContext;
  class User_default_role_clauseContext;
  class Password_expire_clauseContext;
  class User_lock_clauseContext;
  class User_editions_clauseContext;
  class Alter_user_editions_clauseContext;
  class Proxy_clauseContext;
  class Container_namesContext;
  class Set_container_dataContext;
  class Add_rem_container_dataContext;
  class Container_data_clauseContext;
  class Administer_key_managementContext;
  class Keystore_management_clausesContext;
  class Create_keystoreContext;
  class Open_keystoreContext;
  class Force_keystoreContext;
  class Close_keystoreContext;
  class Backup_keystoreContext;
  class Alter_keystore_passwordContext;
  class Merge_into_new_keystoreContext;
  class Merge_into_existing_keystoreContext;
  class Isolate_keystoreContext;
  class Unite_keystoreContext;
  class Key_management_clausesContext;
  class Set_keyContext;
  class Create_keyContext;
  class MkidContext;
  class MkContext;
  class Use_keyContext;
  class Set_key_tagContext;
  class Export_keysContext;
  class Import_keysContext;
  class Migrate_keysContext;
  class Reverse_migrate_keysContext;
  class Move_keysContext;
  class Identified_by_storeContext;
  class Using_algorithm_clauseContext;
  class Using_tag_clauseContext;
  class Secret_management_clausesContext;
  class Add_update_secretContext;
  class Delete_secretContext;
  class Add_update_secret_sepsContext;
  class Delete_secret_sepsContext;
  class Zero_downtime_software_patching_clausesContext;
  class With_backup_clauseContext;
  class Identified_by_password_clauseContext;
  class Keystore_passwordContext;
  class PathContext;
  class SecretContext;
  class AnalyzeContext;
  class Partition_extention_clauseContext;
  class Validation_clausesContext;
  class Compute_clausesContext;
  class For_clauseContext;
  class Online_or_offlineContext;
  class Into_clause1Context;
  class Partition_key_valueContext;
  class Subpartition_key_valueContext;
  class Associate_statisticsContext;
  class Column_associationContext;
  class Function_associationContext;
  class Indextype_nameContext;
  class Using_statistics_typeContext;
  class Statistics_type_nameContext;
  class Default_cost_clauseContext;
  class Cpu_costContext;
  class Io_costContext;
  class Network_costContext;
  class Default_selectivity_clauseContext;
  class Default_selectivityContext;
  class Storage_table_clauseContext;
  class Unified_auditingContext;
  class Policy_nameContext;
  class Audit_traditionalContext;
  class Audit_direct_pathContext;
  class Audit_container_clauseContext;
  class Audit_operation_clauseContext;
  class Auditing_by_clauseContext;
  class Audit_userContext;
  class Audit_schema_object_clauseContext;
  class Sql_operationContext;
  class Auditing_on_clauseContext;
  class Model_nameContext;
  class Object_nameContext;
  class Profile_nameContext;
  class Sql_statement_shortcutContext;
  class Drop_indexContext;
  class Disassociate_statisticsContext;
  class Drop_indextypeContext;
  class Drop_inmemory_join_groupContext;
  class Flashback_tableContext;
  class Restore_pointContext;
  class Purge_statementContext;
  class Noaudit_statementContext;
  class Rename_objectContext;
  class Grant_statementContext;
  class Container_clauseContext;
  class Revoke_statementContext;
  class Revoke_system_privilegeContext;
  class Revokee_clauseContext;
  class Revoke_object_privilegesContext;
  class On_object_clauseContext;
  class Revoke_roles_from_programsContext;
  class Program_unitContext;
  class Create_dimensionContext;
  class Create_directoryContext;
  class Directory_nameContext;
  class Directory_pathContext;
  class Create_inmemory_join_groupContext;
  class Drop_hierarchyContext;
  class Alter_libraryContext;
  class Drop_javaContext;
  class Drop_libraryContext;
  class Create_javaContext;
  class Create_libraryContext;
  class Plsql_library_sourceContext;
  class Credential_nameContext;
  class Library_editionableContext;
  class Library_debugContext;
  class Compiler_parameters_clauseContext;
  class Parameter_valueContext;
  class Library_nameContext;
  class Alter_dimensionContext;
  class Level_clauseContext;
  class Hierarchy_clauseContext;
  class Dimension_join_clauseContext;
  class Attribute_clauseContext;
  class Extended_attribute_clauseContext;
  class Column_one_or_more_sub_clauseContext;
  class Alter_viewContext;
  class Alter_view_editionableContext;
  class Create_viewContext;
  class Editioning_clauseContext;
  class View_optionsContext;
  class View_alias_constraintContext;
  class Object_view_clauseContext;
  class Inline_constraintContext;
  class Inline_ref_constraintContext;
  class Out_of_line_ref_constraintContext;
  class Out_of_line_constraintContext;
  class Constraint_stateContext;
  class Xmltype_view_clauseContext;
  class Xml_schema_specContext;
  class Xml_schema_urlContext;
  class ElementContext;
  class Alter_tablespaceContext;
  class Datafile_tempfile_clausesContext;
  class Tablespace_logging_clausesContext;
  class Tablespace_group_clauseContext;
  class Tablespace_group_nameContext;
  class Tablespace_state_clausesContext;
  class Flashback_mode_clauseContext;
  class New_tablespace_nameContext;
  class Create_tablespaceContext;
  class Permanent_tablespace_clauseContext;
  class Tablespace_encryption_specContext;
  class Logging_clauseContext;
  class Extent_management_clauseContext;
  class Segment_management_clauseContext;
  class Temporary_tablespace_clauseContext;
  class Undo_tablespace_clauseContext;
  class Tablespace_retention_clauseContext;
  class Create_tablespace_setContext;
  class Permanent_tablespace_attrsContext;
  class Tablespace_encryption_clauseContext;
  class Default_tablespace_paramsContext;
  class Default_table_compressionContext;
  class Low_highContext;
  class Default_index_compressionContext;
  class Inmmemory_clauseContext;
  class Datafile_specificationContext;
  class Tempfile_specificationContext;
  class Datafile_tempfile_specContext;
  class Redo_log_file_specContext;
  class Autoextend_clauseContext;
  class Maxsize_clauseContext;
  class Build_clauseContext;
  class Parallel_clauseContext;
  class Parallel_instances_clauseContext;
  class Alter_materialized_viewContext;
  class Alter_mv_option1Context;
  class Alter_mv_refreshContext;
  class Rollback_segmentContext;
  class Modify_mv_column_clauseContext;
  class Alter_materialized_view_logContext;
  class Add_mv_log_column_clauseContext;
  class Move_mv_log_clauseContext;
  class Mv_log_augmentationContext;
  class Create_materialized_view_logContext;
  class New_values_clauseContext;
  class Mv_log_purge_clauseContext;
  class Create_materialized_zonemapContext;
  class Alter_materialized_zonemapContext;
  class Drop_materialized_zonemapContext;
  class Zonemap_refresh_clauseContext;
  class Zonemap_attributesContext;
  class Zonemap_nameContext;
  class Operator_nameContext;
  class Operator_function_nameContext;
  class Create_zonemap_on_tableContext;
  class Create_zonemap_as_subqueryContext;
  class Alter_operatorContext;
  class Drop_operatorContext;
  class Create_operatorContext;
  class Binding_clauseContext;
  class Add_binding_clauseContext;
  class Implementation_clauseContext;
  class Primary_operator_listContext;
  class Primary_operator_itemContext;
  class Operator_context_clauseContext;
  class Using_function_clauseContext;
  class Drop_binding_clauseContext;
  class Create_materialized_viewContext;
  class Scoped_table_ref_constraintContext;
  class Mv_column_aliasContext;
  class Create_mv_refreshContext;
  class Drop_materialized_viewContext;
  class Drop_materialized_view_logContext;
  class Create_contextContext;
  class Oracle_namespaceContext;
  class Create_clusterContext;
  class Create_profileContext;
  class Resource_parametersContext;
  class Password_parametersContext;
  class Create_lockdown_profileContext;
  class Static_base_profileContext;
  class Dynamic_base_profileContext;
  class Create_outlineContext;
  class Create_restore_pointContext;
  class Create_roleContext;
  class Create_tableContext;
  class Xmltype_tableContext;
  class Xmltype_virtual_columnsContext;
  class Xmltype_column_propertiesContext;
  class Xmltype_storageContext;
  class Xmlschema_specContext;
  class Object_tableContext;
  class Object_typeContext;
  class Oid_index_clauseContext;
  class Oid_clauseContext;
  class Object_propertiesContext;
  class Object_table_substitutionContext;
  class Relational_tableContext;
  class Relational_table_propertiesContext;
  class Relational_table_propertyContext;
  class Immutable_table_clausesContext;
  class Immutable_table_no_drop_clauseContext;
  class Immutable_table_no_delete_clauseContext;
  class Blockchain_table_clausesContext;
  class Blockchain_drop_table_clauseContext;
  class Blockchain_row_retention_clauseContext;
  class Blockchain_hash_and_data_format_clauseContext;
  class Collation_nameContext;
  class Table_propertiesContext;
  class Read_only_clauseContext;
  class Indexing_clauseContext;
  class Attribute_clustering_clauseContext;
  class Clustering_joinContext;
  class Clustering_join_itemContext;
  class Equijoin_conditionContext;
  class Cluster_clauseContext;
  class Clustering_columnsContext;
  class Clustering_column_groupContext;
  class Yes_noContext;
  class Zonemap_clauseContext;
  class Logical_replication_clauseContext;
  class Table_nameContext;
  class Relational_propertyContext;
  class Table_partitioning_clausesContext;
  class Range_partitionsContext;
  class List_partitionsContext;
  class Hash_partitionsContext;
  class Individual_hash_partitionsContext;
  class Hash_partitions_by_quantityContext;
  class Hash_partition_quantityContext;
  class Composite_range_partitionsContext;
  class Composite_list_partitionsContext;
  class Composite_hash_partitionsContext;
  class Reference_partitioningContext;
  class Reference_partition_descContext;
  class System_partitioningContext;
  class Range_partition_descContext;
  class List_partition_descContext;
  class Subpartition_templateContext;
  class Hash_subpartition_quantityContext;
  class Subpartition_by_rangeContext;
  class Subpartition_by_listContext;
  class Subpartition_by_hashContext;
  class Subpartition_nameContext;
  class Range_subpartition_descContext;
  class List_subpartition_descContext;
  class Individual_hash_subpartsContext;
  class Hash_subparts_by_quantityContext;
  class Range_values_clauseContext;
  class Range_values_listContext;
  class List_values_clauseContext;
  class Table_partition_descriptionContext;
  class Partitioning_storage_clauseContext;
  class Lob_partitioning_storageContext;
  class Size_clauseContext;
  class Table_compressionContext;
  class Inmemory_table_clauseContext;
  class Inmemory_attributesContext;
  class Inmemory_memcompressContext;
  class Inmemory_priorityContext;
  class Inmemory_distributeContext;
  class Inmemory_duplicateContext;
  class Inmemory_column_clauseContext;
  class Physical_attributes_clauseContext;
  class Storage_clauseContext;
  class Deferred_segment_creationContext;
  class Segment_attributes_clauseContext;
  class Physical_propertiesContext;
  class Ilm_clauseContext;
  class Ilm_policy_clauseContext;
  class Ilm_compression_policyContext;
  class Ilm_tiering_policyContext;
  class Ilm_after_onContext;
  class Segment_groupContext;
  class Ilm_inmemory_policyContext;
  class Ilm_time_periodContext;
  class Heap_org_table_clauseContext;
  class External_table_clauseContext;
  class Access_driver_typeContext;
  class External_table_data_propsContext;
  class External_table_data_formatContext;
  class External_table_transformContext;
  class External_table_fieldContext;
  class External_table_field_listContext;
  class External_table_fields_clauseContext;
  class External_table_position_clauseContext;
  class External_table_datatype_clauseContext;
  class External_table_delimit_clauseContext;
  class External_table_trim_clauseContext;
  class External_table_date_format_clauseContext;
  class External_table_init_clauseContext;
  class External_table_condition_clauseContext;
  class External_table_lls_clauseContext;
  class External_table_recordsContext;
  class External_table_record_options_clauseContext;
  class External_table_output_filesContext;
  class External_table_fieldsContext;
  class External_table_datapumpContext;
  class External_table_hiveContext;
  class External_table_hive_parameter_mapContext;
  class External_table_hive_parameter_map_entryContext;
  class External_table_directoryContext;
  class Row_movement_clauseContext;
  class Flashback_archive_clauseContext;
  class Log_grpContext;
  class Supplemental_table_loggingContext;
  class Supplemental_log_grp_clauseContext;
  class Supplemental_id_key_clauseContext;
  class Allocate_extent_clauseContext;
  class Deallocate_unused_clauseContext;
  class Shrink_clauseContext;
  class Records_per_block_clauseContext;
  class Upgrade_table_clauseContext;
  class Truncate_tableContext;
  class Drop_tableContext;
  class Drop_tablespaceContext;
  class Drop_tablespace_setContext;
  class Including_contents_clauseContext;
  class Drop_viewContext;
  class Comment_on_columnContext;
  class Enable_or_disableContext;
  class Allow_or_disallowContext;
  class Alter_synonymContext;
  class Create_synonymContext;
  class Drop_synonymContext;
  class Create_spfileContext;
  class Spfile_nameContext;
  class Pfile_nameContext;
  class Comment_on_tableContext;
  class Comment_on_materializedContext;
  class Alter_analytic_viewContext;
  class Alter_add_cache_clauseContext;
  class Levels_itemContext;
  class Measure_listContext;
  class Alter_drop_cache_clauseContext;
  class Alter_attribute_dimensionContext;
  class Alter_audit_policyContext;
  class Alter_clusterContext;
  class Drop_analytic_viewContext;
  class Drop_attribute_dimensionContext;
  class Drop_audit_policyContext;
  class Drop_flashback_archiveContext;
  class Drop_clusterContext;
  class Drop_contextContext;
  class Drop_directoryContext;
  class Drop_diskgroupContext;
  class Drop_editionContext;
  class Truncate_clusterContext;
  class Cache_or_nocacheContext;
  class Database_nameContext;
  class Alter_databaseContext;
  class Database_clauseContext;
  class Startup_clausesContext;
  class Resetlogs_or_noresetlogsContext;
  class Upgrade_or_downgradeContext;
  class Recovery_clausesContext;
  class Begin_or_endContext;
  class General_recoveryContext;
  class Full_database_recoveryContext;
  class Partial_database_recoveryContext;
  class Partial_database_recovery_10gContext;
  class Managed_standby_recoveryContext;
  class Db_nameContext;
  class Database_file_clausesContext;
  class Create_datafile_clauseContext;
  class Alter_datafile_clauseContext;
  class Alter_tempfile_clauseContext;
  class Move_datafile_clauseContext;
  class Logfile_clausesContext;
  class Add_logfile_clausesContext;
  class Group_redo_logfileContext;
  class Drop_logfile_clausesContext;
  class Switch_logfile_clauseContext;
  class Supplemental_db_loggingContext;
  class Add_or_dropContext;
  class Supplemental_plsql_clauseContext;
  class Logfile_descriptorContext;
  class Controlfile_clausesContext;
  class Trace_file_clauseContext;
  class Standby_database_clausesContext;
  class Activate_standby_db_clauseContext;
  class Maximize_standby_db_clauseContext;
  class Register_logfile_clauseContext;
  class Commit_switchover_clauseContext;
  class Start_standby_clauseContext;
  class Stop_standby_clauseContext;
  class Convert_database_clauseContext;
  class Default_settings_clauseContext;
  class Set_time_zone_clauseContext;
  class Instance_clausesContext;
  class Security_clauseContext;
  class DomainContext;
  class DatabaseContext;
  class Edition_nameContext;
  class FilenumberContext;
  class FilenameContext;
  class Prepare_clauseContext;
  class Drop_mirror_clauseContext;
  class Lost_write_protectionContext;
  class Cdb_fleet_clausesContext;
  class Lead_cdb_clauseContext;
  class Lead_cdb_uri_clauseContext;
  class Property_clausesContext;
  class Replay_upgrade_clausesContext;
  class Alter_database_linkContext;
  class Password_valueContext;
  class Link_authenticationContext;
  class Create_schemaContext;
  class Create_databaseContext;
  class Database_logging_clausesContext;
  class Database_logging_sub_clauseContext;
  class Tablespace_clausesContext;
  class Enable_pluggable_databaseContext;
  class File_name_convertContext;
  class Filename_convert_sub_clauseContext;
  class Tablespace_datafile_clausesContext;
  class Undo_mode_clauseContext;
  class Default_tablespaceContext;
  class Default_temp_tablespaceContext;
  class Undo_tablespaceContext;
  class Drop_databaseContext;
  class Create_database_linkContext;
  class Drop_database_linkContext;
  class Alter_tablespace_setContext;
  class Alter_tablespace_attrsContext;
  class Alter_tablespace_encryptionContext;
  class Ts_file_name_convertContext;
  class Alter_roleContext;
  class Role_identified_clauseContext;
  class Alter_tableContext;
  class Memoptimize_read_write_clauseContext;
  class Alter_table_propertiesContext;
  class Alter_table_partitioningContext;
  class Add_table_partitionContext;
  class Drop_table_partitionContext;
  class Merge_table_partitionContext;
  class Modify_table_partitionContext;
  class Split_table_partitionContext;
  class Truncate_table_partitionContext;
  class Exchange_table_partitionContext;
  class Coalesce_table_partitionContext;
  class Alter_interval_partitionContext;
  class Move_table_partitionContext;
  class Filter_conditionContext;
  class Rename_table_partitionContext;
  class Partition_extended_namesContext;
  class Subpartition_extended_namesContext;
  class Alter_table_properties_1Context;
  class Alter_iot_clausesContext;
  class Alter_mapping_table_clauseContext;
  class Alter_overflow_clauseContext;
  class Add_overflow_clauseContext;
  class Update_index_clausesContext;
  class Update_global_index_clauseContext;
  class Update_all_indexes_clauseContext;
  class Update_all_indexes_index_clauseContext;
  class Update_index_partitionContext;
  class Update_index_subpartitionContext;
  class Enable_disable_clauseContext;
  class Using_index_clauseContext;
  class Index_attributesContext;
  class Sort_or_nosortContext;
  class Exceptions_clauseContext;
  class Move_table_clauseContext;
  class Index_org_table_clauseContext;
  class Mapping_table_clauseContext;
  class Key_compressionContext;
  class Index_org_overflow_clauseContext;
  class Column_clausesContext;
  class Modify_collection_retrievalContext;
  class Collection_itemContext;
  class Rename_column_clauseContext;
  class Old_column_nameContext;
  class New_column_nameContext;
  class Add_modify_drop_column_clausesContext;
  class Drop_column_clauseContext;
  class Modify_column_clausesContext;
  class Modify_col_propertiesContext;
  class Modify_col_visibilityContext;
  class Modify_col_substitutableContext;
  class Add_column_clauseContext;
  class Varray_col_propertiesContext;
  class Varray_storage_clauseContext;
  class Lob_segnameContext;
  class Lob_itemContext;
  class Lob_storage_parametersContext;
  class Lob_storage_clauseContext;
  class Modify_lob_storage_clauseContext;
  class Modify_lob_parametersContext;
  class Lob_parametersContext;
  class Lob_deduplicate_clauseContext;
  class Lob_compression_clauseContext;
  class Lob_retention_clauseContext;
  class Encryption_specContext;
  class TablespaceContext;
  class Varray_itemContext;
  class Column_propertiesContext;
  class Lob_partition_storageContext;
  class Period_definitionContext;
  class Start_time_columnContext;
  class End_time_columnContext;
  class Column_definitionContext;
  class Column_collation_nameContext;
  class Identity_clauseContext;
  class Identity_options_parenthesesContext;
  class Identity_optionsContext;
  class Virtual_column_definitionContext;
  class Virtual_column_expressionContext;
  class Autogenerated_sequence_definitionContext;
  class By_user_for_statistics_clauseContext;
  class Evaluation_edition_clauseContext;
  class Nested_table_col_propertiesContext;
  class Nested_itemContext;
  class Substitutable_column_clauseContext;
  class Partition_nameContext;
  class Supplemental_logging_propsContext;
  class Object_type_col_propertiesContext;
  class Constraint_clausesContext;
  class Old_constraint_nameContext;
  class New_constraint_nameContext;
  class Drop_constraint_clauseContext;
  class Check_constraintContext;
  class Foreign_key_clauseContext;
  class References_clauseContext;
  class On_delete_clauseContext;
  class Anonymous_blockContext;
  class Invoker_rights_clauseContext;
  class Call_specContext;
  class Java_specContext;
  class C_specContext;
  class C_agent_in_clauseContext;
  class C_parameters_clauseContext;
  class C_external_parameterContext;
  class C_propertyContext;
  class ParameterContext;
  class Default_value_partContext;
  class Seq_of_declare_specsContext;
  class Declare_specContext;
  class Variable_declarationContext;
  class Subtype_declarationContext;
  class Cursor_declarationContext;
  class Parameter_specContext;
  class Exception_declarationContext;
  class Pragma_declarationContext;
  class Record_type_defContext;
  class Field_specContext;
  class Ref_cursor_type_defContext;
  class Type_declarationContext;
  class Table_type_defContext;
  class Table_indexed_by_partContext;
  class Varray_type_defContext;
  class Seq_of_statementsContext;
  class Label_declarationContext;
  class StatementContext;
  class Assignment_statementContext;
  class Continue_statementContext;
  class Exit_statementContext;
  class Goto_statementContext;
  class If_statementContext;
  class Elsif_partContext;
  class Else_partContext;
  class Loop_statementContext;
  class Cursor_loop_paramContext;
  class Forall_statementContext;
  class Bounds_clauseContext;
  class Between_boundContext;
  class Lower_boundContext;
  class Upper_boundContext;
  class Null_statementContext;
  class Raise_statementContext;
  class Return_statementContext;
  class Call_statementContext;
  class Pipe_row_statementContext;
  class Selection_directiveContext;
  class Error_directiveContext;
  class Selection_directive_bodyContext;
  class BodyContext;
  class Exception_handlerContext;
  class Trigger_blockContext;
  class Tps_blockContext;
  class BlockContext;
  class Sql_statementContext;
  class Execute_immediateContext;
  class Dynamic_returning_clauseContext;
  class Data_manipulation_language_statementsContext;
  class Cursor_manipulation_statementsContext;
  class Close_statementContext;
  class Open_statementContext;
  class Fetch_statementContext;
  class Variable_or_collectionContext;
  class Open_for_statementContext;
  class Transaction_control_statementsContext;
  class Set_transaction_commandContext;
  class Set_constraint_commandContext;
  class Commit_statementContext;
  class Write_clauseContext;
  class Rollback_statementContext;
  class Savepoint_statementContext;
  class Collection_method_callContext;
  class Explain_statementContext;
  class Select_only_statementContext;
  class Select_statementContext;
  class With_clauseContext;
  class With_factoring_clauseContext;
  class Subquery_factoring_clauseContext;
  class Search_clauseContext;
  class Cycle_clauseContext;
  class Subav_factoring_clauseContext;
  class Subav_clauseContext;
  class Hierarchies_clauseContext;
  class Filter_clausesContext;
  class Filter_clauseContext;
  class Add_calcs_clauseContext;
  class Add_calc_meas_clauseContext;
  class SubqueryContext;
  class Subquery_basic_elementsContext;
  class Subquery_operation_partContext;
  class Query_blockContext;
  class Selected_listContext;
  class From_clauseContext;
  class Select_list_elementsContext;
  class Table_ref_listContext;
  class Table_refContext;
  class Table_ref_auxContext;
  class Table_ref_aux_internalContext;
  class Join_clauseContext;
  class Join_on_partContext;
  class Join_using_partContext;
  class Outer_join_typeContext;
  class Query_partition_clauseContext;
  class Flashback_query_clauseContext;
  class Pivot_clauseContext;
  class Pivot_elementContext;
  class Pivot_for_clauseContext;
  class Pivot_in_clauseContext;
  class Pivot_in_clause_elementContext;
  class Pivot_in_clause_elementsContext;
  class Unpivot_clauseContext;
  class Unpivot_in_clauseContext;
  class Unpivot_in_elementsContext;
  class Hierarchical_query_clauseContext;
  class Start_partContext;
  class Group_by_clauseContext;
  class Group_by_elementsContext;
  class Rollup_cube_clauseContext;
  class Grouping_sets_clauseContext;
  class Grouping_sets_elementsContext;
  class Having_clauseContext;
  class Model_clauseContext;
  class Cell_reference_optionsContext;
  class Return_rows_clauseContext;
  class Reference_modelContext;
  class Main_modelContext;
  class Model_column_clausesContext;
  class Model_column_partition_partContext;
  class Model_column_listContext;
  class Model_columnContext;
  class Model_rules_clauseContext;
  class Model_rules_partContext;
  class Model_rules_elementContext;
  class Cell_assignmentContext;
  class Model_iterate_clauseContext;
  class Until_partContext;
  class Order_by_clauseContext;
  class Order_by_elementsContext;
  class Offset_clauseContext;
  class Fetch_clauseContext;
  class For_update_clauseContext;
  class For_update_of_partContext;
  class For_update_optionsContext;
  class Update_statementContext;
  class Update_set_clauseContext;
  class Column_based_update_set_clauseContext;
  class Delete_statementContext;
  class Insert_statementContext;
  class Single_table_insertContext;
  class Multi_table_insertContext;
  class Multi_table_elementContext;
  class Conditional_insert_clauseContext;
  class Conditional_insert_when_partContext;
  class Conditional_insert_else_partContext;
  class Insert_into_clauseContext;
  class Values_clauseContext;
  class Merge_statementContext;
  class Merge_update_clauseContext;
  class Merge_elementContext;
  class Merge_update_delete_partContext;
  class Merge_insert_clauseContext;
  class Selected_tableviewContext;
  class Lock_table_statementContext;
  class Wait_nowait_partContext;
  class Lock_table_elementContext;
  class Lock_modeContext;
  class General_table_refContext;
  class Static_returning_clauseContext;
  class Error_logging_clauseContext;
  class Error_logging_into_partContext;
  class Error_logging_reject_partContext;
  class Dml_table_expression_clauseContext;
  class Table_collection_expressionContext;
  class Subquery_restriction_clauseContext;
  class Sample_clauseContext;
  class Seed_partContext;
  class ConditionContext;
  class Expressions_Context;
  class ExpressionContext;
  class Cursor_expressionContext;
  class Logical_expressionContext;
  class Unary_logical_expressionContext;
  class Unary_logical_operationContext;
  class Logical_operationContext;
  class Multiset_expressionContext;
  class Relational_expressionContext;
  class Compound_expressionContext;
  class Relational_operatorContext;
  class In_elementsContext;
  class Between_elementsContext;
  class ConcatenationContext;
  class Interval_expressionContext;
  class Model_expressionContext;
  class Model_expression_elementContext;
  class Single_column_for_loopContext;
  class Multi_column_for_loopContext;
  class Unary_expressionContext;
  class Implicit_cursor_expressionContext;
  class Collection_expressionContext;
  class Case_statementContext;
  class Simple_case_statementContext;
  class Searched_case_statementContext;
  class Case_when_part_statementContext;
  class Case_else_part_statementContext;
  class Case_expressionContext;
  class Simple_case_expressionContext;
  class Searched_case_expressionContext;
  class Case_when_part_expressionContext;
  class Case_else_part_expressionContext;
  class AtomContext;
  class Quantified_expressionContext;
  class String_functionContext;
  class Standard_functionContext;
  class Json_functionContext;
  class Json_object_contentContext;
  class Json_object_entryContext;
  class Json_table_clauseContext;
  class Json_array_elementContext;
  class Json_on_null_clauseContext;
  class Json_return_clauseContext;
  class Json_transform_opContext;
  class Json_column_clauseContext;
  class Json_column_definitionContext;
  class Json_query_returning_clauseContext;
  class Json_query_return_typeContext;
  class Json_query_wrapper_clauseContext;
  class Json_query_on_error_clauseContext;
  class Json_query_on_empty_clauseContext;
  class Json_value_return_clauseContext;
  class Json_value_return_typeContext;
  class Json_value_on_mismatch_clauseContext;
  class LiteralContext;
  class Numeric_function_wrapperContext;
  class Numeric_functionContext;
  class Listagg_overflow_clauseContext;
  class Other_functionContext;
  class Over_clause_keywordContext;
  class Within_or_over_clause_keywordContext;
  class Standard_prediction_function_keywordContext;
  class Over_clauseContext;
  class Windowing_clauseContext;
  class Windowing_typeContext;
  class Windowing_elementsContext;
  class Using_clauseContext;
  class Using_elementContext;
  class Assignable_elementContext;
  class Collect_order_by_partContext;
  class Within_or_over_partContext;
  class String_delimiterContext;
  class Cost_matrix_clauseContext;
  class Xml_passing_clauseContext;
  class Xml_attributes_clauseContext;
  class Xml_namespaces_clauseContext;
  class Xml_table_columnContext;
  class Xml_general_default_partContext;
  class Xml_multiuse_expression_elementContext;
  class Xmlroot_param_version_partContext;
  class Xmlroot_param_standalone_partContext;
  class Xmlserialize_param_enconding_partContext;
  class Xmlserialize_param_version_partContext;
  class Xmlserialize_param_ident_partContext;
  class Annotations_clauseContext;
  class Annotations_listContext;
  class AnnotationContext;
  class Sql_plus_command_no_semicolonContext;
  class Sql_plus_commandContext;
  class Start_commandContext;
  class Whenever_commandContext;
  class Set_commandContext;
  class Timing_commandContext;
  class Clear_commandContext;
  class Partition_extension_clauseContext;
  class Column_aliasContext;
  class Table_aliasContext;
  class Where_clauseContext;
  class Into_clauseContext;
  class Xml_column_nameContext;
  class Cost_class_nameContext;
  class Attribute_nameContext;
  class Savepoint_nameContext;
  class Rollback_segment_nameContext;
  class Schema_nameContext;
  class Routine_nameContext;
  class Package_nameContext;
  class Implementation_type_nameContext;
  class Parameter_nameContext;
  class Reference_model_nameContext;
  class Main_model_nameContext;
  class Container_tableview_nameContext;
  class Aggregate_function_nameContext;
  class Query_nameContext;
  class Grantee_nameContext;
  class Role_nameContext;
  class Constraint_nameContext;
  class Label_nameContext;
  class Type_nameContext;
  class Sequence_nameContext;
  class Exception_nameContext;
  class Function_nameContext;
  class Procedure_nameContext;
  class Trigger_nameContext;
  class Variable_nameContext;
  class Index_nameContext;
  class Cursor_nameContext;
  class Record_nameContext;
  class Link_nameContext;
  class Local_link_nameContext;
  class Connection_qualifierContext;
  class Column_nameContext;
  class Tableview_nameContext;
  class XmltableContext;
  class Char_set_nameContext;
  class Synonym_nameContext;
  class Schema_object_nameContext;
  class Dir_object_nameContext;
  class User_object_nameContext;
  class Grant_object_nameContext;
  class Column_listContext;
  class Paren_column_listContext;
  class Keep_clauseContext;
  class Function_argumentContext;
  class Function_argument_analyticContext;
  class Function_argument_modelingContext;
  class Respect_or_ignore_nullsContext;
  class ArgumentContext;
  class Type_specContext;
  class DatatypeContext;
  class Precision_partContext;
  class Native_datatype_elementContext;
  class Bind_variableContext;
  class General_elementContext;
  class General_element_partContext;
  class Table_elementContext;
  class Object_privilegeContext;
  class System_privilegeContext;
  class ConstantContext;
  class NumericContext;
  class Numeric_negativeContext;
  class Quoted_stringContext;
  class IdentifierContext;
  class Id_expressionContext;
  class Inquiry_directiveContext;
  class Outer_join_signContext;
  class Regular_idContext;
  class Non_reserved_keywords_in_18cContext;
  class Non_reserved_keywords_in_12cContext;
  class Non_reserved_keywords_pre12cContext; 

  class  Sql_scriptContext : public antlr4::ParserRuleContext {
  public:
    Sql_scriptContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EOF();
    Sql_plus_command_no_semicolonContext *sql_plus_command_no_semicolon();
    std::vector<antlr4::tree::TerminalNode *> SEMICOLON();
    antlr4::tree::TerminalNode* SEMICOLON(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SOLIDUS();
    antlr4::tree::TerminalNode* SOLIDUS(size_t i);
    std::vector<Sql_plus_commandContext *> sql_plus_command();
    Sql_plus_commandContext* sql_plus_command(size_t i);
    std::vector<Unit_statementContext *> unit_statement();
    Unit_statementContext* unit_statement(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sql_scriptContext* sql_script();

  class  Unit_statementContext : public antlr4::ParserRuleContext {
  public:
    Unit_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Alter_analytic_viewContext *alter_analytic_view();
    Alter_attribute_dimensionContext *alter_attribute_dimension();
    Alter_audit_policyContext *alter_audit_policy();
    Alter_clusterContext *alter_cluster();
    Alter_databaseContext *alter_database();
    Alter_database_linkContext *alter_database_link();
    Alter_dimensionContext *alter_dimension();
    Alter_diskgroupContext *alter_diskgroup();
    Alter_flashback_archiveContext *alter_flashback_archive();
    Alter_functionContext *alter_function();
    Alter_hierarchyContext *alter_hierarchy();
    Alter_indexContext *alter_index();
    Alter_inmemory_join_groupContext *alter_inmemory_join_group();
    Alter_javaContext *alter_java();
    Alter_libraryContext *alter_library();
    Alter_lockdown_profileContext *alter_lockdown_profile();
    Alter_materialized_viewContext *alter_materialized_view();
    Alter_materialized_view_logContext *alter_materialized_view_log();
    Alter_materialized_zonemapContext *alter_materialized_zonemap();
    Alter_operatorContext *alter_operator();
    Alter_outlineContext *alter_outline();
    Alter_packageContext *alter_package();
    Alter_pmem_filestoreContext *alter_pmem_filestore();
    Alter_procedureContext *alter_procedure();
    Alter_resource_costContext *alter_resource_cost();
    Alter_roleContext *alter_role();
    Alter_rollback_segmentContext *alter_rollback_segment();
    Alter_sequenceContext *alter_sequence();
    Alter_sessionContext *alter_session();
    Alter_synonymContext *alter_synonym();
    Alter_tableContext *alter_table();
    Alter_tablespaceContext *alter_tablespace();
    Alter_tablespace_setContext *alter_tablespace_set();
    Alter_triggerContext *alter_trigger();
    Alter_typeContext *alter_type();
    Alter_userContext *alter_user();
    Alter_viewContext *alter_view();
    Anonymous_blockContext *anonymous_block();
    Call_statementContext *call_statement();
    Create_analytic_viewContext *create_analytic_view();
    Create_attribute_dimensionContext *create_attribute_dimension();
    Create_audit_policyContext *create_audit_policy();
    Create_clusterContext *create_cluster();
    Create_contextContext *create_context();
    Create_controlfileContext *create_controlfile();
    Create_schemaContext *create_schema();
    Create_databaseContext *create_database();
    Create_database_linkContext *create_database_link();
    Create_dimensionContext *create_dimension();
    Create_directoryContext *create_directory();
    Create_diskgroupContext *create_diskgroup();
    Create_editionContext *create_edition();
    Create_flashback_archiveContext *create_flashback_archive();
    Create_function_bodyContext *create_function_body();
    Create_hierarchyContext *create_hierarchy();
    Create_indexContext *create_index();
    Create_inmemory_join_groupContext *create_inmemory_join_group();
    Create_javaContext *create_java();
    Create_libraryContext *create_library();
    Create_lockdown_profileContext *create_lockdown_profile();
    Create_materialized_viewContext *create_materialized_view();
    Create_materialized_view_logContext *create_materialized_view_log();
    Create_materialized_zonemapContext *create_materialized_zonemap();
    Create_operatorContext *create_operator();
    Create_outlineContext *create_outline();
    Create_packageContext *create_package();
    Create_package_bodyContext *create_package_body();
    Create_pmem_filestoreContext *create_pmem_filestore();
    Create_procedure_bodyContext *create_procedure_body();
    Create_profileContext *create_profile();
    Create_restore_pointContext *create_restore_point();
    Create_roleContext *create_role();
    Create_rollback_segmentContext *create_rollback_segment();
    Create_sequenceContext *create_sequence();
    Create_spfileContext *create_spfile();
    Create_synonymContext *create_synonym();
    Create_tableContext *create_table();
    Create_tablespaceContext *create_tablespace();
    Create_tablespace_setContext *create_tablespace_set();
    Create_triggerContext *create_trigger();
    Create_typeContext *create_type();
    Create_userContext *create_user();
    Create_viewContext *create_view();
    Drop_analytic_viewContext *drop_analytic_view();
    Drop_attribute_dimensionContext *drop_attribute_dimension();
    Drop_audit_policyContext *drop_audit_policy();
    Drop_clusterContext *drop_cluster();
    Drop_contextContext *drop_context();
    Drop_databaseContext *drop_database();
    Drop_database_linkContext *drop_database_link();
    Drop_directoryContext *drop_directory();
    Drop_diskgroupContext *drop_diskgroup();
    Drop_editionContext *drop_edition();
    Drop_flashback_archiveContext *drop_flashback_archive();
    Drop_functionContext *drop_function();
    Drop_hierarchyContext *drop_hierarchy();
    Drop_indexContext *drop_index();
    Drop_indextypeContext *drop_indextype();
    Drop_inmemory_join_groupContext *drop_inmemory_join_group();
    Drop_javaContext *drop_java();
    Drop_libraryContext *drop_library();
    Drop_lockdown_profileContext *drop_lockdown_profile();
    Drop_materialized_viewContext *drop_materialized_view();
    Drop_materialized_view_logContext *drop_materialized_view_log();
    Drop_materialized_zonemapContext *drop_materialized_zonemap();
    Drop_operatorContext *drop_operator();
    Drop_outlineContext *drop_outline();
    Drop_packageContext *drop_package();
    Drop_pmem_filestoreContext *drop_pmem_filestore();
    Drop_procedureContext *drop_procedure();
    Drop_restore_pointContext *drop_restore_point();
    Drop_roleContext *drop_role();
    Drop_rollback_segmentContext *drop_rollback_segment();
    Drop_sequenceContext *drop_sequence();
    Drop_synonymContext *drop_synonym();
    Drop_tableContext *drop_table();
    Drop_tablespaceContext *drop_tablespace();
    Drop_tablespace_setContext *drop_tablespace_set();
    Drop_triggerContext *drop_trigger();
    Drop_typeContext *drop_type();
    Drop_userContext *drop_user();
    Drop_viewContext *drop_view();
    Administer_key_managementContext *administer_key_management();
    AnalyzeContext *analyze();
    Associate_statisticsContext *associate_statistics();
    Audit_traditionalContext *audit_traditional();
    Comment_on_columnContext *comment_on_column();
    Comment_on_materializedContext *comment_on_materialized();
    Comment_on_tableContext *comment_on_table();
    Data_manipulation_language_statementsContext *data_manipulation_language_statements();
    Disassociate_statisticsContext *disassociate_statistics();
    Flashback_tableContext *flashback_table();
    Grant_statementContext *grant_statement();
    Noaudit_statementContext *noaudit_statement();
    Purge_statementContext *purge_statement();
    Rename_objectContext *rename_object();
    Revoke_statementContext *revoke_statement();
    Transaction_control_statementsContext *transaction_control_statements();
    Truncate_clusterContext *truncate_cluster();
    Truncate_tableContext *truncate_table();
    Unified_auditingContext *unified_auditing();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unit_statementContext* unit_statement();

  class  Alter_diskgroupContext : public antlr4::ParserRuleContext {
  public:
    Alter_diskgroupContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *DISKGROUP();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *ALL();
    Undrop_disk_clauseContext *undrop_disk_clause();
    Diskgroup_availabilityContext *diskgroup_availability();
    Enable_disable_volumeContext *enable_disable_volume();
    Resize_disk_clauseContext *resize_disk_clause();
    Replace_disk_clauseContext *replace_disk_clause();
    Rename_disk_clauseContext *rename_disk_clause();
    Disk_online_clauseContext *disk_online_clause();
    Disk_offline_clauseContext *disk_offline_clause();
    Rebalance_diskgroup_clauseContext *rebalance_diskgroup_clause();
    Check_diskgroup_clauseContext *check_diskgroup_clause();
    Diskgroup_template_clausesContext *diskgroup_template_clauses();
    Diskgroup_directory_clausesContext *diskgroup_directory_clauses();
    Diskgroup_alias_clausesContext *diskgroup_alias_clauses();
    Diskgroup_volume_clausesContext *diskgroup_volume_clauses();
    Diskgroup_attributesContext *diskgroup_attributes();
    Drop_diskgroup_file_clauseContext *drop_diskgroup_file_clause();
    Convert_redundancy_clauseContext *convert_redundancy_clause();
    Usergroup_clausesContext *usergroup_clauses();
    User_clausesContext *user_clauses();
    File_permissions_clauseContext *file_permissions_clause();
    File_owner_clauseContext *file_owner_clause();
    Scrub_clauseContext *scrub_clause();
    Quotagroup_clausesContext *quotagroup_clauses();
    Filegroup_clausesContext *filegroup_clauses();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Add_disk_clauseContext *> add_disk_clause();
    Add_disk_clauseContext* add_disk_clause(size_t i);
    std::vector<Drop_disk_clauseContext *> drop_disk_clause();
    Drop_disk_clauseContext* drop_disk_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_diskgroupContext* alter_diskgroup();

  class  Add_disk_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *sn = nullptr;
    PlSqlParser::Id_expressionContext *fgn = nullptr;
    Add_disk_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    std::vector<antlr4::tree::TerminalNode *> DISK();
    antlr4::tree::TerminalNode* DISK(size_t i);
    std::vector<Qualified_disk_clauseContext *> qualified_disk_clause();
    Qualified_disk_clauseContext* qualified_disk_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SITE();
    antlr4::tree::TerminalNode* SITE(size_t i);
    std::vector<Quorum_regularContext *> quorum_regular();
    Quorum_regularContext* quorum_regular(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FAILGROUP();
    antlr4::tree::TerminalNode* FAILGROUP(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_disk_clauseContext* add_disk_clause();

  class  Drop_disk_clauseContext : public antlr4::ParserRuleContext {
  public:
    Drop_disk_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *DISK();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *DISKS();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *FAILGROUP();
    Quorum_regularContext *quorum_regular();
    std::vector<Force_noforceContext *> force_noforce();
    Force_noforceContext* force_noforce(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_disk_clauseContext* drop_disk_clause();

  class  Resize_disk_clauseContext : public antlr4::ParserRuleContext {
  public:
    Resize_disk_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RESIZE();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *SIZE();
    Size_clauseContext *size_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Resize_disk_clauseContext* resize_disk_clause();

  class  Replace_disk_clauseContext : public antlr4::ParserRuleContext {
  public:
    Replace_disk_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *DISK();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> WITH();
    antlr4::tree::TerminalNode* WITH(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    std::vector<Force_noforceContext *> force_noforce();
    Force_noforceContext* force_noforce(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *POWER();
    NumericContext *numeric();
    Wait_nowaitContext *wait_nowait();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Replace_disk_clauseContext* replace_disk_clause();

  class  Wait_nowaitContext : public antlr4::ParserRuleContext {
  public:
    Wait_nowaitContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WAIT();
    antlr4::tree::TerminalNode *NOWAIT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Wait_nowaitContext* wait_nowait();

  class  Rename_disk_clauseContext : public antlr4::ParserRuleContext {
  public:
    Rename_disk_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *DISK();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TO();
    antlr4::tree::TerminalNode* TO(size_t i);
    antlr4::tree::TerminalNode *DISKS();
    antlr4::tree::TerminalNode *ALL();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Rename_disk_clauseContext* rename_disk_clause();

  class  Disk_online_clauseContext : public antlr4::ParserRuleContext {
  public:
    Disk_online_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ONLINE();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *POWER();
    NumericContext *numeric();
    Wait_nowaitContext *wait_nowait();
    std::vector<antlr4::tree::TerminalNode *> DISK();
    antlr4::tree::TerminalNode* DISK(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DISKS();
    antlr4::tree::TerminalNode* DISKS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> IN();
    antlr4::tree::TerminalNode* IN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FAILGROUP();
    antlr4::tree::TerminalNode* FAILGROUP(size_t i);
    std::vector<Quorum_regularContext *> quorum_regular();
    Quorum_regularContext* quorum_regular(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Disk_online_clauseContext* disk_online_clause();

  class  Disk_offline_clauseContext : public antlr4::ParserRuleContext {
  public:
    Disk_offline_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OFFLINE();
    antlr4::tree::TerminalNode *DISK();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *DISKS();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *FAILGROUP();
    Timeout_clauseContext *timeout_clause();
    Quorum_regularContext *quorum_regular();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Disk_offline_clauseContext* disk_offline_clause();

  class  Timeout_clauseContext : public antlr4::ParserRuleContext {
  public:
    Timeout_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *AFTER();
    NumericContext *numeric();
    antlr4::tree::TerminalNode *M_LETTER();
    antlr4::tree::TerminalNode *H_LETTER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Timeout_clauseContext* timeout_clause();

  class  Rebalance_diskgroup_clauseContext : public antlr4::ParserRuleContext {
  public:
    Rebalance_diskgroup_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REBALANCE();
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *POWER();
    NumericContext *numeric();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *WITHOUT();
    antlr4::tree::TerminalNode *WAIT();
    antlr4::tree::TerminalNode *NOWAIT();
    std::vector<PhaseContext *> phase();
    PhaseContext* phase(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Rebalance_diskgroup_clauseContext* rebalance_diskgroup_clause();

  class  PhaseContext : public antlr4::ParserRuleContext {
  public:
    PhaseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  PhaseContext* phase();

  class  Check_diskgroup_clauseContext : public antlr4::ParserRuleContext {
  public:
    Check_diskgroup_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHECK();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *REPAIR();
    antlr4::tree::TerminalNode *NOREPAIR();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Check_diskgroup_clauseContext* check_diskgroup_clause();

  class  Diskgroup_template_clausesContext : public antlr4::ParserRuleContext {
  public:
    Diskgroup_template_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TEMPLATE();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<Qualified_template_clauseContext *> qualified_template_clause();
    Qualified_template_clauseContext* qualified_template_clause(size_t i);
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *MODIFY();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *DROP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Diskgroup_template_clausesContext* diskgroup_template_clauses();

  class  Qualified_template_clauseContext : public antlr4::ParserRuleContext {
  public:
    Qualified_template_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ATTRIBUTES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Redundancy_clauseContext *redundancy_clause();
    Striping_clauseContext *striping_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Qualified_template_clauseContext* qualified_template_clause();

  class  Redundancy_clauseContext : public antlr4::ParserRuleContext {
  public:
    Redundancy_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MIRROR();
    antlr4::tree::TerminalNode *HIGH();
    antlr4::tree::TerminalNode *UNPROTECTED();
    antlr4::tree::TerminalNode *PARITY();
    antlr4::tree::TerminalNode *DOUBLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Redundancy_clauseContext* redundancy_clause();

  class  Striping_clauseContext : public antlr4::ParserRuleContext {
  public:
    Striping_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FINE();
    antlr4::tree::TerminalNode *COARSE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Striping_clauseContext* striping_clause();

  class  Force_noforceContext : public antlr4::ParserRuleContext {
  public:
    Force_noforceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *NOFORCE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Force_noforceContext* force_noforce();

  class  Diskgroup_directory_clausesContext : public antlr4::ParserRuleContext {
  public:
    Diskgroup_directory_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *DIRECTORY();
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *DROP();
    std::vector<Force_noforceContext *> force_noforce();
    Force_noforceContext* force_noforce(size_t i);
    antlr4::tree::TerminalNode *RENAME();
    std::vector<Dir_nameContext *> dir_name();
    Dir_nameContext* dir_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TO();
    antlr4::tree::TerminalNode* TO(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Diskgroup_directory_clausesContext* diskgroup_directory_clauses();

  class  Dir_nameContext : public antlr4::ParserRuleContext {
  public:
    Dir_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dir_nameContext* dir_name();

  class  Diskgroup_alias_clausesContext : public antlr4::ParserRuleContext {
  public:
    Diskgroup_alias_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *ALIAS();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FOR();
    antlr4::tree::TerminalNode* FOR(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *RENAME();
    std::vector<antlr4::tree::TerminalNode *> TO();
    antlr4::tree::TerminalNode* TO(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Diskgroup_alias_clausesContext* diskgroup_alias_clauses();

  class  Diskgroup_volume_clausesContext : public antlr4::ParserRuleContext {
  public:
    Diskgroup_volume_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Add_volume_clauseContext *add_volume_clause();
    Modify_volume_clauseContext *modify_volume_clause();
    antlr4::tree::TerminalNode *RESIZE();
    antlr4::tree::TerminalNode *VOLUME();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *SIZE();
    Size_clauseContext *size_clause();
    antlr4::tree::TerminalNode *DROP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Diskgroup_volume_clausesContext* diskgroup_volume_clauses();

  class  Add_volume_clauseContext : public antlr4::ParserRuleContext {
  public:
    Add_volume_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *VOLUME();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *SIZE();
    Size_clauseContext *size_clause();
    Redundancy_clauseContext *redundancy_clause();
    antlr4::tree::TerminalNode *STRIPE_WIDTH();
    std::vector<NumericContext *> numeric();
    NumericContext* numeric(size_t i);
    antlr4::tree::TerminalNode *STRIPE_COLUMNS();
    antlr4::tree::TerminalNode *K_LETTER();
    antlr4::tree::TerminalNode *M_LETTER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_volume_clauseContext* add_volume_clause();

  class  Modify_volume_clauseContext : public antlr4::ParserRuleContext {
  public:
    Modify_volume_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *VOLUME();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *MOUNTPATH();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    antlr4::tree::TerminalNode *USAGE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_volume_clauseContext* modify_volume_clause();

  class  Diskgroup_attributesContext : public antlr4::ParserRuleContext {
  public:
    Diskgroup_attributesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *ATTRIBUTE();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    antlr4::tree::TerminalNode *EQUALS_OP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Diskgroup_attributesContext* diskgroup_attributes();

  class  Drop_diskgroup_file_clauseContext : public antlr4::ParserRuleContext {
  public:
    Drop_diskgroup_file_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *FILE();
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_diskgroup_file_clauseContext* drop_diskgroup_file_clause();

  class  Convert_redundancy_clauseContext : public antlr4::ParserRuleContext {
  public:
    Convert_redundancy_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONVERT();
    antlr4::tree::TerminalNode *REDUNDANCY();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *FLEX();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Convert_redundancy_clauseContext* convert_redundancy_clause();

  class  Usergroup_clausesContext : public antlr4::ParserRuleContext {
  public:
    Usergroup_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *USERGROUP();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *MEMBER();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *DROP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Usergroup_clausesContext* usergroup_clauses();

  class  User_clausesContext : public antlr4::ParserRuleContext {
  public:
    User_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *USER();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *REPLACE();
    std::vector<antlr4::tree::TerminalNode *> WITH();
    antlr4::tree::TerminalNode* WITH(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  User_clausesContext* user_clauses();

  class  File_permissions_clauseContext : public antlr4::ParserRuleContext {
  public:
    File_permissions_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *PERMISSION();
    std::vector<antlr4::tree::TerminalNode *> EQUALS_OP();
    antlr4::tree::TerminalNode* EQUALS_OP(size_t i);
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *FILE();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> OWNER();
    antlr4::tree::TerminalNode* OWNER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> GROUP();
    antlr4::tree::TerminalNode* GROUP(size_t i);
    std::vector<antlr4::tree::TerminalNode *> OTHER();
    antlr4::tree::TerminalNode* OTHER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NONE();
    antlr4::tree::TerminalNode* NONE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> READ();
    antlr4::tree::TerminalNode* READ(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ONLY();
    antlr4::tree::TerminalNode* ONLY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> WRITE();
    antlr4::tree::TerminalNode* WRITE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  File_permissions_clauseContext* file_permissions_clause();

  class  File_owner_clauseContext : public antlr4::ParserRuleContext {
  public:
    File_owner_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *OWNERSHIP();
    std::vector<antlr4::tree::TerminalNode *> EQUALS_OP();
    antlr4::tree::TerminalNode* EQUALS_OP(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *FILE();
    std::vector<antlr4::tree::TerminalNode *> OWNER();
    antlr4::tree::TerminalNode* OWNER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> GROUP();
    antlr4::tree::TerminalNode* GROUP(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  File_owner_clauseContext* file_owner_clause();

  class  Scrub_clauseContext : public antlr4::ParserRuleContext {
  public:
    Scrub_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SCRUB();
    antlr4::tree::TerminalNode *FILE();
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *DISK();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *POWER();
    Wait_nowaitContext *wait_nowait();
    Force_noforceContext *force_noforce();
    antlr4::tree::TerminalNode *STOP();
    antlr4::tree::TerminalNode *REPAIR();
    antlr4::tree::TerminalNode *NOREPAIR();
    antlr4::tree::TerminalNode *AUTO();
    antlr4::tree::TerminalNode *LOW();
    antlr4::tree::TerminalNode *HIGH();
    antlr4::tree::TerminalNode *MAX();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Scrub_clauseContext* scrub_clause();

  class  Quotagroup_clausesContext : public antlr4::ParserRuleContext {
  public:
    Quotagroup_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *QUOTAGROUP();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *SET();
    Property_nameContext *property_name();
    antlr4::tree::TerminalNode *EQUALS_OP();
    Property_valueContext *property_value();
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *MOVE();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *DROP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Quotagroup_clausesContext* quotagroup_clauses();

  class  Property_nameContext : public antlr4::ParserRuleContext {
  public:
    Property_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Property_nameContext* property_name();

  class  Property_valueContext : public antlr4::ParserRuleContext {
  public:
    Property_valueContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Property_valueContext* property_value();

  class  Filegroup_clausesContext : public antlr4::ParserRuleContext {
  public:
    Filegroup_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Add_filegroup_clauseContext *add_filegroup_clause();
    Modify_filegroup_clauseContext *modify_filegroup_clause();
    Move_to_filegroup_clauseContext *move_to_filegroup_clause();
    Drop_filegroup_clauseContext *drop_filegroup_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Filegroup_clausesContext* filegroup_clauses();

  class  Add_filegroup_clauseContext : public antlr4::ParserRuleContext {
  public:
    Add_filegroup_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *FILEGROUP();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TEMPLATE();
    antlr4::tree::TerminalNode* TEMPLATE(size_t i);
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *CLUSTER();
    antlr4::tree::TerminalNode *VOLUME();
    antlr4::tree::TerminalNode *FROM();
    antlr4::tree::TerminalNode *SET();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    antlr4::tree::TerminalNode *EQUALS_OP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_filegroup_clauseContext* add_filegroup_clause();

  class  Modify_filegroup_clauseContext : public antlr4::ParserRuleContext {
  public:
    Modify_filegroup_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *FILEGROUP();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *SET();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    antlr4::tree::TerminalNode *EQUALS_OP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_filegroup_clauseContext* modify_filegroup_clause();

  class  Move_to_filegroup_clauseContext : public antlr4::ParserRuleContext {
  public:
    Move_to_filegroup_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MOVE();
    antlr4::tree::TerminalNode *FILE();
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *FILEGROUP();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Move_to_filegroup_clauseContext* move_to_filegroup_clause();

  class  Drop_filegroup_clauseContext : public antlr4::ParserRuleContext {
  public:
    Drop_filegroup_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *FILEGROUP();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *CASCADE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_filegroup_clauseContext* drop_filegroup_clause();

  class  Quorum_regularContext : public antlr4::ParserRuleContext {
  public:
    Quorum_regularContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *QUORUM();
    antlr4::tree::TerminalNode *REGULAR();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Quorum_regularContext* quorum_regular();

  class  Undrop_disk_clauseContext : public antlr4::ParserRuleContext {
  public:
    Undrop_disk_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNDROP();
    antlr4::tree::TerminalNode *DISKS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Undrop_disk_clauseContext* undrop_disk_clause();

  class  Diskgroup_availabilityContext : public antlr4::ParserRuleContext {
  public:
    Diskgroup_availabilityContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MOUNT();
    antlr4::tree::TerminalNode *RESTRICTED();
    antlr4::tree::TerminalNode *NORMAL();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *NOFORCE();
    antlr4::tree::TerminalNode *DISMOUNT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Diskgroup_availabilityContext* diskgroup_availability();

  class  Enable_disable_volumeContext : public antlr4::ParserRuleContext {
  public:
    Enable_disable_volumeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VOLUME();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *DISABLE();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *ALL();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Enable_disable_volumeContext* enable_disable_volume();

  class  Drop_functionContext : public antlr4::ParserRuleContext {
  public:
    Drop_functionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *FUNCTION();
    Function_nameContext *function_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_functionContext* drop_function();

  class  Alter_flashback_archiveContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *fa = nullptr;
    PlSqlParser::Id_expressionContext *ts = nullptr;
    PlSqlParser::Id_expressionContext *rts = nullptr;
    Alter_flashback_archiveContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *FLASHBACK();
    antlr4::tree::TerminalNode *ARCHIVE();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *TABLESPACE();
    antlr4::tree::TerminalNode *REMOVE();
    antlr4::tree::TerminalNode *MODIFY();
    Flashback_archive_retentionContext *flashback_archive_retention();
    antlr4::tree::TerminalNode *PURGE();
    antlr4::tree::TerminalNode *OPTIMIZE();
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *BEFORE();
    Flashback_archive_quotaContext *flashback_archive_quota();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *SCN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *TIMESTAMP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_flashback_archiveContext* alter_flashback_archive();

  class  Alter_hierarchyContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *hn = nullptr;
    PlSqlParser::Id_expressionContext *nhn = nullptr;
    Alter_hierarchyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *HIERARCHY();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *COMPILE();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_hierarchyContext* alter_hierarchy();

  class  Alter_functionContext : public antlr4::ParserRuleContext {
  public:
    Alter_functionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *FUNCTION();
    Function_nameContext *function_name();
    antlr4::tree::TerminalNode *EDITIONABLE();
    antlr4::tree::TerminalNode *NONEDITIONABLE();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *DEBUG();
    std::vector<Compiler_parameters_clauseContext *> compiler_parameters_clause();
    Compiler_parameters_clauseContext* compiler_parameters_clause(size_t i);
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *SETTINGS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_functionContext* alter_function();

  class  Alter_javaContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *o = nullptr;
    Alter_javaContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *JAVA();
    antlr4::tree::TerminalNode *SOURCE();
    antlr4::tree::TerminalNode *CLASS();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *RESOLVE();
    Invoker_rights_clauseContext *invoker_rights_clause();
    std::vector<Schema_nameContext *> schema_name();
    Schema_nameContext* schema_name(size_t i);
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *RESOLVER();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<Match_stringContext *> match_string();
    Match_stringContext* match_string(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MINUS_SIGN();
    antlr4::tree::TerminalNode* MINUS_SIGN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_javaContext* alter_java();

  class  Match_stringContext : public antlr4::ParserRuleContext {
  public:
    Match_stringContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DELIMITED_ID();
    antlr4::tree::TerminalNode *ASTERISK();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Match_stringContext* match_string();

  class  Create_function_bodyContext : public antlr4::ParserRuleContext {
  public:
    Create_function_bodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *FUNCTION();
    Function_nameContext *function_name();
    antlr4::tree::TerminalNode *RETURN();
    Type_specContext *type_spec();
    Aggregate_clauseContext *aggregate_clause();
    Pipelined_using_clauseContext *pipelined_using_clause();
    Sql_macro_bodyContext *sql_macro_body();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ParameterContext *> parameter();
    ParameterContext* parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *SHARING();
    antlr4::tree::TerminalNode *EQUALS_OP();
    std::vector<Invoker_rights_clauseContext *> invoker_rights_clause();
    Invoker_rights_clauseContext* invoker_rights_clause(size_t i);
    std::vector<Accessible_by_clauseContext *> accessible_by_clause();
    Accessible_by_clauseContext* accessible_by_clause(size_t i);
    std::vector<Default_collation_clauseContext *> default_collation_clause();
    Default_collation_clauseContext* default_collation_clause(size_t i);
    std::vector<Parallel_enable_clauseContext *> parallel_enable_clause();
    Parallel_enable_clauseContext* parallel_enable_clause(size_t i);
    std::vector<Result_cache_clauseContext *> result_cache_clause();
    Result_cache_clauseContext* result_cache_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PIPELINED();
    antlr4::tree::TerminalNode* PIPELINED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DETERMINISTIC();
    antlr4::tree::TerminalNode* DETERMINISTIC(size_t i);
    antlr4::tree::TerminalNode *EDITIONABLE();
    antlr4::tree::TerminalNode *NONEDITIONABLE();
    antlr4::tree::TerminalNode *METADATA();
    antlr4::tree::TerminalNode *NONE();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    BodyContext *body();
    Call_specContext *call_spec();
    antlr4::tree::TerminalNode *DECLARE();
    Seq_of_declare_specsContext *seq_of_declare_specs();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_function_bodyContext* create_function_body();

  class  Sql_macro_bodyContext : public antlr4::ParserRuleContext {
  public:
    Sql_macro_bodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SQL_MACRO();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *BEGIN();
    antlr4::tree::TerminalNode *RETURN();
    Quoted_stringContext *quoted_string();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *END();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sql_macro_bodyContext* sql_macro_body();

  class  Parallel_enable_clauseContext : public antlr4::ParserRuleContext {
  public:
    Parallel_enable_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARALLEL_ENABLE();
    Partition_by_clauseContext *partition_by_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Parallel_enable_clauseContext* parallel_enable_clause();

  class  Partition_by_clauseContext : public antlr4::ParserRuleContext {
  public:
    Partition_by_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *PARTITION();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *ANY();
    Paren_column_listContext *paren_column_list();
    antlr4::tree::TerminalNode *HASH();
    antlr4::tree::TerminalNode *RANGE();
    antlr4::tree::TerminalNode *LIST();
    Streaming_clauseContext *streaming_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partition_by_clauseContext* partition_by_clause();

  class  Result_cache_clauseContext : public antlr4::ParserRuleContext {
  public:
    Result_cache_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RESULT_CACHE();
    Relies_on_partContext *relies_on_part();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *MODE();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *FORCE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Result_cache_clauseContext* result_cache_clause();

  class  Accessible_by_clauseContext : public antlr4::ParserRuleContext {
  public:
    Accessible_by_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ACCESSIBLE();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<AccessorContext *> accessor();
    AccessorContext* accessor(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Accessible_by_clauseContext* accessible_by_clause();

  class  Default_collation_clauseContext : public antlr4::ParserRuleContext {
  public:
    Default_collation_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *COLLATION();
    antlr4::tree::TerminalNode *USING_NLS_COMP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Default_collation_clauseContext* default_collation_clause();

  class  Aggregate_clauseContext : public antlr4::ParserRuleContext {
  public:
    Aggregate_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AGGREGATE();
    antlr4::tree::TerminalNode *USING();
    Implementation_type_nameContext *implementation_type_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Aggregate_clauseContext* aggregate_clause();

  class  Pipelined_using_clauseContext : public antlr4::ParserRuleContext {
  public:
    Pipelined_using_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PIPELINED();
    antlr4::tree::TerminalNode *USING();
    Implementation_type_nameContext *implementation_type_name();
    antlr4::tree::TerminalNode *POLYMORPHIC();
    antlr4::tree::TerminalNode *ROW();
    antlr4::tree::TerminalNode *TABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pipelined_using_clauseContext* pipelined_using_clause();

  class  AccessorContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *unitKind = nullptr;
    AccessorContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Function_nameContext *function_name();
    antlr4::tree::TerminalNode *FUNCTION();
    antlr4::tree::TerminalNode *PROCEDURE();
    antlr4::tree::TerminalNode *PACKAGE();
    antlr4::tree::TerminalNode *TRIGGER();
    antlr4::tree::TerminalNode *TYPE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  AccessorContext* accessor();

  class  Relies_on_partContext : public antlr4::ParserRuleContext {
  public:
    Relies_on_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RELIES_ON();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Tableview_nameContext *> tableview_name();
    Tableview_nameContext* tableview_name(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Relies_on_partContext* relies_on_part();

  class  Streaming_clauseContext : public antlr4::ParserRuleContext {
  public:
    Streaming_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *BY();
    Paren_column_listContext *paren_column_list();
    antlr4::tree::TerminalNode *ORDER();
    antlr4::tree::TerminalNode *CLUSTER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Streaming_clauseContext* streaming_clause();

  class  Alter_outlineContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *o = nullptr;
    Alter_outlineContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *OUTLINE();
    Id_expressionContext *id_expression();
    std::vector<Outline_optionsContext *> outline_options();
    Outline_optionsContext* outline_options(size_t i);
    antlr4::tree::TerminalNode *PUBLIC();
    antlr4::tree::TerminalNode *PRIVATE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_outlineContext* alter_outline();

  class  Outline_optionsContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *non = nullptr;
    PlSqlParser::Id_expressionContext *ncn = nullptr;
    Outline_optionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REBUILD();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *TO();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *CHANGE();
    antlr4::tree::TerminalNode *CATEGORY();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *DISABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Outline_optionsContext* outline_options();

  class  Alter_lockdown_profileContext : public antlr4::ParserRuleContext {
  public:
    Alter_lockdown_profileContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *LOCKDOWN();
    antlr4::tree::TerminalNode *PROFILE();
    Id_expressionContext *id_expression();
    Lockdown_featureContext *lockdown_feature();
    Lockdown_optionsContext *lockdown_options();
    Lockdown_statementsContext *lockdown_statements();
    antlr4::tree::TerminalNode *USERS();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *COMMON();
    antlr4::tree::TerminalNode *LOCAL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_lockdown_profileContext* alter_lockdown_profile();

  class  Lockdown_featureContext : public antlr4::ParserRuleContext {
  public:
    Lockdown_featureContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Disable_enableContext *disable_enable();
    antlr4::tree::TerminalNode *FEATURE();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    String_listContext *string_list();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *EXCEPT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lockdown_featureContext* lockdown_feature();

  class  Lockdown_optionsContext : public antlr4::ParserRuleContext {
  public:
    Lockdown_optionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Disable_enableContext *disable_enable();
    antlr4::tree::TerminalNode *OPTION();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    String_listContext *string_list();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *EXCEPT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lockdown_optionsContext* lockdown_options();

  class  Lockdown_statementsContext : public antlr4::ParserRuleContext {
  public:
    Lockdown_statementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Disable_enableContext *disable_enable();
    antlr4::tree::TerminalNode *STATEMENT();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    String_listContext *string_list();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *CHAR_STRING();
    Statement_clausesContext *statement_clauses();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *EXCEPT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lockdown_statementsContext* lockdown_statements();

  class  Statement_clausesContext : public antlr4::ParserRuleContext {
  public:
    Statement_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CLAUSE();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    String_listContext *string_list();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *CHAR_STRING();
    Clause_optionsContext *clause_options();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *EXCEPT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Statement_clausesContext* statement_clauses();

  class  Clause_optionsContext : public antlr4::ParserRuleContext {
  public:
    Clause_optionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OPTION();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    String_listContext *string_list();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *ALL();
    std::vector<Option_valuesContext *> option_values();
    Option_valuesContext* option_values(size_t i);
    antlr4::tree::TerminalNode *EXCEPT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Clause_optionsContext* clause_options();

  class  Option_valuesContext : public antlr4::ParserRuleContext {
  public:
    Option_valuesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VALUE();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    String_listContext *string_list();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *MINVALUE();
    antlr4::tree::TerminalNode *MAXVALUE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Option_valuesContext* option_values();

  class  String_listContext : public antlr4::ParserRuleContext {
  public:
    String_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  String_listContext* string_list();

  class  Disable_enableContext : public antlr4::ParserRuleContext {
  public:
    Disable_enableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DISABLE();
    antlr4::tree::TerminalNode *ENABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Disable_enableContext* disable_enable();

  class  Drop_lockdown_profileContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *p = nullptr;
    Drop_lockdown_profileContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *LOCKDOWN();
    antlr4::tree::TerminalNode *PROFILE();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_lockdown_profileContext* drop_lockdown_profile();

  class  Drop_packageContext : public antlr4::ParserRuleContext {
  public:
    Drop_packageContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *PACKAGE();
    Package_nameContext *package_name();
    antlr4::tree::TerminalNode *BODY();
    Schema_object_nameContext *schema_object_name();
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_packageContext* drop_package();

  class  Alter_packageContext : public antlr4::ParserRuleContext {
  public:
    Alter_packageContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    std::vector<antlr4::tree::TerminalNode *> PACKAGE();
    antlr4::tree::TerminalNode* PACKAGE(size_t i);
    Package_nameContext *package_name();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *DEBUG();
    std::vector<Compiler_parameters_clauseContext *> compiler_parameters_clause();
    Compiler_parameters_clauseContext* compiler_parameters_clause(size_t i);
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *SETTINGS();
    antlr4::tree::TerminalNode *BODY();
    antlr4::tree::TerminalNode *SPECIFICATION();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_packageContext* alter_package();

  class  Create_packageContext : public antlr4::ParserRuleContext {
  public:
    Create_packageContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *PACKAGE();
    std::vector<Package_nameContext *> package_name();
    Package_nameContext* package_name(size_t i);
    antlr4::tree::TerminalNode *END();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    Schema_object_nameContext *schema_object_name();
    antlr4::tree::TerminalNode *PERIOD();
    Invoker_rights_clauseContext *invoker_rights_clause();
    std::vector<Package_obj_specContext *> package_obj_spec();
    Package_obj_specContext* package_obj_spec(size_t i);
    antlr4::tree::TerminalNode *EDITIONABLE();
    antlr4::tree::TerminalNode *NONEDITIONABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_packageContext* create_package();

  class  Create_package_bodyContext : public antlr4::ParserRuleContext {
  public:
    Create_package_bodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *PACKAGE();
    antlr4::tree::TerminalNode *BODY();
    std::vector<Package_nameContext *> package_name();
    Package_nameContext* package_name(size_t i);
    antlr4::tree::TerminalNode *END();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    Schema_object_nameContext *schema_object_name();
    antlr4::tree::TerminalNode *PERIOD();
    std::vector<Package_obj_bodyContext *> package_obj_body();
    Package_obj_bodyContext* package_obj_body(size_t i);
    antlr4::tree::TerminalNode *BEGIN();
    Seq_of_statementsContext *seq_of_statements();
    antlr4::tree::TerminalNode *EDITIONABLE();
    antlr4::tree::TerminalNode *NONEDITIONABLE();
    antlr4::tree::TerminalNode *EXCEPTION();
    std::vector<Exception_handlerContext *> exception_handler();
    Exception_handlerContext* exception_handler(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_package_bodyContext* create_package_body();

  class  Package_obj_specContext : public antlr4::ParserRuleContext {
  public:
    Package_obj_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Pragma_declarationContext *pragma_declaration();
    Exception_declarationContext *exception_declaration();
    Procedure_specContext *procedure_spec();
    Function_specContext *function_spec();
    Variable_declarationContext *variable_declaration();
    Subtype_declarationContext *subtype_declaration();
    Cursor_declarationContext *cursor_declaration();
    Type_declarationContext *type_declaration();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Package_obj_specContext* package_obj_spec();

  class  Procedure_specContext : public antlr4::ParserRuleContext {
  public:
    Procedure_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PROCEDURE();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ParameterContext *> parameter();
    ParameterContext* parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Accessible_by_clauseContext *> accessible_by_clause();
    Accessible_by_clauseContext* accessible_by_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PARALLEL_ENABLE();
    antlr4::tree::TerminalNode* PARALLEL_ENABLE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DETERMINISTIC();
    antlr4::tree::TerminalNode* DETERMINISTIC(size_t i);
    antlr4::tree::TerminalNode *AS();
    Call_specContext *call_spec();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Procedure_specContext* procedure_spec();

  class  Function_specContext : public antlr4::ParserRuleContext {
  public:
    Function_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FUNCTION();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *RETURN();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ParameterContext *> parameter();
    ParameterContext* parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> DETERMINISTIC();
    antlr4::tree::TerminalNode* DETERMINISTIC(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PIPELINED();
    antlr4::tree::TerminalNode* PIPELINED(size_t i);
    std::vector<Parallel_enable_clauseContext *> parallel_enable_clause();
    Parallel_enable_clauseContext* parallel_enable_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RESULT_CACHE();
    antlr4::tree::TerminalNode* RESULT_CACHE(size_t i);
    std::vector<Streaming_clauseContext *> streaming_clause();
    Streaming_clauseContext* streaming_clause(size_t i);
    antlr4::tree::TerminalNode *AS();
    Call_specContext *call_spec();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Function_specContext* function_spec();

  class  Package_obj_bodyContext : public antlr4::ParserRuleContext {
  public:
    Package_obj_bodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Pragma_declarationContext *pragma_declaration();
    Exception_declarationContext *exception_declaration();
    Procedure_specContext *procedure_spec();
    Function_specContext *function_spec();
    Subtype_declarationContext *subtype_declaration();
    Cursor_declarationContext *cursor_declaration();
    Variable_declarationContext *variable_declaration();
    Type_declarationContext *type_declaration();
    Procedure_bodyContext *procedure_body();
    Function_bodyContext *function_body();
    Selection_directiveContext *selection_directive();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Package_obj_bodyContext* package_obj_body();

  class  Alter_pmem_filestoreContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *fsn = nullptr;
    Alter_pmem_filestoreContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *PMEM();
    antlr4::tree::TerminalNode *FILESTORE();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *RESIZE();
    Size_clauseContext *size_clause();
    Autoextend_clauseContext *autoextend_clause();
    antlr4::tree::TerminalNode *MOUNT();
    antlr4::tree::TerminalNode *DISMOUNT();
    antlr4::tree::TerminalNode *MOUNTPOINT();
    File_pathContext *file_path();
    antlr4::tree::TerminalNode *BACKINGFILE();
    FilenameContext *filename();
    antlr4::tree::TerminalNode *FORCE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_pmem_filestoreContext* alter_pmem_filestore();

  class  Drop_pmem_filestoreContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *fsn = nullptr;
    Drop_pmem_filestoreContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *PMEM();
    antlr4::tree::TerminalNode *FILESTORE();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *CONTENTS();
    antlr4::tree::TerminalNode *INCLUDING();
    antlr4::tree::TerminalNode *EXCLUDING();
    antlr4::tree::TerminalNode *FORCE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_pmem_filestoreContext* drop_pmem_filestore();

  class  Drop_procedureContext : public antlr4::ParserRuleContext {
  public:
    Drop_procedureContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *PROCEDURE();
    Procedure_nameContext *procedure_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_procedureContext* drop_procedure();

  class  Alter_procedureContext : public antlr4::ParserRuleContext {
  public:
    Alter_procedureContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *PROCEDURE();
    Procedure_nameContext *procedure_name();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *DEBUG();
    std::vector<Compiler_parameters_clauseContext *> compiler_parameters_clause();
    Compiler_parameters_clauseContext* compiler_parameters_clause(size_t i);
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *SETTINGS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_procedureContext* alter_procedure();

  class  Function_bodyContext : public antlr4::ParserRuleContext {
  public:
    Function_bodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FUNCTION();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *RETURN();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *USING();
    Implementation_type_nameContext *implementation_type_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ParameterContext *> parameter();
    ParameterContext* parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> PIPELINED();
    antlr4::tree::TerminalNode* PIPELINED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DETERMINISTIC();
    antlr4::tree::TerminalNode* DETERMINISTIC(size_t i);
    std::vector<Invoker_rights_clauseContext *> invoker_rights_clause();
    Invoker_rights_clauseContext* invoker_rights_clause(size_t i);
    std::vector<Parallel_enable_clauseContext *> parallel_enable_clause();
    Parallel_enable_clauseContext* parallel_enable_clause(size_t i);
    std::vector<Result_cache_clauseContext *> result_cache_clause();
    Result_cache_clauseContext* result_cache_clause(size_t i);
    std::vector<Streaming_clauseContext *> streaming_clause();
    Streaming_clauseContext* streaming_clause(size_t i);
    antlr4::tree::TerminalNode *AGGREGATE();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    BodyContext *body();
    Call_specContext *call_spec();
    antlr4::tree::TerminalNode *DECLARE();
    Seq_of_declare_specsContext *seq_of_declare_specs();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Function_bodyContext* function_body();

  class  Procedure_bodyContext : public antlr4::ParserRuleContext {
  public:
    Procedure_bodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PROCEDURE();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    BodyContext *body();
    Call_specContext *call_spec();
    antlr4::tree::TerminalNode *EXTERNAL();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ParameterContext *> parameter();
    ParameterContext* parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Accessible_by_clauseContext *> accessible_by_clause();
    Accessible_by_clauseContext* accessible_by_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PARALLEL_ENABLE();
    antlr4::tree::TerminalNode* PARALLEL_ENABLE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DETERMINISTIC();
    antlr4::tree::TerminalNode* DETERMINISTIC(size_t i);
    antlr4::tree::TerminalNode *DECLARE();
    Seq_of_declare_specsContext *seq_of_declare_specs();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Procedure_bodyContext* procedure_body();

  class  Create_procedure_bodyContext : public antlr4::ParserRuleContext {
  public:
    Create_procedure_bodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *PROCEDURE();
    Procedure_nameContext *procedure_name();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    BodyContext *body();
    Call_specContext *call_spec();
    antlr4::tree::TerminalNode *EXTERNAL();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ParameterContext *> parameter();
    ParameterContext* parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Invoker_rights_clauseContext *invoker_rights_clause();
    std::vector<antlr4::tree::TerminalNode *> PARALLEL_ENABLE();
    antlr4::tree::TerminalNode* PARALLEL_ENABLE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DETERMINISTIC();
    antlr4::tree::TerminalNode* DETERMINISTIC(size_t i);
    antlr4::tree::TerminalNode *DECLARE();
    Seq_of_declare_specsContext *seq_of_declare_specs();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_procedure_bodyContext* create_procedure_body();

  class  Alter_resource_costContext : public antlr4::ParserRuleContext {
  public:
    Alter_resource_costContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *RESOURCE();
    antlr4::tree::TerminalNode *COST();
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CPU_PER_SESSION();
    antlr4::tree::TerminalNode* CPU_PER_SESSION(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CONNECT_TIME();
    antlr4::tree::TerminalNode* CONNECT_TIME(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LOGICAL_READS_PER_SESSION();
    antlr4::tree::TerminalNode* LOGICAL_READS_PER_SESSION(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PRIVATE_SGA();
    antlr4::tree::TerminalNode* PRIVATE_SGA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_resource_costContext* alter_resource_cost();

  class  Drop_outlineContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *o = nullptr;
    Drop_outlineContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *OUTLINE();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_outlineContext* drop_outline();

  class  Alter_rollback_segmentContext : public antlr4::ParserRuleContext {
  public:
    Alter_rollback_segmentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *ROLLBACK();
    antlr4::tree::TerminalNode *SEGMENT();
    Rollback_segment_nameContext *rollback_segment_name();
    antlr4::tree::TerminalNode *ONLINE();
    antlr4::tree::TerminalNode *OFFLINE();
    Storage_clauseContext *storage_clause();
    antlr4::tree::TerminalNode *SHRINK();
    antlr4::tree::TerminalNode *TO();
    Size_clauseContext *size_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_rollback_segmentContext* alter_rollback_segment();

  class  Drop_restore_pointContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *rp = nullptr;
    PlSqlParser::Id_expressionContext *pdb = nullptr;
    Drop_restore_pointContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *RESTORE();
    antlr4::tree::TerminalNode *POINT();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *PLUGGABLE();
    antlr4::tree::TerminalNode *DATABASE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_restore_pointContext* drop_restore_point();

  class  Drop_rollback_segmentContext : public antlr4::ParserRuleContext {
  public:
    Drop_rollback_segmentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *ROLLBACK();
    antlr4::tree::TerminalNode *SEGMENT();
    Rollback_segment_nameContext *rollback_segment_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_rollback_segmentContext* drop_rollback_segment();

  class  Drop_roleContext : public antlr4::ParserRuleContext {
  public:
    Drop_roleContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *ROLE();
    Role_nameContext *role_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_roleContext* drop_role();

  class  Create_pmem_filestoreContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *fsn = nullptr;
    Create_pmem_filestoreContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *PMEM();
    antlr4::tree::TerminalNode *FILESTORE();
    Id_expressionContext *id_expression();
    std::vector<Pmem_filestore_optionsContext *> pmem_filestore_options();
    Pmem_filestore_optionsContext* pmem_filestore_options(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_pmem_filestoreContext* create_pmem_filestore();

  class  Pmem_filestore_optionsContext : public antlr4::ParserRuleContext {
  public:
    Pmem_filestore_optionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MOUNTPOINT();
    File_pathContext *file_path();
    antlr4::tree::TerminalNode *BACKINGFILE();
    FilenameContext *filename();
    antlr4::tree::TerminalNode *REUSE();
    Size_clauseContext *size_clause();
    antlr4::tree::TerminalNode *SIZE();
    antlr4::tree::TerminalNode *BLOCKSIZE();
    Autoextend_clauseContext *autoextend_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pmem_filestore_optionsContext* pmem_filestore_options();

  class  File_pathContext : public antlr4::ParserRuleContext {
  public:
    File_pathContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  File_pathContext* file_path();

  class  Create_rollback_segmentContext : public antlr4::ParserRuleContext {
  public:
    Create_rollback_segmentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *ROLLBACK();
    antlr4::tree::TerminalNode *SEGMENT();
    Rollback_segment_nameContext *rollback_segment_name();
    antlr4::tree::TerminalNode *PUBLIC();
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<Storage_clauseContext *> storage_clause();
    Storage_clauseContext* storage_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_rollback_segmentContext* create_rollback_segment();

  class  Drop_triggerContext : public antlr4::ParserRuleContext {
  public:
    Drop_triggerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *TRIGGER();
    Trigger_nameContext *trigger_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_triggerContext* drop_trigger();

  class  Alter_triggerContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Trigger_nameContext *alter_trigger_name = nullptr;
    PlSqlParser::Trigger_nameContext *rename_trigger_name = nullptr;
    Alter_triggerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *TRIGGER();
    std::vector<Trigger_nameContext *> trigger_name();
    Trigger_nameContext* trigger_name(size_t i);
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *DISABLE();
    antlr4::tree::TerminalNode *DEBUG();
    std::vector<Compiler_parameters_clauseContext *> compiler_parameters_clause();
    Compiler_parameters_clauseContext* compiler_parameters_clause(size_t i);
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *SETTINGS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_triggerContext* alter_trigger();

  class  Create_triggerContext : public antlr4::ParserRuleContext {
  public:
    Create_triggerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *TRIGGER();
    Trigger_nameContext *trigger_name();
    Trigger_bodyContext *trigger_body();
    Simple_dml_triggerContext *simple_dml_trigger();
    Compound_dml_triggerContext *compound_dml_trigger();
    Non_dml_triggerContext *non_dml_trigger();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    Trigger_follows_clauseContext *trigger_follows_clause();
    Trigger_when_clauseContext *trigger_when_clause();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *DISABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_triggerContext* create_trigger();

  class  Trigger_follows_clauseContext : public antlr4::ParserRuleContext {
  public:
    Trigger_follows_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOLLOWS();
    std::vector<Trigger_nameContext *> trigger_name();
    Trigger_nameContext* trigger_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Trigger_follows_clauseContext* trigger_follows_clause();

  class  Trigger_when_clauseContext : public antlr4::ParserRuleContext {
  public:
    Trigger_when_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Trigger_when_clauseContext* trigger_when_clause();

  class  Simple_dml_triggerContext : public antlr4::ParserRuleContext {
  public:
    Simple_dml_triggerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Dml_event_clauseContext *dml_event_clause();
    antlr4::tree::TerminalNode *BEFORE();
    antlr4::tree::TerminalNode *AFTER();
    antlr4::tree::TerminalNode *INSTEAD();
    antlr4::tree::TerminalNode *OF();
    Referencing_clauseContext *referencing_clause();
    For_each_rowContext *for_each_row();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Simple_dml_triggerContext* simple_dml_trigger();

  class  For_each_rowContext : public antlr4::ParserRuleContext {
  public:
    For_each_rowContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *EACH();
    antlr4::tree::TerminalNode *ROW();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  For_each_rowContext* for_each_row();

  class  Compound_dml_triggerContext : public antlr4::ParserRuleContext {
  public:
    Compound_dml_triggerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOR();
    Dml_event_clauseContext *dml_event_clause();
    Referencing_clauseContext *referencing_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Compound_dml_triggerContext* compound_dml_trigger();

  class  Non_dml_triggerContext : public antlr4::ParserRuleContext {
  public:
    Non_dml_triggerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Non_dml_eventContext *> non_dml_event();
    Non_dml_eventContext* non_dml_event(size_t i);
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *BEFORE();
    antlr4::tree::TerminalNode *AFTER();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *SCHEMA();
    std::vector<antlr4::tree::TerminalNode *> OR();
    antlr4::tree::TerminalNode* OR(size_t i);
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Non_dml_triggerContext* non_dml_trigger();

  class  Trigger_bodyContext : public antlr4::ParserRuleContext {
  public:
    Trigger_bodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Compound_trigger_blockContext *compound_trigger_block();
    antlr4::tree::TerminalNode *CALL();
    IdentifierContext *identifier();
    Trigger_blockContext *trigger_block();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Trigger_bodyContext* trigger_body();

  class  Compound_trigger_blockContext : public antlr4::ParserRuleContext {
  public:
    Compound_trigger_blockContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COMPOUND();
    antlr4::tree::TerminalNode *TRIGGER();
    antlr4::tree::TerminalNode *END();
    Seq_of_declare_specsContext *seq_of_declare_specs();
    std::vector<Timing_point_sectionContext *> timing_point_section();
    Timing_point_sectionContext* timing_point_section(size_t i);
    Trigger_nameContext *trigger_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Compound_trigger_blockContext* compound_trigger_block();

  class  Timing_point_sectionContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *bk = nullptr;
    antlr4::Token *ak = nullptr;
    Timing_point_sectionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> STATEMENT();
    antlr4::tree::TerminalNode* STATEMENT(size_t i);
    antlr4::tree::TerminalNode *IS();
    Tps_blockContext *tps_block();
    std::vector<antlr4::tree::TerminalNode *> BEFORE();
    antlr4::tree::TerminalNode* BEFORE(size_t i);
    antlr4::tree::TerminalNode *SEMICOLON();
    std::vector<antlr4::tree::TerminalNode *> EACH();
    antlr4::tree::TerminalNode* EACH(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ROW();
    antlr4::tree::TerminalNode* ROW(size_t i);
    std::vector<antlr4::tree::TerminalNode *> AFTER();
    antlr4::tree::TerminalNode* AFTER(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Timing_point_sectionContext* timing_point_section();

  class  Non_dml_eventContext : public antlr4::ParserRuleContext {
  public:
    Non_dml_eventContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *ANALYZE();
    antlr4::tree::TerminalNode *ASSOCIATE();
    antlr4::tree::TerminalNode *STATISTICS();
    antlr4::tree::TerminalNode *AUDIT();
    antlr4::tree::TerminalNode *COMMENT();
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *DISASSOCIATE();
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *GRANT();
    antlr4::tree::TerminalNode *NOAUDIT();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *REVOKE();
    antlr4::tree::TerminalNode *TRUNCATE();
    antlr4::tree::TerminalNode *DDL();
    antlr4::tree::TerminalNode *STARTUP();
    antlr4::tree::TerminalNode *SHUTDOWN();
    antlr4::tree::TerminalNode *DB_ROLE_CHANGE();
    antlr4::tree::TerminalNode *LOGON();
    antlr4::tree::TerminalNode *LOGOFF();
    antlr4::tree::TerminalNode *SERVERERROR();
    antlr4::tree::TerminalNode *SUSPEND();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *SCHEMA();
    antlr4::tree::TerminalNode *FOLLOWS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Non_dml_eventContext* non_dml_event();

  class  Dml_event_clauseContext : public antlr4::ParserRuleContext {
  public:
    Dml_event_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Dml_event_elementContext *> dml_event_element();
    Dml_event_elementContext* dml_event_element(size_t i);
    antlr4::tree::TerminalNode *ON();
    Tableview_nameContext *tableview_name();
    std::vector<antlr4::tree::TerminalNode *> OR();
    antlr4::tree::TerminalNode* OR(size_t i);
    Dml_event_nested_clauseContext *dml_event_nested_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dml_event_clauseContext* dml_event_clause();

  class  Dml_event_elementContext : public antlr4::ParserRuleContext {
  public:
    Dml_event_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *INSERT();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *OF();
    Column_listContext *column_list();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dml_event_elementContext* dml_event_element();

  class  Dml_event_nested_clauseContext : public antlr4::ParserRuleContext {
  public:
    Dml_event_nested_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NESTED();
    antlr4::tree::TerminalNode *TABLE();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *OF();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dml_event_nested_clauseContext* dml_event_nested_clause();

  class  Referencing_clauseContext : public antlr4::ParserRuleContext {
  public:
    Referencing_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REFERENCING();
    std::vector<Referencing_elementContext *> referencing_element();
    Referencing_elementContext* referencing_element(size_t i);
    antlr4::tree::TerminalNode *REFERENCES();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Referencing_clauseContext* referencing_clause();

  class  Referencing_elementContext : public antlr4::ParserRuleContext {
  public:
    Referencing_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_aliasContext *column_alias();
    antlr4::tree::TerminalNode *NEW();
    antlr4::tree::TerminalNode *OLD();
    antlr4::tree::TerminalNode *PARENT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Referencing_elementContext* referencing_element();

  class  Drop_typeContext : public antlr4::ParserRuleContext {
  public:
    Drop_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *TYPE();
    Type_nameContext *type_name();
    antlr4::tree::TerminalNode *BODY();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *VALIDATE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_typeContext* drop_type();

  class  Alter_typeContext : public antlr4::ParserRuleContext {
  public:
    Alter_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *TYPE();
    Type_nameContext *type_name();
    Compile_type_clauseContext *compile_type_clause();
    Replace_type_clauseContext *replace_type_clause();
    Alter_method_specContext *alter_method_spec();
    Alter_collection_clausesContext *alter_collection_clauses();
    Modifier_clauseContext *modifier_clause();
    Overriding_subprogram_specContext *overriding_subprogram_spec();
    Dependent_handling_clauseContext *dependent_handling_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_typeContext* alter_type();

  class  Compile_type_clauseContext : public antlr4::ParserRuleContext {
  public:
    Compile_type_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *DEBUG();
    std::vector<Compiler_parameters_clauseContext *> compiler_parameters_clause();
    Compiler_parameters_clauseContext* compiler_parameters_clause(size_t i);
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *SETTINGS();
    antlr4::tree::TerminalNode *SPECIFICATION();
    antlr4::tree::TerminalNode *BODY();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Compile_type_clauseContext* compile_type_clause();

  class  Replace_type_clauseContext : public antlr4::ParserRuleContext {
  public:
    Replace_type_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *OBJECT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Object_member_specContext *> object_member_spec();
    Object_member_specContext* object_member_spec(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Invoker_rights_clauseContext *invoker_rights_clause();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Replace_type_clauseContext* replace_type_clause();

  class  Alter_method_specContext : public antlr4::ParserRuleContext {
  public:
    Alter_method_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Alter_method_elementContext *> alter_method_element();
    Alter_method_elementContext* alter_method_element(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_method_specContext* alter_method_spec();

  class  Alter_method_elementContext : public antlr4::ParserRuleContext {
  public:
    Alter_method_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *DROP();
    Map_order_function_specContext *map_order_function_spec();
    Subprogram_specContext *subprogram_spec();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_method_elementContext* alter_method_element();

  class  Alter_collection_clausesContext : public antlr4::ParserRuleContext {
  public:
    Alter_collection_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *LIMIT();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *ELEMENT();
    antlr4::tree::TerminalNode *TYPE();
    Type_specContext *type_spec();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_collection_clausesContext* alter_collection_clauses();

  class  Dependent_handling_clauseContext : public antlr4::ParserRuleContext {
  public:
    Dependent_handling_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INVALIDATE();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *CONVERT();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *SUBSTITUTABLE();
    antlr4::tree::TerminalNode *INCLUDING();
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *DATA();
    Dependent_exceptions_partContext *dependent_exceptions_part();
    antlr4::tree::TerminalNode *NOT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dependent_handling_clauseContext* dependent_handling_clause();

  class  Dependent_exceptions_partContext : public antlr4::ParserRuleContext {
  public:
    Dependent_exceptions_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXCEPTIONS();
    antlr4::tree::TerminalNode *INTO();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *FORCE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dependent_exceptions_partContext* dependent_exceptions_part();

  class  Create_typeContext : public antlr4::ParserRuleContext {
  public:
    Create_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *TYPE();
    Type_definitionContext *type_definition();
    Type_bodyContext *type_body();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *EDITIONABLE();
    antlr4::tree::TerminalNode *NONEDITIONABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_typeContext* create_type();

  class  Type_definitionContext : public antlr4::ParserRuleContext {
  public:
    Type_definitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Type_nameContext *type_name();
    antlr4::tree::TerminalNode *OID();
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *FORCE();
    Object_type_defContext *object_type_def();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Type_definitionContext* type_definition();

  class  Object_type_defContext : public antlr4::ParserRuleContext {
  public:
    Object_type_defContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Object_as_partContext *object_as_part();
    Object_under_partContext *object_under_part();
    Invoker_rights_clauseContext *invoker_rights_clause();
    Sqlj_object_typeContext *sqlj_object_type();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Object_member_specContext *> object_member_spec();
    Object_member_specContext* object_member_spec(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Modifier_clauseContext *> modifier_clause();
    Modifier_clauseContext* modifier_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_type_defContext* object_type_def();

  class  Object_as_partContext : public antlr4::ParserRuleContext {
  public:
    Object_as_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *OBJECT();
    Varray_type_defContext *varray_type_def();
    Nested_table_type_defContext *nested_table_type_def();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_as_partContext* object_as_part();

  class  Object_under_partContext : public antlr4::ParserRuleContext {
  public:
    Object_under_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNDER();
    Type_specContext *type_spec();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_under_partContext* object_under_part();

  class  Nested_table_type_defContext : public antlr4::ParserRuleContext {
  public:
    Nested_table_type_defContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *OF();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *NULL_();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Nested_table_type_defContext* nested_table_type_def();

  class  Sqlj_object_typeContext : public antlr4::ParserRuleContext {
  public:
    Sqlj_object_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXTERNAL();
    antlr4::tree::TerminalNode *NAME();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *LANGUAGE();
    antlr4::tree::TerminalNode *JAVA();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *SQLDATA();
    antlr4::tree::TerminalNode *CUSTOMDATUM();
    antlr4::tree::TerminalNode *ORADATA();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sqlj_object_typeContext* sqlj_object_type();

  class  Type_bodyContext : public antlr4::ParserRuleContext {
  public:
    Type_bodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BODY();
    Type_nameContext *type_name();
    antlr4::tree::TerminalNode *END();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    std::vector<Type_body_elementsContext *> type_body_elements();
    Type_body_elementsContext* type_body_elements(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Type_bodyContext* type_body();

  class  Type_body_elementsContext : public antlr4::ParserRuleContext {
  public:
    Type_body_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Map_order_func_declarationContext *map_order_func_declaration();
    Subprog_decl_in_typeContext *subprog_decl_in_type();
    Overriding_subprogram_specContext *overriding_subprogram_spec();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Type_body_elementsContext* type_body_elements();

  class  Map_order_func_declarationContext : public antlr4::ParserRuleContext {
  public:
    Map_order_func_declarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MEMBER();
    Func_decl_in_typeContext *func_decl_in_type();
    antlr4::tree::TerminalNode *MAP();
    antlr4::tree::TerminalNode *ORDER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Map_order_func_declarationContext* map_order_func_declaration();

  class  Subprog_decl_in_typeContext : public antlr4::ParserRuleContext {
  public:
    Subprog_decl_in_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Proc_decl_in_typeContext *proc_decl_in_type();
    Func_decl_in_typeContext *func_decl_in_type();
    Constructor_declarationContext *constructor_declaration();
    antlr4::tree::TerminalNode *MEMBER();
    antlr4::tree::TerminalNode *STATIC();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subprog_decl_in_typeContext* subprog_decl_in_type();

  class  Proc_decl_in_typeContext : public antlr4::ParserRuleContext {
  public:
    Proc_decl_in_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PROCEDURE();
    Procedure_nameContext *procedure_name();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    Call_specContext *call_spec();
    BodyContext *body();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Type_elements_parameterContext *> type_elements_parameter();
    Type_elements_parameterContext* type_elements_parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *DECLARE();
    Seq_of_declare_specsContext *seq_of_declare_specs();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Proc_decl_in_typeContext* proc_decl_in_type();

  class  Func_decl_in_typeContext : public antlr4::ParserRuleContext {
  public:
    Func_decl_in_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FUNCTION();
    Function_nameContext *function_name();
    antlr4::tree::TerminalNode *RETURN();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    Call_specContext *call_spec();
    BodyContext *body();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Type_elements_parameterContext *> type_elements_parameter();
    Type_elements_parameterContext* type_elements_parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *DECLARE();
    Seq_of_declare_specsContext *seq_of_declare_specs();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Func_decl_in_typeContext* func_decl_in_type();

  class  Constructor_declarationContext : public antlr4::ParserRuleContext {
  public:
    Constructor_declarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONSTRUCTOR();
    antlr4::tree::TerminalNode *FUNCTION();
    Function_nameContext *function_name();
    antlr4::tree::TerminalNode *RETURN();
    std::vector<antlr4::tree::TerminalNode *> SELF();
    antlr4::tree::TerminalNode* SELF(size_t i);
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);
    antlr4::tree::TerminalNode *RESULT();
    antlr4::tree::TerminalNode *IS();
    Call_specContext *call_spec();
    BodyContext *body();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *FINAL();
    antlr4::tree::TerminalNode *INSTANTIABLE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *DECLARE();
    Seq_of_declare_specsContext *seq_of_declare_specs();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *OUT();
    Type_specContext *type_spec();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Type_elements_parameterContext *> type_elements_parameter();
    Type_elements_parameterContext* type_elements_parameter(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Constructor_declarationContext* constructor_declaration();

  class  Modifier_clauseContext : public antlr4::ParserRuleContext {
  public:
    Modifier_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INSTANTIABLE();
    antlr4::tree::TerminalNode *FINAL();
    antlr4::tree::TerminalNode *OVERRIDING();
    antlr4::tree::TerminalNode *NOT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modifier_clauseContext* modifier_clause();

  class  Object_member_specContext : public antlr4::ParserRuleContext {
  public:
    Object_member_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    Type_specContext *type_spec();
    Sqlj_object_type_attrContext *sqlj_object_type_attr();
    Element_specContext *element_spec();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_member_specContext* object_member_spec();

  class  Sqlj_object_type_attrContext : public antlr4::ParserRuleContext {
  public:
    Sqlj_object_type_attrContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXTERNAL();
    antlr4::tree::TerminalNode *NAME();
    ExpressionContext *expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sqlj_object_type_attrContext* sqlj_object_type_attr();

  class  Element_specContext : public antlr4::ParserRuleContext {
  public:
    Element_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Modifier_clauseContext *modifier_clause();
    std::vector<Element_spec_optionsContext *> element_spec_options();
    Element_spec_optionsContext* element_spec_options(size_t i);
    antlr4::tree::TerminalNode *COMMA();
    Pragma_clauseContext *pragma_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Element_specContext* element_spec();

  class  Element_spec_optionsContext : public antlr4::ParserRuleContext {
  public:
    Element_spec_optionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Subprogram_specContext *subprogram_spec();
    Constructor_specContext *constructor_spec();
    Map_order_function_specContext *map_order_function_spec();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Element_spec_optionsContext* element_spec_options();

  class  Subprogram_specContext : public antlr4::ParserRuleContext {
  public:
    Subprogram_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MEMBER();
    antlr4::tree::TerminalNode *STATIC();
    Type_procedure_specContext *type_procedure_spec();
    Type_function_specContext *type_function_spec();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subprogram_specContext* subprogram_spec();

  class  Overriding_subprogram_specContext : public antlr4::ParserRuleContext {
  public:
    Overriding_subprogram_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OVERRIDING();
    antlr4::tree::TerminalNode *MEMBER();
    Overriding_function_specContext *overriding_function_spec();
    Overriding_procedure_specContext *overriding_procedure_spec();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Overriding_subprogram_specContext* overriding_subprogram_spec();

  class  Overriding_function_specContext : public antlr4::ParserRuleContext {
  public:
    Overriding_function_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FUNCTION();
    Function_nameContext *function_name();
    antlr4::tree::TerminalNode *RETURN();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *SELF();
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);
    antlr4::tree::TerminalNode *RESULT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Type_elements_parameterContext *> type_elements_parameter();
    Type_elements_parameterContext* type_elements_parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *IS();
    BodyContext *body();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *PIPELINED();
    antlr4::tree::TerminalNode *DECLARE();
    Seq_of_declare_specsContext *seq_of_declare_specs();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Overriding_function_specContext* overriding_function_spec();

  class  Overriding_procedure_specContext : public antlr4::ParserRuleContext {
  public:
    Overriding_procedure_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PROCEDURE();
    Procedure_nameContext *procedure_name();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    Call_specContext *call_spec();
    BodyContext *body();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Type_elements_parameterContext *> type_elements_parameter();
    Type_elements_parameterContext* type_elements_parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *DECLARE();
    Seq_of_declare_specsContext *seq_of_declare_specs();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Overriding_procedure_specContext* overriding_procedure_spec();

  class  Type_procedure_specContext : public antlr4::ParserRuleContext {
  public:
    Type_procedure_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PROCEDURE();
    Procedure_nameContext *procedure_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Type_elements_parameterContext *> type_elements_parameter();
    Type_elements_parameterContext* type_elements_parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Call_specContext *call_spec();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Type_procedure_specContext* type_procedure_spec();

  class  Type_function_specContext : public antlr4::ParserRuleContext {
  public:
    Type_function_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FUNCTION();
    Function_nameContext *function_name();
    antlr4::tree::TerminalNode *RETURN();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *SELF();
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);
    antlr4::tree::TerminalNode *RESULT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Type_elements_parameterContext *> type_elements_parameter();
    Type_elements_parameterContext* type_elements_parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Call_specContext *call_spec();
    antlr4::tree::TerminalNode *EXTERNAL();
    antlr4::tree::TerminalNode *NAME();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *IS();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *VARIABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Type_function_specContext* type_function_spec();

  class  Constructor_specContext : public antlr4::ParserRuleContext {
  public:
    Constructor_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONSTRUCTOR();
    antlr4::tree::TerminalNode *FUNCTION();
    std::vector<Type_specContext *> type_spec();
    Type_specContext* type_spec(size_t i);
    antlr4::tree::TerminalNode *RETURN();
    std::vector<antlr4::tree::TerminalNode *> SELF();
    antlr4::tree::TerminalNode* SELF(size_t i);
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);
    antlr4::tree::TerminalNode *RESULT();
    antlr4::tree::TerminalNode *FINAL();
    antlr4::tree::TerminalNode *INSTANTIABLE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Call_specContext *call_spec();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *OUT();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Type_elements_parameterContext *> type_elements_parameter();
    Type_elements_parameterContext* type_elements_parameter(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Constructor_specContext* constructor_spec();

  class  Map_order_function_specContext : public antlr4::ParserRuleContext {
  public:
    Map_order_function_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MEMBER();
    Type_function_specContext *type_function_spec();
    antlr4::tree::TerminalNode *MAP();
    antlr4::tree::TerminalNode *ORDER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Map_order_function_specContext* map_order_function_spec();

  class  Pragma_clauseContext : public antlr4::ParserRuleContext {
  public:
    Pragma_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PRAGMA();
    antlr4::tree::TerminalNode *RESTRICT_REFERENCES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Pragma_elementsContext *> pragma_elements();
    Pragma_elementsContext* pragma_elements(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pragma_clauseContext* pragma_clause();

  class  Pragma_elementsContext : public antlr4::ParserRuleContext {
  public:
    Pragma_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *DEFAULT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pragma_elementsContext* pragma_elements();

  class  Type_elements_parameterContext : public antlr4::ParserRuleContext {
  public:
    Type_elements_parameterContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Parameter_nameContext *parameter_name();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *OUT();
    antlr4::tree::TerminalNode *NOCOPY();
    antlr4::tree::TerminalNode *ASSIGN_OP();
    ConstantContext *constant();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Type_elements_parameterContext* type_elements_parameter();

  class  Drop_sequenceContext : public antlr4::ParserRuleContext {
  public:
    Drop_sequenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *SEQUENCE();
    Sequence_nameContext *sequence_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_sequenceContext* drop_sequence();

  class  Alter_sequenceContext : public antlr4::ParserRuleContext {
  public:
    Alter_sequenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *SEQUENCE();
    Sequence_nameContext *sequence_name();
    std::vector<Sequence_specContext *> sequence_spec();
    Sequence_specContext* sequence_spec(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_sequenceContext* alter_sequence();

  class  Alter_sessionContext : public antlr4::ParserRuleContext {
  public:
    Alter_sessionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *SESSION();
    antlr4::tree::TerminalNode *ADVISE();
    antlr4::tree::TerminalNode *CLOSE();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *LINK();
    Parameter_nameContext *parameter_name();
    Enable_or_disableContext *enable_or_disable();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *PROCEDURE();
    antlr4::tree::TerminalNode *GUARD();
    std::vector<antlr4::tree::TerminalNode *> PARALLEL();
    antlr4::tree::TerminalNode* PARALLEL(size_t i);
    antlr4::tree::TerminalNode *SET();
    Alter_session_set_clauseContext *alter_session_set_clause();
    antlr4::tree::TerminalNode *ROLLBACK();
    antlr4::tree::TerminalNode *NOTHING();
    antlr4::tree::TerminalNode *DML();
    antlr4::tree::TerminalNode *DDL();
    antlr4::tree::TerminalNode *QUERY();
    antlr4::tree::TerminalNode *FORCE();
    LiteralContext *literal();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_sessionContext* alter_session();

  class  Alter_session_set_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *en = nullptr;
    PlSqlParser::Id_expressionContext *cn = nullptr;
    PlSqlParser::Id_expressionContext *sn = nullptr;
    PlSqlParser::Id_expressionContext *c = nullptr;
    Alter_session_set_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Parameter_nameContext *> parameter_name();
    Parameter_nameContext* parameter_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> EQUALS_OP();
    antlr4::tree::TerminalNode* EQUALS_OP(size_t i);
    std::vector<Parameter_valueContext *> parameter_value();
    Parameter_valueContext* parameter_value(size_t i);
    antlr4::tree::TerminalNode *EDITION();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *CONTAINER();
    antlr4::tree::TerminalNode *SERVICE();
    antlr4::tree::TerminalNode *ROW();
    antlr4::tree::TerminalNode *ARCHIVAL();
    antlr4::tree::TerminalNode *VISIBILITY();
    antlr4::tree::TerminalNode *ACTIVE();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *DEFAULT_COLLATION();
    antlr4::tree::TerminalNode *NONE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_session_set_clauseContext* alter_session_set_clause();

  class  Create_sequenceContext : public antlr4::ParserRuleContext {
  public:
    Create_sequenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *SEQUENCE();
    Sequence_nameContext *sequence_name();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *EXISTS();
    std::vector<Sequence_specContext *> sequence_spec();
    Sequence_specContext* sequence_spec(size_t i);
    antlr4::tree::TerminalNode *SHARING();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *METADATA();
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *NONE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_sequenceContext* create_sequence();

  class  Sequence_specContext : public antlr4::ParserRuleContext {
  public:
    Sequence_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INCREMENT();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    Sequence_start_clauseContext *sequence_start_clause();
    antlr4::tree::TerminalNode *MAXVALUE();
    antlr4::tree::TerminalNode *NOMAXVALUE();
    antlr4::tree::TerminalNode *MINVALUE();
    antlr4::tree::TerminalNode *NOMINVALUE();
    antlr4::tree::TerminalNode *CYCLE();
    antlr4::tree::TerminalNode *NOCYCLE();
    antlr4::tree::TerminalNode *CACHE();
    antlr4::tree::TerminalNode *NOCACHE();
    antlr4::tree::TerminalNode *ORDER();
    antlr4::tree::TerminalNode *NOORDER();
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *NOKEEP();
    antlr4::tree::TerminalNode *SCALE();
    antlr4::tree::TerminalNode *EXTEND();
    antlr4::tree::TerminalNode *NOEXTEND();
    antlr4::tree::TerminalNode *NOSCALE();
    antlr4::tree::TerminalNode *SHARD();
    antlr4::tree::TerminalNode *NOSHARD();
    antlr4::tree::TerminalNode *SESSION();
    antlr4::tree::TerminalNode *GLOBAL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sequence_specContext* sequence_spec();

  class  Sequence_start_clauseContext : public antlr4::ParserRuleContext {
  public:
    Sequence_start_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *START();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sequence_start_clauseContext* sequence_start_clause();

  class  Create_analytic_viewContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *av = nullptr;
    Create_analytic_viewContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *ANALYTIC();
    antlr4::tree::TerminalNode *VIEW();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *SHARING();
    antlr4::tree::TerminalNode *EQUALS_OP();
    std::vector<Classification_clauseContext *> classification_clause();
    Classification_clauseContext* classification_clause(size_t i);
    Cav_using_clauseContext *cav_using_clause();
    Dim_by_clauseContext *dim_by_clause();
    Measures_clauseContext *measures_clause();
    Default_measure_clauseContext *default_measure_clause();
    Default_aggregate_clauseContext *default_aggregate_clause();
    Cache_clauseContext *cache_clause();
    Fact_columns_clauseContext *fact_columns_clause();
    Qry_transform_clauseContext *qry_transform_clause();
    antlr4::tree::TerminalNode *NOFORCE();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *METADATA();
    antlr4::tree::TerminalNode *NONE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_analytic_viewContext* create_analytic_view();

  class  Classification_clauseContext : public antlr4::ParserRuleContext {
  public:
    Classification_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Caption_clauseContext *caption_clause();
    Description_clauseContext *description_clause();
    std::vector<Classification_itemContext *> classification_item();
    Classification_itemContext* classification_item(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Classification_clauseContext* classification_clause();

  class  Caption_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Quoted_stringContext *c = nullptr;
    Caption_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CAPTION();
    Quoted_stringContext *quoted_string();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Caption_clauseContext* caption_clause();

  class  Description_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Quoted_stringContext *d = nullptr;
    Description_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DESCRIPTION();
    Quoted_stringContext *quoted_string();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Description_clauseContext* description_clause();

  class  Classification_itemContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *cn = nullptr;
    PlSqlParser::Quoted_stringContext *cv = nullptr;
    Classification_itemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CLASSIFICATION();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *VALUE();
    antlr4::tree::TerminalNode *LANGUAGE();
    LanguageContext *language();
    Quoted_stringContext *quoted_string();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Classification_itemContext* classification_item();

  class  LanguageContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *nls = nullptr;
    LanguageContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NULL_();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  LanguageContext* language();

  class  Cav_using_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *t = nullptr;
    PlSqlParser::Id_expressionContext *ta = nullptr;
    Cav_using_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *REMOTE();
    antlr4::tree::TerminalNode *AS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cav_using_clauseContext* cav_using_clause();

  class  Dim_by_clauseContext : public antlr4::ParserRuleContext {
  public:
    Dim_by_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DIMENSION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Dim_keyContext *> dim_key();
    Dim_keyContext* dim_key(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dim_by_clauseContext* dim_by_clause();

  class  Dim_keyContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *a = nullptr;
    PlSqlParser::Column_nameContext *f = nullptr;
    Dim_keyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Dim_refContext *dim_ref();
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *REFERENCES();
    antlr4::tree::TerminalNode *HIERARCHIES();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<Hier_refContext *> hier_ref();
    Hier_refContext* hier_ref(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<Attribute_nameContext *> attribute_name();
    Attribute_nameContext* attribute_name(size_t i);
    std::vector<Classification_clauseContext *> classification_clause();
    Classification_clauseContext* classification_clause(size_t i);
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *DISTINCT();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dim_keyContext* dim_key();

  class  Dim_refContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *ad = nullptr;
    PlSqlParser::Id_expressionContext *da = nullptr;
    Dim_refContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *AS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dim_refContext* dim_ref();

  class  Hier_refContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *h = nullptr;
    PlSqlParser::Id_expressionContext *ha = nullptr;
    Hier_refContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *AS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hier_refContext* hier_ref();

  class  Measures_clauseContext : public antlr4::ParserRuleContext {
  public:
    Measures_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MEASURES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Av_measureContext *> av_measure();
    Av_measureContext* av_measure(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Measures_clauseContext* measures_clause();

  class  Av_measureContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *mn = nullptr;
    Av_measureContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();
    Base_meas_clauseContext *base_meas_clause();
    Calc_meas_clauseContext *calc_meas_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Av_measureContext* av_measure();

  class  Base_meas_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *bm = nullptr;
    Base_meas_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FACT();
    Id_expressionContext *id_expression();
    Meas_aggregate_clauseContext *meas_aggregate_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Base_meas_clauseContext* base_meas_clause();

  class  Meas_aggregate_clauseContext : public antlr4::ParserRuleContext {
  public:
    Meas_aggregate_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AGGREGATE();
    antlr4::tree::TerminalNode *BY();
    Aggregate_function_nameContext *aggregate_function_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Meas_aggregate_clauseContext* meas_aggregate_clause();

  class  Calc_meas_clauseContext : public antlr4::ParserRuleContext {
  public:
    Calc_meas_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Calc_meas_clauseContext* calc_meas_clause();

  class  Default_measure_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *m = nullptr;
    Default_measure_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *MEASURE();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Default_measure_clauseContext* default_measure_clause();

  class  Default_aggregate_clauseContext : public antlr4::ParserRuleContext {
  public:
    Default_aggregate_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *AGGREGATE();
    antlr4::tree::TerminalNode *BY();
    Aggregate_function_nameContext *aggregate_function_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Default_aggregate_clauseContext* default_aggregate_clause();

  class  Cache_clauseContext : public antlr4::ParserRuleContext {
  public:
    Cache_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CACHE();
    std::vector<Cache_specificationContext *> cache_specification();
    Cache_specificationContext* cache_specification(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cache_clauseContext* cache_clause();

  class  Cache_specificationContext : public antlr4::ParserRuleContext {
  public:
    Cache_specificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MEASURE();
    antlr4::tree::TerminalNode *GROUP();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Levels_clauseContext *> levels_clause();
    Levels_clauseContext* levels_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cache_specificationContext* cache_specification();

  class  Levels_clauseContext : public antlr4::ParserRuleContext {
  public:
    Levels_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEVELS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Level_specificationContext *> level_specification();
    Level_specificationContext* level_specification(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Level_group_typeContext *level_group_type();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Levels_clauseContext* levels_clause();

  class  Level_specificationContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *d = nullptr;
    PlSqlParser::Id_expressionContext *h = nullptr;
    PlSqlParser::Id_expressionContext *l = nullptr;
    Level_specificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Level_specificationContext* level_specification();

  class  Level_group_typeContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *t = nullptr;
    Level_group_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DYNAMIC();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *USING();
    Id_expressionContext *id_expression();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Level_group_typeContext* level_group_type();

  class  Fact_columns_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Column_nameContext *f = nullptr;
    PlSqlParser::Id_expressionContext *fa = nullptr;
    Fact_columns_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FACT();
    antlr4::tree::TerminalNode *COLUMN();
    Column_nameContext *column_name();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Fact_columns_clauseContext* fact_columns_clause();

  class  Qry_transform_clauseContext : public antlr4::ParserRuleContext {
  public:
    Qry_transform_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *QUERY();
    antlr4::tree::TerminalNode *TRANSFORM();
    antlr4::tree::TerminalNode *RELY();
    antlr4::tree::TerminalNode *NORELY();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Qry_transform_clauseContext* qry_transform_clause();

  class  Create_attribute_dimensionContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *ad = nullptr;
    Create_attribute_dimensionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *ATTRIBUTE();
    std::vector<antlr4::tree::TerminalNode *> DIMENSION();
    antlr4::tree::TerminalNode* DIMENSION(size_t i);
    Ad_using_clauseContext *ad_using_clause();
    Attributes_clauseContext *attributes_clause();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *SHARING();
    antlr4::tree::TerminalNode *EQUALS_OP();
    std::vector<Classification_clauseContext *> classification_clause();
    Classification_clauseContext* classification_clause(size_t i);
    antlr4::tree::TerminalNode *TYPE();
    std::vector<Ad_level_clauseContext *> ad_level_clause();
    Ad_level_clauseContext* ad_level_clause(size_t i);
    All_clauseContext *all_clause();
    antlr4::tree::TerminalNode *NOFORCE();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *METADATA();
    antlr4::tree::TerminalNode *NONE();
    antlr4::tree::TerminalNode *STANDARD();
    antlr4::tree::TerminalNode *TIME();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_attribute_dimensionContext* create_attribute_dimension();

  class  Ad_using_clauseContext : public antlr4::ParserRuleContext {
  public:
    Ad_using_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    std::vector<Source_clauseContext *> source_clause();
    Source_clauseContext* source_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Join_path_clauseContext *> join_path_clause();
    Join_path_clauseContext* join_path_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Ad_using_clauseContext* ad_using_clause();

  class  Source_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *ftov = nullptr;
    PlSqlParser::Id_expressionContext *a = nullptr;
    Source_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *REMOTE();
    antlr4::tree::TerminalNode *AS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Source_clauseContext* source_clause();

  class  Join_path_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *jpn = nullptr;
    Join_path_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *JOIN();
    antlr4::tree::TerminalNode *PATH();
    antlr4::tree::TerminalNode *ON();
    Join_conditionContext *join_condition();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Join_path_clauseContext* join_path_clause();

  class  Join_conditionContext : public antlr4::ParserRuleContext {
  public:
    Join_conditionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Join_condition_itemContext *> join_condition_item();
    Join_condition_itemContext* join_condition_item(size_t i);
    std::vector<antlr4::tree::TerminalNode *> AND();
    antlr4::tree::TerminalNode* AND(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Join_conditionContext* join_condition();

  class  Join_condition_itemContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *a = nullptr;
    PlSqlParser::Id_expressionContext *b = nullptr;
    Join_condition_itemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *EQUALS_OP();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Join_condition_itemContext* join_condition_item();

  class  Attributes_clauseContext : public antlr4::ParserRuleContext {
  public:
    Attributes_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ATTRIBUTES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Ad_attributes_clauseContext *> ad_attributes_clause();
    Ad_attributes_clauseContext* ad_attributes_clause(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Attributes_clauseContext* attributes_clause();

  class  Ad_attributes_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *a = nullptr;
    PlSqlParser::Id_expressionContext *an = nullptr;
    Ad_attributes_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *PERIOD();
    std::vector<Classification_clauseContext *> classification_clause();
    Classification_clauseContext* classification_clause(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *AS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Ad_attributes_clauseContext* ad_attributes_clause();

  class  Ad_level_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *l = nullptr;
    Ad_level_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> LEVEL();
    antlr4::tree::TerminalNode* LEVEL(size_t i);
    Key_clauseContext *key_clause();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *SKIP_();
    antlr4::tree::TerminalNode *WHEN();
    antlr4::tree::TerminalNode *TYPE();
    std::vector<Classification_clauseContext *> classification_clause();
    Classification_clauseContext* classification_clause(size_t i);
    Alternate_key_clauseContext *alternate_key_clause();
    std::vector<antlr4::tree::TerminalNode *> MEMBER();
    antlr4::tree::TerminalNode* MEMBER(size_t i);
    antlr4::tree::TerminalNode *NAME();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *CAPTION();
    antlr4::tree::TerminalNode *DESCRIPTION();
    antlr4::tree::TerminalNode *ORDER();
    antlr4::tree::TerminalNode *BY();
    std::vector<Dim_order_clauseContext *> dim_order_clause();
    Dim_order_clauseContext* dim_order_clause(size_t i);
    antlr4::tree::TerminalNode *DETERMINES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *STANDARD();
    antlr4::tree::TerminalNode *YEARS();
    antlr4::tree::TerminalNode *HALF_YEARS();
    antlr4::tree::TerminalNode *QUARTERS();
    antlr4::tree::TerminalNode *MONTHS();
    antlr4::tree::TerminalNode *WEEKS();
    antlr4::tree::TerminalNode *DAYS();
    antlr4::tree::TerminalNode *HOURS();
    antlr4::tree::TerminalNode *MINUTES();
    antlr4::tree::TerminalNode *SECONDS();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MIN();
    antlr4::tree::TerminalNode* MIN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MAX();
    antlr4::tree::TerminalNode* MAX(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Ad_level_clauseContext* ad_level_clause();

  class  Key_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *a = nullptr;
    Key_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Key_clauseContext* key_clause();

  class  Alternate_key_clauseContext : public antlr4::ParserRuleContext {
  public:
    Alternate_key_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTERNATE();
    Key_clauseContext *key_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alternate_key_clauseContext* alternate_key_clause();

  class  Dim_order_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *a = nullptr;
    Dim_order_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *NULLS();
    antlr4::tree::TerminalNode *ASC();
    antlr4::tree::TerminalNode *DESC();
    antlr4::tree::TerminalNode *FIRST();
    antlr4::tree::TerminalNode *LAST();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dim_order_clauseContext* dim_order_clause();

  class  All_clauseContext : public antlr4::ParserRuleContext {
  public:
    All_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALL();
    std::vector<antlr4::tree::TerminalNode *> MEMBER();
    antlr4::tree::TerminalNode* MEMBER(size_t i);
    antlr4::tree::TerminalNode *NAME();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *CAPTION();
    antlr4::tree::TerminalNode *DESCRIPTION();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  All_clauseContext* all_clause();

  class  Create_audit_policyContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *p = nullptr;
    Create_audit_policyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *AUDIT();
    antlr4::tree::TerminalNode *POLICY();
    Id_expressionContext *id_expression();
    Privilege_audit_clauseContext *privilege_audit_clause();
    Action_audit_clauseContext *action_audit_clause();
    Role_audit_clauseContext *role_audit_clause();
    antlr4::tree::TerminalNode *WHEN();
    Quoted_stringContext *quoted_string();
    antlr4::tree::TerminalNode *EVALUATE();
    antlr4::tree::TerminalNode *PER();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *TOPLEVEL();
    Container_clauseContext *container_clause();
    antlr4::tree::TerminalNode *STATEMENT();
    antlr4::tree::TerminalNode *SESSION();
    antlr4::tree::TerminalNode *INSTANCE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_audit_policyContext* create_audit_policy();

  class  Privilege_audit_clauseContext : public antlr4::ParserRuleContext {
  public:
    Privilege_audit_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PRIVILEGES();
    std::vector<System_privilegeContext *> system_privilege();
    System_privilegeContext* system_privilege(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Privilege_audit_clauseContext* privilege_audit_clause();

  class  Action_audit_clauseContext : public antlr4::ParserRuleContext {
  public:
    Action_audit_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Standard_actionsContext *> standard_actions();
    Standard_actionsContext* standard_actions(size_t i);
    std::vector<Component_actionsContext *> component_actions();
    Component_actionsContext* component_actions(size_t i);
    std::vector<System_actionsContext *> system_actions();
    System_actionsContext* system_actions(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Action_audit_clauseContext* action_audit_clause();

  class  System_actionsContext : public antlr4::ParserRuleContext {
  public:
    System_actionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ACTIONS();
    std::vector<System_privilegeContext *> system_privilege();
    System_privilegeContext* system_privilege(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  System_actionsContext* system_actions();

  class  Standard_actionsContext : public antlr4::ParserRuleContext {
  public:
    Standard_actionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ACTIONS();
    std::vector<Actions_clauseContext *> actions_clause();
    Actions_clauseContext* actions_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Standard_actionsContext* standard_actions();

  class  Actions_clauseContext : public antlr4::ParserRuleContext {
  public:
    Actions_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ON();
    Object_actionContext *object_action();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *DIRECTORY();
    Directory_nameContext *directory_name();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *MINING();
    antlr4::tree::TerminalNode *MODEL();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();
    System_actionContext *system_action();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Actions_clauseContext* actions_clause();

  class  Object_actionContext : public antlr4::ParserRuleContext {
  public:
    Object_actionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *GRANT();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *EXECUTE();
    antlr4::tree::TerminalNode *AUDIT();
    antlr4::tree::TerminalNode *COMMENT();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *INDEX();
    antlr4::tree::TerminalNode *INSERT();
    antlr4::tree::TerminalNode *LOCK();
    antlr4::tree::TerminalNode *SELECT();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *FLASHBACK();
    antlr4::tree::TerminalNode *RENAME();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_actionContext* object_action();

  class  System_actionContext : public antlr4::ParserRuleContext {
  public:
    System_actionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *JAVA();
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *LOCK();
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *DIRECTORY();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *WRITE();
    antlr4::tree::TerminalNode *EXECUTE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  System_actionContext* system_action();

  class  Component_actionsContext : public antlr4::ParserRuleContext {
  public:
    Component_actionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ACTIONS();
    antlr4::tree::TerminalNode *COMPONENT();
    antlr4::tree::TerminalNode *EQUALS_OP();
    std::vector<Component_actionContext *> component_action();
    Component_actionContext* component_action(size_t i);
    antlr4::tree::TerminalNode *DV();
    std::vector<antlr4::tree::TerminalNode *> ON();
    antlr4::tree::TerminalNode* ON(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *PROTOCOL();
    antlr4::tree::TerminalNode *DATAPUMP();
    antlr4::tree::TerminalNode *DIRECT_LOAD();
    antlr4::tree::TerminalNode *OLS();
    antlr4::tree::TerminalNode *XS();
    antlr4::tree::TerminalNode *FTP();
    antlr4::tree::TerminalNode *HTTP();
    antlr4::tree::TerminalNode *AUTHENTICATION();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Component_actionsContext* component_actions();

  class  Component_actionContext : public antlr4::ParserRuleContext {
  public:
    Component_actionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Component_actionContext* component_action();

  class  Role_audit_clauseContext : public antlr4::ParserRuleContext {
  public:
    Role_audit_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ROLES();
    std::vector<Role_nameContext *> role_name();
    Role_nameContext* role_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Role_audit_clauseContext* role_audit_clause();

  class  Create_controlfileContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *d = nullptr;
    Create_controlfileContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *CONTROLFILE();
    antlr4::tree::TerminalNode *DATABASE();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *RESETLOGS();
    antlr4::tree::TerminalNode *NORESETLOGS();
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *SET();
    Logfile_clauseContext *logfile_clause();
    antlr4::tree::TerminalNode *DATAFILE();
    std::vector<File_specificationContext *> file_specification();
    File_specificationContext* file_specification(size_t i);
    std::vector<Controlfile_optionsContext *> controlfile_options();
    Controlfile_optionsContext* controlfile_options(size_t i);
    Character_set_clauseContext *character_set_clause();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_controlfileContext* create_controlfile();

  class  Controlfile_optionsContext : public antlr4::ParserRuleContext {
  public:
    Controlfile_optionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MAXLOGFILES();
    NumericContext *numeric();
    antlr4::tree::TerminalNode *MAXLOGMEMBERS();
    antlr4::tree::TerminalNode *MAXLOGHISTORY();
    antlr4::tree::TerminalNode *MAXDATAFILES();
    antlr4::tree::TerminalNode *MAXINSTANCES();
    antlr4::tree::TerminalNode *ARCHIVELOG();
    antlr4::tree::TerminalNode *NOARCHIVELOG();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *LOGGING();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *NOLOGGING();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *AVAILABILITY();
    antlr4::tree::TerminalNode *LOAD();
    antlr4::tree::TerminalNode *PERFORMANCE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Controlfile_optionsContext* controlfile_options();

  class  Logfile_clauseContext : public antlr4::ParserRuleContext {
  public:
    Logfile_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOGFILE();
    std::vector<File_specificationContext *> file_specification();
    File_specificationContext* file_specification(size_t i);
    std::vector<NumericContext *> numeric();
    NumericContext* numeric(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<antlr4::tree::TerminalNode *> GROUP();
    antlr4::tree::TerminalNode* GROUP(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Logfile_clauseContext* logfile_clause();

  class  Character_set_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *cs = nullptr;
    Character_set_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHARACTER();
    antlr4::tree::TerminalNode *SET();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Character_set_clauseContext* character_set_clause();

  class  File_specificationContext : public antlr4::ParserRuleContext {
  public:
    File_specificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Datafile_tempfile_specContext *datafile_tempfile_spec();
    Redo_log_file_specContext *redo_log_file_spec();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  File_specificationContext* file_specification();

  class  Create_diskgroupContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *sn = nullptr;
    PlSqlParser::Id_expressionContext *fg = nullptr;
    antlr4::Token *an = nullptr;
    antlr4::Token *av = nullptr;
    Create_diskgroupContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *DISKGROUP();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *REDUNDANCY();
    std::vector<antlr4::tree::TerminalNode *> DISK();
    antlr4::tree::TerminalNode* DISK(size_t i);
    std::vector<Qualified_disk_clauseContext *> qualified_disk_clause();
    Qualified_disk_clauseContext* qualified_disk_clause(size_t i);
    antlr4::tree::TerminalNode *ATTRIBUTE();
    std::vector<antlr4::tree::TerminalNode *> EQUALS_OP();
    antlr4::tree::TerminalNode* EQUALS_OP(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    antlr4::tree::TerminalNode *HIGH();
    antlr4::tree::TerminalNode *NORMAL();
    antlr4::tree::TerminalNode *FLEX();
    antlr4::tree::TerminalNode *EXTENDED();
    antlr4::tree::TerminalNode *EXTERNAL();
    std::vector<Quorum_regularContext *> quorum_regular();
    Quorum_regularContext* quorum_regular(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FAILGROUP();
    antlr4::tree::TerminalNode* FAILGROUP(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *SITE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_diskgroupContext* create_diskgroup();

  class  Qualified_disk_clauseContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *ss = nullptr;
    PlSqlParser::Id_expressionContext *dn = nullptr;
    Qualified_disk_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *NAME();
    antlr4::tree::TerminalNode *SIZE();
    Size_clauseContext *size_clause();
    Force_noforceContext *force_noforce();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Qualified_disk_clauseContext* qualified_disk_clause();

  class  Create_editionContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *e = nullptr;
    PlSqlParser::Id_expressionContext *pe = nullptr;
    Create_editionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *EDITION();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *CHILD();
    antlr4::tree::TerminalNode *OF();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_editionContext* create_edition();

  class  Create_flashback_archiveContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *fa = nullptr;
    PlSqlParser::Id_expressionContext *ts = nullptr;
    Create_flashback_archiveContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *FLASHBACK();
    antlr4::tree::TerminalNode *ARCHIVE();
    antlr4::tree::TerminalNode *TABLESPACE();
    Flashback_archive_retentionContext *flashback_archive_retention();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *DEFAULT();
    Flashback_archive_quotaContext *flashback_archive_quota();
    antlr4::tree::TerminalNode *OPTIMIZE();
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *NO();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_flashback_archiveContext* create_flashback_archive();

  class  Flashback_archive_quotaContext : public antlr4::ParserRuleContext {
  public:
    Flashback_archive_quotaContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *QUOTA();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *M_LETTER();
    antlr4::tree::TerminalNode *G_LETTER();
    antlr4::tree::TerminalNode *T_LETTER();
    antlr4::tree::TerminalNode *P_LETTER();
    antlr4::tree::TerminalNode *E_LETTER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Flashback_archive_quotaContext* flashback_archive_quota();

  class  Flashback_archive_retentionContext : public antlr4::ParserRuleContext {
  public:
    Flashback_archive_retentionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RETENTION();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *YEAR();
    antlr4::tree::TerminalNode *MONTH();
    antlr4::tree::TerminalNode *DAY();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Flashback_archive_retentionContext* flashback_archive_retention();

  class  Create_hierarchyContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *h = nullptr;
    Create_hierarchyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *HIERARCHY();
    Hier_using_clauseContext *hier_using_clause();
    Level_hier_clauseContext *level_hier_clause();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *FORCE();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *SHARING();
    antlr4::tree::TerminalNode *EQUALS_OP();
    std::vector<Classification_clauseContext *> classification_clause();
    Classification_clauseContext* classification_clause(size_t i);
    Hier_attrs_clauseContext *hier_attrs_clause();
    antlr4::tree::TerminalNode *METADATA();
    antlr4::tree::TerminalNode *NONE();
    antlr4::tree::TerminalNode *NO();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_hierarchyContext* create_hierarchy();

  class  Hier_using_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *ad = nullptr;
    Hier_using_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    Id_expressionContext *id_expression();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hier_using_clauseContext* hier_using_clause();

  class  Level_hier_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *l = nullptr;
    Level_hier_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CHILD();
    antlr4::tree::TerminalNode* CHILD(size_t i);
    std::vector<antlr4::tree::TerminalNode *> OF();
    antlr4::tree::TerminalNode* OF(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Level_hier_clauseContext* level_hier_clause();

  class  Hier_attrs_clauseContext : public antlr4::ParserRuleContext {
  public:
    Hier_attrs_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *HIERARCHICAL();
    antlr4::tree::TerminalNode *ATTRIBUTES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Hier_attr_clauseContext *hier_attr_clause();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hier_attrs_clauseContext* hier_attrs_clause();

  class  Hier_attr_clauseContext : public antlr4::ParserRuleContext {
  public:
    Hier_attr_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Hier_attr_nameContext *hier_attr_name();
    std::vector<Classification_clauseContext *> classification_clause();
    Classification_clauseContext* classification_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hier_attr_clauseContext* hier_attr_clause();

  class  Hier_attr_nameContext : public antlr4::ParserRuleContext {
  public:
    Hier_attr_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MEMBER_NAME();
    antlr4::tree::TerminalNode *MEMBER_UNIQUE_NAME();
    antlr4::tree::TerminalNode *MEMBER_CAPTION();
    antlr4::tree::TerminalNode *MEMBER_DESCRIPTION();
    antlr4::tree::TerminalNode *LEVEL_NAME();
    antlr4::tree::TerminalNode *HIER_ORDER();
    antlr4::tree::TerminalNode *DEPTH();
    antlr4::tree::TerminalNode *IS_LEAF();
    antlr4::tree::TerminalNode *PARENT_LEVEL_NAME();
    antlr4::tree::TerminalNode *PARENT_UNIQUE_NAME();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hier_attr_nameContext* hier_attr_name();

  class  Create_indexContext : public antlr4::ParserRuleContext {
  public:
    Create_indexContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *INDEX();
    Index_nameContext *index_name();
    antlr4::tree::TerminalNode *ON();
    Cluster_index_clauseContext *cluster_index_clause();
    Table_index_clauseContext *table_index_clause();
    Bitmap_join_index_clauseContext *bitmap_join_index_clause();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *EXISTS();
    antlr4::tree::TerminalNode *INVALIDATION();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *BITMAP();
    antlr4::tree::TerminalNode *USABLE();
    antlr4::tree::TerminalNode *UNUSABLE();
    antlr4::tree::TerminalNode *DEFERRED();
    antlr4::tree::TerminalNode *IMMEDIATE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_indexContext* create_index();

  class  Cluster_index_clauseContext : public antlr4::ParserRuleContext {
  public:
    Cluster_index_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CLUSTER();
    Cluster_nameContext *cluster_name();
    Index_attributesContext *index_attributes();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cluster_index_clauseContext* cluster_index_clause();

  class  Cluster_nameContext : public antlr4::ParserRuleContext {
  public:
    Cluster_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cluster_nameContext* cluster_name();

  class  Table_index_clauseContext : public antlr4::ParserRuleContext {
  public:
    Table_index_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Index_exprContext *> index_expr();
    Index_exprContext* index_expr(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Table_aliasContext *table_alias();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Index_propertiesContext *index_properties();
    std::vector<antlr4::tree::TerminalNode *> ASC();
    antlr4::tree::TerminalNode* ASC(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DESC();
    antlr4::tree::TerminalNode* DESC(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_index_clauseContext* table_index_clause();

  class  Bitmap_join_index_clauseContext : public antlr4::ParserRuleContext {
  public:
    Bitmap_join_index_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Tableview_nameContext *> tableview_name();
    Tableview_nameContext* tableview_name(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *FROM();
    std::vector<Table_aliasContext *> table_alias();
    Table_aliasContext* table_alias(size_t i);
    Where_clauseContext *where_clause();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Local_partitioned_indexContext *local_partitioned_index();
    Index_attributesContext *index_attributes();
    std::vector<antlr4::tree::TerminalNode *> ASC();
    antlr4::tree::TerminalNode* ASC(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DESC();
    antlr4::tree::TerminalNode* DESC(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Bitmap_join_index_clauseContext* bitmap_join_index_clause();

  class  Index_exprContext : public antlr4::ParserRuleContext {
  public:
    Index_exprContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    ExpressionContext *expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_exprContext* index_expr();

  class  Index_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Index_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Global_partitioned_indexContext *> global_partitioned_index();
    Global_partitioned_indexContext* global_partitioned_index(size_t i);
    std::vector<Local_partitioned_indexContext *> local_partitioned_index();
    Local_partitioned_indexContext* local_partitioned_index(size_t i);
    std::vector<Index_attributesContext *> index_attributes();
    Index_attributesContext* index_attributes(size_t i);
    antlr4::tree::TerminalNode *INDEXTYPE();
    antlr4::tree::TerminalNode *IS();
    Domain_index_clauseContext *domain_index_clause();
    Xmlindex_clauseContext *xmlindex_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_propertiesContext* index_properties();

  class  Domain_index_clauseContext : public antlr4::ParserRuleContext {
  public:
    Domain_index_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IndextypeContext *indextype();
    Local_domain_index_clauseContext *local_domain_index_clause();
    Parallel_clauseContext *parallel_clause();
    antlr4::tree::TerminalNode *PARAMETERS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Odci_parametersContext *odci_parameters();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Domain_index_clauseContext* domain_index_clause();

  class  Local_domain_index_clauseContext : public antlr4::ParserRuleContext {
  public:
    Local_domain_index_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOCAL();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PARTITION();
    antlr4::tree::TerminalNode* PARTITION(size_t i);
    std::vector<Partition_nameContext *> partition_name();
    Partition_nameContext* partition_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PARAMETERS();
    antlr4::tree::TerminalNode* PARAMETERS(size_t i);
    std::vector<Odci_parametersContext *> odci_parameters();
    Odci_parametersContext* odci_parameters(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Local_domain_index_clauseContext* local_domain_index_clause();

  class  Xmlindex_clauseContext : public antlr4::ParserRuleContext {
  public:
    Xmlindex_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *XMLINDEX();
    antlr4::tree::TerminalNode *XDB();
    antlr4::tree::TerminalNode *PERIOD();
    Local_xmlindex_clauseContext *local_xmlindex_clause();
    Parallel_clauseContext *parallel_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmlindex_clauseContext* xmlindex_clause();

  class  Local_xmlindex_clauseContext : public antlr4::ParserRuleContext {
  public:
    Local_xmlindex_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOCAL();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> PARTITION();
    antlr4::tree::TerminalNode* PARTITION(size_t i);
    std::vector<Partition_nameContext *> partition_name();
    Partition_nameContext* partition_name(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Local_xmlindex_clauseContext* local_xmlindex_clause();

  class  Global_partitioned_indexContext : public antlr4::ParserRuleContext {
  public:
    Global_partitioned_indexContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GLOBAL();
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *RANGE();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<Index_partitioning_clauseContext *> index_partitioning_clause();
    Index_partitioning_clauseContext* index_partitioning_clause(size_t i);
    antlr4::tree::TerminalNode *HASH();
    Individual_hash_partitionsContext *individual_hash_partitions();
    Hash_partitions_by_quantityContext *hash_partitions_by_quantity();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Global_partitioned_indexContext* global_partitioned_index();

  class  Index_partitioning_clauseContext : public antlr4::ParserRuleContext {
  public:
    Index_partitioning_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *VALUES();
    antlr4::tree::TerminalNode *LESS();
    antlr4::tree::TerminalNode *THAN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Index_partitioning_values_listContext *index_partitioning_values_list();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Partition_nameContext *partition_name();
    Segment_attributes_clauseContext *segment_attributes_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_partitioning_clauseContext* index_partitioning_clause();

  class  Index_partitioning_values_listContext : public antlr4::ParserRuleContext {
  public:
    Index_partitioning_values_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<LiteralContext *> literal();
    LiteralContext* literal(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TIMESTAMP();
    antlr4::tree::TerminalNode* TIMESTAMP(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_partitioning_values_listContext* index_partitioning_values_list();

  class  Local_partitioned_indexContext : public antlr4::ParserRuleContext {
  public:
    Local_partitioned_indexContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOCAL();
    On_range_partitioned_tableContext *on_range_partitioned_table();
    On_list_partitioned_tableContext *on_list_partitioned_table();
    On_hash_partitioned_tableContext *on_hash_partitioned_table();
    On_comp_partitioned_tableContext *on_comp_partitioned_table();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Local_partitioned_indexContext* local_partitioned_index();

  class  On_range_partitioned_tableContext : public antlr4::ParserRuleContext {
  public:
    On_range_partitioned_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Partitioned_tableContext *> partitioned_table();
    Partitioned_tableContext* partitioned_table(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  On_range_partitioned_tableContext* on_range_partitioned_table();

  class  On_list_partitioned_tableContext : public antlr4::ParserRuleContext {
  public:
    On_list_partitioned_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Partitioned_tableContext *> partitioned_table();
    Partitioned_tableContext* partitioned_table(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  On_list_partitioned_tableContext* on_list_partitioned_table();

  class  Partitioned_tableContext : public antlr4::ParserRuleContext {
  public:
    Partitioned_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();
    std::vector<Segment_attributes_clauseContext *> segment_attributes_clause();
    Segment_attributes_clauseContext* segment_attributes_clause(size_t i);
    std::vector<Key_compressionContext *> key_compression();
    Key_compressionContext* key_compression(size_t i);
    antlr4::tree::TerminalNode *UNUSABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partitioned_tableContext* partitioned_table();

  class  On_hash_partitioned_tableContext : public antlr4::ParserRuleContext {
  public:
    On_hash_partitioned_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<On_hash_partitioned_clauseContext *> on_hash_partitioned_clause();
    On_hash_partitioned_clauseContext* on_hash_partitioned_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  On_hash_partitioned_tableContext* on_hash_partitioned_table();

  class  On_hash_partitioned_clauseContext : public antlr4::ParserRuleContext {
  public:
    On_hash_partitioned_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();
    antlr4::tree::TerminalNode *TABLESPACE();
    TablespaceContext *tablespace();
    Key_compressionContext *key_compression();
    antlr4::tree::TerminalNode *UNUSABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  On_hash_partitioned_clauseContext* on_hash_partitioned_clause();

  class  On_comp_partitioned_tableContext : public antlr4::ParserRuleContext {
  public:
    On_comp_partitioned_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<On_comp_partitioned_clauseContext *> on_comp_partitioned_clause();
    On_comp_partitioned_clauseContext* on_comp_partitioned_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *IN();
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  On_comp_partitioned_tableContext* on_comp_partitioned_table();

  class  On_comp_partitioned_clauseContext : public antlr4::ParserRuleContext {
  public:
    On_comp_partitioned_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();
    std::vector<Segment_attributes_clauseContext *> segment_attributes_clause();
    Segment_attributes_clauseContext* segment_attributes_clause(size_t i);
    std::vector<Key_compressionContext *> key_compression();
    Key_compressionContext* key_compression(size_t i);
    antlr4::tree::TerminalNode *UNUSABLE();
    Index_subpartition_clauseContext *index_subpartition_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  On_comp_partitioned_clauseContext* on_comp_partitioned_clause();

  class  Index_subpartition_clauseContext : public antlr4::ParserRuleContext {
  public:
    Index_subpartition_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Index_subpartition_subclauseContext *> index_subpartition_subclause();
    Index_subpartition_subclauseContext* index_subpartition_subclause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_subpartition_clauseContext* index_subpartition_clause();

  class  Index_subpartition_subclauseContext : public antlr4::ParserRuleContext {
  public:
    Index_subpartition_subclauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBPARTITION();
    Subpartition_nameContext *subpartition_name();
    antlr4::tree::TerminalNode *TABLESPACE();
    TablespaceContext *tablespace();
    Key_compressionContext *key_compression();
    antlr4::tree::TerminalNode *UNUSABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_subpartition_subclauseContext* index_subpartition_subclause();

  class  Odci_parametersContext : public antlr4::ParserRuleContext {
  public:
    Odci_parametersContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Odci_parametersContext* odci_parameters();

  class  IndextypeContext : public antlr4::ParserRuleContext {
  public:
    IndextypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  IndextypeContext* indextype();

  class  Alter_indexContext : public antlr4::ParserRuleContext {
  public:
    Alter_indexContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *INDEX();
    Index_nameContext *index_name();
    Alter_index_ops_set1Context *alter_index_ops_set1();
    Alter_index_ops_set2Context *alter_index_ops_set2();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_indexContext* alter_index();

  class  Alter_index_ops_set1Context : public antlr4::ParserRuleContext {
  public:
    Alter_index_ops_set1Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Deallocate_unused_clauseContext *> deallocate_unused_clause();
    Deallocate_unused_clauseContext* deallocate_unused_clause(size_t i);
    std::vector<Allocate_extent_clauseContext *> allocate_extent_clause();
    Allocate_extent_clauseContext* allocate_extent_clause(size_t i);
    std::vector<Shrink_clauseContext *> shrink_clause();
    Shrink_clauseContext* shrink_clause(size_t i);
    std::vector<Parallel_clauseContext *> parallel_clause();
    Parallel_clauseContext* parallel_clause(size_t i);
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<Logging_clauseContext *> logging_clause();
    Logging_clauseContext* logging_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_index_ops_set1Context* alter_index_ops_set1();

  class  Alter_index_ops_set2Context : public antlr4::ParserRuleContext {
  public:
    Alter_index_ops_set2Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Rebuild_clauseContext *rebuild_clause();
    antlr4::tree::TerminalNode *PARAMETERS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Odci_parametersContext *odci_parameters();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *COMPILE();
    Enable_or_disableContext *enable_or_disable();
    antlr4::tree::TerminalNode *UNUSABLE();
    Visible_or_invisibleContext *visible_or_invisible();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *TO();
    New_index_nameContext *new_index_name();
    antlr4::tree::TerminalNode *COALESCE();
    Monitoring_nomonitoringContext *monitoring_nomonitoring();
    antlr4::tree::TerminalNode *USAGE();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *BLOCK();
    antlr4::tree::TerminalNode *REFERENCES();
    Alter_index_partitioningContext *alter_index_partitioning();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_index_ops_set2Context* alter_index_ops_set2();

  class  Visible_or_invisibleContext : public antlr4::ParserRuleContext {
  public:
    Visible_or_invisibleContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VISIBLE();
    antlr4::tree::TerminalNode *INVISIBLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Visible_or_invisibleContext* visible_or_invisible();

  class  Monitoring_nomonitoringContext : public antlr4::ParserRuleContext {
  public:
    Monitoring_nomonitoringContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MONITORING();
    antlr4::tree::TerminalNode *NOMONITORING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Monitoring_nomonitoringContext* monitoring_nomonitoring();

  class  Rebuild_clauseContext : public antlr4::ParserRuleContext {
  public:
    Rebuild_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REBUILD();
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();
    antlr4::tree::TerminalNode *SUBPARTITION();
    Subpartition_nameContext *subpartition_name();
    antlr4::tree::TerminalNode *REVERSE();
    antlr4::tree::TerminalNode *NOREVERSE();
    std::vector<Parallel_clauseContext *> parallel_clause();
    Parallel_clauseContext* parallel_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PARAMETERS();
    antlr4::tree::TerminalNode* PARAMETERS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<Odci_parametersContext *> odci_parameters();
    Odci_parametersContext* odci_parameters(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ONLINE();
    antlr4::tree::TerminalNode* ONLINE(size_t i);
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<Key_compressionContext *> key_compression();
    Key_compressionContext* key_compression(size_t i);
    std::vector<Logging_clauseContext *> logging_clause();
    Logging_clauseContext* logging_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Rebuild_clauseContext* rebuild_clause();

  class  Alter_index_partitioningContext : public antlr4::ParserRuleContext {
  public:
    Alter_index_partitioningContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Modify_index_default_attrsContext *modify_index_default_attrs();
    Add_hash_index_partitionContext *add_hash_index_partition();
    Modify_index_partitionContext *modify_index_partition();
    Rename_index_partitionContext *rename_index_partition();
    Drop_index_partitionContext *drop_index_partition();
    Split_index_partitionContext *split_index_partition();
    Coalesce_index_partitionContext *coalesce_index_partition();
    Modify_index_subpartitionContext *modify_index_subpartition();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_index_partitioningContext* alter_index_partitioning();

  class  Modify_index_default_attrsContext : public antlr4::ParserRuleContext {
  public:
    Modify_index_default_attrsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    std::vector<antlr4::tree::TerminalNode *> DEFAULT();
    antlr4::tree::TerminalNode* DEFAULT(size_t i);
    antlr4::tree::TerminalNode *ATTRIBUTES();
    Physical_attributes_clauseContext *physical_attributes_clause();
    antlr4::tree::TerminalNode *TABLESPACE();
    Logging_clauseContext *logging_clause();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();
    TablespaceContext *tablespace();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_index_default_attrsContext* modify_index_default_attrs();

  class  Add_hash_index_partitionContext : public antlr4::ParserRuleContext {
  public:
    Add_hash_index_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();
    antlr4::tree::TerminalNode *TABLESPACE();
    TablespaceContext *tablespace();
    Key_compressionContext *key_compression();
    Parallel_clauseContext *parallel_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_hash_index_partitionContext* add_hash_index_partition();

  class  Coalesce_index_partitionContext : public antlr4::ParserRuleContext {
  public:
    Coalesce_index_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COALESCE();
    antlr4::tree::TerminalNode *PARTITION();
    Parallel_clauseContext *parallel_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Coalesce_index_partitionContext* coalesce_index_partition();

  class  Modify_index_partitionContext : public antlr4::ParserRuleContext {
  public:
    Modify_index_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();
    antlr4::tree::TerminalNode *PARAMETERS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Odci_parametersContext *odci_parameters();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *COALESCE();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *BLOCK();
    antlr4::tree::TerminalNode *REFERENCES();
    antlr4::tree::TerminalNode *UNUSABLE();
    std::vector<Modify_index_partitions_opsContext *> modify_index_partitions_ops();
    Modify_index_partitions_opsContext* modify_index_partitions_ops(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_index_partitionContext* modify_index_partition();

  class  Modify_index_partitions_opsContext : public antlr4::ParserRuleContext {
  public:
    Modify_index_partitions_opsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Deallocate_unused_clauseContext *deallocate_unused_clause();
    Allocate_extent_clauseContext *allocate_extent_clause();
    Physical_attributes_clauseContext *physical_attributes_clause();
    Logging_clauseContext *logging_clause();
    Key_compressionContext *key_compression();
    Shrink_clauseContext *shrink_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_index_partitions_opsContext* modify_index_partitions_ops();

  class  Rename_index_partitionContext : public antlr4::ParserRuleContext {
  public:
    Rename_index_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *TO();
    New_partition_nameContext *new_partition_name();
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();
    antlr4::tree::TerminalNode *SUBPARTITION();
    Subpartition_nameContext *subpartition_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Rename_index_partitionContext* rename_index_partition();

  class  Drop_index_partitionContext : public antlr4::ParserRuleContext {
  public:
    Drop_index_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_index_partitionContext* drop_index_partition();

  class  Split_index_partitionContext : public antlr4::ParserRuleContext {
  public:
    Split_index_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SPLIT();
    antlr4::tree::TerminalNode *PARTITION();
    Partition_name_oldContext *partition_name_old();
    antlr4::tree::TerminalNode *AT();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<LiteralContext *> literal();
    LiteralContext* literal(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *INTO();
    std::vector<Index_partition_descriptionContext *> index_partition_description();
    Index_partition_descriptionContext* index_partition_description(size_t i);
    Parallel_clauseContext *parallel_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Split_index_partitionContext* split_index_partition();

  class  Index_partition_descriptionContext : public antlr4::ParserRuleContext {
  public:
    Index_partition_descriptionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();
    antlr4::tree::TerminalNode *PARAMETERS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Odci_parametersContext *odci_parameters();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *UNUSABLE();
    std::vector<Segment_attributes_clauseContext *> segment_attributes_clause();
    Segment_attributes_clauseContext* segment_attributes_clause(size_t i);
    std::vector<Key_compressionContext *> key_compression();
    Key_compressionContext* key_compression(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_partition_descriptionContext* index_partition_description();

  class  Modify_index_subpartitionContext : public antlr4::ParserRuleContext {
  public:
    Modify_index_subpartitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *SUBPARTITION();
    Subpartition_nameContext *subpartition_name();
    antlr4::tree::TerminalNode *UNUSABLE();
    Allocate_extent_clauseContext *allocate_extent_clause();
    Deallocate_unused_clauseContext *deallocate_unused_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_index_subpartitionContext* modify_index_subpartition();

  class  Partition_name_oldContext : public antlr4::ParserRuleContext {
  public:
    Partition_name_oldContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Partition_nameContext *partition_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partition_name_oldContext* partition_name_old();

  class  New_partition_nameContext : public antlr4::ParserRuleContext {
  public:
    New_partition_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Partition_nameContext *partition_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  New_partition_nameContext* new_partition_name();

  class  New_index_nameContext : public antlr4::ParserRuleContext {
  public:
    New_index_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Index_nameContext *index_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  New_index_nameContext* new_index_name();

  class  Alter_inmemory_join_groupContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *jg = nullptr;
    PlSqlParser::Id_expressionContext *t = nullptr;
    PlSqlParser::Id_expressionContext *c = nullptr;
    Alter_inmemory_join_groupContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *INMEMORY();
    antlr4::tree::TerminalNode *JOIN();
    antlr4::tree::TerminalNode *GROUP();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *REMOVE();
    std::vector<Schema_nameContext *> schema_name();
    Schema_nameContext* schema_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_inmemory_join_groupContext* alter_inmemory_join_group();

  class  Create_userContext : public antlr4::ParserRuleContext {
  public:
    Create_userContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *USER();
    User_object_nameContext *user_object_name();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *EXISTS();
    std::vector<Identified_byContext *> identified_by();
    Identified_byContext* identified_by(size_t i);
    std::vector<Identified_other_clauseContext *> identified_other_clause();
    Identified_other_clauseContext* identified_other_clause(size_t i);
    std::vector<User_tablespace_clauseContext *> user_tablespace_clause();
    User_tablespace_clauseContext* user_tablespace_clause(size_t i);
    std::vector<Quota_clauseContext *> quota_clause();
    Quota_clauseContext* quota_clause(size_t i);
    std::vector<Profile_clauseContext *> profile_clause();
    Profile_clauseContext* profile_clause(size_t i);
    std::vector<Password_expire_clauseContext *> password_expire_clause();
    Password_expire_clauseContext* password_expire_clause(size_t i);
    std::vector<User_lock_clauseContext *> user_lock_clause();
    User_lock_clauseContext* user_lock_clause(size_t i);
    std::vector<User_editions_clauseContext *> user_editions_clause();
    User_editions_clauseContext* user_editions_clause(size_t i);
    std::vector<Container_clauseContext *> container_clause();
    Container_clauseContext* container_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_userContext* create_user();

  class  Alter_userContext : public antlr4::ParserRuleContext {
  public:
    Alter_userContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *USER();
    std::vector<User_object_nameContext *> user_object_name();
    User_object_nameContext* user_object_name(size_t i);
    std::vector<Alter_identified_byContext *> alter_identified_by();
    Alter_identified_byContext* alter_identified_by(size_t i);
    std::vector<Identified_other_clauseContext *> identified_other_clause();
    Identified_other_clauseContext* identified_other_clause(size_t i);
    std::vector<User_tablespace_clauseContext *> user_tablespace_clause();
    User_tablespace_clauseContext* user_tablespace_clause(size_t i);
    std::vector<Quota_clauseContext *> quota_clause();
    Quota_clauseContext* quota_clause(size_t i);
    std::vector<Profile_clauseContext *> profile_clause();
    Profile_clauseContext* profile_clause(size_t i);
    std::vector<User_default_role_clauseContext *> user_default_role_clause();
    User_default_role_clauseContext* user_default_role_clause(size_t i);
    std::vector<Password_expire_clauseContext *> password_expire_clause();
    Password_expire_clauseContext* password_expire_clause(size_t i);
    std::vector<User_lock_clauseContext *> user_lock_clause();
    User_lock_clauseContext* user_lock_clause(size_t i);
    std::vector<Alter_user_editions_clauseContext *> alter_user_editions_clause();
    Alter_user_editions_clauseContext* alter_user_editions_clause(size_t i);
    std::vector<Container_clauseContext *> container_clause();
    Container_clauseContext* container_clause(size_t i);
    std::vector<Container_data_clauseContext *> container_data_clause();
    Container_data_clauseContext* container_data_clause(size_t i);
    Proxy_clauseContext *proxy_clause();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_userContext* alter_user();

  class  Drop_userContext : public antlr4::ParserRuleContext {
  public:
    Drop_userContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *USER();
    User_object_nameContext *user_object_name();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *EXISTS();
    antlr4::tree::TerminalNode *CASCADE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_userContext* drop_user();

  class  Alter_identified_byContext : public antlr4::ParserRuleContext {
  public:
    Alter_identified_byContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Identified_byContext *identified_by();
    antlr4::tree::TerminalNode *REPLACE();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_identified_byContext* alter_identified_by();

  class  Identified_byContext : public antlr4::ParserRuleContext {
  public:
    Identified_byContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IDENTIFIED();
    antlr4::tree::TerminalNode *BY();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Identified_byContext* identified_by();

  class  Identified_other_clauseContext : public antlr4::ParserRuleContext {
  public:
    Identified_other_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IDENTIFIED();
    antlr4::tree::TerminalNode *EXTERNALLY();
    antlr4::tree::TerminalNode *GLOBALLY();
    antlr4::tree::TerminalNode *AS();
    Quoted_stringContext *quoted_string();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Identified_other_clauseContext* identified_other_clause();

  class  User_tablespace_clauseContext : public antlr4::ParserRuleContext {
  public:
    User_tablespace_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLESPACE();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *TEMPORARY();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  User_tablespace_clauseContext* user_tablespace_clause();

  class  Quota_clauseContext : public antlr4::ParserRuleContext {
  public:
    Quota_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *QUOTA();
    antlr4::tree::TerminalNode *ON();
    Id_expressionContext *id_expression();
    Size_clauseContext *size_clause();
    antlr4::tree::TerminalNode *UNLIMITED();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Quota_clauseContext* quota_clause();

  class  Profile_clauseContext : public antlr4::ParserRuleContext {
  public:
    Profile_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PROFILE();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Profile_clauseContext* profile_clause();

  class  Role_clauseContext : public antlr4::ParserRuleContext {
  public:
    Role_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Role_nameContext *> role_name();
    Role_nameContext* role_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *ALL();
    std::vector<antlr4::tree::TerminalNode *> EXCEPT();
    antlr4::tree::TerminalNode* EXCEPT(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Role_clauseContext* role_clause();

  class  User_default_role_clauseContext : public antlr4::ParserRuleContext {
  public:
    User_default_role_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *ROLE();
    antlr4::tree::TerminalNode *NONE();
    Role_clauseContext *role_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  User_default_role_clauseContext* user_default_role_clause();

  class  Password_expire_clauseContext : public antlr4::ParserRuleContext {
  public:
    Password_expire_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PASSWORD();
    antlr4::tree::TerminalNode *EXPIRE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Password_expire_clauseContext* password_expire_clause();

  class  User_lock_clauseContext : public antlr4::ParserRuleContext {
  public:
    User_lock_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ACCOUNT();
    antlr4::tree::TerminalNode *LOCK();
    antlr4::tree::TerminalNode *UNLOCK();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  User_lock_clauseContext* user_lock_clause();

  class  User_editions_clauseContext : public antlr4::ParserRuleContext {
  public:
    User_editions_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *EDITIONS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  User_editions_clauseContext* user_editions_clause();

  class  Alter_user_editions_clauseContext : public antlr4::ParserRuleContext {
  public:
    Alter_user_editions_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    User_editions_clauseContext *user_editions_clause();
    antlr4::tree::TerminalNode *FOR();
    std::vector<Regular_idContext *> regular_id();
    Regular_idContext* regular_id(size_t i);
    antlr4::tree::TerminalNode *FORCE();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_user_editions_clauseContext* alter_user_editions_clause();

  class  Proxy_clauseContext : public antlr4::ParserRuleContext {
  public:
    Proxy_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REVOKE();
    antlr4::tree::TerminalNode *CONNECT();
    antlr4::tree::TerminalNode *THROUGH();
    antlr4::tree::TerminalNode *ENTERPRISE();
    antlr4::tree::TerminalNode *USERS();
    User_object_nameContext *user_object_name();
    antlr4::tree::TerminalNode *GRANT();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *AUTHENTICATION();
    antlr4::tree::TerminalNode *REQUIRED();
    antlr4::tree::TerminalNode *AUTHENTICATED();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *ROLES();
    antlr4::tree::TerminalNode *ROLE();
    Role_clauseContext *role_clause();
    antlr4::tree::TerminalNode *PASSWORD();
    antlr4::tree::TerminalNode *CERTIFICATE();
    antlr4::tree::TerminalNode *DISTINGUISHED();
    antlr4::tree::TerminalNode *NAME();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Proxy_clauseContext* proxy_clause();

  class  Container_namesContext : public antlr4::ParserRuleContext {
  public:
    Container_namesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Container_namesContext* container_names();

  class  Set_container_dataContext : public antlr4::ParserRuleContext {
  public:
    Set_container_dataContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *CONTAINER_DATA();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *DEFAULT();
    Container_namesContext *container_names();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Set_container_dataContext* set_container_data();

  class  Add_rem_container_dataContext : public antlr4::ParserRuleContext {
  public:
    Add_rem_container_dataContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONTAINER_DATA();
    antlr4::tree::TerminalNode *EQUALS_OP();
    Container_namesContext *container_names();
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *REMOVE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_rem_container_dataContext* add_rem_container_data();

  class  Container_data_clauseContext : public antlr4::ParserRuleContext {
  public:
    Container_data_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Set_container_dataContext *set_container_data();
    Add_rem_container_dataContext *add_rem_container_data();
    antlr4::tree::TerminalNode *FOR();
    Container_tableview_nameContext *container_tableview_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Container_data_clauseContext* container_data_clause();

  class  Administer_key_managementContext : public antlr4::ParserRuleContext {
  public:
    Administer_key_managementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADMINISTER();
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *MANAGEMENT();
    Keystore_management_clausesContext *keystore_management_clauses();
    Key_management_clausesContext *key_management_clauses();
    Secret_management_clausesContext *secret_management_clauses();
    Zero_downtime_software_patching_clausesContext *zero_downtime_software_patching_clauses();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Administer_key_managementContext* administer_key_management();

  class  Keystore_management_clausesContext : public antlr4::ParserRuleContext {
  public:
    Keystore_management_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Create_keystoreContext *create_keystore();
    Open_keystoreContext *open_keystore();
    Close_keystoreContext *close_keystore();
    Backup_keystoreContext *backup_keystore();
    Alter_keystore_passwordContext *alter_keystore_password();
    Merge_into_new_keystoreContext *merge_into_new_keystore();
    Merge_into_existing_keystoreContext *merge_into_existing_keystore();
    Isolate_keystoreContext *isolate_keystore();
    Unite_keystoreContext *unite_keystore();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Keystore_management_clausesContext* keystore_management_clauses();

  class  Create_keystoreContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *ksl = nullptr;
    Create_keystoreContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *IDENTIFIED();
    antlr4::tree::TerminalNode *BY();
    Keystore_passwordContext *keystore_password();
    std::vector<antlr4::tree::TerminalNode *> KEYSTORE();
    antlr4::tree::TerminalNode* KEYSTORE(size_t i);
    antlr4::tree::TerminalNode *AUTO_LOGIN();
    antlr4::tree::TerminalNode *FROM();
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *LOCAL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_keystoreContext* create_keystore();

  class  Open_keystoreContext : public antlr4::ParserRuleContext {
  public:
    Open_keystoreContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *KEYSTORE();
    antlr4::tree::TerminalNode *OPEN();
    Identified_by_storeContext *identified_by_store();
    Force_keystoreContext *force_keystore();
    Container_clauseContext *container_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Open_keystoreContext* open_keystore();

  class  Force_keystoreContext : public antlr4::ParserRuleContext {
  public:
    Force_keystoreContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *KEYSTORE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Force_keystoreContext* force_keystore();

  class  Close_keystoreContext : public antlr4::ParserRuleContext {
  public:
    Close_keystoreContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *KEYSTORE();
    antlr4::tree::TerminalNode *CLOSE();
    Identified_by_storeContext *identified_by_store();
    Container_clauseContext *container_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Close_keystoreContext* close_keystore();

  class  Backup_keystoreContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *bi = nullptr;
    antlr4::Token *ksl = nullptr;
    Backup_keystoreContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BACKUP();
    antlr4::tree::TerminalNode *KEYSTORE();
    Identified_by_storeContext *identified_by_store();
    antlr4::tree::TerminalNode *USING();
    Force_keystoreContext *force_keystore();
    antlr4::tree::TerminalNode *TO();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Backup_keystoreContext* backup_keystore();

  class  Alter_keystore_passwordContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Keystore_passwordContext *o = nullptr;
    PlSqlParser::Keystore_passwordContext *n = nullptr;
    Alter_keystore_passwordContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *KEYSTORE();
    antlr4::tree::TerminalNode *PASSWORD();
    antlr4::tree::TerminalNode *IDENTIFIED();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *SET();
    std::vector<Keystore_passwordContext *> keystore_password();
    Keystore_passwordContext* keystore_password(size_t i);
    Force_keystoreContext *force_keystore();
    With_backup_clauseContext *with_backup_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_keystore_passwordContext* alter_keystore_password();

  class  Merge_into_new_keystoreContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *ksl1 = nullptr;
    antlr4::Token *ksl2 = nullptr;
    Merge_into_new_keystoreContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MERGE();
    std::vector<antlr4::tree::TerminalNode *> KEYSTORE();
    antlr4::tree::TerminalNode* KEYSTORE(size_t i);
    antlr4::tree::TerminalNode *AND();
    antlr4::tree::TerminalNode *INTO();
    antlr4::tree::TerminalNode *NEW();
    std::vector<Identified_by_password_clauseContext *> identified_by_password_clause();
    Identified_by_password_clauseContext* identified_by_password_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Merge_into_new_keystoreContext* merge_into_new_keystore();

  class  Merge_into_existing_keystoreContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *ksl1 = nullptr;
    antlr4::Token *ksl2 = nullptr;
    Merge_into_existing_keystoreContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MERGE();
    std::vector<antlr4::tree::TerminalNode *> KEYSTORE();
    antlr4::tree::TerminalNode* KEYSTORE(size_t i);
    antlr4::tree::TerminalNode *INTO();
    antlr4::tree::TerminalNode *EXISTING();
    std::vector<Identified_by_password_clauseContext *> identified_by_password_clause();
    Identified_by_password_clauseContext* identified_by_password_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    With_backup_clauseContext *with_backup_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Merge_into_existing_keystoreContext* merge_into_existing_keystore();

  class  Isolate_keystoreContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Keystore_passwordContext *i = nullptr;
    Isolate_keystoreContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ISOLATE();
    std::vector<antlr4::tree::TerminalNode *> KEYSTORE();
    antlr4::tree::TerminalNode* KEYSTORE(size_t i);
    antlr4::tree::TerminalNode *IDENTIFIED();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *FROM();
    antlr4::tree::TerminalNode *ROOT();
    Identified_by_storeContext *identified_by_store();
    Keystore_passwordContext *keystore_password();
    antlr4::tree::TerminalNode *FORCE();
    Force_keystoreContext *force_keystore();
    With_backup_clauseContext *with_backup_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Isolate_keystoreContext* isolate_keystore();

  class  Unite_keystoreContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Keystore_passwordContext *i = nullptr;
    Unite_keystoreContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNITE();
    std::vector<antlr4::tree::TerminalNode *> KEYSTORE();
    antlr4::tree::TerminalNode* KEYSTORE(size_t i);
    antlr4::tree::TerminalNode *IDENTIFIED();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *ROOT();
    Identified_by_storeContext *identified_by_store();
    Keystore_passwordContext *keystore_password();
    Force_keystoreContext *force_keystore();
    With_backup_clauseContext *with_backup_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unite_keystoreContext* unite_keystore();

  class  Key_management_clausesContext : public antlr4::ParserRuleContext {
  public:
    Key_management_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Set_keyContext *set_key();
    Create_keyContext *create_key();
    Use_keyContext *use_key();
    Set_key_tagContext *set_key_tag();
    Export_keysContext *export_keys();
    Import_keysContext *import_keys();
    Migrate_keysContext *migrate_keys();
    Reverse_migrate_keysContext *reverse_migrate_keys();
    Move_keysContext *move_keys();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Key_management_clausesContext* key_management_clauses();

  class  Set_keyContext : public antlr4::ParserRuleContext {
  public:
    Set_keyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *KEY();
    Identified_by_storeContext *identified_by_store();
    antlr4::tree::TerminalNode *ENCRYPTION();
    MkContext *mk();
    Using_tag_clauseContext *using_tag_clause();
    Using_algorithm_clauseContext *using_algorithm_clause();
    Force_keystoreContext *force_keystore();
    With_backup_clauseContext *with_backup_clause();
    Container_clauseContext *container_clause();
    MkidContext *mkid();
    antlr4::tree::TerminalNode *COLON();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Set_keyContext* set_key();

  class  Create_keyContext : public antlr4::ParserRuleContext {
  public:
    Create_keyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *KEY();
    Identified_by_storeContext *identified_by_store();
    antlr4::tree::TerminalNode *ENCRYPTION();
    MkContext *mk();
    Using_tag_clauseContext *using_tag_clause();
    Using_algorithm_clauseContext *using_algorithm_clause();
    Force_keystoreContext *force_keystore();
    With_backup_clauseContext *with_backup_clause();
    Container_clauseContext *container_clause();
    MkidContext *mkid();
    antlr4::tree::TerminalNode *COLON();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_keyContext* create_key();

  class  MkidContext : public antlr4::ParserRuleContext {
  public:
    MkidContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  MkidContext* mkid();

  class  MkContext : public antlr4::ParserRuleContext {
  public:
    MkContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  MkContext* mk();

  class  Use_keyContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *k = nullptr;
    Use_keyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USE();
    antlr4::tree::TerminalNode *KEY();
    Identified_by_storeContext *identified_by_store();
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *ENCRYPTION();
    Using_tag_clauseContext *using_tag_clause();
    Force_keystoreContext *force_keystore();
    With_backup_clauseContext *with_backup_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Use_keyContext* use_key();

  class  Set_key_tagContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *t = nullptr;
    antlr4::Token *k = nullptr;
    Set_key_tagContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *TAG();
    antlr4::tree::TerminalNode *FOR();
    Identified_by_storeContext *identified_by_store();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    Force_keystoreContext *force_keystore();
    With_backup_clauseContext *with_backup_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Set_key_tagContext* set_key_tag();

  class  Export_keysContext : public antlr4::ParserRuleContext {
  public:
    Export_keysContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXPORT();
    antlr4::tree::TerminalNode *KEYS();
    std::vector<antlr4::tree::TerminalNode *> WITH();
    antlr4::tree::TerminalNode* WITH(size_t i);
    antlr4::tree::TerminalNode *SECRET();
    SecretContext *secret();
    antlr4::tree::TerminalNode *TO();
    FilenameContext *filename();
    Identified_by_storeContext *identified_by_store();
    antlr4::tree::TerminalNode *ENCRYPTION();
    Force_keystoreContext *force_keystore();
    antlr4::tree::TerminalNode *IDENTIFIER();
    antlr4::tree::TerminalNode *IN();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Export_keysContext* export_keys();

  class  Import_keysContext : public antlr4::ParserRuleContext {
  public:
    Import_keysContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IMPORT();
    antlr4::tree::TerminalNode *KEYS();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *SECRET();
    SecretContext *secret();
    antlr4::tree::TerminalNode *FROM();
    FilenameContext *filename();
    Identified_by_storeContext *identified_by_store();
    antlr4::tree::TerminalNode *ENCRYPTION();
    Force_keystoreContext *force_keystore();
    With_backup_clauseContext *with_backup_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Import_keysContext* import_keys();

  class  Migrate_keysContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::SecretContext *hsm = nullptr;
    Migrate_keysContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *IDENTIFIED();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *MIGRATE();
    antlr4::tree::TerminalNode *USING();
    Keystore_passwordContext *keystore_password();
    SecretContext *secret();
    antlr4::tree::TerminalNode *ENCRYPTION();
    Force_keystoreContext *force_keystore();
    With_backup_clauseContext *with_backup_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Migrate_keysContext* migrate_keys();

  class  Reverse_migrate_keysContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::SecretContext *s = nullptr;
    PlSqlParser::SecretContext *hsm = nullptr;
    Reverse_migrate_keysContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *IDENTIFIED();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *REVERSE();
    antlr4::tree::TerminalNode *MIGRATE();
    antlr4::tree::TerminalNode *USING();
    std::vector<SecretContext *> secret();
    SecretContext* secret(size_t i);
    antlr4::tree::TerminalNode *ENCRYPTION();
    Force_keystoreContext *force_keystore();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Reverse_migrate_keysContext* reverse_migrate_keys();

  class  Move_keysContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *ksl1 = nullptr;
    PlSqlParser::Keystore_passwordContext *ksp1 = nullptr;
    PlSqlParser::Keystore_passwordContext *ksp = nullptr;
    Move_keysContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MOVE();
    antlr4::tree::TerminalNode *KEYS();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *NEW();
    std::vector<antlr4::tree::TerminalNode *> KEYSTORE();
    antlr4::tree::TerminalNode* KEYSTORE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> IDENTIFIED();
    antlr4::tree::TerminalNode* IDENTIFIED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> BY();
    antlr4::tree::TerminalNode* BY(size_t i);
    antlr4::tree::TerminalNode *FROM();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    std::vector<Keystore_passwordContext *> keystore_password();
    Keystore_passwordContext* keystore_password(size_t i);
    antlr4::tree::TerminalNode *ENCRYPTION();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *IDENTIFIER();
    antlr4::tree::TerminalNode *IN();
    With_backup_clauseContext *with_backup_clause();
    SubqueryContext *subquery();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Move_keysContext* move_keys();

  class  Identified_by_storeContext : public antlr4::ParserRuleContext {
  public:
    Identified_by_storeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IDENTIFIED();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *EXTERNAL();
    antlr4::tree::TerminalNode *STORE();
    Keystore_passwordContext *keystore_password();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Identified_by_storeContext* identified_by_store();

  class  Using_algorithm_clauseContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *ea = nullptr;
    Using_algorithm_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *ALGORITHM();
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Using_algorithm_clauseContext* using_algorithm_clause();

  class  Using_tag_clauseContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *t = nullptr;
    Using_tag_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *TAG();
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Using_tag_clauseContext* using_tag_clause();

  class  Secret_management_clausesContext : public antlr4::ParserRuleContext {
  public:
    Secret_management_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Add_update_secretContext *add_update_secret();
    Delete_secretContext *delete_secret();
    Add_update_secret_sepsContext *add_update_secret_seps();
    Delete_secret_sepsContext *delete_secret_seps();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Secret_management_clausesContext* secret_management_clauses();

  class  Add_update_secretContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *s = nullptr;
    antlr4::Token *ci = nullptr;
    Add_update_secretContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SECRET();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *CLIENT();
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *UPDATE();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    Using_tag_clauseContext *using_tag_clause();
    Force_keystoreContext *force_keystore();
    Identified_by_storeContext *identified_by_store();
    With_backup_clauseContext *with_backup_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_update_secretContext* add_update_secret();

  class  Delete_secretContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *ci = nullptr;
    Delete_secretContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *SECRET();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *CLIENT();
    Identified_by_storeContext *identified_by_store();
    antlr4::tree::TerminalNode *CHAR_STRING();
    Force_keystoreContext *force_keystore();
    With_backup_clauseContext *with_backup_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Delete_secretContext* delete_secret();

  class  Add_update_secret_sepsContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *s = nullptr;
    antlr4::Token *ci = nullptr;
    Add_update_secret_sepsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SECRET();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *CLIENT();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *AUTO_LOGIN();
    antlr4::tree::TerminalNode *KEYSTORE();
    Directory_pathContext *directory_path();
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *UPDATE();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    Using_tag_clauseContext *using_tag_clause();
    antlr4::tree::TerminalNode *LOCAL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_update_secret_sepsContext* add_update_secret_seps();

  class  Delete_secret_sepsContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *s = nullptr;
    antlr4::Token *ci = nullptr;
    Delete_secret_sepsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *SECRET();
    antlr4::tree::TerminalNode *SQ();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *CLIENT();
    antlr4::tree::TerminalNode *FROM();
    antlr4::tree::TerminalNode *AUTO_LOGIN();
    antlr4::tree::TerminalNode *KEYSTORE();
    Directory_pathContext *directory_path();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    antlr4::tree::TerminalNode *LOCAL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Delete_secret_sepsContext* delete_secret_seps();

  class  Zero_downtime_software_patching_clausesContext : public antlr4::ParserRuleContext {
  public:
    Zero_downtime_software_patching_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SWITCHOVER();
    antlr4::tree::TerminalNode *LIBRARY();
    PathContext *path();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *CONTAINERS();
    antlr4::tree::TerminalNode *TO();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Zero_downtime_software_patching_clausesContext* zero_downtime_software_patching_clauses();

  class  With_backup_clauseContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *bi = nullptr;
    With_backup_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *BACKUP();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  With_backup_clauseContext* with_backup_clause();

  class  Identified_by_password_clauseContext : public antlr4::ParserRuleContext {
  public:
    Identified_by_password_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IDENTIFIED();
    antlr4::tree::TerminalNode *BY();
    Keystore_passwordContext *keystore_password();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Identified_by_password_clauseContext* identified_by_password_clause();

  class  Keystore_passwordContext : public antlr4::ParserRuleContext {
  public:
    Keystore_passwordContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DELIMITED_ID();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Keystore_passwordContext* keystore_password();

  class  PathContext : public antlr4::ParserRuleContext {
  public:
    PathContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  PathContext* path();

  class  SecretContext : public antlr4::ParserRuleContext {
  public:
    SecretContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DELIMITED_ID();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  SecretContext* secret();

  class  AnalyzeContext : public antlr4::ParserRuleContext {
  public:
    AnalyzeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ANALYZE();
    antlr4::tree::TerminalNode *CLUSTER();
    Cluster_nameContext *cluster_name();
    Validation_clausesContext *validation_clauses();
    Compute_clausesContext *compute_clauses();
    antlr4::tree::TerminalNode *ESTIMATE();
    antlr4::tree::TerminalNode *STATISTICS();
    antlr4::tree::TerminalNode *LIST();
    antlr4::tree::TerminalNode *CHAINED();
    antlr4::tree::TerminalNode *ROWS();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *TABLE();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *INDEX();
    Index_nameContext *index_name();
    Partition_extention_clauseContext *partition_extention_clause();
    antlr4::tree::TerminalNode *SYSTEM();
    For_clauseContext *for_clause();
    antlr4::tree::TerminalNode *SAMPLE();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    Into_clause1Context *into_clause1();
    antlr4::tree::TerminalNode *PERCENT_KEYWORD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  AnalyzeContext* analyze();

  class  Partition_extention_clauseContext : public antlr4::ParserRuleContext {
  public:
    Partition_extention_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Partition_nameContext *partition_name();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *FOR();
    std::vector<Partition_key_valueContext *> partition_key_value();
    Partition_key_valueContext* partition_key_value(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *SUBPARTITION();
    Subpartition_nameContext *subpartition_name();
    std::vector<Subpartition_key_valueContext *> subpartition_key_value();
    Subpartition_key_valueContext* subpartition_key_value(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partition_extention_clauseContext* partition_extention_clause();

  class  Validation_clausesContext : public antlr4::ParserRuleContext {
  public:
    Validation_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VALIDATE();
    antlr4::tree::TerminalNode *REF();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *DANGLING();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *STRUCTURE();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *FAST();
    std::vector<Online_or_offlineContext *> online_or_offline();
    Online_or_offlineContext* online_or_offline(size_t i);
    std::vector<Into_clauseContext *> into_clause();
    Into_clauseContext* into_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Validation_clausesContext* validation_clauses();

  class  Compute_clausesContext : public antlr4::ParserRuleContext {
  public:
    Compute_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COMPUTE();
    antlr4::tree::TerminalNode *STATISTICS();
    antlr4::tree::TerminalNode *SYSTEM();
    For_clauseContext *for_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Compute_clausesContext* compute_clauses();

  class  For_clauseContext : public antlr4::ParserRuleContext {
  public:
    For_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *COLUMNS();
    antlr4::tree::TerminalNode *INDEXES();
    std::vector<For_clauseContext *> for_clause();
    For_clauseContext* for_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SIZE();
    antlr4::tree::TerminalNode* SIZE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *INDEXED();
    antlr4::tree::TerminalNode *LOCAL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  For_clauseContext* for_clause();

  class  Online_or_offlineContext : public antlr4::ParserRuleContext {
  public:
    Online_or_offlineContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OFFLINE();
    antlr4::tree::TerminalNode *ONLINE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Online_or_offlineContext* online_or_offline();

  class  Into_clause1Context : public antlr4::ParserRuleContext {
  public:
    Into_clause1Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INTO();
    Tableview_nameContext *tableview_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Into_clause1Context* into_clause1();

  class  Partition_key_valueContext : public antlr4::ParserRuleContext {
  public:
    Partition_key_valueContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    LiteralContext *literal();
    antlr4::tree::TerminalNode *TIMESTAMP();
    Quoted_stringContext *quoted_string();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partition_key_valueContext* partition_key_value();

  class  Subpartition_key_valueContext : public antlr4::ParserRuleContext {
  public:
    Subpartition_key_valueContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    LiteralContext *literal();
    antlr4::tree::TerminalNode *TIMESTAMP();
    Quoted_stringContext *quoted_string();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subpartition_key_valueContext* subpartition_key_value();

  class  Associate_statisticsContext : public antlr4::ParserRuleContext {
  public:
    Associate_statisticsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ASSOCIATE();
    antlr4::tree::TerminalNode *STATISTICS();
    antlr4::tree::TerminalNode *WITH();
    Column_associationContext *column_association();
    Function_associationContext *function_association();
    Storage_table_clauseContext *storage_table_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Associate_statisticsContext* associate_statistics();

  class  Column_associationContext : public antlr4::ParserRuleContext {
  public:
    Column_associationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COLUMNS();
    std::vector<Tableview_nameContext *> tableview_name();
    Tableview_nameContext* tableview_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    Using_statistics_typeContext *using_statistics_type();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_associationContext* column_association();

  class  Function_associationContext : public antlr4::ParserRuleContext {
  public:
    Function_associationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FUNCTIONS();
    std::vector<Function_nameContext *> function_name();
    Function_nameContext* function_name(size_t i);
    antlr4::tree::TerminalNode *PACKAGES();
    std::vector<Package_nameContext *> package_name();
    Package_nameContext* package_name(size_t i);
    antlr4::tree::TerminalNode *TYPES();
    std::vector<Type_nameContext *> type_name();
    Type_nameContext* type_name(size_t i);
    antlr4::tree::TerminalNode *INDEXES();
    std::vector<Index_nameContext *> index_name();
    Index_nameContext* index_name(size_t i);
    antlr4::tree::TerminalNode *INDEXTYPES();
    std::vector<Indextype_nameContext *> indextype_name();
    Indextype_nameContext* indextype_name(size_t i);
    Using_statistics_typeContext *using_statistics_type();
    Default_cost_clauseContext *default_cost_clause();
    Default_selectivity_clauseContext *default_selectivity_clause();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Function_associationContext* function_association();

  class  Indextype_nameContext : public antlr4::ParserRuleContext {
  public:
    Indextype_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Indextype_nameContext* indextype_name();

  class  Using_statistics_typeContext : public antlr4::ParserRuleContext {
  public:
    Using_statistics_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    Statistics_type_nameContext *statistics_type_name();
    antlr4::tree::TerminalNode *NULL_();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Using_statistics_typeContext* using_statistics_type();

  class  Statistics_type_nameContext : public antlr4::ParserRuleContext {
  public:
    Statistics_type_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Statistics_type_nameContext* statistics_type_name();

  class  Default_cost_clauseContext : public antlr4::ParserRuleContext {
  public:
    Default_cost_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *COST();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Cpu_costContext *cpu_cost();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Io_costContext *io_cost();
    Network_costContext *network_cost();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Default_cost_clauseContext* default_cost_clause();

  class  Cpu_costContext : public antlr4::ParserRuleContext {
  public:
    Cpu_costContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cpu_costContext* cpu_cost();

  class  Io_costContext : public antlr4::ParserRuleContext {
  public:
    Io_costContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Io_costContext* io_cost();

  class  Network_costContext : public antlr4::ParserRuleContext {
  public:
    Network_costContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Network_costContext* network_cost();

  class  Default_selectivity_clauseContext : public antlr4::ParserRuleContext {
  public:
    Default_selectivity_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *SELECTIVITY();
    Default_selectivityContext *default_selectivity();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Default_selectivity_clauseContext* default_selectivity_clause();

  class  Default_selectivityContext : public antlr4::ParserRuleContext {
  public:
    Default_selectivityContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Default_selectivityContext* default_selectivity();

  class  Storage_table_clauseContext : public antlr4::ParserRuleContext {
  public:
    Storage_table_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *MANAGED();
    antlr4::tree::TerminalNode *STORAGE();
    antlr4::tree::TerminalNode *TABLES();
    antlr4::tree::TerminalNode *SYSTEM();
    antlr4::tree::TerminalNode *USER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Storage_table_clauseContext* storage_table_clause();

  class  Unified_auditingContext : public antlr4::ParserRuleContext {
  public:
    Unified_auditingContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AUDIT();
    antlr4::tree::TerminalNode *POLICY();
    Policy_nameContext *policy_name();
    antlr4::tree::TerminalNode *CONTEXT();
    antlr4::tree::TerminalNode *NAMESPACE();
    Oracle_namespaceContext *oracle_namespace();
    antlr4::tree::TerminalNode *ATTRIBUTES();
    std::vector<Attribute_nameContext *> attribute_name();
    Attribute_nameContext* attribute_name(size_t i);
    std::vector<Audit_userContext *> audit_user();
    Audit_userContext* audit_user(size_t i);
    antlr4::tree::TerminalNode *WHENEVER();
    antlr4::tree::TerminalNode *SUCCESSFUL();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *EXCEPT();
    antlr4::tree::TerminalNode *NOT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unified_auditingContext* unified_auditing();

  class  Policy_nameContext : public antlr4::ParserRuleContext {
  public:
    Policy_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Policy_nameContext* policy_name();

  class  Audit_traditionalContext : public antlr4::ParserRuleContext {
  public:
    Audit_traditionalContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AUDIT();
    Audit_operation_clauseContext *audit_operation_clause();
    Audit_schema_object_clauseContext *audit_schema_object_clause();
    antlr4::tree::TerminalNode *NETWORK();
    Audit_direct_pathContext *audit_direct_path();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *WHENEVER();
    antlr4::tree::TerminalNode *SUCCESSFUL();
    Audit_container_clauseContext *audit_container_clause();
    std::vector<antlr4::tree::TerminalNode *> SESSION();
    antlr4::tree::TerminalNode* SESSION(size_t i);
    antlr4::tree::TerminalNode *ACCESS();
    Auditing_by_clauseContext *auditing_by_clause();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *CURRENT();
    antlr4::tree::TerminalNode *NOT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Audit_traditionalContext* audit_traditional();

  class  Audit_direct_pathContext : public antlr4::ParserRuleContext {
  public:
    Audit_direct_pathContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DIRECT_PATH();
    Auditing_by_clauseContext *auditing_by_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Audit_direct_pathContext* audit_direct_path();

  class  Audit_container_clauseContext : public antlr4::ParserRuleContext {
  public:
    Audit_container_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONTAINER();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *CURRENT();
    antlr4::tree::TerminalNode *ALL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Audit_container_clauseContext* audit_container_clause();

  class  Audit_operation_clauseContext : public antlr4::ParserRuleContext {
  public:
    Audit_operation_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Sql_statement_shortcutContext *> sql_statement_shortcut();
    Sql_statement_shortcutContext* sql_statement_shortcut(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ALL();
    antlr4::tree::TerminalNode* ALL(size_t i);
    std::vector<System_privilegeContext *> system_privilege();
    System_privilegeContext* system_privilege(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PRIVILEGES();
    antlr4::tree::TerminalNode* PRIVILEGES(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<antlr4::tree::TerminalNode *> STATEMENTS();
    antlr4::tree::TerminalNode* STATEMENTS(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Audit_operation_clauseContext* audit_operation_clause();

  class  Auditing_by_clauseContext : public antlr4::ParserRuleContext {
  public:
    Auditing_by_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BY();
    std::vector<Audit_userContext *> audit_user();
    Audit_userContext* audit_user(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Auditing_by_clauseContext* auditing_by_clause();

  class  Audit_userContext : public antlr4::ParserRuleContext {
  public:
    Audit_userContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Audit_userContext* audit_user();

  class  Audit_schema_object_clauseContext : public antlr4::ParserRuleContext {
  public:
    Audit_schema_object_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Auditing_on_clauseContext *auditing_on_clause();
    std::vector<Sql_operationContext *> sql_operation();
    Sql_operationContext* sql_operation(size_t i);
    antlr4::tree::TerminalNode *ALL();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Audit_schema_object_clauseContext* audit_schema_object_clause();

  class  Sql_operationContext : public antlr4::ParserRuleContext {
  public:
    Sql_operationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *AUDIT();
    antlr4::tree::TerminalNode *COMMENT();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *EXECUTE();
    antlr4::tree::TerminalNode *FLASHBACK();
    antlr4::tree::TerminalNode *GRANT();
    antlr4::tree::TerminalNode *INDEX();
    antlr4::tree::TerminalNode *INSERT();
    antlr4::tree::TerminalNode *LOCK();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *SELECT();
    antlr4::tree::TerminalNode *UPDATE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sql_operationContext* sql_operation();

  class  Auditing_on_clauseContext : public antlr4::ParserRuleContext {
  public:
    Auditing_on_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ON();
    Object_nameContext *object_name();
    antlr4::tree::TerminalNode *DIRECTORY();
    Regular_idContext *regular_id();
    antlr4::tree::TerminalNode *MINING();
    antlr4::tree::TerminalNode *MODEL();
    Model_nameContext *model_name();
    antlr4::tree::TerminalNode *SQL();
    antlr4::tree::TerminalNode *TRANSLATION();
    antlr4::tree::TerminalNode *PROFILE();
    Profile_nameContext *profile_name();
    antlr4::tree::TerminalNode *DEFAULT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Auditing_on_clauseContext* auditing_on_clause();

  class  Model_nameContext : public antlr4::ParserRuleContext {
  public:
    Model_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_nameContext* model_name();

  class  Object_nameContext : public antlr4::ParserRuleContext {
  public:
    Object_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_nameContext* object_name();

  class  Profile_nameContext : public antlr4::ParserRuleContext {
  public:
    Profile_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Profile_nameContext* profile_name();

  class  Sql_statement_shortcutContext : public antlr4::ParserRuleContext {
  public:
    Sql_statement_shortcutContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *SYSTEM();
    antlr4::tree::TerminalNode *CLUSTER();
    antlr4::tree::TerminalNode *CONTEXT();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *LINK();
    antlr4::tree::TerminalNode *DIMENSION();
    antlr4::tree::TerminalNode *DIRECTORY();
    antlr4::tree::TerminalNode *INDEX();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *VIEW();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *EXISTS();
    antlr4::tree::TerminalNode *OUTLINE();
    antlr4::tree::TerminalNode *PLUGGABLE();
    antlr4::tree::TerminalNode *PROCEDURE();
    antlr4::tree::TerminalNode *PROFILE();
    antlr4::tree::TerminalNode *PUBLIC();
    antlr4::tree::TerminalNode *SYNONYM();
    antlr4::tree::TerminalNode *ROLE();
    antlr4::tree::TerminalNode *ROLLBACK();
    antlr4::tree::TerminalNode *SEGMENT();
    antlr4::tree::TerminalNode *SEQUENCE();
    antlr4::tree::TerminalNode *SESSION();
    antlr4::tree::TerminalNode *AUDIT();
    antlr4::tree::TerminalNode *GRANT();
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *TABLESPACE();
    antlr4::tree::TerminalNode *TRIGGER();
    antlr4::tree::TerminalNode *TYPE();
    antlr4::tree::TerminalNode *USER();
    antlr4::tree::TerminalNode *COMMENT();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *EXECUTE();
    antlr4::tree::TerminalNode *INSERT();
    antlr4::tree::TerminalNode *LOCK();
    antlr4::tree::TerminalNode *SELECT();
    antlr4::tree::TerminalNode *UPDATE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sql_statement_shortcutContext* sql_statement_shortcut();

  class  Drop_indexContext : public antlr4::ParserRuleContext {
  public:
    Drop_indexContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *INDEX();
    Index_nameContext *index_name();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *EXISTS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_indexContext* drop_index();

  class  Disassociate_statisticsContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *tb = nullptr;
    PlSqlParser::Id_expressionContext *c = nullptr;
    PlSqlParser::Id_expressionContext *fn = nullptr;
    PlSqlParser::Id_expressionContext *pkg = nullptr;
    PlSqlParser::Id_expressionContext *t = nullptr;
    PlSqlParser::Id_expressionContext *ix = nullptr;
    PlSqlParser::Id_expressionContext *it = nullptr;
    Disassociate_statisticsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DISASSOCIATE();
    antlr4::tree::TerminalNode *STATISTICS();
    antlr4::tree::TerminalNode *FROM();
    antlr4::tree::TerminalNode *COLUMNS();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    antlr4::tree::TerminalNode *FUNCTIONS();
    antlr4::tree::TerminalNode *PACKAGES();
    antlr4::tree::TerminalNode *TYPES();
    antlr4::tree::TerminalNode *INDEXES();
    antlr4::tree::TerminalNode *INDEXTYPES();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *FORCE();
    std::vector<Schema_nameContext *> schema_name();
    Schema_nameContext* schema_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Disassociate_statisticsContext* disassociate_statistics();

  class  Drop_indextypeContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *it = nullptr;
    Drop_indextypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *INDEXTYPE();
    Id_expressionContext *id_expression();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *FORCE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_indextypeContext* drop_indextype();

  class  Drop_inmemory_join_groupContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *jg = nullptr;
    Drop_inmemory_join_groupContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *INMEMORY();
    antlr4::tree::TerminalNode *JOIN();
    antlr4::tree::TerminalNode *GROUP();
    Id_expressionContext *id_expression();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_inmemory_join_groupContext* drop_inmemory_join_group();

  class  Flashback_tableContext : public antlr4::ParserRuleContext {
  public:
    Flashback_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FLASHBACK();
    antlr4::tree::TerminalNode *TABLE();
    std::vector<Tableview_nameContext *> tableview_name();
    Tableview_nameContext* tableview_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TO();
    antlr4::tree::TerminalNode* TO(size_t i);
    antlr4::tree::TerminalNode *BEFORE();
    antlr4::tree::TerminalNode *DROP();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RESTORE();
    antlr4::tree::TerminalNode *POINT();
    Restore_pointContext *restore_point();
    antlr4::tree::TerminalNode *SCN();
    antlr4::tree::TerminalNode *TIMESTAMP();
    antlr4::tree::TerminalNode *TRIGGERS();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *DISABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Flashback_tableContext* flashback_table();

  class  Restore_pointContext : public antlr4::ParserRuleContext {
  public:
    Restore_pointContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Restore_pointContext* restore_point();

  class  Purge_statementContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *ts = nullptr;
    PlSqlParser::Id_expressionContext *u = nullptr;
    Purge_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PURGE();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *TABLESPACE();
    antlr4::tree::TerminalNode *RECYCLEBIN();
    antlr4::tree::TerminalNode *DBA_RECYCLEBIN();
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *INDEX();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *USER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Purge_statementContext* purge_statement();

  class  Noaudit_statementContext : public antlr4::ParserRuleContext {
  public:
    Noaudit_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NOAUDIT();
    Audit_operation_clauseContext *audit_operation_clause();
    Audit_schema_object_clauseContext *audit_schema_object_clause();
    antlr4::tree::TerminalNode *NETWORK();
    antlr4::tree::TerminalNode *DIRECT_PATH();
    antlr4::tree::TerminalNode *LOAD();
    antlr4::tree::TerminalNode *WHENEVER();
    antlr4::tree::TerminalNode *SUCCESSFUL();
    Container_clauseContext *container_clause();
    Auditing_by_clauseContext *auditing_by_clause();
    antlr4::tree::TerminalNode *NOT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Noaudit_statementContext* noaudit_statement();

  class  Rename_objectContext : public antlr4::ParserRuleContext {
  public:
    Rename_objectContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RENAME();
    std::vector<Object_nameContext *> object_name();
    Object_nameContext* object_name(size_t i);
    antlr4::tree::TerminalNode *TO();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Rename_objectContext* rename_object();

  class  Grant_statementContext : public antlr4::ParserRuleContext {
  public:
    Grant_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> GRANT();
    antlr4::tree::TerminalNode* GRANT(size_t i);
    antlr4::tree::TerminalNode *TO();
    std::vector<Grantee_nameContext *> grantee_name();
    Grantee_nameContext* grantee_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PUBLIC();
    antlr4::tree::TerminalNode* PUBLIC(size_t i);
    antlr4::tree::TerminalNode *ON();
    Grant_object_nameContext *grant_object_name();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<antlr4::tree::TerminalNode *> WITH();
    antlr4::tree::TerminalNode* WITH(size_t i);
    std::vector<antlr4::tree::TerminalNode *> OPTION();
    antlr4::tree::TerminalNode* OPTION(size_t i);
    antlr4::tree::TerminalNode *HIERARCHY();
    Container_clauseContext *container_clause();
    antlr4::tree::TerminalNode *ADMIN();
    antlr4::tree::TerminalNode *DELEGATE();
    std::vector<Role_nameContext *> role_name();
    Role_nameContext* role_name(size_t i);
    std::vector<System_privilegeContext *> system_privilege();
    System_privilegeContext* system_privilege(size_t i);
    std::vector<Object_privilegeContext *> object_privilege();
    Object_privilegeContext* object_privilege(size_t i);
    std::vector<Paren_column_listContext *> paren_column_list();
    Paren_column_listContext* paren_column_list(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Grant_statementContext* grant_statement();

  class  Container_clauseContext : public antlr4::ParserRuleContext {
  public:
    Container_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONTAINER();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *CURRENT();
    antlr4::tree::TerminalNode *ALL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Container_clauseContext* container_clause();

  class  Revoke_statementContext : public antlr4::ParserRuleContext {
  public:
    Revoke_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REVOKE();
    Revoke_roles_from_programsContext *revoke_roles_from_programs();
    Revoke_system_privilegeContext *revoke_system_privilege();
    Revoke_object_privilegesContext *revoke_object_privileges();
    Container_clauseContext *container_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Revoke_statementContext* revoke_statement();

  class  Revoke_system_privilegeContext : public antlr4::ParserRuleContext {
  public:
    Revoke_system_privilegeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FROM();
    Revokee_clauseContext *revokee_clause();
    System_privilegeContext *system_privilege();
    Role_nameContext *role_name();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *PRIVILEGES();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Revoke_system_privilegeContext* revoke_system_privilege();

  class  Revokee_clauseContext : public antlr4::ParserRuleContext {
  public:
    Revokee_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PUBLIC();
    antlr4::tree::TerminalNode* PUBLIC(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Revokee_clauseContext* revokee_clause();

  class  Revoke_object_privilegesContext : public antlr4::ParserRuleContext {
  public:
    Revoke_object_privilegesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    On_object_clauseContext *on_object_clause();
    antlr4::tree::TerminalNode *FROM();
    Revokee_clauseContext *revokee_clause();
    std::vector<Object_privilegeContext *> object_privilege();
    Object_privilegeContext* object_privilege(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ALL();
    antlr4::tree::TerminalNode* ALL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *CONSTRAINTS();
    antlr4::tree::TerminalNode *FORCE();
    std::vector<antlr4::tree::TerminalNode *> PRIVILEGES();
    antlr4::tree::TerminalNode* PRIVILEGES(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Revoke_object_privilegesContext* revoke_object_privileges();

  class  On_object_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *o = nullptr;
    PlSqlParser::Id_expressionContext *mmn = nullptr;
    PlSqlParser::Id_expressionContext *o2 = nullptr;
    PlSqlParser::Id_expressionContext *p = nullptr;
    On_object_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *USER();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *DIRECTORY();
    Directory_nameContext *directory_name();
    antlr4::tree::TerminalNode *EDITION();
    Edition_nameContext *edition_name();
    antlr4::tree::TerminalNode *MINING();
    antlr4::tree::TerminalNode *MODEL();
    antlr4::tree::TerminalNode *JAVA();
    antlr4::tree::TerminalNode *SQL();
    antlr4::tree::TerminalNode *TRANSLATION();
    antlr4::tree::TerminalNode *PROFILE();
    antlr4::tree::TerminalNode *SOURCE();
    antlr4::tree::TerminalNode *RESOURCE();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  On_object_clauseContext* on_object_clause();

  class  Revoke_roles_from_programsContext : public antlr4::ParserRuleContext {
  public:
    Revoke_roles_from_programsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FROM();
    std::vector<Program_unitContext *> program_unit();
    Program_unitContext* program_unit(size_t i);
    std::vector<Role_nameContext *> role_name();
    Role_nameContext* role_name(size_t i);
    antlr4::tree::TerminalNode *ALL();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Revoke_roles_from_programsContext* revoke_roles_from_programs();

  class  Program_unitContext : public antlr4::ParserRuleContext {
  public:
    Program_unitContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *FUNCTION();
    antlr4::tree::TerminalNode *PROCEDURE();
    antlr4::tree::TerminalNode *PACKAGE();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Program_unitContext* program_unit();

  class  Create_dimensionContext : public antlr4::ParserRuleContext {
  public:
    Create_dimensionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *DIMENSION();
    IdentifierContext *identifier();
    std::vector<Level_clauseContext *> level_clause();
    Level_clauseContext* level_clause(size_t i);
    std::vector<Hierarchy_clauseContext *> hierarchy_clause();
    Hierarchy_clauseContext* hierarchy_clause(size_t i);
    std::vector<Attribute_clauseContext *> attribute_clause();
    Attribute_clauseContext* attribute_clause(size_t i);
    std::vector<Extended_attribute_clauseContext *> extended_attribute_clause();
    Extended_attribute_clauseContext* extended_attribute_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_dimensionContext* create_dimension();

  class  Create_directoryContext : public antlr4::ParserRuleContext {
  public:
    Create_directoryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *DIRECTORY();
    Directory_nameContext *directory_name();
    antlr4::tree::TerminalNode *AS();
    Directory_pathContext *directory_path();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *SHARING();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *METADATA();
    antlr4::tree::TerminalNode *NONE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_directoryContext* create_directory();

  class  Directory_nameContext : public antlr4::ParserRuleContext {
  public:
    Directory_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Directory_nameContext* directory_name();

  class  Directory_pathContext : public antlr4::ParserRuleContext {
  public:
    Directory_pathContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Directory_pathContext* directory_path();

  class  Create_inmemory_join_groupContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *jg = nullptr;
    PlSqlParser::Id_expressionContext *t = nullptr;
    PlSqlParser::Id_expressionContext *c = nullptr;
    Create_inmemory_join_groupContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *INMEMORY();
    antlr4::tree::TerminalNode *JOIN();
    antlr4::tree::TerminalNode *GROUP();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<Schema_nameContext *> schema_name();
    Schema_nameContext* schema_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_inmemory_join_groupContext* create_inmemory_join_group();

  class  Drop_hierarchyContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *hn = nullptr;
    Drop_hierarchyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *HIERARCHY();
    Id_expressionContext *id_expression();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_hierarchyContext* drop_hierarchy();

  class  Alter_libraryContext : public antlr4::ParserRuleContext {
  public:
    Alter_libraryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *LIBRARY();
    Library_nameContext *library_name();
    antlr4::tree::TerminalNode *COMPILE();
    Library_editionableContext *library_editionable();
    Library_debugContext *library_debug();
    std::vector<Compiler_parameters_clauseContext *> compiler_parameters_clause();
    Compiler_parameters_clauseContext* compiler_parameters_clause(size_t i);
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *SETTINGS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_libraryContext* alter_library();

  class  Drop_javaContext : public antlr4::ParserRuleContext {
  public:
    Drop_javaContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *JAVA();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *SOURCE();
    antlr4::tree::TerminalNode *CLASS();
    antlr4::tree::TerminalNode *RESOURCE();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_javaContext* drop_java();

  class  Drop_libraryContext : public antlr4::ParserRuleContext {
  public:
    Drop_libraryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *LIBRARY();
    Library_nameContext *library_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_libraryContext* drop_library();

  class  Create_javaContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *pn = nullptr;
    PlSqlParser::Id_expressionContext *sn = nullptr;
    PlSqlParser::Id_expressionContext *d = nullptr;
    Create_javaContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *JAVA();
    antlr4::tree::TerminalNode *NAMED();
    antlr4::tree::TerminalNode *CLASS();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *AS();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *AND();
    antlr4::tree::TerminalNode *NOFORCE();
    antlr4::tree::TerminalNode *SOURCE();
    antlr4::tree::TerminalNode *RESOURCE();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *SHARING();
    antlr4::tree::TerminalNode *EQUALS_OP();
    Invoker_rights_clauseContext *invoker_rights_clause();
    antlr4::tree::TerminalNode *RESOLVER();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *RESOLVE();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *METADATA();
    antlr4::tree::TerminalNode *NONE();
    antlr4::tree::TerminalNode *BFILE();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    FilenameContext *filename();
    SubqueryContext *subquery();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *SCHEMA();
    antlr4::tree::TerminalNode *CLOB();
    antlr4::tree::TerminalNode *BLOB();
    std::vector<antlr4::tree::TerminalNode *> MINUS_SIGN();
    antlr4::tree::TerminalNode* MINUS_SIGN(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_javaContext* create_java();

  class  Create_libraryContext : public antlr4::ParserRuleContext {
  public:
    Create_libraryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *LIBRARY();
    Plsql_library_sourceContext *plsql_library_source();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *EDITIONABLE();
    antlr4::tree::TerminalNode *NONEDITIONABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_libraryContext* create_library();

  class  Plsql_library_sourceContext : public antlr4::ParserRuleContext {
  public:
    Plsql_library_sourceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Library_nameContext *library_name();
    std::vector<Quoted_stringContext *> quoted_string();
    Quoted_stringContext* quoted_string(size_t i);
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *IN();
    Directory_nameContext *directory_name();
    antlr4::tree::TerminalNode *AGENT();
    antlr4::tree::TerminalNode *CREDENTIAL();
    Credential_nameContext *credential_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Plsql_library_sourceContext* plsql_library_source();

  class  Credential_nameContext : public antlr4::ParserRuleContext {
  public:
    Credential_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Credential_nameContext* credential_name();

  class  Library_editionableContext : public antlr4::ParserRuleContext {
  public:
    Library_editionableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EDITIONABLE();
    antlr4::tree::TerminalNode *NONEDITIONABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Library_editionableContext* library_editionable();

  class  Library_debugContext : public antlr4::ParserRuleContext {
  public:
    Library_debugContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEBUG();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Library_debugContext* library_debug();

  class  Compiler_parameters_clauseContext : public antlr4::ParserRuleContext {
  public:
    Compiler_parameters_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Parameter_nameContext *parameter_name();
    antlr4::tree::TerminalNode *EQUALS_OP();
    Parameter_valueContext *parameter_value();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Compiler_parameters_clauseContext* compiler_parameters_clause();

  class  Parameter_valueContext : public antlr4::ParserRuleContext {
  public:
    Parameter_valueContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Parameter_valueContext* parameter_value();

  class  Library_nameContext : public antlr4::ParserRuleContext {
  public:
    Library_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Regular_idContext *> regular_id();
    Regular_idContext* regular_id(size_t i);
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Library_nameContext* library_name();

  class  Alter_dimensionContext : public antlr4::ParserRuleContext {
  public:
    Alter_dimensionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *DIMENSION();
    std::vector<IdentifierContext *> identifier();
    IdentifierContext* identifier(size_t i);
    antlr4::tree::TerminalNode *COMPILE();
    std::vector<antlr4::tree::TerminalNode *> ADD();
    antlr4::tree::TerminalNode* ADD(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DROP();
    antlr4::tree::TerminalNode* DROP(size_t i);
    std::vector<Level_clauseContext *> level_clause();
    Level_clauseContext* level_clause(size_t i);
    std::vector<Hierarchy_clauseContext *> hierarchy_clause();
    Hierarchy_clauseContext* hierarchy_clause(size_t i);
    std::vector<Attribute_clauseContext *> attribute_clause();
    Attribute_clauseContext* attribute_clause(size_t i);
    std::vector<Extended_attribute_clauseContext *> extended_attribute_clause();
    Extended_attribute_clauseContext* extended_attribute_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LEVEL();
    antlr4::tree::TerminalNode* LEVEL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> HIERARCHY();
    antlr4::tree::TerminalNode* HIERARCHY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ATTRIBUTE();
    antlr4::tree::TerminalNode* ATTRIBUTE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RESTRICT();
    antlr4::tree::TerminalNode* RESTRICT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CASCADE();
    antlr4::tree::TerminalNode* CASCADE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COLUMN();
    antlr4::tree::TerminalNode* COLUMN(size_t i);
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_dimensionContext* alter_dimension();

  class  Level_clauseContext : public antlr4::ParserRuleContext {
  public:
    Level_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEVEL();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *IS();
    std::vector<Table_nameContext *> table_name();
    Table_nameContext* table_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *SKIP_();
    antlr4::tree::TerminalNode *WHEN();
    antlr4::tree::TerminalNode *NULL_();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Level_clauseContext* level_clause();

  class  Hierarchy_clauseContext : public antlr4::ParserRuleContext {
  public:
    Hierarchy_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *HIERARCHY();
    std::vector<IdentifierContext *> identifier();
    IdentifierContext* identifier(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> CHILD();
    antlr4::tree::TerminalNode* CHILD(size_t i);
    std::vector<antlr4::tree::TerminalNode *> OF();
    antlr4::tree::TerminalNode* OF(size_t i);
    Dimension_join_clauseContext *dimension_join_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hierarchy_clauseContext* hierarchy_clause();

  class  Dimension_join_clauseContext : public antlr4::ParserRuleContext {
  public:
    Dimension_join_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> JOIN();
    antlr4::tree::TerminalNode* JOIN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> KEY();
    antlr4::tree::TerminalNode* KEY(size_t i);
    std::vector<Column_one_or_more_sub_clauseContext *> column_one_or_more_sub_clause();
    Column_one_or_more_sub_clauseContext* column_one_or_more_sub_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> REFERENCES();
    antlr4::tree::TerminalNode* REFERENCES(size_t i);
    std::vector<IdentifierContext *> identifier();
    IdentifierContext* identifier(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dimension_join_clauseContext* dimension_join_clause();

  class  Attribute_clauseContext : public antlr4::ParserRuleContext {
  public:
    Attribute_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> ATTRIBUTE();
    antlr4::tree::TerminalNode* ATTRIBUTE(size_t i);
    std::vector<IdentifierContext *> identifier();
    IdentifierContext* identifier(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DETERMINES();
    antlr4::tree::TerminalNode* DETERMINES(size_t i);
    std::vector<Column_one_or_more_sub_clauseContext *> column_one_or_more_sub_clause();
    Column_one_or_more_sub_clauseContext* column_one_or_more_sub_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Attribute_clauseContext* attribute_clause();

  class  Extended_attribute_clauseContext : public antlr4::ParserRuleContext {
  public:
    Extended_attribute_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ATTRIBUTE();
    std::vector<IdentifierContext *> identifier();
    IdentifierContext* identifier(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LEVEL();
    antlr4::tree::TerminalNode* LEVEL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DETERMINES();
    antlr4::tree::TerminalNode* DETERMINES(size_t i);
    std::vector<Column_one_or_more_sub_clauseContext *> column_one_or_more_sub_clause();
    Column_one_or_more_sub_clauseContext* column_one_or_more_sub_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Extended_attribute_clauseContext* extended_attribute_clause();

  class  Column_one_or_more_sub_clauseContext : public antlr4::ParserRuleContext {
  public:
    Column_one_or_more_sub_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_one_or_more_sub_clauseContext* column_one_or_more_sub_clause();

  class  Alter_viewContext : public antlr4::ParserRuleContext {
  public:
    Alter_viewContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *VIEW();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *ADD();
    Out_of_line_constraintContext *out_of_line_constraint();
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *RELY();
    antlr4::tree::TerminalNode *NORELY();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *WRITE();
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Alter_view_editionableContext *alter_view_editionable();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_viewContext* alter_view();

  class  Alter_view_editionableContext : public antlr4::ParserRuleContext {
  public:
    Alter_view_editionableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EDITIONABLE();
    antlr4::tree::TerminalNode *NONEDITIONABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_view_editionableContext* alter_view_editionable();

  class  Create_viewContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *v = nullptr;
    PlSqlParser::Id_expressionContext *cn = nullptr;
    Create_viewContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *VIEW();
    antlr4::tree::TerminalNode *AS();
    Select_only_statementContext *select_only_statement();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *FORCE();
    Editioning_clauseContext *editioning_clause();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *EXISTS();
    antlr4::tree::TerminalNode *SHARING();
    antlr4::tree::TerminalNode *EQUALS_OP();
    View_optionsContext *view_options();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *COLLATION();
    antlr4::tree::TerminalNode *BEQUEATH();
    Subquery_restriction_clauseContext *subquery_restriction_clause();
    antlr4::tree::TerminalNode *CURRENT_USER();
    antlr4::tree::TerminalNode *DEFINER();
    antlr4::tree::TerminalNode *CONTAINER_MAP();
    antlr4::tree::TerminalNode *CONTAINERS_DEFAULT();
    antlr4::tree::TerminalNode *METADATA();
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *NONE();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *EXTENDED();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_viewContext* create_view();

  class  Editioning_clauseContext : public antlr4::ParserRuleContext {
  public:
    Editioning_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EDITIONING();
    antlr4::tree::TerminalNode *EDITIONABLE();
    antlr4::tree::TerminalNode *NONEDITIONABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Editioning_clauseContext* editioning_clause();

  class  View_optionsContext : public antlr4::ParserRuleContext {
  public:
    View_optionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    View_alias_constraintContext *view_alias_constraint();
    Object_view_clauseContext *object_view_clause();
    Xmltype_view_clauseContext *xmltype_view_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  View_optionsContext* view_options();

  class  View_alias_constraintContext : public antlr4::ParserRuleContext {
  public:
    View_alias_constraintContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Table_aliasContext *> table_alias();
    Table_aliasContext* table_alias(size_t i);
    std::vector<Out_of_line_constraintContext *> out_of_line_constraint();
    Out_of_line_constraintContext* out_of_line_constraint(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Inline_constraintContext *> inline_constraint();
    Inline_constraintContext* inline_constraint(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  View_alias_constraintContext* view_alias_constraint();

  class  Object_view_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *tn = nullptr;
    PlSqlParser::Id_expressionContext *sv = nullptr;
    Object_view_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OF();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *OBJECT();
    antlr4::tree::TerminalNode *UNDER();
    std::vector<Schema_nameContext *> schema_name();
    Schema_nameContext* schema_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    antlr4::tree::TerminalNode *IDENTIFIER();
    antlr4::tree::TerminalNode *ID();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *DEFAULT();
    std::vector<antlr4::tree::TerminalNode *> REGULAR_ID();
    antlr4::tree::TerminalNode* REGULAR_ID(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Out_of_line_constraintContext *> out_of_line_constraint();
    Out_of_line_constraintContext* out_of_line_constraint(size_t i);
    std::vector<Inline_constraintContext *> inline_constraint();
    Inline_constraintContext* inline_constraint(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_view_clauseContext* object_view_clause();

  class  Inline_constraintContext : public antlr4::ParserRuleContext {
  public:
    Inline_constraintContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *KEY();
    References_clauseContext *references_clause();
    Check_constraintContext *check_constraint();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();
    Constraint_stateContext *constraint_state();
    antlr4::tree::TerminalNode *NOT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Inline_constraintContext* inline_constraint();

  class  Inline_ref_constraintContext : public antlr4::ParserRuleContext {
  public:
    Inline_ref_constraintContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SCOPE();
    antlr4::tree::TerminalNode *IS();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *ROWID();
    References_clauseContext *references_clause();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();
    Constraint_stateContext *constraint_state();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Inline_ref_constraintContext* inline_ref_constraint();

  class  Out_of_line_ref_constraintContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Regular_idContext *ref_col_or_attr = nullptr;
    Out_of_line_ref_constraintContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SCOPE();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *IS();
    Tableview_nameContext *tableview_name();
    std::vector<Regular_idContext *> regular_id();
    Regular_idContext* regular_id(size_t i);
    antlr4::tree::TerminalNode *REF();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *ROWID();
    antlr4::tree::TerminalNode *FOREIGN();
    antlr4::tree::TerminalNode *KEY();
    References_clauseContext *references_clause();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();
    Constraint_stateContext *constraint_state();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Out_of_line_ref_constraintContext* out_of_line_ref_constraint();

  class  Out_of_line_constraintContext : public antlr4::ParserRuleContext {
  public:
    Out_of_line_constraintContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Constraint_stateContext *constraint_state();
    Parallel_clauseContext *parallel_clause();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *KEY();
    Foreign_key_clauseContext *foreign_key_clause();
    antlr4::tree::TerminalNode *CHECK();
    ConditionContext *condition();
    Constraint_nameContext *constraint_name();
    antlr4::tree::TerminalNode *CONSTRAINT();
    antlr4::tree::TerminalNode *CONSTRAINTS();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Out_of_line_constraintContext* out_of_line_constraint();

  class  Constraint_stateContext : public antlr4::ParserRuleContext {
  public:
    Constraint_stateContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> DEFERRABLE();
    antlr4::tree::TerminalNode* DEFERRABLE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> INITIALLY();
    antlr4::tree::TerminalNode* INITIALLY(size_t i);
    std::vector<Using_index_clauseContext *> using_index_clause();
    Using_index_clauseContext* using_index_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> IMMEDIATE();
    antlr4::tree::TerminalNode* IMMEDIATE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DEFERRED();
    antlr4::tree::TerminalNode* DEFERRED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RELY();
    antlr4::tree::TerminalNode* RELY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NORELY();
    antlr4::tree::TerminalNode* NORELY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ENABLE();
    antlr4::tree::TerminalNode* ENABLE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DISABLE();
    antlr4::tree::TerminalNode* DISABLE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> VALIDATE();
    antlr4::tree::TerminalNode* VALIDATE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NOVALIDATE();
    antlr4::tree::TerminalNode* NOVALIDATE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NOT();
    antlr4::tree::TerminalNode* NOT(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Constraint_stateContext* constraint_state();

  class  Xmltype_view_clauseContext : public antlr4::ParserRuleContext {
  public:
    Xmltype_view_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OF();
    antlr4::tree::TerminalNode *XMLTYPE();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *OBJECT();
    antlr4::tree::TerminalNode *IDENTIFIER();
    antlr4::tree::TerminalNode *ID();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Xml_schema_specContext *xml_schema_spec();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmltype_view_clauseContext* xmltype_view_clause();

  class  Xml_schema_specContext : public antlr4::ParserRuleContext {
  public:
    Xml_schema_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ELEMENT();
    ElementContext *element();
    std::vector<Xml_schema_urlContext *> xml_schema_url();
    Xml_schema_urlContext* xml_schema_url(size_t i);
    antlr4::tree::TerminalNode *HASH_OP();
    antlr4::tree::TerminalNode *XMLSCHEMA();
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *VARRAYS();
    antlr4::tree::TerminalNode *AS();
    std::vector<Allow_or_disallowContext *> allow_or_disallow();
    Allow_or_disallowContext* allow_or_disallow(size_t i);
    antlr4::tree::TerminalNode *NONSCHEMA();
    antlr4::tree::TerminalNode *ANYSCHEMA();
    antlr4::tree::TerminalNode *LOBS();
    antlr4::tree::TerminalNode *TABLES();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_schema_specContext* xml_schema_spec();

  class  Xml_schema_urlContext : public antlr4::ParserRuleContext {
  public:
    Xml_schema_urlContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DELIMITED_ID();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_schema_urlContext* xml_schema_url();

  class  ElementContext : public antlr4::ParserRuleContext {
  public:
    ElementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DELIMITED_ID();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ElementContext* element();

  class  Alter_tablespaceContext : public antlr4::ParserRuleContext {
  public:
    Alter_tablespaceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *TABLESPACE();
    TablespaceContext *tablespace();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *MINIMUM();
    antlr4::tree::TerminalNode *EXTENT();
    Size_clauseContext *size_clause();
    antlr4::tree::TerminalNode *RESIZE();
    antlr4::tree::TerminalNode *COALESCE();
    antlr4::tree::TerminalNode *SHRINK();
    antlr4::tree::TerminalNode *SPACE_KEYWORD();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *TO();
    New_tablespace_nameContext *new_tablespace_name();
    Begin_or_endContext *begin_or_end();
    antlr4::tree::TerminalNode *BACKUP();
    Datafile_tempfile_clausesContext *datafile_tempfile_clauses();
    Tablespace_logging_clausesContext *tablespace_logging_clauses();
    Tablespace_group_clauseContext *tablespace_group_clause();
    Tablespace_state_clausesContext *tablespace_state_clauses();
    Autoextend_clauseContext *autoextend_clause();
    Flashback_mode_clauseContext *flashback_mode_clause();
    Tablespace_retention_clauseContext *tablespace_retention_clause();
    Table_compressionContext *table_compression();
    Storage_clauseContext *storage_clause();
    antlr4::tree::TerminalNode *KEEP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_tablespaceContext* alter_tablespace();

  class  Datafile_tempfile_clausesContext : public antlr4::ParserRuleContext {
  public:
    Datafile_tempfile_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    Datafile_specificationContext *datafile_specification();
    Tempfile_specificationContext *tempfile_specification();
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *DATAFILE();
    antlr4::tree::TerminalNode *TEMPFILE();
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *KEEP();
    Size_clauseContext *size_clause();
    antlr4::tree::TerminalNode *SHRINK();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *TO();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Online_or_offlineContext *online_or_offline();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Datafile_tempfile_clausesContext* datafile_tempfile_clauses();

  class  Tablespace_logging_clausesContext : public antlr4::ParserRuleContext {
  public:
    Tablespace_logging_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Logging_clauseContext *logging_clause();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *LOGGING();
    antlr4::tree::TerminalNode *NO();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tablespace_logging_clausesContext* tablespace_logging_clauses();

  class  Tablespace_group_clauseContext : public antlr4::ParserRuleContext {
  public:
    Tablespace_group_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLESPACE();
    antlr4::tree::TerminalNode *GROUP();
    Tablespace_group_nameContext *tablespace_group_name();
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tablespace_group_clauseContext* tablespace_group_clause();

  class  Tablespace_group_nameContext : public antlr4::ParserRuleContext {
  public:
    Tablespace_group_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tablespace_group_nameContext* tablespace_group_name();

  class  Tablespace_state_clausesContext : public antlr4::ParserRuleContext {
  public:
    Tablespace_state_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ONLINE();
    antlr4::tree::TerminalNode *OFFLINE();
    antlr4::tree::TerminalNode *NORMAL();
    antlr4::tree::TerminalNode *TEMPORARY();
    antlr4::tree::TerminalNode *IMMEDIATE();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *WRITE();
    antlr4::tree::TerminalNode *PERMANENT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tablespace_state_clausesContext* tablespace_state_clauses();

  class  Flashback_mode_clauseContext : public antlr4::ParserRuleContext {
  public:
    Flashback_mode_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FLASHBACK();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *OFF();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Flashback_mode_clauseContext* flashback_mode_clause();

  class  New_tablespace_nameContext : public antlr4::ParserRuleContext {
  public:
    New_tablespace_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    TablespaceContext *tablespace();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  New_tablespace_nameContext* new_tablespace_name();

  class  Create_tablespaceContext : public antlr4::ParserRuleContext {
  public:
    Create_tablespaceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    Permanent_tablespace_clauseContext *permanent_tablespace_clause();
    Temporary_tablespace_clauseContext *temporary_tablespace_clause();
    Undo_tablespace_clauseContext *undo_tablespace_clause();
    antlr4::tree::TerminalNode *BIGFILE();
    antlr4::tree::TerminalNode *SMALLFILE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_tablespaceContext* create_tablespace();

  class  Permanent_tablespace_clauseContext : public antlr4::ParserRuleContext {
  public:
    Permanent_tablespace_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLESPACE();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *EXISTS();
    Datafile_specificationContext *datafile_specification();
    std::vector<antlr4::tree::TerminalNode *> MINIMUM();
    antlr4::tree::TerminalNode* MINIMUM(size_t i);
    std::vector<antlr4::tree::TerminalNode *> EXTENT();
    antlr4::tree::TerminalNode* EXTENT(size_t i);
    std::vector<Size_clauseContext *> size_clause();
    Size_clauseContext* size_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> BLOCKSIZE();
    antlr4::tree::TerminalNode* BLOCKSIZE(size_t i);
    std::vector<Logging_clauseContext *> logging_clause();
    Logging_clauseContext* logging_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FORCE();
    antlr4::tree::TerminalNode* FORCE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LOGGING();
    antlr4::tree::TerminalNode* LOGGING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ENCRYPTION();
    antlr4::tree::TerminalNode* ENCRYPTION(size_t i);
    std::vector<Tablespace_encryption_specContext *> tablespace_encryption_spec();
    Tablespace_encryption_specContext* tablespace_encryption_spec(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DEFAULT();
    antlr4::tree::TerminalNode* DEFAULT(size_t i);
    std::vector<Extent_management_clauseContext *> extent_management_clause();
    Extent_management_clauseContext* extent_management_clause(size_t i);
    std::vector<Segment_management_clauseContext *> segment_management_clause();
    Segment_management_clauseContext* segment_management_clause(size_t i);
    std::vector<Flashback_mode_clauseContext *> flashback_mode_clause();
    Flashback_mode_clauseContext* flashback_mode_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ONLINE();
    antlr4::tree::TerminalNode* ONLINE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> OFFLINE();
    antlr4::tree::TerminalNode* OFFLINE(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Permanent_tablespace_clauseContext* permanent_tablespace_clause();

  class  Tablespace_encryption_specContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *encrypt_algorithm = nullptr;
    Tablespace_encryption_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tablespace_encryption_specContext* tablespace_encryption_spec();

  class  Logging_clauseContext : public antlr4::ParserRuleContext {
  public:
    Logging_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOGGING();
    antlr4::tree::TerminalNode *NOLOGGING();
    antlr4::tree::TerminalNode *FILESYSTEM_LIKE_LOGGING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Logging_clauseContext* logging_clause();

  class  Extent_management_clauseContext : public antlr4::ParserRuleContext {
  public:
    Extent_management_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXTENT();
    antlr4::tree::TerminalNode *MANAGEMENT();
    antlr4::tree::TerminalNode *LOCAL();
    antlr4::tree::TerminalNode *AUTOALLOCATE();
    antlr4::tree::TerminalNode *UNIFORM();
    antlr4::tree::TerminalNode *SIZE();
    Size_clauseContext *size_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Extent_management_clauseContext* extent_management_clause();

  class  Segment_management_clauseContext : public antlr4::ParserRuleContext {
  public:
    Segment_management_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SEGMENT();
    antlr4::tree::TerminalNode *SPACE_KEYWORD();
    antlr4::tree::TerminalNode *MANAGEMENT();
    antlr4::tree::TerminalNode *AUTO();
    antlr4::tree::TerminalNode *MANUAL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Segment_management_clauseContext* segment_management_clause();

  class  Temporary_tablespace_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *tablespace_name = nullptr;
    Temporary_tablespace_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TEMPORARY();
    antlr4::tree::TerminalNode *TABLESPACE();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *EXISTS();
    Tempfile_specificationContext *tempfile_specification();
    Tablespace_group_clauseContext *tablespace_group_clause();
    Extent_management_clauseContext *extent_management_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Temporary_tablespace_clauseContext* temporary_tablespace_clause();

  class  Undo_tablespace_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *tablespace_name = nullptr;
    Undo_tablespace_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNDO();
    antlr4::tree::TerminalNode *TABLESPACE();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *EXISTS();
    Datafile_specificationContext *datafile_specification();
    Extent_management_clauseContext *extent_management_clause();
    Tablespace_retention_clauseContext *tablespace_retention_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Undo_tablespace_clauseContext* undo_tablespace_clause();

  class  Tablespace_retention_clauseContext : public antlr4::ParserRuleContext {
  public:
    Tablespace_retention_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RETENTION();
    antlr4::tree::TerminalNode *GUARANTEE();
    antlr4::tree::TerminalNode *NOGUARANTEE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tablespace_retention_clauseContext* tablespace_retention_clause();

  class  Create_tablespace_setContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *tss = nullptr;
    PlSqlParser::Id_expressionContext *ss = nullptr;
    Create_tablespace_setContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *TABLESPACE();
    antlr4::tree::TerminalNode *SET();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *SHARDSPACE();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *TEMPLATE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *DATAFILE();
    std::vector<File_specificationContext *> file_specification();
    File_specificationContext* file_specification(size_t i);
    std::vector<Permanent_tablespace_attrsContext *> permanent_tablespace_attrs();
    Permanent_tablespace_attrsContext* permanent_tablespace_attrs(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_tablespace_setContext* create_tablespace_set();

  class  Permanent_tablespace_attrsContext : public antlr4::ParserRuleContext {
  public:
    Permanent_tablespace_attrsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MINIMUM();
    antlr4::tree::TerminalNode *EXTENT();
    Size_clauseContext *size_clause();
    antlr4::tree::TerminalNode *BLOCKSIZE();
    NumericContext *numeric();
    antlr4::tree::TerminalNode *K_LETTER();
    Logging_clauseContext *logging_clause();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *LOGGING();
    Tablespace_encryption_clauseContext *tablespace_encryption_clause();
    Default_tablespace_paramsContext *default_tablespace_params();
    antlr4::tree::TerminalNode *ONLINE();
    antlr4::tree::TerminalNode *OFFLINE();
    Extent_management_clauseContext *extent_management_clause();
    Segment_management_clauseContext *segment_management_clause();
    Flashback_mode_clauseContext *flashback_mode_clause();
    Lost_write_protectionContext *lost_write_protection();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Permanent_tablespace_attrsContext* permanent_tablespace_attrs();

  class  Tablespace_encryption_clauseContext : public antlr4::ParserRuleContext {
  public:
    Tablespace_encryption_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ENCRYPTION();
    antlr4::tree::TerminalNode *ENCRYPT();
    antlr4::tree::TerminalNode *DECRYPT();
    Tablespace_encryption_specContext *tablespace_encryption_spec();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tablespace_encryption_clauseContext* tablespace_encryption_clause();

  class  Default_tablespace_paramsContext : public antlr4::ParserRuleContext {
  public:
    Default_tablespace_paramsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEFAULT();
    Default_table_compressionContext *default_table_compression();
    Default_index_compressionContext *default_index_compression();
    Inmmemory_clauseContext *inmmemory_clause();
    Ilm_clauseContext *ilm_clause();
    Storage_clauseContext *storage_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Default_tablespace_paramsContext* default_tablespace_params();

  class  Default_table_compressionContext : public antlr4::ParserRuleContext {
  public:
    Default_table_compressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *COMPRESS();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *NOCOMPRESS();
    antlr4::tree::TerminalNode *OLTP();
    antlr4::tree::TerminalNode *QUERY();
    Low_highContext *low_high();
    antlr4::tree::TerminalNode *ARCHIVE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Default_table_compressionContext* default_table_compression();

  class  Low_highContext : public antlr4::ParserRuleContext {
  public:
    Low_highContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOW();
    antlr4::tree::TerminalNode *HIGH();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Low_highContext* low_high();

  class  Default_index_compressionContext : public antlr4::ParserRuleContext {
  public:
    Default_index_compressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INDEX();
    antlr4::tree::TerminalNode *COMPRESS();
    antlr4::tree::TerminalNode *ADVANCED();
    Low_highContext *low_high();
    antlr4::tree::TerminalNode *NOCOMPRESS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Default_index_compressionContext* default_index_compression();

  class  Inmmemory_clauseContext : public antlr4::ParserRuleContext {
  public:
    Inmmemory_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INMEMORY();
    Inmemory_attributesContext *inmemory_attributes();
    antlr4::tree::TerminalNode *TEXT();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> USING();
    antlr4::tree::TerminalNode* USING(size_t i);
    std::vector<Policy_nameContext *> policy_name();
    Policy_nameContext* policy_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *NO();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Inmmemory_clauseContext* inmmemory_clause();

  class  Datafile_specificationContext : public antlr4::ParserRuleContext {
  public:
    Datafile_specificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DATAFILE();
    Datafile_tempfile_specContext *datafile_tempfile_spec();
    antlr4::tree::TerminalNode *COMMA();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Datafile_specificationContext* datafile_specification();

  class  Tempfile_specificationContext : public antlr4::ParserRuleContext {
  public:
    Tempfile_specificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TEMPFILE();
    Datafile_tempfile_specContext *datafile_tempfile_spec();
    antlr4::tree::TerminalNode *COMMA();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tempfile_specificationContext* tempfile_specification();

  class  Datafile_tempfile_specContext : public antlr4::ParserRuleContext {
  public:
    Datafile_tempfile_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *SIZE();
    Size_clauseContext *size_clause();
    antlr4::tree::TerminalNode *REUSE();
    Autoextend_clauseContext *autoextend_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Datafile_tempfile_specContext* datafile_tempfile_spec();

  class  Redo_log_file_specContext : public antlr4::ParserRuleContext {
  public:
    Redo_log_file_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *SIZE();
    std::vector<Size_clauseContext *> size_clause();
    Size_clauseContext* size_clause(size_t i);
    antlr4::tree::TerminalNode *BLOCKSIZE();
    antlr4::tree::TerminalNode *REUSE();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Redo_log_file_specContext* redo_log_file_spec();

  class  Autoextend_clauseContext : public antlr4::ParserRuleContext {
  public:
    Autoextend_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AUTOEXTEND();
    antlr4::tree::TerminalNode *OFF();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *NEXT();
    Size_clauseContext *size_clause();
    Maxsize_clauseContext *maxsize_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Autoextend_clauseContext* autoextend_clause();

  class  Maxsize_clauseContext : public antlr4::ParserRuleContext {
  public:
    Maxsize_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MAXSIZE();
    antlr4::tree::TerminalNode *UNLIMITED();
    Size_clauseContext *size_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Maxsize_clauseContext* maxsize_clause();

  class  Build_clauseContext : public antlr4::ParserRuleContext {
  public:
    Build_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BUILD();
    antlr4::tree::TerminalNode *IMMEDIATE();
    antlr4::tree::TerminalNode *DEFERRED();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Build_clauseContext* build_clause();

  class  Parallel_clauseContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *parallel_count = nullptr;
    Parallel_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NOPARALLEL();
    antlr4::tree::TerminalNode *PARALLEL();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *DEGREE();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    Parallel_instances_clauseContext *parallel_instances_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Parallel_clauseContext* parallel_clause();

  class  Parallel_instances_clauseContext : public antlr4::ParserRuleContext {
  public:
    Parallel_instances_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INSTANCES();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *DEFAULT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Parallel_instances_clauseContext* parallel_instances_clause();

  class  Alter_materialized_viewContext : public antlr4::ParserRuleContext {
  public:
    Alter_materialized_viewContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *VIEW();
    Tableview_nameContext *tableview_name();
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    Modify_mv_column_clauseContext *modify_mv_column_clause();
    Table_compressionContext *table_compression();
    std::vector<Lob_storage_clauseContext *> lob_storage_clause();
    Lob_storage_clauseContext* lob_storage_clause(size_t i);
    std::vector<Modify_lob_storage_clauseContext *> modify_lob_storage_clause();
    Modify_lob_storage_clauseContext* modify_lob_storage_clause(size_t i);
    Parallel_clauseContext *parallel_clause();
    Logging_clauseContext *logging_clause();
    Allocate_extent_clauseContext *allocate_extent_clause();
    Deallocate_unused_clauseContext *deallocate_unused_clause();
    Shrink_clauseContext *shrink_clause();
    Alter_iot_clausesContext *alter_iot_clauses();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *INDEX();
    Alter_mv_option1Context *alter_mv_option1();
    Enable_or_disableContext *enable_or_disable();
    antlr4::tree::TerminalNode *QUERY();
    antlr4::tree::TerminalNode *REWRITE();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *CONSIDER();
    antlr4::tree::TerminalNode *FRESH();
    Cache_or_nocacheContext *cache_or_nocache();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_materialized_viewContext* alter_materialized_view();

  class  Alter_mv_option1Context : public antlr4::ParserRuleContext {
  public:
    Alter_mv_option1Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Alter_mv_refreshContext *alter_mv_refresh();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_mv_option1Context* alter_mv_option1();

  class  Alter_mv_refreshContext : public antlr4::ParserRuleContext {
  public:
    Alter_mv_refreshContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REFRESH();
    std::vector<antlr4::tree::TerminalNode *> FAST();
    antlr4::tree::TerminalNode* FAST(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMPLETE();
    antlr4::tree::TerminalNode* COMPLETE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FORCE();
    antlr4::tree::TerminalNode* FORCE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ON();
    antlr4::tree::TerminalNode* ON(size_t i);
    std::vector<antlr4::tree::TerminalNode *> START();
    antlr4::tree::TerminalNode* START(size_t i);
    std::vector<antlr4::tree::TerminalNode *> WITH();
    antlr4::tree::TerminalNode* WITH(size_t i);
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NEXT();
    antlr4::tree::TerminalNode* NEXT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PRIMARY();
    antlr4::tree::TerminalNode* PRIMARY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> KEY();
    antlr4::tree::TerminalNode* KEY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> USING();
    antlr4::tree::TerminalNode* USING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MASTER();
    antlr4::tree::TerminalNode* MASTER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ROLLBACK();
    antlr4::tree::TerminalNode* ROLLBACK(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SEGMENT();
    antlr4::tree::TerminalNode* SEGMENT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CONSTRAINTS();
    antlr4::tree::TerminalNode* CONSTRAINTS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DEMAND();
    antlr4::tree::TerminalNode* DEMAND(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMIT();
    antlr4::tree::TerminalNode* COMMIT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ENFORCED();
    antlr4::tree::TerminalNode* ENFORCED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TRUSTED();
    antlr4::tree::TerminalNode* TRUSTED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DEFAULT();
    antlr4::tree::TerminalNode* DEFAULT(size_t i);
    std::vector<Rollback_segmentContext *> rollback_segment();
    Rollback_segmentContext* rollback_segment(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_mv_refreshContext* alter_mv_refresh();

  class  Rollback_segmentContext : public antlr4::ParserRuleContext {
  public:
    Rollback_segmentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Rollback_segmentContext* rollback_segment();

  class  Modify_mv_column_clauseContext : public antlr4::ParserRuleContext {
  public:
    Modify_mv_column_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *ENCRYPT();
    Encryption_specContext *encryption_spec();
    antlr4::tree::TerminalNode *DECRYPT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_mv_column_clauseContext* modify_mv_column_clause();

  class  Alter_materialized_view_logContext : public antlr4::ParserRuleContext {
  public:
    Alter_materialized_view_logContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *VIEW();
    antlr4::tree::TerminalNode *LOG();
    antlr4::tree::TerminalNode *ON();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *FORCE();
    Physical_attributes_clauseContext *physical_attributes_clause();
    Add_mv_log_column_clauseContext *add_mv_log_column_clause();
    Parallel_clauseContext *parallel_clause();
    Logging_clauseContext *logging_clause();
    Allocate_extent_clauseContext *allocate_extent_clause();
    Shrink_clauseContext *shrink_clause();
    Move_mv_log_clauseContext *move_mv_log_clause();
    Cache_or_nocacheContext *cache_or_nocache();
    Mv_log_augmentationContext *mv_log_augmentation();
    Mv_log_purge_clauseContext *mv_log_purge_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_materialized_view_logContext* alter_materialized_view_log();

  class  Add_mv_log_column_clauseContext : public antlr4::ParserRuleContext {
  public:
    Add_mv_log_column_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_mv_log_column_clauseContext* add_mv_log_column_clause();

  class  Move_mv_log_clauseContext : public antlr4::ParserRuleContext {
  public:
    Move_mv_log_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MOVE();
    Segment_attributes_clauseContext *segment_attributes_clause();
    Parallel_clauseContext *parallel_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Move_mv_log_clauseContext* move_mv_log_clause();

  class  Mv_log_augmentationContext : public antlr4::ParserRuleContext {
  public:
    Mv_log_augmentationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    New_values_clauseContext *new_values_clause();
    antlr4::tree::TerminalNode *OBJECT();
    antlr4::tree::TerminalNode *ID();
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *ROWID();
    antlr4::tree::TerminalNode *SEQUENCE();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Mv_log_augmentationContext* mv_log_augmentation();

  class  Create_materialized_view_logContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *tablespace_name = nullptr;
    Create_materialized_view_logContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *VIEW();
    antlr4::tree::TerminalNode *LOG();
    antlr4::tree::TerminalNode *ON();
    Tableview_nameContext *tableview_name();
    Parallel_clauseContext *parallel_clause();
    std::vector<antlr4::tree::TerminalNode *> WITH();
    antlr4::tree::TerminalNode* WITH(size_t i);
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<Logging_clauseContext *> logging_clause();
    Logging_clauseContext* logging_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<Mv_log_purge_clauseContext *> mv_log_purge_clause();
    Mv_log_purge_clauseContext* mv_log_purge_clause(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CACHE();
    antlr4::tree::TerminalNode* CACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NOCACHE();
    antlr4::tree::TerminalNode* NOCACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> OBJECT();
    antlr4::tree::TerminalNode* OBJECT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ID();
    antlr4::tree::TerminalNode* ID(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PRIMARY();
    antlr4::tree::TerminalNode* PRIMARY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> KEY();
    antlr4::tree::TerminalNode* KEY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ROWID();
    antlr4::tree::TerminalNode* ROWID(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SEQUENCE();
    antlr4::tree::TerminalNode* SEQUENCE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMIT();
    antlr4::tree::TerminalNode* COMMIT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SCN();
    antlr4::tree::TerminalNode* SCN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Regular_idContext *> regular_id();
    Regular_idContext* regular_id(size_t i);
    std::vector<New_values_clauseContext *> new_values_clause();
    New_values_clauseContext* new_values_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_materialized_view_logContext* create_materialized_view_log();

  class  New_values_clauseContext : public antlr4::ParserRuleContext {
  public:
    New_values_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NEW();
    antlr4::tree::TerminalNode *VALUES();
    antlr4::tree::TerminalNode *INCLUDING();
    antlr4::tree::TerminalNode *EXCLUDING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  New_values_clauseContext* new_values_clause();

  class  Mv_log_purge_clauseContext : public antlr4::ParserRuleContext {
  public:
    Mv_log_purge_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PURGE();
    antlr4::tree::TerminalNode *IMMEDIATE();
    antlr4::tree::TerminalNode *SYNCHRONOUS();
    antlr4::tree::TerminalNode *ASYNCHRONOUS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Mv_log_purge_clauseContext* mv_log_purge_clause();

  class  Create_materialized_zonemapContext : public antlr4::ParserRuleContext {
  public:
    Create_materialized_zonemapContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *ZONEMAP();
    Zonemap_nameContext *zonemap_name();
    Create_zonemap_on_tableContext *create_zonemap_on_table();
    Create_zonemap_as_subqueryContext *create_zonemap_as_subquery();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Column_listContext *column_list();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Zonemap_attributesContext *zonemap_attributes();
    Zonemap_refresh_clauseContext *zonemap_refresh_clause();
    antlr4::tree::TerminalNode *PRUNING();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *DISABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_materialized_zonemapContext* create_materialized_zonemap();

  class  Alter_materialized_zonemapContext : public antlr4::ParserRuleContext {
  public:
    Alter_materialized_zonemapContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *ZONEMAP();
    Zonemap_nameContext *zonemap_name();
    Zonemap_attributesContext *zonemap_attributes();
    Zonemap_refresh_clauseContext *zonemap_refresh_clause();
    antlr4::tree::TerminalNode *PRUNING();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *REBUILD();
    antlr4::tree::TerminalNode *UNUSABLE();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *DISABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_materialized_zonemapContext* alter_materialized_zonemap();

  class  Drop_materialized_zonemapContext : public antlr4::ParserRuleContext {
  public:
    Drop_materialized_zonemapContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *ZONEMAP();
    Zonemap_nameContext *zonemap_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_materialized_zonemapContext* drop_materialized_zonemap();

  class  Zonemap_refresh_clauseContext : public antlr4::ParserRuleContext {
  public:
    Zonemap_refresh_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REFRESH();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *FAST();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *DEMAND();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *LOAD();
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *MOVEMENT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Zonemap_refresh_clauseContext* zonemap_refresh_clause();

  class  Zonemap_attributesContext : public antlr4::ParserRuleContext {
  public:
    Zonemap_attributesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> PCTFREE();
    antlr4::tree::TerminalNode* PCTFREE(size_t i);
    std::vector<NumericContext *> numeric();
    NumericContext* numeric(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PCTUSED();
    antlr4::tree::TerminalNode* PCTUSED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SCALE();
    antlr4::tree::TerminalNode* SCALE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CACHE();
    antlr4::tree::TerminalNode* CACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NOCACHE();
    antlr4::tree::TerminalNode* NOCACHE(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Zonemap_attributesContext* zonemap_attributes();

  class  Zonemap_nameContext : public antlr4::ParserRuleContext {
  public:
    Zonemap_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *PERIOD();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Zonemap_nameContext* zonemap_name();

  class  Operator_nameContext : public antlr4::ParserRuleContext {
  public:
    Operator_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *PERIOD();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Operator_nameContext* operator_name();

  class  Operator_function_nameContext : public antlr4::ParserRuleContext {
  public:
    Operator_function_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Operator_function_nameContext* operator_function_name();

  class  Create_zonemap_on_tableContext : public antlr4::ParserRuleContext {
  public:
    Create_zonemap_on_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ON();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Column_listContext *column_list();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_zonemap_on_tableContext* create_zonemap_on_table();

  class  Create_zonemap_as_subqueryContext : public antlr4::ParserRuleContext {
  public:
    Create_zonemap_as_subqueryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AS();
    SubqueryContext *subquery();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_zonemap_as_subqueryContext* create_zonemap_as_subquery();

  class  Alter_operatorContext : public antlr4::ParserRuleContext {
  public:
    Alter_operatorContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *OPERATOR();
    Operator_nameContext *operator_name();
    Add_binding_clauseContext *add_binding_clause();
    Drop_binding_clauseContext *drop_binding_clause();
    antlr4::tree::TerminalNode *COMPILE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_operatorContext* alter_operator();

  class  Drop_operatorContext : public antlr4::ParserRuleContext {
  public:
    Drop_operatorContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *OPERATOR();
    Operator_nameContext *operator_name();
    antlr4::tree::TerminalNode *FORCE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_operatorContext* drop_operator();

  class  Create_operatorContext : public antlr4::ParserRuleContext {
  public:
    Create_operatorContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *OPERATOR();
    Operator_nameContext *operator_name();
    antlr4::tree::TerminalNode *BINDING();
    std::vector<Binding_clauseContext *> binding_clause();
    Binding_clauseContext* binding_clause(size_t i);
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *SHARING();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *METADATA();
    antlr4::tree::TerminalNode *NONE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_operatorContext* create_operator();

  class  Binding_clauseContext : public antlr4::ParserRuleContext {
  public:
    Binding_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<DatatypeContext *> datatype();
    DatatypeContext* datatype(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *RETURN();
    Using_function_clauseContext *using_function_clause();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Implementation_clauseContext *implementation_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Binding_clauseContext* binding_clause();

  class  Add_binding_clauseContext : public antlr4::ParserRuleContext {
  public:
    Add_binding_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *BINDING();
    Binding_clauseContext *binding_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_binding_clauseContext* add_binding_clause();

  class  Implementation_clauseContext : public antlr4::ParserRuleContext {
  public:
    Implementation_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ANCILLARY();
    antlr4::tree::TerminalNode *TO();
    Primary_operator_listContext *primary_operator_list();
    Operator_context_clauseContext *operator_context_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Implementation_clauseContext* implementation_clause();

  class  Primary_operator_listContext : public antlr4::ParserRuleContext {
  public:
    Primary_operator_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Primary_operator_itemContext *> primary_operator_item();
    Primary_operator_itemContext* primary_operator_item(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Primary_operator_listContext* primary_operator_list();

  class  Primary_operator_itemContext : public antlr4::ParserRuleContext {
  public:
    Primary_operator_itemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Schema_object_nameContext *schema_object_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<DatatypeContext *> datatype();
    DatatypeContext* datatype(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Primary_operator_itemContext* primary_operator_item();

  class  Operator_context_clauseContext : public antlr4::ParserRuleContext {
  public:
    Operator_context_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> WITH();
    antlr4::tree::TerminalNode* WITH(size_t i);
    antlr4::tree::TerminalNode *INDEX();
    std::vector<antlr4::tree::TerminalNode *> CONTEXT();
    antlr4::tree::TerminalNode* CONTEXT(size_t i);
    antlr4::tree::TerminalNode *COMMA();
    antlr4::tree::TerminalNode *SCAN();
    Implementation_type_nameContext *implementation_type_name();
    antlr4::tree::TerminalNode *COMPUTE();
    antlr4::tree::TerminalNode *ANCILLARY();
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *COLUMN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Operator_context_clauseContext* operator_context_clause();

  class  Using_function_clauseContext : public antlr4::ParserRuleContext {
  public:
    Using_function_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    Operator_function_nameContext *operator_function_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Using_function_clauseContext* using_function_clause();

  class  Drop_binding_clauseContext : public antlr4::ParserRuleContext {
  public:
    Drop_binding_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *BINDING();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<DatatypeContext *> datatype();
    DatatypeContext* datatype(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *FORCE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_binding_clauseContext* drop_binding_clause();

  class  Create_materialized_viewContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *mv_tablespace = nullptr;
    Create_materialized_viewContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *VIEW();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *AS();
    Select_only_statementContext *select_only_statement();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *PREBUILT();
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *OF();
    Type_nameContext *type_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *INDEX();
    antlr4::tree::TerminalNode *NO();
    Create_mv_refreshContext *create_mv_refresh();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *QUERY();
    antlr4::tree::TerminalNode *REWRITE();
    antlr4::tree::TerminalNode *DISABLE();
    antlr4::tree::TerminalNode *ENABLE();
    std::vector<Scoped_table_ref_constraintContext *> scoped_table_ref_constraint();
    Scoped_table_ref_constraintContext* scoped_table_ref_constraint(size_t i);
    std::vector<Mv_column_aliasContext *> mv_column_alias();
    Mv_column_aliasContext* mv_column_alias(size_t i);
    antlr4::tree::TerminalNode *REDUCED();
    antlr4::tree::TerminalNode *PRECISION();
    Physical_propertiesContext *physical_properties();
    Parallel_clauseContext *parallel_clause();
    Build_clauseContext *build_clause();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *WITHOUT();
    antlr4::tree::TerminalNode *CACHE();
    antlr4::tree::TerminalNode *NOCACHE();
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_materialized_viewContext* create_materialized_view();

  class  Scoped_table_ref_constraintContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::IdentifierContext *ref_column_or_attribute = nullptr;
    PlSqlParser::IdentifierContext *scope_table_name_or_c_alias = nullptr;
    Scoped_table_ref_constraintContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SCOPE();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *IS();
    std::vector<IdentifierContext *> identifier();
    IdentifierContext* identifier(size_t i);
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Scoped_table_ref_constraintContext* scoped_table_ref_constraint();

  class  Mv_column_aliasContext : public antlr4::ParserRuleContext {
  public:
    Mv_column_aliasContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    Quoted_stringContext *quoted_string();
    antlr4::tree::TerminalNode *ENCRYPT();
    Encryption_specContext *encryption_spec();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Mv_column_aliasContext* mv_column_alias();

  class  Create_mv_refreshContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *rb_segment = nullptr;
    Create_mv_refreshContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NEVER();
    antlr4::tree::TerminalNode *REFRESH();
    std::vector<antlr4::tree::TerminalNode *> ON();
    antlr4::tree::TerminalNode* ON(size_t i);
    std::vector<antlr4::tree::TerminalNode *> WITH();
    antlr4::tree::TerminalNode* WITH(size_t i);
    std::vector<antlr4::tree::TerminalNode *> USING();
    antlr4::tree::TerminalNode* USING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CONSTRAINTS();
    antlr4::tree::TerminalNode* CONSTRAINTS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FAST();
    antlr4::tree::TerminalNode* FAST(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMPLETE();
    antlr4::tree::TerminalNode* COMPLETE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FORCE();
    antlr4::tree::TerminalNode* FORCE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DEMAND();
    antlr4::tree::TerminalNode* DEMAND(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMIT();
    antlr4::tree::TerminalNode* COMMIT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ENFORCED();
    antlr4::tree::TerminalNode* ENFORCED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TRUSTED();
    antlr4::tree::TerminalNode* TRUSTED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> START();
    antlr4::tree::TerminalNode* START(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NEXT();
    antlr4::tree::TerminalNode* NEXT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PRIMARY();
    antlr4::tree::TerminalNode* PRIMARY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> KEY();
    antlr4::tree::TerminalNode* KEY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ROWID();
    antlr4::tree::TerminalNode* ROWID(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DEFAULT();
    antlr4::tree::TerminalNode* DEFAULT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ROLLBACK();
    antlr4::tree::TerminalNode* ROLLBACK(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SEGMENT();
    antlr4::tree::TerminalNode* SEGMENT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> REGULAR_ID();
    antlr4::tree::TerminalNode* REGULAR_ID(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MASTER();
    antlr4::tree::TerminalNode* MASTER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LOCAL();
    antlr4::tree::TerminalNode* LOCAL(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_mv_refreshContext* create_mv_refresh();

  class  Drop_materialized_viewContext : public antlr4::ParserRuleContext {
  public:
    Drop_materialized_viewContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *VIEW();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *PRESERVE();
    antlr4::tree::TerminalNode *TABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_materialized_viewContext* drop_materialized_view();

  class  Drop_materialized_view_logContext : public antlr4::ParserRuleContext {
  public:
    Drop_materialized_view_logContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *VIEW();
    antlr4::tree::TerminalNode *LOG();
    antlr4::tree::TerminalNode *ON();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *EXISTS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_materialized_view_logContext* drop_materialized_view_log();

  class  Create_contextContext : public antlr4::ParserRuleContext {
  public:
    Create_contextContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *CONTEXT();
    Oracle_namespaceContext *oracle_namespace();
    antlr4::tree::TerminalNode *USING();
    Package_nameContext *package_name();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    Schema_object_nameContext *schema_object_name();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *INITIALIZED();
    antlr4::tree::TerminalNode *ACCESSED();
    antlr4::tree::TerminalNode *GLOBALLY();
    antlr4::tree::TerminalNode *EXTERNALLY();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_contextContext* create_context();

  class  Oracle_namespaceContext : public antlr4::ParserRuleContext {
  public:
    Oracle_namespaceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Oracle_namespaceContext* oracle_namespace();

  class  Create_clusterContext : public antlr4::ParserRuleContext {
  public:
    Create_clusterContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *CLUSTER();
    Cluster_nameContext *cluster_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<DatatypeContext *> datatype();
    DatatypeContext* datatype(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> SORT();
    antlr4::tree::TerminalNode* SORT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SIZE();
    antlr4::tree::TerminalNode* SIZE(size_t i);
    std::vector<Size_clauseContext *> size_clause();
    Size_clauseContext* size_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<antlr4::tree::TerminalNode *> INDEX();
    antlr4::tree::TerminalNode* INDEX(size_t i);
    std::vector<antlr4::tree::TerminalNode *> HASHKEYS();
    antlr4::tree::TerminalNode* HASHKEYS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    Parallel_clauseContext *parallel_clause();
    antlr4::tree::TerminalNode *ROWDEPENDENCIES();
    antlr4::tree::TerminalNode *NOROWDEPENDENCIES();
    antlr4::tree::TerminalNode *CACHE();
    antlr4::tree::TerminalNode *NOCACHE();
    std::vector<antlr4::tree::TerminalNode *> SINGLE();
    antlr4::tree::TerminalNode* SINGLE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLE();
    antlr4::tree::TerminalNode* TABLE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> HASH();
    antlr4::tree::TerminalNode* HASH(size_t i);
    std::vector<antlr4::tree::TerminalNode *> IS();
    antlr4::tree::TerminalNode* IS(size_t i);
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_clusterContext* create_cluster();

  class  Create_profileContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *p = nullptr;
    Create_profileContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *PROFILE();
    antlr4::tree::TerminalNode *LIMIT();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *MANDATORY();
    std::vector<Resource_parametersContext *> resource_parameters();
    Resource_parametersContext* resource_parameters(size_t i);
    std::vector<Password_parametersContext *> password_parameters();
    Password_parametersContext* password_parameters(size_t i);
    Container_clauseContext *container_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_profileContext* create_profile();

  class  Resource_parametersContext : public antlr4::ParserRuleContext {
  public:
    Resource_parametersContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SESSIONS_PER_USER();
    antlr4::tree::TerminalNode *CPU_PER_SESSION();
    antlr4::tree::TerminalNode *CPU_PER_CALL();
    antlr4::tree::TerminalNode *CONNECT_TIME();
    antlr4::tree::TerminalNode *IDLE_TIME();
    antlr4::tree::TerminalNode *LOGICAL_READS_PER_SESSION();
    antlr4::tree::TerminalNode *LOGICAL_READS_PER_CALL();
    antlr4::tree::TerminalNode *COMPOSITE_LIMIT();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *UNLIMITED();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *PRIVATE_SGA();
    Size_clauseContext *size_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Resource_parametersContext* resource_parameters();

  class  Password_parametersContext : public antlr4::ParserRuleContext {
  public:
    Password_parametersContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FAILED_LOGIN_ATTEMPTS();
    antlr4::tree::TerminalNode *PASSWORD_LIFE_TIME();
    antlr4::tree::TerminalNode *PASSWORD_REUSE_TIME();
    antlr4::tree::TerminalNode *PASSWORD_REUSE_MAX();
    antlr4::tree::TerminalNode *PASSWORD_LOCK_TIME();
    antlr4::tree::TerminalNode *PASSWORD_GRACE_TIME();
    antlr4::tree::TerminalNode *INACTIVE_ACCOUNT_TIME();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *UNLIMITED();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *PASSWORD_VERIFY_FUNCTION();
    Function_nameContext *function_name();
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *PASSWORD_ROLLOVER_TIME();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Password_parametersContext* password_parameters();

  class  Create_lockdown_profileContext : public antlr4::ParserRuleContext {
  public:
    Create_lockdown_profileContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *LOCKDOWN();
    antlr4::tree::TerminalNode *PROFILE();
    Id_expressionContext *id_expression();
    Static_base_profileContext *static_base_profile();
    Dynamic_base_profileContext *dynamic_base_profile();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_lockdown_profileContext* create_lockdown_profile();

  class  Static_base_profileContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *bp = nullptr;
    Static_base_profileContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FROM();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Static_base_profileContext* static_base_profile();

  class  Dynamic_base_profileContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *bp = nullptr;
    Dynamic_base_profileContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INCLUDING();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dynamic_base_profileContext* dynamic_base_profile();

  class  Create_outlineContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *o = nullptr;
    PlSqlParser::Id_expressionContext *so = nullptr;
    PlSqlParser::Id_expressionContext *c = nullptr;
    Create_outlineContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *OUTLINE();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *FROM();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *CATEGORY();
    antlr4::tree::TerminalNode *ON();
    StatementContext *statement();
    std::vector<antlr4::tree::TerminalNode *> PUBLIC();
    antlr4::tree::TerminalNode* PUBLIC(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PRIVATE();
    antlr4::tree::TerminalNode* PRIVATE(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_outlineContext* create_outline();

  class  Create_restore_pointContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *rp = nullptr;
    PlSqlParser::Id_expressionContext *pdb = nullptr;
    Create_restore_pointContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *RESTORE();
    antlr4::tree::TerminalNode *POINT();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *CLEAN();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *PLUGGABLE();
    std::vector<antlr4::tree::TerminalNode *> DATABASE();
    antlr4::tree::TerminalNode* DATABASE(size_t i);
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *OF();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *PRESERVE();
    antlr4::tree::TerminalNode *GUARANTEE();
    antlr4::tree::TerminalNode *FLASHBACK();
    antlr4::tree::TerminalNode *TIMESTAMP();
    antlr4::tree::TerminalNode *SCN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_restore_pointContext* create_restore_point();

  class  Create_roleContext : public antlr4::ParserRuleContext {
  public:
    Create_roleContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *ROLE();
    Role_nameContext *role_name();
    Role_identified_clauseContext *role_identified_clause();
    Container_clauseContext *container_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_roleContext* create_role();

  class  Create_tableContext : public antlr4::ParserRuleContext {
  public:
    Create_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *TABLE();
    Table_nameContext *table_name();
    Relational_tableContext *relational_table();
    Xmltype_tableContext *xmltype_table();
    Object_tableContext *object_table();
    antlr4::tree::TerminalNode *TEMPORARY();
    antlr4::tree::TerminalNode *SHARDED();
    antlr4::tree::TerminalNode *DUPLICATED();
    antlr4::tree::TerminalNode *BLOCKCHAIN();
    antlr4::tree::TerminalNode *IMMUTABLE();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *EXISTS();
    antlr4::tree::TerminalNode *SHARING();
    antlr4::tree::TerminalNode *EQUALS_OP();
    Memoptimize_read_write_clauseContext *memoptimize_read_write_clause();
    antlr4::tree::TerminalNode *PARENT();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *USAGE();
    antlr4::tree::TerminalNode *QUEUE();
    antlr4::tree::TerminalNode *GLOBAL();
    antlr4::tree::TerminalNode *PRIVATE();
    antlr4::tree::TerminalNode *METADATA();
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *NONE();
    antlr4::tree::TerminalNode *EXTENDED();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_tableContext* create_table();

  class  Xmltype_tableContext : public antlr4::ParserRuleContext {
  public:
    Xmltype_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OF();
    std::vector<antlr4::tree::TerminalNode *> XMLTYPE();
    antlr4::tree::TerminalNode* XMLTYPE(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Object_propertiesContext *object_properties();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Xmltype_storageContext *xmltype_storage();
    Xmlschema_specContext *xmlschema_spec();
    Xmltype_virtual_columnsContext *xmltype_virtual_columns();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *ROWS();
    Oid_clauseContext *oid_clause();
    Oid_index_clauseContext *oid_index_clause();
    Physical_propertiesContext *physical_properties();
    Table_propertiesContext *table_properties();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *PRESERVE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmltype_tableContext* xmltype_table();

  class  Xmltype_virtual_columnsContext : public antlr4::ParserRuleContext {
  public:
    Xmltype_virtual_columnsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VIRTUAL();
    antlr4::tree::TerminalNode *COLUMNS();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmltype_virtual_columnsContext* xmltype_virtual_columns();

  class  Xmltype_column_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Xmltype_column_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *XMLTYPE();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *COLUMN();
    Xmltype_storageContext *xmltype_storage();
    Xmlschema_specContext *xmlschema_spec();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmltype_column_propertiesContext* xmltype_column_properties();

  class  Xmltype_storageContext : public antlr4::ParserRuleContext {
  public:
    Xmltype_storageContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *OBJECT();
    antlr4::tree::TerminalNode *RELATIONAL();
    antlr4::tree::TerminalNode *CLOB();
    antlr4::tree::TerminalNode *BINARY();
    antlr4::tree::TerminalNode *XML();
    Lob_segnameContext *lob_segname();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Lob_parametersContext *lob_parameters();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *SECUREFILE();
    antlr4::tree::TerminalNode *BASICFILE();
    antlr4::tree::TerminalNode *VARRAYS();
    antlr4::tree::TerminalNode *LOBS();
    antlr4::tree::TerminalNode *TABLES();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmltype_storageContext* xmltype_storage();

  class  Xmlschema_specContext : public antlr4::ParserRuleContext {
  public:
    Xmlschema_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ELEMENT();
    std::vector<antlr4::tree::TerminalNode *> DELIMITED_ID();
    antlr4::tree::TerminalNode* DELIMITED_ID(size_t i);
    antlr4::tree::TerminalNode *XMLSCHEMA();
    std::vector<Allow_or_disallowContext *> allow_or_disallow();
    Allow_or_disallowContext* allow_or_disallow(size_t i);
    antlr4::tree::TerminalNode *NONSCHEMA();
    antlr4::tree::TerminalNode *ANYSCHEMA();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmlschema_specContext* xmlschema_spec();

  class  Object_tableContext : public antlr4::ParserRuleContext {
  public:
    Object_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OF();
    Object_typeContext *object_type();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();
    Object_table_substitutionContext *object_table_substitution();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Object_propertiesContext *> object_properties();
    Object_propertiesContext* object_properties(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *ROWS();
    Oid_clauseContext *oid_clause();
    Oid_index_clauseContext *oid_index_clause();
    Physical_propertiesContext *physical_properties();
    Table_propertiesContext *table_properties();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *PRESERVE();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_tableContext* object_table();

  class  Object_typeContext : public antlr4::ParserRuleContext {
  public:
    Object_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_typeContext* object_type();

  class  Oid_index_clauseContext : public antlr4::ParserRuleContext {
  public:
    Oid_index_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OIDINDEX();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Index_nameContext *index_name();
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Oid_index_clauseContext* oid_index_clause();

  class  Oid_clauseContext : public antlr4::ParserRuleContext {
  public:
    Oid_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OBJECT();
    antlr4::tree::TerminalNode *IDENTIFIER();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *SYSTEM();
    antlr4::tree::TerminalNode *GENERATED();
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *KEY();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Oid_clauseContext* oid_clause();

  class  Object_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Object_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    Attribute_nameContext *attribute_name();
    antlr4::tree::TerminalNode *DEFAULT();
    ExpressionContext *expression();
    std::vector<Inline_constraintContext *> inline_constraint();
    Inline_constraintContext* inline_constraint(size_t i);
    Inline_ref_constraintContext *inline_ref_constraint();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Out_of_line_constraintContext *out_of_line_constraint();
    Out_of_line_ref_constraintContext *out_of_line_ref_constraint();
    Supplemental_logging_propsContext *supplemental_logging_props();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_propertiesContext* object_properties();

  class  Object_table_substitutionContext : public antlr4::ParserRuleContext {
  public:
    Object_table_substitutionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBSTITUTABLE();
    antlr4::tree::TerminalNode *AT();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *LEVELS();
    antlr4::tree::TerminalNode *NOT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_table_substitutionContext* object_table_substitution();

  class  Relational_tableContext : public antlr4::ParserRuleContext {
  public:
    Relational_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Relational_propertyContext *> relational_property();
    Relational_propertyContext* relational_property(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Relational_table_propertiesContext *relational_table_properties();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Relational_tableContext* relational_table();

  class  Relational_table_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Relational_table_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Relational_table_propertyContext *> relational_table_property();
    Relational_table_propertyContext* relational_table_property(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Relational_table_propertiesContext* relational_table_properties();

  class  Relational_table_propertyContext : public antlr4::ParserRuleContext {
  public:
    Relational_table_propertyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Immutable_table_clausesContext *immutable_table_clauses();
    Blockchain_table_clausesContext *blockchain_table_clauses();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *COLLATION();
    Collation_nameContext *collation_name();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *DEFINITION();
    antlr4::tree::TerminalNode *ROWS();
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *PRESERVE();
    antlr4::tree::TerminalNode *DELETE();
    Physical_propertiesContext *physical_properties();
    Table_propertiesContext *table_properties();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Relational_table_propertyContext* relational_table_property();

  class  Immutable_table_clausesContext : public antlr4::ParserRuleContext {
  public:
    Immutable_table_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Immutable_table_no_drop_clauseContext *immutable_table_no_drop_clause();
    Immutable_table_no_delete_clauseContext *immutable_table_no_delete_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Immutable_table_clausesContext* immutable_table_clauses();

  class  Immutable_table_no_drop_clauseContext : public antlr4::ParserRuleContext {
  public:
    Immutable_table_no_drop_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *UNTIL();
    NumericContext *numeric();
    antlr4::tree::TerminalNode *DAYS();
    antlr4::tree::TerminalNode *IDLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Immutable_table_no_drop_clauseContext* immutable_table_no_drop_clause();

  class  Immutable_table_no_delete_clauseContext : public antlr4::ParserRuleContext {
  public:
    Immutable_table_no_delete_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *UNTIL();
    NumericContext *numeric();
    antlr4::tree::TerminalNode *DAYS();
    antlr4::tree::TerminalNode *AFTER();
    antlr4::tree::TerminalNode *INSERT();
    antlr4::tree::TerminalNode *LOCKED();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Immutable_table_no_delete_clauseContext* immutable_table_no_delete_clause();

  class  Blockchain_table_clausesContext : public antlr4::ParserRuleContext {
  public:
    Blockchain_table_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Blockchain_drop_table_clauseContext *blockchain_drop_table_clause();
    Blockchain_row_retention_clauseContext *blockchain_row_retention_clause();
    Blockchain_hash_and_data_format_clauseContext *blockchain_hash_and_data_format_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Blockchain_table_clausesContext* blockchain_table_clauses();

  class  Blockchain_drop_table_clauseContext : public antlr4::ParserRuleContext {
  public:
    Blockchain_drop_table_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *UNTIL();
    NumericContext *numeric();
    antlr4::tree::TerminalNode *DAYS();
    antlr4::tree::TerminalNode *IDLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Blockchain_drop_table_clauseContext* blockchain_drop_table_clause();

  class  Blockchain_row_retention_clauseContext : public antlr4::ParserRuleContext {
  public:
    Blockchain_row_retention_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *UNTIL();
    NumericContext *numeric();
    antlr4::tree::TerminalNode *DAYS();
    antlr4::tree::TerminalNode *AFTER();
    antlr4::tree::TerminalNode *INSERT();
    antlr4::tree::TerminalNode *LOCKED();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Blockchain_row_retention_clauseContext* blockchain_row_retention_clause();

  class  Blockchain_hash_and_data_format_clauseContext : public antlr4::ParserRuleContext {
  public:
    Blockchain_hash_and_data_format_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *HASHING();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *SHA2_512_Q();
    antlr4::tree::TerminalNode *VERSION();
    antlr4::tree::TerminalNode *V1_Q();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Blockchain_hash_and_data_format_clauseContext* blockchain_hash_and_data_format_clause();

  class  Collation_nameContext : public antlr4::ParserRuleContext {
  public:
    Collation_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Collation_nameContext* collation_name();

  class  Table_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Table_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_propertiesContext *column_properties();
    Read_only_clauseContext *read_only_clause();
    Indexing_clauseContext *indexing_clause();
    Table_partitioning_clausesContext *table_partitioning_clauses();
    Attribute_clustering_clauseContext *attribute_clustering_clause();
    antlr4::tree::TerminalNode *CACHE();
    antlr4::tree::TerminalNode *NOCACHE();
    Result_cache_clauseContext *result_cache_clause();
    Parallel_clauseContext *parallel_clause();
    Monitoring_nomonitoringContext *monitoring_nomonitoring();
    antlr4::tree::TerminalNode *ROWDEPENDENCIES();
    antlr4::tree::TerminalNode *NOROWDEPENDENCIES();
    Enable_disable_clauseContext *enable_disable_clause();
    Row_movement_clauseContext *row_movement_clause();
    Logical_replication_clauseContext *logical_replication_clause();
    Flashback_archive_clauseContext *flashback_archive_clause();
    Physical_propertiesContext *physical_properties();
    antlr4::tree::TerminalNode *ROW();
    antlr4::tree::TerminalNode *ARCHIVAL();
    antlr4::tree::TerminalNode *AS();
    Select_only_statementContext *select_only_statement();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *EXCHANGE();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *TABLE();
    Table_nameContext *table_name();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();
    Annotations_clauseContext *annotations_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_propertiesContext* table_properties();

  class  Read_only_clauseContext : public antlr4::ParserRuleContext {
  public:
    Read_only_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *WRITE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Read_only_clauseContext* read_only_clause();

  class  Indexing_clauseContext : public antlr4::ParserRuleContext {
  public:
    Indexing_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INDEXING();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *OFF();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Indexing_clauseContext* indexing_clause();

  class  Attribute_clustering_clauseContext : public antlr4::ParserRuleContext {
  public:
    Attribute_clustering_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CLUSTERING();
    Cluster_clauseContext *cluster_clause();
    Clustering_joinContext *clustering_join();
    std::vector<antlr4::tree::TerminalNode *> ON();
    antlr4::tree::TerminalNode* ON(size_t i);
    antlr4::tree::TerminalNode *LOAD();
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *MOVEMENT();
    Zonemap_clauseContext *zonemap_clause();
    std::vector<Yes_noContext *> yes_no();
    Yes_noContext* yes_no(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Attribute_clustering_clauseContext* attribute_clustering_clause();

  class  Clustering_joinContext : public antlr4::ParserRuleContext {
  public:
    Clustering_joinContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Table_nameContext *table_name();
    std::vector<Clustering_join_itemContext *> clustering_join_item();
    Clustering_join_itemContext* clustering_join_item(size_t i);
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Clustering_joinContext* clustering_join();

  class  Clustering_join_itemContext : public antlr4::ParserRuleContext {
  public:
    Clustering_join_itemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *JOIN();
    Table_nameContext *table_name();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Equijoin_conditionContext *equijoin_condition();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Clustering_join_itemContext* clustering_join_item();

  class  Equijoin_conditionContext : public antlr4::ParserRuleContext {
  public:
    Equijoin_conditionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Equijoin_conditionContext* equijoin_condition();

  class  Cluster_clauseContext : public antlr4::ParserRuleContext {
  public:
    Cluster_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *ORDER();
    Clustering_columnsContext *clustering_columns();
    antlr4::tree::TerminalNode *LINEAR();
    antlr4::tree::TerminalNode *INTERLEAVED();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cluster_clauseContext* cluster_clause();

  class  Clustering_columnsContext : public antlr4::ParserRuleContext {
  public:
    Clustering_columnsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Clustering_column_groupContext *> clustering_column_group();
    Clustering_column_groupContext* clustering_column_group(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Clustering_columnsContext* clustering_columns();

  class  Clustering_column_groupContext : public antlr4::ParserRuleContext {
  public:
    Clustering_column_groupContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Clustering_column_groupContext* clustering_column_group();

  class  Yes_noContext : public antlr4::ParserRuleContext {
  public:
    Yes_noContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *YES();
    antlr4::tree::TerminalNode *NO();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Yes_noContext* yes_no();

  class  Zonemap_clauseContext : public antlr4::ParserRuleContext {
  public:
    Zonemap_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *ZONEMAP();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Zonemap_nameContext *zonemap_name();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *WITHOUT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Zonemap_clauseContext* zonemap_clause();

  class  Logical_replication_clauseContext : public antlr4::ParserRuleContext {
  public:
    Logical_replication_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DISABLE();
    antlr4::tree::TerminalNode *LOGICAL();
    antlr4::tree::TerminalNode *REPLICATION();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *KEYS();
    antlr4::tree::TerminalNode *PARTIAL();
    antlr4::tree::TerminalNode *JSON();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *ALLOW();
    antlr4::tree::TerminalNode *NOVALIDATE();
    antlr4::tree::TerminalNode *NO();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Logical_replication_clauseContext* logical_replication_clause();

  class  Table_nameContext : public antlr4::ParserRuleContext {
  public:
    Table_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_nameContext* table_name();

  class  Relational_propertyContext : public antlr4::ParserRuleContext {
  public:
    Relational_propertyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Out_of_line_constraintContext *out_of_line_constraint();
    Out_of_line_ref_constraintContext *out_of_line_ref_constraint();
    Column_definitionContext *column_definition();
    Virtual_column_definitionContext *virtual_column_definition();
    Period_definitionContext *period_definition();
    Supplemental_logging_propsContext *supplemental_logging_props();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Relational_propertyContext* relational_property();

  class  Table_partitioning_clausesContext : public antlr4::ParserRuleContext {
  public:
    Table_partitioning_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Range_partitionsContext *range_partitions();
    List_partitionsContext *list_partitions();
    Hash_partitionsContext *hash_partitions();
    Composite_range_partitionsContext *composite_range_partitions();
    Composite_list_partitionsContext *composite_list_partitions();
    Composite_hash_partitionsContext *composite_hash_partitions();
    Reference_partitioningContext *reference_partitioning();
    System_partitioningContext *system_partitioning();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_partitioning_clausesContext* table_partitioning_clauses();

  class  Range_partitionsContext : public antlr4::ParserRuleContext {
  public:
    Range_partitionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> PARTITION();
    antlr4::tree::TerminalNode* PARTITION(size_t i);
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *RANGE();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<Range_values_clauseContext *> range_values_clause();
    Range_values_clauseContext* range_values_clause(size_t i);
    std::vector<Table_partition_descriptionContext *> table_partition_description();
    Table_partition_descriptionContext* table_partition_description(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *INTERVAL();
    ExpressionContext *expression();
    std::vector<Partition_nameContext *> partition_name();
    Partition_nameContext* partition_name(size_t i);
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *IN();
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Range_partitionsContext* range_partitions();

  class  List_partitionsContext : public antlr4::ParserRuleContext {
  public:
    List_partitionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> PARTITION();
    antlr4::tree::TerminalNode* PARTITION(size_t i);
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *LIST();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    Column_nameContext *column_name();
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<List_values_clauseContext *> list_values_clause();
    List_values_clauseContext* list_values_clause(size_t i);
    std::vector<Table_partition_descriptionContext *> table_partition_description();
    Table_partition_descriptionContext* table_partition_description(size_t i);
    std::vector<Partition_nameContext *> partition_name();
    Partition_nameContext* partition_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  List_partitionsContext* list_partitions();

  class  Hash_partitionsContext : public antlr4::ParserRuleContext {
  public:
    Hash_partitionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *HASH();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Individual_hash_partitionsContext *individual_hash_partitions();
    Hash_partitions_by_quantityContext *hash_partitions_by_quantity();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hash_partitionsContext* hash_partitions();

  class  Individual_hash_partitionsContext : public antlr4::ParserRuleContext {
  public:
    Individual_hash_partitionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> PARTITION();
    antlr4::tree::TerminalNode* PARTITION(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Partition_nameContext *> partition_name();
    Partition_nameContext* partition_name(size_t i);
    std::vector<Partitioning_storage_clauseContext *> partitioning_storage_clause();
    Partitioning_storage_clauseContext* partitioning_storage_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Individual_hash_partitionsContext* individual_hash_partitions();

  class  Hash_partitions_by_quantityContext : public antlr4::ParserRuleContext {
  public:
    Hash_partitions_by_quantityContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITIONS();
    Hash_partition_quantityContext *hash_partition_quantity();
    std::vector<antlr4::tree::TerminalNode *> STORE();
    antlr4::tree::TerminalNode* STORE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> IN();
    antlr4::tree::TerminalNode* IN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    Table_compressionContext *table_compression();
    Key_compressionContext *key_compression();
    antlr4::tree::TerminalNode *OVERFLOW_();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hash_partitions_by_quantityContext* hash_partitions_by_quantity();

  class  Hash_partition_quantityContext : public antlr4::ParserRuleContext {
  public:
    Hash_partition_quantityContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hash_partition_quantityContext* hash_partition_quantity();

  class  Composite_range_partitionsContext : public antlr4::ParserRuleContext {
  public:
    Composite_range_partitionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *RANGE();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<Range_partition_descContext *> range_partition_desc();
    Range_partition_descContext* range_partition_desc(size_t i);
    Subpartition_by_rangeContext *subpartition_by_range();
    Subpartition_by_listContext *subpartition_by_list();
    Subpartition_by_hashContext *subpartition_by_hash();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *INTERVAL();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *IN();
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Composite_range_partitionsContext* composite_range_partitions();

  class  Composite_list_partitionsContext : public antlr4::ParserRuleContext {
  public:
    Composite_list_partitionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *LIST();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    Column_nameContext *column_name();
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<List_partition_descContext *> list_partition_desc();
    List_partition_descContext* list_partition_desc(size_t i);
    Subpartition_by_rangeContext *subpartition_by_range();
    Subpartition_by_listContext *subpartition_by_list();
    Subpartition_by_hashContext *subpartition_by_hash();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Composite_list_partitionsContext* composite_list_partitions();

  class  Composite_hash_partitionsContext : public antlr4::ParserRuleContext {
  public:
    Composite_hash_partitionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *HASH();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Subpartition_by_rangeContext *subpartition_by_range();
    Subpartition_by_listContext *subpartition_by_list();
    Subpartition_by_hashContext *subpartition_by_hash();
    Individual_hash_partitionsContext *individual_hash_partitions();
    Hash_partitions_by_quantityContext *hash_partitions_by_quantity();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Composite_hash_partitionsContext* composite_hash_partitions();

  class  Reference_partitioningContext : public antlr4::ParserRuleContext {
  public:
    Reference_partitioningContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *REFERENCE();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    Constraint_nameContext *constraint_name();
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<Reference_partition_descContext *> reference_partition_desc();
    Reference_partition_descContext* reference_partition_desc(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Reference_partitioningContext* reference_partitioning();

  class  Reference_partition_descContext : public antlr4::ParserRuleContext {
  public:
    Reference_partition_descContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    Table_partition_descriptionContext *table_partition_description();
    Partition_nameContext *partition_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Reference_partition_descContext* reference_partition_desc();

  class  System_partitioningContext : public antlr4::ParserRuleContext {
  public:
    System_partitioningContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *SYSTEM();
    antlr4::tree::TerminalNode *PARTITIONS();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    std::vector<Reference_partition_descContext *> reference_partition_desc();
    Reference_partition_descContext* reference_partition_desc(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  System_partitioningContext* system_partitioning();

  class  Range_partition_descContext : public antlr4::ParserRuleContext {
  public:
    Range_partition_descContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    Table_partition_descriptionContext *table_partition_description();
    Partition_nameContext *partition_name();
    Range_values_clauseContext *range_values_clause();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Hash_subparts_by_quantityContext *hash_subparts_by_quantity();
    std::vector<Range_subpartition_descContext *> range_subpartition_desc();
    Range_subpartition_descContext* range_subpartition_desc(size_t i);
    std::vector<List_subpartition_descContext *> list_subpartition_desc();
    List_subpartition_descContext* list_subpartition_desc(size_t i);
    std::vector<Individual_hash_subpartsContext *> individual_hash_subparts();
    Individual_hash_subpartsContext* individual_hash_subparts(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Range_partition_descContext* range_partition_desc();

  class  List_partition_descContext : public antlr4::ParserRuleContext {
  public:
    List_partition_descContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    Table_partition_descriptionContext *table_partition_description();
    Partition_nameContext *partition_name();
    List_values_clauseContext *list_values_clause();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Hash_subparts_by_quantityContext *hash_subparts_by_quantity();
    std::vector<Range_subpartition_descContext *> range_subpartition_desc();
    Range_subpartition_descContext* range_subpartition_desc(size_t i);
    std::vector<List_subpartition_descContext *> list_subpartition_desc();
    List_subpartition_descContext* list_subpartition_desc(size_t i);
    std::vector<Individual_hash_subpartsContext *> individual_hash_subparts();
    Individual_hash_subpartsContext* individual_hash_subparts(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  List_partition_descContext* list_partition_desc();

  class  Subpartition_templateContext : public antlr4::ParserRuleContext {
  public:
    Subpartition_templateContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBPARTITION();
    antlr4::tree::TerminalNode *TEMPLATE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Hash_subpartition_quantityContext *hash_subpartition_quantity();
    std::vector<Range_subpartition_descContext *> range_subpartition_desc();
    Range_subpartition_descContext* range_subpartition_desc(size_t i);
    std::vector<List_subpartition_descContext *> list_subpartition_desc();
    List_subpartition_descContext* list_subpartition_desc(size_t i);
    std::vector<Individual_hash_subpartsContext *> individual_hash_subparts();
    Individual_hash_subpartsContext* individual_hash_subparts(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subpartition_templateContext* subpartition_template();

  class  Hash_subpartition_quantityContext : public antlr4::ParserRuleContext {
  public:
    Hash_subpartition_quantityContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hash_subpartition_quantityContext* hash_subpartition_quantity();

  class  Subpartition_by_rangeContext : public antlr4::ParserRuleContext {
  public:
    Subpartition_by_rangeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBPARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *RANGE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Subpartition_templateContext *subpartition_template();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subpartition_by_rangeContext* subpartition_by_range();

  class  Subpartition_by_listContext : public antlr4::ParserRuleContext {
  public:
    Subpartition_by_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBPARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *LIST();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Subpartition_templateContext *subpartition_template();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subpartition_by_listContext* subpartition_by_list();

  class  Subpartition_by_hashContext : public antlr4::ParserRuleContext {
  public:
    Subpartition_by_hashContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBPARTITION();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *HASH();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *SUBPARTITIONS();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    Subpartition_templateContext *subpartition_template();
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *IN();
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subpartition_by_hashContext* subpartition_by_hash();

  class  Subpartition_nameContext : public antlr4::ParserRuleContext {
  public:
    Subpartition_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Partition_nameContext *partition_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subpartition_nameContext* subpartition_name();

  class  Range_subpartition_descContext : public antlr4::ParserRuleContext {
  public:
    Range_subpartition_descContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBPARTITION();
    Range_values_clauseContext *range_values_clause();
    Subpartition_nameContext *subpartition_name();
    Partitioning_storage_clauseContext *partitioning_storage_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Range_subpartition_descContext* range_subpartition_desc();

  class  List_subpartition_descContext : public antlr4::ParserRuleContext {
  public:
    List_subpartition_descContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBPARTITION();
    List_values_clauseContext *list_values_clause();
    Subpartition_nameContext *subpartition_name();
    Partitioning_storage_clauseContext *partitioning_storage_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  List_subpartition_descContext* list_subpartition_desc();

  class  Individual_hash_subpartsContext : public antlr4::ParserRuleContext {
  public:
    Individual_hash_subpartsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBPARTITION();
    Subpartition_nameContext *subpartition_name();
    Partitioning_storage_clauseContext *partitioning_storage_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Individual_hash_subpartsContext* individual_hash_subparts();

  class  Hash_subparts_by_quantityContext : public antlr4::ParserRuleContext {
  public:
    Hash_subparts_by_quantityContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBPARTITIONS();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hash_subparts_by_quantityContext* hash_subparts_by_quantity();

  class  Range_values_clauseContext : public antlr4::ParserRuleContext {
  public:
    Range_values_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VALUES();
    antlr4::tree::TerminalNode *LESS();
    antlr4::tree::TerminalNode *THAN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Range_values_listContext *range_values_list();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Range_values_clauseContext* range_values_clause();

  class  Range_values_listContext : public antlr4::ParserRuleContext {
  public:
    Range_values_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<LiteralContext *> literal();
    LiteralContext* literal(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TIMESTAMP();
    antlr4::tree::TerminalNode* TIMESTAMP(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Range_values_listContext* range_values_list();

  class  List_values_clauseContext : public antlr4::ParserRuleContext {
  public:
    List_values_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VALUES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<LiteralContext *> literal();
    LiteralContext* literal(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TIMESTAMP();
    antlr4::tree::TerminalNode* TIMESTAMP(size_t i);
    antlr4::tree::TerminalNode *DEFAULT();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  List_values_clauseContext* list_values_clause();

  class  Table_partition_descriptionContext : public antlr4::ParserRuleContext {
  public:
    Table_partition_descriptionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Deferred_segment_creationContext *deferred_segment_creation();
    Read_only_clauseContext *read_only_clause();
    Indexing_clauseContext *indexing_clause();
    std::vector<Segment_attributes_clauseContext *> segment_attributes_clause();
    Segment_attributes_clauseContext* segment_attributes_clause(size_t i);
    Table_compressionContext *table_compression();
    Key_compressionContext *key_compression();
    Inmemory_table_clauseContext *inmemory_table_clause();
    Ilm_clauseContext *ilm_clause();
    antlr4::tree::TerminalNode *OVERFLOW_();
    std::vector<Lob_storage_clauseContext *> lob_storage_clause();
    Lob_storage_clauseContext* lob_storage_clause(size_t i);
    std::vector<Varray_col_propertiesContext *> varray_col_properties();
    Varray_col_propertiesContext* varray_col_properties(size_t i);
    std::vector<Nested_table_col_propertiesContext *> nested_table_col_properties();
    Nested_table_col_propertiesContext* nested_table_col_properties(size_t i);
    antlr4::tree::TerminalNode *INTERNAL();
    antlr4::tree::TerminalNode *EXTERNAL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_partition_descriptionContext* table_partition_description();

  class  Partitioning_storage_clauseContext : public antlr4::ParserRuleContext {
  public:
    Partitioning_storage_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<antlr4::tree::TerminalNode *> OVERFLOW_();
    antlr4::tree::TerminalNode* OVERFLOW_(size_t i);
    std::vector<Table_compressionContext *> table_compression();
    Table_compressionContext* table_compression(size_t i);
    std::vector<Key_compressionContext *> key_compression();
    Key_compressionContext* key_compression(size_t i);
    std::vector<Inmemory_table_clauseContext *> inmemory_table_clause();
    Inmemory_table_clauseContext* inmemory_table_clause(size_t i);
    std::vector<Lob_partitioning_storageContext *> lob_partitioning_storage();
    Lob_partitioning_storageContext* lob_partitioning_storage(size_t i);
    std::vector<antlr4::tree::TerminalNode *> VARRAY();
    antlr4::tree::TerminalNode* VARRAY(size_t i);
    std::vector<Varray_itemContext *> varray_item();
    Varray_itemContext* varray_item(size_t i);
    std::vector<antlr4::tree::TerminalNode *> STORE();
    antlr4::tree::TerminalNode* STORE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LOB();
    antlr4::tree::TerminalNode* LOB(size_t i);
    std::vector<Lob_segnameContext *> lob_segname();
    Lob_segnameContext* lob_segname(size_t i);
    std::vector<antlr4::tree::TerminalNode *> BASICFILE();
    antlr4::tree::TerminalNode* BASICFILE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SECUREFILE();
    antlr4::tree::TerminalNode* SECUREFILE(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partitioning_storage_clauseContext* partitioning_storage_clause();

  class  Lob_partitioning_storageContext : public antlr4::ParserRuleContext {
  public:
    Lob_partitioning_storageContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOB();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    Lob_itemContext *lob_item();
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *AS();
    Lob_segnameContext *lob_segname();
    antlr4::tree::TerminalNode *TABLESPACE();
    TablespaceContext *tablespace();
    antlr4::tree::TerminalNode *BASICFILE();
    antlr4::tree::TerminalNode *SECUREFILE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lob_partitioning_storageContext* lob_partitioning_storage();

  class  Size_clauseContext : public antlr4::ParserRuleContext {
  public:
    Size_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *K_LETTER();
    antlr4::tree::TerminalNode *M_LETTER();
    antlr4::tree::TerminalNode *G_LETTER();
    antlr4::tree::TerminalNode *T_LETTER();
    antlr4::tree::TerminalNode *P_LETTER();
    antlr4::tree::TerminalNode *E_LETTER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Size_clauseContext* size_clause();

  class  Table_compressionContext : public antlr4::ParserRuleContext {
  public:
    Table_compressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COMPRESS();
    antlr4::tree::TerminalNode *BASIC();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *OLTP();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *OPERATIONS();
    antlr4::tree::TerminalNode *DIRECT_LOAD();
    antlr4::tree::TerminalNode *QUERY();
    antlr4::tree::TerminalNode *ARCHIVE();
    antlr4::tree::TerminalNode *LOW();
    antlr4::tree::TerminalNode *HIGH();
    antlr4::tree::TerminalNode *ROW();
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *ADVANCED();
    antlr4::tree::TerminalNode *COLUMN();
    antlr4::tree::TerminalNode *LEVEL();
    antlr4::tree::TerminalNode *LOCKING();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *NOCOMPRESS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_compressionContext* table_compression();

  class  Inmemory_table_clauseContext : public antlr4::ParserRuleContext {
  public:
    Inmemory_table_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Inmemory_column_clauseContext *> inmemory_column_clause();
    Inmemory_column_clauseContext* inmemory_column_clause(size_t i);
    antlr4::tree::TerminalNode *INMEMORY();
    antlr4::tree::TerminalNode *NO();
    Inmemory_attributesContext *inmemory_attributes();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Inmemory_table_clauseContext* inmemory_table_clause();

  class  Inmemory_attributesContext : public antlr4::ParserRuleContext {
  public:
    Inmemory_attributesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Inmemory_memcompressContext *> inmemory_memcompress();
    Inmemory_memcompressContext* inmemory_memcompress(size_t i);
    std::vector<Inmemory_priorityContext *> inmemory_priority();
    Inmemory_priorityContext* inmemory_priority(size_t i);
    std::vector<Inmemory_distributeContext *> inmemory_distribute();
    Inmemory_distributeContext* inmemory_distribute(size_t i);
    std::vector<Inmemory_duplicateContext *> inmemory_duplicate();
    Inmemory_duplicateContext* inmemory_duplicate(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Inmemory_attributesContext* inmemory_attributes();

  class  Inmemory_memcompressContext : public antlr4::ParserRuleContext {
  public:
    Inmemory_memcompressContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MEMCOMPRESS();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *DML();
    antlr4::tree::TerminalNode *QUERY();
    antlr4::tree::TerminalNode *CAPACITY();
    antlr4::tree::TerminalNode *LOW();
    antlr4::tree::TerminalNode *HIGH();
    antlr4::tree::TerminalNode *NO();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Inmemory_memcompressContext* inmemory_memcompress();

  class  Inmemory_priorityContext : public antlr4::ParserRuleContext {
  public:
    Inmemory_priorityContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PRIORITY();
    antlr4::tree::TerminalNode *NONE();
    antlr4::tree::TerminalNode *LOW();
    antlr4::tree::TerminalNode *MEDIUM();
    antlr4::tree::TerminalNode *HIGH();
    antlr4::tree::TerminalNode *CRITICAL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Inmemory_priorityContext* inmemory_priority();

  class  Inmemory_distributeContext : public antlr4::ParserRuleContext {
  public:
    Inmemory_distributeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DISTRIBUTE();
    antlr4::tree::TerminalNode *AUTO();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *SERVICE();
    antlr4::tree::TerminalNode *ROWID();
    antlr4::tree::TerminalNode *RANGE();
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *SUBPARTITION();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *ALL();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *NONE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Inmemory_distributeContext* inmemory_distribute();

  class  Inmemory_duplicateContext : public antlr4::ParserRuleContext {
  public:
    Inmemory_duplicateContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DUPLICATE();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *NO();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Inmemory_duplicateContext* inmemory_duplicate();

  class  Inmemory_column_clauseContext : public antlr4::ParserRuleContext {
  public:
    Inmemory_column_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Column_listContext *column_list();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *INMEMORY();
    antlr4::tree::TerminalNode *NO();
    Inmemory_memcompressContext *inmemory_memcompress();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Inmemory_column_clauseContext* inmemory_column_clause();

  class  Physical_attributes_clauseContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *pctfree = nullptr;
    antlr4::Token *pctused = nullptr;
    antlr4::Token *inittrans = nullptr;
    antlr4::Token *maxtrans = nullptr;
    Physical_attributes_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> PCTFREE();
    antlr4::tree::TerminalNode* PCTFREE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PCTUSED();
    antlr4::tree::TerminalNode* PCTUSED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> INITRANS();
    antlr4::tree::TerminalNode* INITRANS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MAXTRANS();
    antlr4::tree::TerminalNode* MAXTRANS(size_t i);
    std::vector<Storage_clauseContext *> storage_clause();
    Storage_clauseContext* storage_clause(size_t i);
    std::vector<Compute_clausesContext *> compute_clauses();
    Compute_clausesContext* compute_clauses(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Physical_attributes_clauseContext* physical_attributes_clause();

  class  Storage_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Size_clauseContext *initial_size = nullptr;
    PlSqlParser::Size_clauseContext *next_size = nullptr;
    antlr4::Token *minextents = nullptr;
    antlr4::Token *pctincrease = nullptr;
    antlr4::Token *freelists = nullptr;
    antlr4::Token *freelist_groups = nullptr;
    Storage_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *STORAGE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> INITIAL();
    antlr4::tree::TerminalNode* INITIAL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NEXT();
    antlr4::tree::TerminalNode* NEXT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MINEXTENTS();
    antlr4::tree::TerminalNode* MINEXTENTS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MAXEXTENTS();
    antlr4::tree::TerminalNode* MAXEXTENTS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PCTINCREASE();
    antlr4::tree::TerminalNode* PCTINCREASE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FREELISTS();
    antlr4::tree::TerminalNode* FREELISTS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FREELIST();
    antlr4::tree::TerminalNode* FREELIST(size_t i);
    std::vector<antlr4::tree::TerminalNode *> GROUPS();
    antlr4::tree::TerminalNode* GROUPS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> OPTIMAL();
    antlr4::tree::TerminalNode* OPTIMAL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> BUFFER_POOL();
    antlr4::tree::TerminalNode* BUFFER_POOL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FLASH_CACHE();
    antlr4::tree::TerminalNode* FLASH_CACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CELL_FLASH_CACHE();
    antlr4::tree::TerminalNode* CELL_FLASH_CACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ENCRYPT();
    antlr4::tree::TerminalNode* ENCRYPT(size_t i);
    std::vector<Size_clauseContext *> size_clause();
    Size_clauseContext* size_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> KEEP();
    antlr4::tree::TerminalNode* KEEP(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RECYCLE();
    antlr4::tree::TerminalNode* RECYCLE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DEFAULT();
    antlr4::tree::TerminalNode* DEFAULT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NONE();
    antlr4::tree::TerminalNode* NONE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNLIMITED();
    antlr4::tree::TerminalNode* UNLIMITED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NULL_();
    antlr4::tree::TerminalNode* NULL_(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Storage_clauseContext* storage_clause();

  class  Deferred_segment_creationContext : public antlr4::ParserRuleContext {
  public:
    Deferred_segment_creationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SEGMENT();
    antlr4::tree::TerminalNode *CREATION();
    antlr4::tree::TerminalNode *IMMEDIATE();
    antlr4::tree::TerminalNode *DEFERRED();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Deferred_segment_creationContext* deferred_segment_creation();

  class  Segment_attributes_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *tablespace_name = nullptr;
    Segment_attributes_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<Table_compressionContext *> table_compression();
    Table_compressionContext* table_compression(size_t i);
    std::vector<Logging_clauseContext *> logging_clause();
    Logging_clauseContext* logging_clause(size_t i);
    std::vector<IdentifierContext *> identifier();
    IdentifierContext* identifier(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SET();
    antlr4::tree::TerminalNode* SET(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Segment_attributes_clauseContext* segment_attributes_clause();

  class  Physical_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Physical_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Deferred_segment_creationContext *deferred_segment_creation();
    Segment_attributes_clauseContext *segment_attributes_clause();
    Table_compressionContext *table_compression();
    Inmemory_table_clauseContext *inmemory_table_clause();
    Ilm_clauseContext *ilm_clause();
    antlr4::tree::TerminalNode *ORGANIZATION();
    antlr4::tree::TerminalNode *HEAP();
    Heap_org_table_clauseContext *heap_org_table_clause();
    antlr4::tree::TerminalNode *INDEX();
    antlr4::tree::TerminalNode *EXTERNAL();
    External_table_clauseContext *external_table_clause();
    Index_org_table_clauseContext *index_org_table_clause();
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *ATTRIBUTES();
    antlr4::tree::TerminalNode *REJECT();
    antlr4::tree::TerminalNode *LIMIT();
    antlr4::tree::TerminalNode *CLUSTER();
    Cluster_nameContext *cluster_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Physical_propertiesContext* physical_properties();

  class  Ilm_clauseContext : public antlr4::ParserRuleContext {
  public:
    Ilm_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ILM();
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *POLICY();
    Ilm_policy_clauseContext *ilm_policy_clause();
    antlr4::tree::TerminalNode *DELETE_ALL();
    antlr4::tree::TerminalNode *ENABLE_ALL();
    antlr4::tree::TerminalNode *DISABLE_ALL();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *DISABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Ilm_clauseContext* ilm_clause();

  class  Ilm_policy_clauseContext : public antlr4::ParserRuleContext {
  public:
    Ilm_policy_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Ilm_compression_policyContext *ilm_compression_policy();
    Ilm_tiering_policyContext *ilm_tiering_policy();
    Ilm_inmemory_policyContext *ilm_inmemory_policy();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Ilm_policy_clauseContext* ilm_policy_clause();

  class  Ilm_compression_policyContext : public antlr4::ParserRuleContext {
  public:
    Ilm_compression_policyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Table_compressionContext *table_compression();
    Segment_groupContext *segment_group();
    Ilm_after_onContext *ilm_after_on();
    std::vector<antlr4::tree::TerminalNode *> ROW();
    antlr4::tree::TerminalNode* ROW(size_t i);
    antlr4::tree::TerminalNode *AFTER();
    Ilm_time_periodContext *ilm_time_period();
    antlr4::tree::TerminalNode *OF();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *MODIFICATION();
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *COMPRESS();
    antlr4::tree::TerminalNode *COLUMN();
    antlr4::tree::TerminalNode *ADVANCED();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *QUERY();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Ilm_compression_policyContext* ilm_compression_policy();

  class  Ilm_tiering_policyContext : public antlr4::ParserRuleContext {
  public:
    Ilm_tiering_policyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TIER();
    antlr4::tree::TerminalNode *TO();
    TablespaceContext *tablespace();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *ONLY();
    Ilm_after_onContext *ilm_after_on();
    Segment_groupContext *segment_group();
    antlr4::tree::TerminalNode *ON();
    Function_nameContext *function_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Ilm_tiering_policyContext* ilm_tiering_policy();

  class  Ilm_after_onContext : public antlr4::ParserRuleContext {
  public:
    Ilm_after_onContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AFTER();
    Ilm_time_periodContext *ilm_time_period();
    antlr4::tree::TerminalNode *OF();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *CREATION();
    antlr4::tree::TerminalNode *ACCESS();
    antlr4::tree::TerminalNode *MODIFICATION();
    antlr4::tree::TerminalNode *ON();
    Function_nameContext *function_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Ilm_after_onContext* ilm_after_on();

  class  Segment_groupContext : public antlr4::ParserRuleContext {
  public:
    Segment_groupContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SEGMENT();
    antlr4::tree::TerminalNode *GROUP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Segment_groupContext* segment_group();

  class  Ilm_inmemory_policyContext : public antlr4::ParserRuleContext {
  public:
    Ilm_inmemory_policyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Ilm_after_onContext *ilm_after_on();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *INMEMORY();
    antlr4::tree::TerminalNode *MODIFY();
    Inmemory_memcompressContext *inmemory_memcompress();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *SEGMENT();
    Inmemory_attributesContext *inmemory_attributes();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Ilm_inmemory_policyContext* ilm_inmemory_policy();

  class  Ilm_time_periodContext : public antlr4::ParserRuleContext {
  public:
    Ilm_time_periodContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NumericContext *numeric();
    antlr4::tree::TerminalNode *DAY();
    antlr4::tree::TerminalNode *DAYS();
    antlr4::tree::TerminalNode *MONTH();
    antlr4::tree::TerminalNode *MONTHS();
    antlr4::tree::TerminalNode *YEAR();
    antlr4::tree::TerminalNode *YEARS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Ilm_time_periodContext* ilm_time_period();

  class  Heap_org_table_clauseContext : public antlr4::ParserRuleContext {
  public:
    Heap_org_table_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Table_compressionContext *table_compression();
    Inmemory_table_clauseContext *inmemory_table_clause();
    Ilm_clauseContext *ilm_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Heap_org_table_clauseContext* heap_org_table_clause();

  class  External_table_clauseContext : public antlr4::ParserRuleContext {
  public:
    External_table_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    External_table_data_propsContext *external_table_data_props();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *TYPE();
    Access_driver_typeContext *access_driver_type();
    Parallel_clauseContext *parallel_clause();
    antlr4::tree::TerminalNode *REJECT();
    antlr4::tree::TerminalNode *LIMIT();
    Inmemory_table_clauseContext *inmemory_table_clause();
    NumericContext *numeric();
    antlr4::tree::TerminalNode *UNLIMITED();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_clauseContext* external_table_clause();

  class  Access_driver_typeContext : public antlr4::ParserRuleContext {
  public:
    Access_driver_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ORACLE_LOADER();
    antlr4::tree::TerminalNode *ORACLE_DATAPUMP();
    antlr4::tree::TerminalNode *ORACLE_HDFS();
    antlr4::tree::TerminalNode *ORACLE_HIVE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Access_driver_typeContext* access_driver_type();

  class  External_table_data_propsContext : public antlr4::ParserRuleContext {
  public:
    External_table_data_propsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *DIRECTORY();
    std::vector<External_table_directoryContext *> external_table_directory();
    External_table_directoryContext* external_table_directory(size_t i);
    antlr4::tree::TerminalNode *ACCESS();
    antlr4::tree::TerminalNode *PARAMETERS();
    antlr4::tree::TerminalNode *LOCATION();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *CLOB();
    Select_only_statementContext *select_only_statement();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<External_table_data_formatContext *> external_table_data_format();
    External_table_data_formatContext* external_table_data_format(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_data_propsContext* external_table_data_props();

  class  External_table_data_formatContext : public antlr4::ParserRuleContext {
  public:
    External_table_data_formatContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RECORDS();
    antlr4::tree::TerminalNode *DELIMITED();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *NEWLINE_();
    antlr4::tree::TerminalNode *COLUMN();
    antlr4::tree::TerminalNode *TRANSFORMS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<External_table_transformContext *> external_table_transform();
    External_table_transformContext* external_table_transform(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    External_table_recordsContext *external_table_records();
    External_table_fieldsContext *external_table_fields();
    External_table_datapumpContext *external_table_datapump();
    External_table_hiveContext *external_table_hive();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_data_formatContext* external_table_data_format();

  class  External_table_transformContext : public antlr4::ParserRuleContext {
  public:
    External_table_transformContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    std::vector<antlr4::tree::TerminalNode *> FROM();
    antlr4::tree::TerminalNode* FROM(size_t i);
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *CONSTANT();
    Quoted_stringContext *quoted_string();
    antlr4::tree::TerminalNode *STARTOF();
    External_table_field_listContext *external_table_field_list();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *CONCAT();
    antlr4::tree::TerminalNode *LOBFILE();
    External_table_fieldContext *external_table_field();
    std::vector<External_table_directoryContext *> external_table_directory();
    External_table_directoryContext* external_table_directory(size_t i);
    antlr4::tree::TerminalNode *CLOB();
    antlr4::tree::TerminalNode *BLOB();
    antlr4::tree::TerminalNode *CHARACTERSET();
    antlr4::tree::TerminalNode *EQUALS_OP();
    Char_set_nameContext *char_set_name();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_transformContext* external_table_transform();

  class  External_table_fieldContext : public antlr4::ParserRuleContext {
  public:
    External_table_fieldContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    Type_nameContext *type_name();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *NULL_();
    Default_value_partContext *default_value_part();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_fieldContext* external_table_field();

  class  External_table_field_listContext : public antlr4::ParserRuleContext {
  public:
    External_table_field_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<External_table_fields_clauseContext *> external_table_fields_clause();
    External_table_fields_clauseContext* external_table_fields_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_field_listContext* external_table_field_list();

  class  External_table_fields_clauseContext : public antlr4::ParserRuleContext {
  public:
    External_table_fields_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    External_table_fieldContext *external_table_field();
    std::vector<External_table_position_clauseContext *> external_table_position_clause();
    External_table_position_clauseContext* external_table_position_clause(size_t i);
    std::vector<External_table_datatype_clauseContext *> external_table_datatype_clause();
    External_table_datatype_clauseContext* external_table_datatype_clause(size_t i);
    std::vector<External_table_init_clauseContext *> external_table_init_clause();
    External_table_init_clauseContext* external_table_init_clause(size_t i);
    std::vector<External_table_lls_clauseContext *> external_table_lls_clause();
    External_table_lls_clauseContext* external_table_lls_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_fields_clauseContext* external_table_fields_clause();

  class  External_table_position_clauseContext : public antlr4::ParserRuleContext {
  public:
    External_table_position_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *BINDVAR();
    antlr4::tree::TerminalNode *POSITION();
    antlr4::tree::TerminalNode *COLON();
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    antlr4::tree::TerminalNode *ASTERISK();
    std::vector<antlr4::tree::TerminalNode *> PLUS_SIGN();
    antlr4::tree::TerminalNode* PLUS_SIGN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MINUS_SIGN();
    antlr4::tree::TerminalNode* MINUS_SIGN(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_position_clauseContext* external_table_position_clause();

  class  External_table_datatype_clauseContext : public antlr4::ParserRuleContext {
  public:
    External_table_datatype_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INTEGER();
    antlr4::tree::TerminalNode *UNSIGNED();
    antlr4::tree::TerminalNode *EXTERNAL();
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    External_table_delimit_clauseContext *external_table_delimit_clause();
    antlr4::tree::TerminalNode *DECIMAL();
    antlr4::tree::TerminalNode *ZONED();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *COMMA();
    antlr4::tree::TerminalNode *ORACLE_DATE();
    antlr4::tree::TerminalNode *ORACLE_NUMBER();
    antlr4::tree::TerminalNode *COUNTED();
    antlr4::tree::TerminalNode *FLOAT();
    antlr4::tree::TerminalNode *DOUBLE();
    antlr4::tree::TerminalNode *BINARY_FLOAT();
    antlr4::tree::TerminalNode *BINARY_DOUBLE();
    antlr4::tree::TerminalNode *RAW();
    antlr4::tree::TerminalNode *CHAR();
    External_table_trim_clauseContext *external_table_trim_clause();
    External_table_date_format_clauseContext *external_table_date_format_clause();
    antlr4::tree::TerminalNode *VARCHAR();
    antlr4::tree::TerminalNode *VARRAW();
    antlr4::tree::TerminalNode *VARCHARC();
    antlr4::tree::TerminalNode *VARRAWC();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_datatype_clauseContext* external_table_datatype_clause();

  class  External_table_delimit_clauseContext : public antlr4::ParserRuleContext {
  public:
    External_table_delimit_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ENCLOSED();
    std::vector<antlr4::tree::TerminalNode *> BY();
    antlr4::tree::TerminalNode* BY(size_t i);
    std::vector<Quoted_stringContext *> quoted_string();
    Quoted_stringContext* quoted_string(size_t i);
    antlr4::tree::TerminalNode *AND();
    antlr4::tree::TerminalNode *TERMINATED();
    antlr4::tree::TerminalNode *WHITESPACE();
    antlr4::tree::TerminalNode *OPTIONALLY();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_delimit_clauseContext* external_table_delimit_clause();

  class  External_table_trim_clauseContext : public antlr4::ParserRuleContext {
  public:
    External_table_trim_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LRTRIM();
    antlr4::tree::TerminalNode *NOTRIM();
    antlr4::tree::TerminalNode *LTRIM();
    antlr4::tree::TerminalNode *RTRIM();
    antlr4::tree::TerminalNode *LDRTRIM();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_trim_clauseContext* external_table_trim_clause();

  class  External_table_date_format_clauseContext : public antlr4::ParserRuleContext {
  public:
    External_table_date_format_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DATE();
    antlr4::tree::TerminalNode *TIMESTAMP();
    antlr4::tree::TerminalNode *MASK();
    Quoted_stringContext *quoted_string();
    antlr4::tree::TerminalNode *INTERVAL();
    antlr4::tree::TerminalNode *DATE_FORMAT();
    antlr4::tree::TerminalNode *YEAR_TO_MONTH();
    antlr4::tree::TerminalNode *DAY_TO_SECOND();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *TIME();
    antlr4::tree::TerminalNode *ZONE();
    antlr4::tree::TerminalNode *LOCAL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_date_format_clauseContext* external_table_date_format_clause();

  class  External_table_init_clauseContext : public antlr4::ParserRuleContext {
  public:
    External_table_init_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    External_table_condition_clauseContext *external_table_condition_clause();
    antlr4::tree::TerminalNode *DEFAULTIF();
    antlr4::tree::TerminalNode *NULLIF();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_init_clauseContext* external_table_init_clause();

  class  External_table_condition_clauseContext : public antlr4::ParserRuleContext {
  public:
    External_table_condition_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Relational_operatorContext *relational_operator();
    Field_specContext *field_spec();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *BINDVAR();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Quoted_stringContext *quoted_string();
    antlr4::tree::TerminalNode *HEX_STRING_LIT();
    antlr4::tree::TerminalNode *BLANKS();
    std::vector<External_table_condition_clauseContext *> external_table_condition_clause();
    External_table_condition_clauseContext* external_table_condition_clause(size_t i);
    antlr4::tree::TerminalNode *AND();
    antlr4::tree::TerminalNode *OR();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_condition_clauseContext* external_table_condition_clause();
  External_table_condition_clauseContext* external_table_condition_clause(int precedence);
  class  External_table_lls_clauseContext : public antlr4::ParserRuleContext {
  public:
    External_table_lls_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LLS();
    External_table_directoryContext *external_table_directory();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_lls_clauseContext* external_table_lls_clause();

  class  External_table_recordsContext : public antlr4::ParserRuleContext {
  public:
    External_table_recordsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RECORDS();
    antlr4::tree::TerminalNode *FIXED();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *VARIABLE();
    antlr4::tree::TerminalNode *DELIMITED();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *XMLTAG();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<External_table_record_options_clauseContext *> external_table_record_options_clause();
    External_table_record_options_clauseContext* external_table_record_options_clause(size_t i);
    antlr4::tree::TerminalNode *NEWLINE_();
    Quoted_stringContext *quoted_string();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *DETECTED();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_recordsContext* external_table_records();

  class  External_table_record_options_clauseContext : public antlr4::ParserRuleContext {
  public:
    External_table_record_options_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHARACTERSET();
    Char_set_nameContext *char_set_name();
    antlr4::tree::TerminalNode *EXTERNAL();
    antlr4::tree::TerminalNode *VARIABLE();
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *PREPROCESSOR();
    External_table_directoryContext *external_table_directory();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *ENDIAN();
    antlr4::tree::TerminalNode *LITTLE();
    antlr4::tree::TerminalNode *BIG();
    antlr4::tree::TerminalNode *BYTEORDERMARK();
    antlr4::tree::TerminalNode *CHECK();
    antlr4::tree::TerminalNode *NOCHECK();
    antlr4::tree::TerminalNode *STRING();
    antlr4::tree::TerminalNode *SIZES();
    antlr4::tree::TerminalNode *ARE();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *BYTES();
    antlr4::tree::TerminalNode *CHARACTERS();
    antlr4::tree::TerminalNode *LOAD();
    antlr4::tree::TerminalNode *WHEN();
    External_table_condition_clauseContext *external_table_condition_clause();
    External_table_output_filesContext *external_table_output_files();
    antlr4::tree::TerminalNode *READSIZE();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *DISABLE_DIRECTORY_LINK_CHECK();
    antlr4::tree::TerminalNode *DATE_CACHE();
    antlr4::tree::TerminalNode *SKIP_();
    antlr4::tree::TerminalNode *IO_OPTIONS();
    antlr4::tree::TerminalNode *DIRECTIO();
    antlr4::tree::TerminalNode *NODIRECTIO();
    antlr4::tree::TerminalNode *DNFS_ENABLE();
    antlr4::tree::TerminalNode *DNFS_DISABLE();
    antlr4::tree::TerminalNode *DNFS_READBUFFERS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_record_options_clauseContext* external_table_record_options_clause();

  class  External_table_output_filesContext : public antlr4::ParserRuleContext {
  public:
    External_table_output_filesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    FilenameContext *filename();
    antlr4::tree::TerminalNode *NOBADFILE();
    antlr4::tree::TerminalNode *NODISCARDFILE();
    antlr4::tree::TerminalNode *NOLOGFILE();
    antlr4::tree::TerminalNode *BADFILE();
    antlr4::tree::TerminalNode *DISCARDFILE();
    antlr4::tree::TerminalNode *LOGFILE();
    External_table_directoryContext *external_table_directory();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_output_filesContext* external_table_output_files();

  class  External_table_fieldsContext : public antlr4::ParserRuleContext {
  public:
    External_table_fieldsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> FIELDS();
    antlr4::tree::TerminalNode* FIELDS(size_t i);
    antlr4::tree::TerminalNode *IGNORE_CHARS_AFTER_EOR();
    antlr4::tree::TerminalNode *CSV();
    antlr4::tree::TerminalNode *EMBEDDED();
    External_table_delimit_clauseContext *external_table_delimit_clause();
    External_table_trim_clauseContext *external_table_trim_clause();
    std::vector<antlr4::tree::TerminalNode *> ALL();
    antlr4::tree::TerminalNode* ALL(size_t i);
    antlr4::tree::TerminalNode *OVERRIDE();
    antlr4::tree::TerminalNode *THESE();
    antlr4::tree::TerminalNode *MISSING();
    antlr4::tree::TerminalNode *FIELD();
    antlr4::tree::TerminalNode *VALUES();
    antlr4::tree::TerminalNode *ARE();
    std::vector<antlr4::tree::TerminalNode *> NULL_();
    antlr4::tree::TerminalNode* NULL_(size_t i);
    antlr4::tree::TerminalNode *REJECT();
    antlr4::tree::TerminalNode *ROWS();
    std::vector<antlr4::tree::TerminalNode *> WITH();
    antlr4::tree::TerminalNode* WITH(size_t i);
    antlr4::tree::TerminalNode *DATE_FORMAT();
    antlr4::tree::TerminalNode *MASK();
    std::vector<Quoted_stringContext *> quoted_string();
    Quoted_stringContext* quoted_string(size_t i);
    antlr4::tree::TerminalNode *NULLIF();
    antlr4::tree::TerminalNode *NONULLIF();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    External_table_field_listContext *external_table_field_list();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *WITHOUT();
    antlr4::tree::TerminalNode *DATE();
    antlr4::tree::TerminalNode *TIMESTAMP();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *NOT_EQUAL_OP();
    antlr4::tree::TerminalNode *HEX_STRING_LIT();
    antlr4::tree::TerminalNode *BLANKS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_fieldsContext* external_table_fields();

  class  External_table_datapumpContext : public antlr4::ParserRuleContext {
  public:
    External_table_datapumpContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ENCRYPTION();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *DISABLED();
    antlr4::tree::TerminalNode *NOLOGFILE();
    antlr4::tree::TerminalNode *LOGFILE();
    FilenameContext *filename();
    External_table_directoryContext *external_table_directory();
    antlr4::tree::TerminalNode *COMPRESSION();
    antlr4::tree::TerminalNode *ENABLED();
    antlr4::tree::TerminalNode *BASIC();
    antlr4::tree::TerminalNode *LOW();
    antlr4::tree::TerminalNode *MEDIUM();
    antlr4::tree::TerminalNode *HIGH();
    antlr4::tree::TerminalNode *HADOOP_TRAILERS();
    antlr4::tree::TerminalNode *VERSION();
    antlr4::tree::TerminalNode *COMPATIBLE();
    antlr4::tree::TerminalNode *LATEST();
    Quoted_stringContext *quoted_string();
    antlr4::tree::TerminalNode *NOLOG();
    antlr4::tree::TerminalNode *DEBUG();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *DATAPUMP();
    antlr4::tree::TerminalNode *INTERNAL();
    antlr4::tree::TerminalNode *TABLE();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *TEMPLATE_TABLE();
    antlr4::tree::TerminalNode *JOB();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *WORKERID();
    antlr4::tree::TerminalNode *PARALLEL();
    antlr4::tree::TerminalNode *ENCRYPTPASSWORDISNULL();
    antlr4::tree::TerminalNode *DBLINK();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_datapumpContext* external_table_datapump();

  class  External_table_hiveContext : public antlr4::ParserRuleContext {
  public:
    External_table_hiveContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> EQUALS_OP();
    antlr4::tree::TerminalNode* EQUALS_OP(size_t i);
    antlr4::tree::TerminalNode *COLON();
    Tableview_nameContext *tableview_name();
    std::vector<External_table_hive_parameter_mapContext *> external_table_hive_parameter_map();
    External_table_hive_parameter_mapContext* external_table_hive_parameter_map(size_t i);
    antlr4::tree::TerminalNode *LEFT_BRACKET();
    antlr4::tree::TerminalNode *RIGHT_BRACKET();
    External_table_fieldContext *external_table_field();
    DatatypeContext *datatype();
    antlr4::tree::TerminalNode *SEQUENCEFILE();
    antlr4::tree::TerminalNode *TEXTFILE();
    antlr4::tree::TerminalNode *RCFILE();
    antlr4::tree::TerminalNode *ORC();
    antlr4::tree::TerminalNode *PARQUET();
    antlr4::tree::TerminalNode *INPUTFORMAT();
    std::vector<Quoted_stringContext *> quoted_string();
    Quoted_stringContext* quoted_string(size_t i);
    antlr4::tree::TerminalNode *OUTPUTFORMAT();
    External_table_directoryContext *external_table_directory();
    antlr4::tree::TerminalNode *SERDE();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    External_table_hiveContext *external_table_hive();
    antlr4::tree::TerminalNode *FIELDS();
    antlr4::tree::TerminalNode *TERMINATED();
    std::vector<antlr4::tree::TerminalNode *> BY();
    antlr4::tree::TerminalNode* BY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CHARACTER();
    antlr4::tree::TerminalNode* CHARACTER(size_t i);
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *DEFINED();
    antlr4::tree::TerminalNode *AS();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMENT();
    antlr4::tree::TerminalNode* COMMENT(size_t i);
    antlr4::tree::TerminalNode *DELIMITED();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *SERDEPROPERTIES();
    antlr4::tree::TerminalNode *ESCAPED();
    antlr4::tree::TerminalNode *COLLECTION();
    antlr4::tree::TerminalNode *ITEMS();
    antlr4::tree::TerminalNode *MAP();
    antlr4::tree::TerminalNode *KEYS();
    antlr4::tree::TerminalNode *LINES();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_hiveContext* external_table_hive();

  class  External_table_hive_parameter_mapContext : public antlr4::ParserRuleContext {
  public:
    External_table_hive_parameter_mapContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_CURLY_PAREN();
    antlr4::tree::TerminalNode *RIGHT_CURLY_PAREN();
    std::vector<External_table_hive_parameter_map_entryContext *> external_table_hive_parameter_map_entry();
    External_table_hive_parameter_map_entryContext* external_table_hive_parameter_map_entry(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_hive_parameter_mapContext* external_table_hive_parameter_map();

  class  External_table_hive_parameter_map_entryContext : public antlr4::ParserRuleContext {
  public:
    External_table_hive_parameter_map_entryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *BINDVAR();
    antlr4::tree::TerminalNode *COLON();
    antlr4::tree::TerminalNode *LEFT_BRACKET();
    antlr4::tree::TerminalNode *RIGHT_BRACKET();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_hive_parameter_map_entryContext* external_table_hive_parameter_map_entry();

  class  External_table_directoryContext : public antlr4::ParserRuleContext {
  public:
    External_table_directoryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Directory_nameContext *directory_name();
    antlr4::tree::TerminalNode *COLON();
    antlr4::tree::TerminalNode *CHAR_STRING();
    Object_nameContext *object_name();
    Quoted_stringContext *quoted_string();
    Variable_nameContext *variable_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  External_table_directoryContext* external_table_directory();

  class  Row_movement_clauseContext : public antlr4::ParserRuleContext {
  public:
    Row_movement_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ROW();
    antlr4::tree::TerminalNode *MOVEMENT();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *DISABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Row_movement_clauseContext* row_movement_clause();

  class  Flashback_archive_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *fa = nullptr;
    Flashback_archive_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FLASHBACK();
    antlr4::tree::TerminalNode *ARCHIVE();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *NO();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Flashback_archive_clauseContext* flashback_archive_clause();

  class  Log_grpContext : public antlr4::ParserRuleContext {
  public:
    Log_grpContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    IdentifierContext *identifier();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Log_grpContext* log_grp();

  class  Supplemental_table_loggingContext : public antlr4::ParserRuleContext {
  public:
    Supplemental_table_loggingContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    std::vector<antlr4::tree::TerminalNode *> SUPPLEMENTAL();
    antlr4::tree::TerminalNode* SUPPLEMENTAL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LOG();
    antlr4::tree::TerminalNode* LOG(size_t i);
    std::vector<Supplemental_log_grp_clauseContext *> supplemental_log_grp_clause();
    Supplemental_log_grp_clauseContext* supplemental_log_grp_clause(size_t i);
    std::vector<Supplemental_id_key_clauseContext *> supplemental_id_key_clause();
    Supplemental_id_key_clauseContext* supplemental_id_key_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *DROP();
    std::vector<antlr4::tree::TerminalNode *> GROUP();
    antlr4::tree::TerminalNode* GROUP(size_t i);
    std::vector<Log_grpContext *> log_grp();
    Log_grpContext* log_grp(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Supplemental_table_loggingContext* supplemental_table_logging();

  class  Supplemental_log_grp_clauseContext : public antlr4::ParserRuleContext {
  public:
    Supplemental_log_grp_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GROUP();
    Log_grpContext *log_grp();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> NO();
    antlr4::tree::TerminalNode* NO(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LOG();
    antlr4::tree::TerminalNode* LOG(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *ALWAYS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Supplemental_log_grp_clauseContext* supplemental_log_grp_clause();

  class  Supplemental_id_key_clauseContext : public antlr4::ParserRuleContext {
  public:
    Supplemental_id_key_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *COLUMNS();
    std::vector<antlr4::tree::TerminalNode *> ALL();
    antlr4::tree::TerminalNode* ALL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PRIMARY();
    antlr4::tree::TerminalNode* PRIMARY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> KEY();
    antlr4::tree::TerminalNode* KEY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNIQUE();
    antlr4::tree::TerminalNode* UNIQUE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FOREIGN();
    antlr4::tree::TerminalNode* FOREIGN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<antlr4::tree::TerminalNode *> INDEX();
    antlr4::tree::TerminalNode* INDEX(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Supplemental_id_key_clauseContext* supplemental_id_key_clause();

  class  Allocate_extent_clauseContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *datafile = nullptr;
    antlr4::Token *inst_num = nullptr;
    Allocate_extent_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALLOCATE();
    antlr4::tree::TerminalNode *EXTENT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> SIZE();
    antlr4::tree::TerminalNode* SIZE(size_t i);
    std::vector<Size_clauseContext *> size_clause();
    Size_clauseContext* size_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DATAFILE();
    antlr4::tree::TerminalNode* DATAFILE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> INSTANCE();
    antlr4::tree::TerminalNode* INSTANCE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Allocate_extent_clauseContext* allocate_extent_clause();

  class  Deallocate_unused_clauseContext : public antlr4::ParserRuleContext {
  public:
    Deallocate_unused_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEALLOCATE();
    antlr4::tree::TerminalNode *UNUSED();
    antlr4::tree::TerminalNode *KEEP();
    Size_clauseContext *size_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Deallocate_unused_clauseContext* deallocate_unused_clause();

  class  Shrink_clauseContext : public antlr4::ParserRuleContext {
  public:
    Shrink_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SHRINK();
    antlr4::tree::TerminalNode *SPACE_KEYWORD();
    antlr4::tree::TerminalNode *COMPACT();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *CHECK();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Shrink_clauseContext* shrink_clause();

  class  Records_per_block_clauseContext : public antlr4::ParserRuleContext {
  public:
    Records_per_block_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RECORDS_PER_BLOCK();
    antlr4::tree::TerminalNode *MINIMIZE();
    antlr4::tree::TerminalNode *NOMINIMIZE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Records_per_block_clauseContext* records_per_block_clause();

  class  Upgrade_table_clauseContext : public antlr4::ParserRuleContext {
  public:
    Upgrade_table_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UPGRADE();
    Column_propertiesContext *column_properties();
    antlr4::tree::TerminalNode *INCLUDING();
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *NOT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Upgrade_table_clauseContext* upgrade_table_clause();

  class  Truncate_tableContext : public antlr4::ParserRuleContext {
  public:
    Truncate_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TRUNCATE();
    antlr4::tree::TerminalNode *TABLE();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *STORAGE();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *PRESERVE();
    antlr4::tree::TerminalNode *PURGE();
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *VIEW();
    antlr4::tree::TerminalNode *LOG();
    antlr4::tree::TerminalNode *ALL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Truncate_tableContext* truncate_table();

  class  Drop_tableContext : public antlr4::ParserRuleContext {
  public:
    Drop_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *TABLE();
    std::vector<Tableview_nameContext *> tableview_name();
    Tableview_nameContext* tableview_name(size_t i);
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *EXISTS();
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *PURGE();
    Table_aliasContext *table_alias();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *CONSTRAINT();
    antlr4::tree::TerminalNode *CONSTRAINTS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_tableContext* drop_table();

  class  Drop_tablespaceContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *ts = nullptr;
    Drop_tablespaceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> DROP();
    antlr4::tree::TerminalNode* DROP(size_t i);
    antlr4::tree::TerminalNode *TABLESPACE();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *EXISTS();
    Including_contents_clauseContext *including_contents_clause();
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *QUOTA();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_tablespaceContext* drop_tablespace();

  class  Drop_tablespace_setContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *tss = nullptr;
    Drop_tablespace_setContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *TABLESPACE();
    antlr4::tree::TerminalNode *SET();
    Id_expressionContext *id_expression();
    Including_contents_clauseContext *including_contents_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_tablespace_setContext* drop_tablespace_set();

  class  Including_contents_clauseContext : public antlr4::ParserRuleContext {
  public:
    Including_contents_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INCLUDING();
    antlr4::tree::TerminalNode *CONTENTS();
    antlr4::tree::TerminalNode *DATAFILES();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *CONSTRAINTS();
    antlr4::tree::TerminalNode *AND();
    antlr4::tree::TerminalNode *KEEP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Including_contents_clauseContext* including_contents_clause();

  class  Drop_viewContext : public antlr4::ParserRuleContext {
  public:
    Drop_viewContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *VIEW();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *EXISTS();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *CONSTRAINT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_viewContext* drop_view();

  class  Comment_on_columnContext : public antlr4::ParserRuleContext {
  public:
    Comment_on_columnContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COMMENT();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *COLUMN();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *IS();
    Quoted_stringContext *quoted_string();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Comment_on_columnContext* comment_on_column();

  class  Enable_or_disableContext : public antlr4::ParserRuleContext {
  public:
    Enable_or_disableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *DISABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Enable_or_disableContext* enable_or_disable();

  class  Allow_or_disallowContext : public antlr4::ParserRuleContext {
  public:
    Allow_or_disallowContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALLOW();
    antlr4::tree::TerminalNode *DISALLOW();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Allow_or_disallowContext* allow_or_disallow();

  class  Alter_synonymContext : public antlr4::ParserRuleContext {
  public:
    Alter_synonymContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *SYNONYM();
    Synonym_nameContext *synonym_name();
    antlr4::tree::TerminalNode *EDITIONABLE();
    antlr4::tree::TerminalNode *NONEDITIONABLE();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *PUBLIC();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_synonymContext* alter_synonym();

  class  Create_synonymContext : public antlr4::ParserRuleContext {
  public:
    Create_synonymContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *PUBLIC();
    antlr4::tree::TerminalNode *SYNONYM();
    Synonym_nameContext *synonym_name();
    antlr4::tree::TerminalNode *FOR();
    Schema_object_nameContext *schema_object_name();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    std::vector<Schema_nameContext *> schema_name();
    Schema_nameContext* schema_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    antlr4::tree::TerminalNode *AT_SIGN();
    Link_nameContext *link_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_synonymContext* create_synonym();

  class  Drop_synonymContext : public antlr4::ParserRuleContext {
  public:
    Drop_synonymContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *SYNONYM();
    Synonym_nameContext *synonym_name();
    antlr4::tree::TerminalNode *PUBLIC();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *FORCE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_synonymContext* drop_synonym();

  class  Create_spfileContext : public antlr4::ParserRuleContext {
  public:
    Create_spfileContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *SPFILE();
    antlr4::tree::TerminalNode *FROM();
    antlr4::tree::TerminalNode *PFILE();
    antlr4::tree::TerminalNode *MEMORY();
    std::vector<antlr4::tree::TerminalNode *> EQUALS_OP();
    antlr4::tree::TerminalNode* EQUALS_OP(size_t i);
    Spfile_nameContext *spfile_name();
    Pfile_nameContext *pfile_name();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *COPY();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_spfileContext* create_spfile();

  class  Spfile_nameContext : public antlr4::ParserRuleContext {
  public:
    Spfile_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Spfile_nameContext* spfile_name();

  class  Pfile_nameContext : public antlr4::ParserRuleContext {
  public:
    Pfile_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pfile_nameContext* pfile_name();

  class  Comment_on_tableContext : public antlr4::ParserRuleContext {
  public:
    Comment_on_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COMMENT();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *TABLE();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *IS();
    Quoted_stringContext *quoted_string();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Comment_on_tableContext* comment_on_table();

  class  Comment_on_materializedContext : public antlr4::ParserRuleContext {
  public:
    Comment_on_materializedContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COMMENT();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *VIEW();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *IS();
    Quoted_stringContext *quoted_string();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Comment_on_materializedContext* comment_on_materialized();

  class  Alter_analytic_viewContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *av = nullptr;
    Alter_analytic_viewContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *ANALYTIC();
    antlr4::tree::TerminalNode *VIEW();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *COMPILE();
    Alter_add_cache_clauseContext *alter_add_cache_clause();
    Alter_drop_cache_clauseContext *alter_drop_cache_clause();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_analytic_viewContext* alter_analytic_view();

  class  Alter_add_cache_clauseContext : public antlr4::ParserRuleContext {
  public:
    Alter_add_cache_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *CACHE();
    antlr4::tree::TerminalNode *MEASURE();
    antlr4::tree::TerminalNode *GROUP();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *LEVELS();
    std::vector<Levels_itemContext *> levels_item();
    Levels_itemContext* levels_item(size_t i);
    antlr4::tree::TerminalNode *ALL();
    Measure_listContext *measure_list();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_add_cache_clauseContext* alter_add_cache_clause();

  class  Levels_itemContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *d = nullptr;
    PlSqlParser::Id_expressionContext *h = nullptr;
    PlSqlParser::Id_expressionContext *l = nullptr;
    Levels_itemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Levels_itemContext* levels_item();

  class  Measure_listContext : public antlr4::ParserRuleContext {
  public:
    Measure_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Measure_listContext* measure_list();

  class  Alter_drop_cache_clauseContext : public antlr4::ParserRuleContext {
  public:
    Alter_drop_cache_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *CACHE();
    antlr4::tree::TerminalNode *MEASURE();
    antlr4::tree::TerminalNode *GROUP();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *LEVELS();
    std::vector<Levels_itemContext *> levels_item();
    Levels_itemContext* levels_item(size_t i);
    antlr4::tree::TerminalNode *ALL();
    Measure_listContext *measure_list();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_drop_cache_clauseContext* alter_drop_cache_clause();

  class  Alter_attribute_dimensionContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *ad = nullptr;
    PlSqlParser::Id_expressionContext *nad = nullptr;
    Alter_attribute_dimensionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *ATTRIBUTE();
    antlr4::tree::TerminalNode *DIMENSION();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *COMPILE();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_attribute_dimensionContext* alter_attribute_dimension();

  class  Alter_audit_policyContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *p = nullptr;
    Alter_audit_policyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *AUDIT();
    antlr4::tree::TerminalNode *POLICY();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *ADD();
    std::vector<antlr4::tree::TerminalNode *> DROP();
    antlr4::tree::TerminalNode* DROP(size_t i);
    antlr4::tree::TerminalNode *CONDITION();
    std::vector<Privilege_audit_clauseContext *> privilege_audit_clause();
    Privilege_audit_clauseContext* privilege_audit_clause(size_t i);
    std::vector<Action_audit_clauseContext *> action_audit_clause();
    Action_audit_clauseContext* action_audit_clause(size_t i);
    std::vector<Role_audit_clauseContext *> role_audit_clause();
    Role_audit_clauseContext* role_audit_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ONLY();
    antlr4::tree::TerminalNode* ONLY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TOPLEVEL();
    antlr4::tree::TerminalNode* TOPLEVEL(size_t i);
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *EVALUATE();
    antlr4::tree::TerminalNode *PER();
    antlr4::tree::TerminalNode *STATEMENT();
    antlr4::tree::TerminalNode *SESSION();
    antlr4::tree::TerminalNode *INSTANCE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_audit_policyContext* alter_audit_policy();

  class  Alter_clusterContext : public antlr4::ParserRuleContext {
  public:
    Alter_clusterContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *CLUSTER();
    Cluster_nameContext *cluster_name();
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SIZE();
    antlr4::tree::TerminalNode* SIZE(size_t i);
    std::vector<Size_clauseContext *> size_clause();
    Size_clauseContext* size_clause(size_t i);
    std::vector<Allocate_extent_clauseContext *> allocate_extent_clause();
    Allocate_extent_clauseContext* allocate_extent_clause(size_t i);
    std::vector<Deallocate_unused_clauseContext *> deallocate_unused_clause();
    Deallocate_unused_clauseContext* deallocate_unused_clause(size_t i);
    std::vector<Cache_or_nocacheContext *> cache_or_nocache();
    Cache_or_nocacheContext* cache_or_nocache(size_t i);
    Parallel_clauseContext *parallel_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_clusterContext* alter_cluster();

  class  Drop_analytic_viewContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *av = nullptr;
    Drop_analytic_viewContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *ANALYTIC();
    antlr4::tree::TerminalNode *VIEW();
    Id_expressionContext *id_expression();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_analytic_viewContext* drop_analytic_view();

  class  Drop_attribute_dimensionContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *ad = nullptr;
    Drop_attribute_dimensionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *ATTRIBUTE();
    antlr4::tree::TerminalNode *DIMENSION();
    Id_expressionContext *id_expression();
    Schema_nameContext *schema_name();
    antlr4::tree::TerminalNode *PERIOD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_attribute_dimensionContext* drop_attribute_dimension();

  class  Drop_audit_policyContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *p = nullptr;
    Drop_audit_policyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *AUDIT();
    antlr4::tree::TerminalNode *POLICY();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_audit_policyContext* drop_audit_policy();

  class  Drop_flashback_archiveContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *fa = nullptr;
    Drop_flashback_archiveContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *FLASHBACK();
    antlr4::tree::TerminalNode *ARCHIVE();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_flashback_archiveContext* drop_flashback_archive();

  class  Drop_clusterContext : public antlr4::ParserRuleContext {
  public:
    Drop_clusterContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *CLUSTER();
    Cluster_nameContext *cluster_name();
    antlr4::tree::TerminalNode *INCLUDING();
    antlr4::tree::TerminalNode *TABLES();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *CONSTRAINTS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_clusterContext* drop_cluster();

  class  Drop_contextContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *ns = nullptr;
    Drop_contextContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *CONTEXT();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_contextContext* drop_context();

  class  Drop_directoryContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *dn = nullptr;
    Drop_directoryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *DIRECTORY();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_directoryContext* drop_directory();

  class  Drop_diskgroupContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *dgn = nullptr;
    Drop_diskgroupContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *DISKGROUP();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *CONTENTS();
    antlr4::tree::TerminalNode *INCLUDING();
    antlr4::tree::TerminalNode *EXCLUDING();
    antlr4::tree::TerminalNode *FORCE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_diskgroupContext* drop_diskgroup();

  class  Drop_editionContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *e = nullptr;
    Drop_editionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *EDITION();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *CASCADE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_editionContext* drop_edition();

  class  Truncate_clusterContext : public antlr4::ParserRuleContext {
  public:
    Truncate_clusterContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TRUNCATE();
    antlr4::tree::TerminalNode *CLUSTER();
    Cluster_nameContext *cluster_name();
    antlr4::tree::TerminalNode *STORAGE();
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *REUSE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Truncate_clusterContext* truncate_cluster();

  class  Cache_or_nocacheContext : public antlr4::ParserRuleContext {
  public:
    Cache_or_nocacheContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CACHE();
    antlr4::tree::TerminalNode *NOCACHE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cache_or_nocacheContext* cache_or_nocache();

  class  Database_nameContext : public antlr4::ParserRuleContext {
  public:
    Database_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Database_nameContext* database_name();

  class  Alter_databaseContext : public antlr4::ParserRuleContext {
  public:
    Alter_databaseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    Database_clauseContext *database_clause();
    Startup_clausesContext *startup_clauses();
    Recovery_clausesContext *recovery_clauses();
    Database_file_clausesContext *database_file_clauses();
    Logfile_clausesContext *logfile_clauses();
    Controlfile_clausesContext *controlfile_clauses();
    Standby_database_clausesContext *standby_database_clauses();
    Default_settings_clauseContext *default_settings_clause();
    Instance_clausesContext *instance_clauses();
    Security_clauseContext *security_clause();
    Prepare_clauseContext *prepare_clause();
    Drop_mirror_clauseContext *drop_mirror_clause();
    Lost_write_protectionContext *lost_write_protection();
    Cdb_fleet_clausesContext *cdb_fleet_clauses();
    Property_clausesContext *property_clauses();
    Replay_upgrade_clausesContext *replay_upgrade_clauses();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_databaseContext* alter_database();

  class  Database_clauseContext : public antlr4::ParserRuleContext {
  public:
    Database_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *PLUGGABLE();
    Database_nameContext *database_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Database_clauseContext* database_clause();

  class  Startup_clausesContext : public antlr4::ParserRuleContext {
  public:
    Startup_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MOUNT();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *CLONE();
    antlr4::tree::TerminalNode *OPEN();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *WRITE();
    Resetlogs_or_noresetlogsContext *resetlogs_or_noresetlogs();
    Upgrade_or_downgradeContext *upgrade_or_downgrade();
    antlr4::tree::TerminalNode *ONLY();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Startup_clausesContext* startup_clauses();

  class  Resetlogs_or_noresetlogsContext : public antlr4::ParserRuleContext {
  public:
    Resetlogs_or_noresetlogsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RESETLOGS();
    antlr4::tree::TerminalNode *NORESETLOGS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Resetlogs_or_noresetlogsContext* resetlogs_or_noresetlogs();

  class  Upgrade_or_downgradeContext : public antlr4::ParserRuleContext {
  public:
    Upgrade_or_downgradeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UPGRADE();
    antlr4::tree::TerminalNode *DOWNGRADE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Upgrade_or_downgradeContext* upgrade_or_downgrade();

  class  Recovery_clausesContext : public antlr4::ParserRuleContext {
  public:
    Recovery_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    General_recoveryContext *general_recovery();
    Managed_standby_recoveryContext *managed_standby_recovery();
    Begin_or_endContext *begin_or_end();
    antlr4::tree::TerminalNode *BACKUP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Recovery_clausesContext* recovery_clauses();

  class  Begin_or_endContext : public antlr4::ParserRuleContext {
  public:
    Begin_or_endContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BEGIN();
    antlr4::tree::TerminalNode *END();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Begin_or_endContext* begin_or_end();

  class  General_recoveryContext : public antlr4::ParserRuleContext {
  public:
    General_recoveryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RECOVER();
    antlr4::tree::TerminalNode *CONTINUE();
    antlr4::tree::TerminalNode *CANCEL();
    antlr4::tree::TerminalNode *AUTOMATIC();
    antlr4::tree::TerminalNode *FROM();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    Full_database_recoveryContext *full_database_recovery();
    Partial_database_recoveryContext *partial_database_recovery();
    antlr4::tree::TerminalNode *LOGFILE();
    antlr4::tree::TerminalNode *DEFAULT();
    std::vector<antlr4::tree::TerminalNode *> TEST();
    antlr4::tree::TerminalNode* TEST(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ALLOW();
    antlr4::tree::TerminalNode* ALLOW(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CORRUPTION();
    antlr4::tree::TerminalNode* CORRUPTION(size_t i);
    std::vector<Parallel_clauseContext *> parallel_clause();
    Parallel_clauseContext* parallel_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  General_recoveryContext* general_recovery();

  class  Full_database_recoveryContext : public antlr4::ParserRuleContext {
  public:
    Full_database_recoveryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *STANDBY();
    std::vector<antlr4::tree::TerminalNode *> UNTIL();
    antlr4::tree::TerminalNode* UNTIL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> USING();
    antlr4::tree::TerminalNode* USING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> BACKUP();
    antlr4::tree::TerminalNode* BACKUP(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CONTROLFILE();
    antlr4::tree::TerminalNode* CONTROLFILE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SNAPSHOT();
    antlr4::tree::TerminalNode* SNAPSHOT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TIME();
    antlr4::tree::TerminalNode* TIME(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CANCEL();
    antlr4::tree::TerminalNode* CANCEL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CHANGE();
    antlr4::tree::TerminalNode* CHANGE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CONSISTENT();
    antlr4::tree::TerminalNode* CONSISTENT(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Full_database_recoveryContext* full_database_recovery();

  class  Partial_database_recoveryContext : public antlr4::ParserRuleContext {
  public:
    Partial_database_recoveryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLESPACE();
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *DATAFILE();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    std::vector<FilenumberContext *> filenumber();
    FilenumberContext* filenumber(size_t i);
    Partial_database_recovery_10gContext *partial_database_recovery_10g();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partial_database_recoveryContext* partial_database_recovery();

  class  Partial_database_recovery_10gContext : public antlr4::ParserRuleContext {
  public:
    Partial_database_recovery_10gContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *UNTIL();
    antlr4::tree::TerminalNode *CONTROLFILE();
    antlr4::tree::TerminalNode *TABLESPACE();
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    antlr4::tree::TerminalNode *DATAFILE();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    std::vector<FilenumberContext *> filenumber();
    FilenumberContext* filenumber(size_t i);
    antlr4::tree::TerminalNode *CONSISTENT();
    antlr4::tree::TerminalNode *WITH();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partial_database_recovery_10gContext* partial_database_recovery_10g();

  class  Managed_standby_recoveryContext : public antlr4::ParserRuleContext {
  public:
    Managed_standby_recoveryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RECOVER();
    antlr4::tree::TerminalNode *MANAGED();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *LOGICAL();
    Db_nameContext *db_name();
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *IDENTITY();
    antlr4::tree::TerminalNode *FINISH();
    antlr4::tree::TerminalNode *CANCEL();
    std::vector<antlr4::tree::TerminalNode *> USING();
    antlr4::tree::TerminalNode* USING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CURRENT();
    antlr4::tree::TerminalNode* CURRENT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LOGFILE();
    antlr4::tree::TerminalNode* LOGFILE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DISCONNECT();
    antlr4::tree::TerminalNode* DISCONNECT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NODELAY();
    antlr4::tree::TerminalNode* NODELAY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNTIL();
    antlr4::tree::TerminalNode* UNTIL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CHANGE();
    antlr4::tree::TerminalNode* CHANGE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CONSISTENT();
    antlr4::tree::TerminalNode* CONSISTENT(size_t i);
    std::vector<Parallel_clauseContext *> parallel_clause();
    Parallel_clauseContext* parallel_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FROM();
    antlr4::tree::TerminalNode* FROM(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SESSION();
    antlr4::tree::TerminalNode* SESSION(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Managed_standby_recoveryContext* managed_standby_recovery();

  class  Db_nameContext : public antlr4::ParserRuleContext {
  public:
    Db_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Db_nameContext* db_name();

  class  Database_file_clausesContext : public antlr4::ParserRuleContext {
  public:
    Database_file_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *FILE();
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    antlr4::tree::TerminalNode *TO();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Create_datafile_clauseContext *create_datafile_clause();
    Alter_datafile_clauseContext *alter_datafile_clause();
    Alter_tempfile_clauseContext *alter_tempfile_clause();
    Move_datafile_clauseContext *move_datafile_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Database_file_clausesContext* database_file_clauses();

  class  Create_datafile_clauseContext : public antlr4::ParserRuleContext {
  public:
    Create_datafile_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *DATAFILE();
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    std::vector<FilenumberContext *> filenumber();
    FilenumberContext* filenumber(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *NEW();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_datafile_clauseContext* create_datafile_clause();

  class  Alter_datafile_clauseContext : public antlr4::ParserRuleContext {
  public:
    Alter_datafile_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DATAFILE();
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    std::vector<FilenumberContext *> filenumber();
    FilenumberContext* filenumber(size_t i);
    antlr4::tree::TerminalNode *ONLINE();
    antlr4::tree::TerminalNode *OFFLINE();
    antlr4::tree::TerminalNode *RESIZE();
    Size_clauseContext *size_clause();
    Autoextend_clauseContext *autoextend_clause();
    antlr4::tree::TerminalNode *END();
    antlr4::tree::TerminalNode *BACKUP();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *DROP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_datafile_clauseContext* alter_datafile_clause();

  class  Alter_tempfile_clauseContext : public antlr4::ParserRuleContext {
  public:
    Alter_tempfile_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TEMPFILE();
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    std::vector<FilenumberContext *> filenumber();
    FilenumberContext* filenumber(size_t i);
    antlr4::tree::TerminalNode *RESIZE();
    Size_clauseContext *size_clause();
    Autoextend_clauseContext *autoextend_clause();
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *ONLINE();
    antlr4::tree::TerminalNode *OFFLINE();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *INCLUDING();
    antlr4::tree::TerminalNode *DATAFILES();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_tempfile_clauseContext* alter_tempfile_clause();

  class  Move_datafile_clauseContext : public antlr4::ParserRuleContext {
  public:
    Move_datafile_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MOVE();
    antlr4::tree::TerminalNode *DATAFILE();
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    std::vector<FilenumberContext *> filenumber();
    FilenumberContext* filenumber(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *KEEP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Move_datafile_clauseContext* move_datafile_clause();

  class  Logfile_clausesContext : public antlr4::ParserRuleContext {
  public:
    Logfile_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ARCHIVELOG();
    antlr4::tree::TerminalNode *NOARCHIVELOG();
    antlr4::tree::TerminalNode *MANUAL();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *LOGGING();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *NOLOGGING();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *AVAILABILITY();
    antlr4::tree::TerminalNode *LOAD();
    antlr4::tree::TerminalNode *PERFORMANCE();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *FILE();
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    antlr4::tree::TerminalNode *TO();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *CLEAR();
    antlr4::tree::TerminalNode *LOGFILE();
    std::vector<Logfile_descriptorContext *> logfile_descriptor();
    Logfile_descriptorContext* logfile_descriptor(size_t i);
    antlr4::tree::TerminalNode *UNARCHIVED();
    antlr4::tree::TerminalNode *UNRECOVERABLE();
    antlr4::tree::TerminalNode *DATAFILE();
    Add_logfile_clausesContext *add_logfile_clauses();
    Drop_logfile_clausesContext *drop_logfile_clauses();
    Switch_logfile_clauseContext *switch_logfile_clause();
    Supplemental_db_loggingContext *supplemental_db_logging();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Logfile_clausesContext* logfile_clauses();

  class  Add_logfile_clausesContext : public antlr4::ParserRuleContext {
  public:
    Add_logfile_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *LOGFILE();
    antlr4::tree::TerminalNode *MEMBER();
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    antlr4::tree::TerminalNode *TO();
    std::vector<Logfile_descriptorContext *> logfile_descriptor();
    Logfile_descriptorContext* logfile_descriptor(size_t i);
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *INSTANCE();
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *THREAD();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    std::vector<Group_redo_logfileContext *> group_redo_logfile();
    Group_redo_logfileContext* group_redo_logfile(size_t i);
    std::vector<antlr4::tree::TerminalNode *> REUSE();
    antlr4::tree::TerminalNode* REUSE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_logfile_clausesContext* add_logfile_clauses();

  class  Group_redo_logfileContext : public antlr4::ParserRuleContext {
  public:
    Group_redo_logfileContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Redo_log_file_specContext *redo_log_file_spec();
    antlr4::tree::TerminalNode *GROUP();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Group_redo_logfileContext* group_redo_logfile();

  class  Drop_logfile_clausesContext : public antlr4::ParserRuleContext {
  public:
    Drop_logfile_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *LOGFILE();
    std::vector<Logfile_descriptorContext *> logfile_descriptor();
    Logfile_descriptorContext* logfile_descriptor(size_t i);
    antlr4::tree::TerminalNode *MEMBER();
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    antlr4::tree::TerminalNode *STANDBY();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_logfile_clausesContext* drop_logfile_clauses();

  class  Switch_logfile_clauseContext : public antlr4::ParserRuleContext {
  public:
    Switch_logfile_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SWITCH();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *LOGFILES();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *BLOCKSIZE();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Switch_logfile_clauseContext* switch_logfile_clause();

  class  Supplemental_db_loggingContext : public antlr4::ParserRuleContext {
  public:
    Supplemental_db_loggingContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Add_or_dropContext *add_or_drop();
    antlr4::tree::TerminalNode *SUPPLEMENTAL();
    antlr4::tree::TerminalNode *LOG();
    antlr4::tree::TerminalNode *DATA();
    Supplemental_id_key_clauseContext *supplemental_id_key_clause();
    Supplemental_plsql_clauseContext *supplemental_plsql_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Supplemental_db_loggingContext* supplemental_db_logging();

  class  Add_or_dropContext : public antlr4::ParserRuleContext {
  public:
    Add_or_dropContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *DROP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_or_dropContext* add_or_drop();

  class  Supplemental_plsql_clauseContext : public antlr4::ParserRuleContext {
  public:
    Supplemental_plsql_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *PROCEDURAL();
    antlr4::tree::TerminalNode *REPLICATION();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Supplemental_plsql_clauseContext* supplemental_plsql_clause();

  class  Logfile_descriptorContext : public antlr4::ParserRuleContext {
  public:
    Logfile_descriptorContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GROUP();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<FilenameContext *> filename();
    FilenameContext* filename(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Logfile_descriptorContext* logfile_descriptor();

  class  Controlfile_clausesContext : public antlr4::ParserRuleContext {
  public:
    Controlfile_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *CONTROLFILE();
    antlr4::tree::TerminalNode *AS();
    FilenameContext *filename();
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *LOGICAL();
    antlr4::tree::TerminalNode *PHYSICAL();
    antlr4::tree::TerminalNode *BACKUP();
    antlr4::tree::TerminalNode *TO();
    Trace_file_clauseContext *trace_file_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Controlfile_clausesContext* controlfile_clauses();

  class  Trace_file_clauseContext : public antlr4::ParserRuleContext {
  public:
    Trace_file_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TRACE();
    antlr4::tree::TerminalNode *AS();
    FilenameContext *filename();
    antlr4::tree::TerminalNode *RESETLOGS();
    antlr4::tree::TerminalNode *NORESETLOGS();
    antlr4::tree::TerminalNode *REUSE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Trace_file_clauseContext* trace_file_clause();

  class  Standby_database_clausesContext : public antlr4::ParserRuleContext {
  public:
    Standby_database_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Activate_standby_db_clauseContext *activate_standby_db_clause();
    Maximize_standby_db_clauseContext *maximize_standby_db_clause();
    Register_logfile_clauseContext *register_logfile_clause();
    Commit_switchover_clauseContext *commit_switchover_clause();
    Start_standby_clauseContext *start_standby_clause();
    Stop_standby_clauseContext *stop_standby_clause();
    Convert_database_clauseContext *convert_database_clause();
    Parallel_clauseContext *parallel_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Standby_database_clausesContext* standby_database_clauses();

  class  Activate_standby_db_clauseContext : public antlr4::ParserRuleContext {
  public:
    Activate_standby_db_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ACTIVATE();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *FINISH();
    antlr4::tree::TerminalNode *APPLY();
    antlr4::tree::TerminalNode *PHYSICAL();
    antlr4::tree::TerminalNode *LOGICAL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Activate_standby_db_clauseContext* activate_standby_db_clause();

  class  Maximize_standby_db_clauseContext : public antlr4::ParserRuleContext {
  public:
    Maximize_standby_db_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *MAXIMIZE();
    antlr4::tree::TerminalNode *PROTECTION();
    antlr4::tree::TerminalNode *AVAILABILITY();
    antlr4::tree::TerminalNode *PERFORMANCE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Maximize_standby_db_clauseContext* maximize_standby_db_clause();

  class  Register_logfile_clauseContext : public antlr4::ParserRuleContext {
  public:
    Register_logfile_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REGISTER();
    antlr4::tree::TerminalNode *LOGFILE();
    antlr4::tree::TerminalNode *PHYSICAL();
    antlr4::tree::TerminalNode *LOGICAL();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Register_logfile_clauseContext* register_logfile_clause();

  class  Commit_switchover_clauseContext : public antlr4::ParserRuleContext {
  public:
    Commit_switchover_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> TO();
    antlr4::tree::TerminalNode* TO(size_t i);
    antlr4::tree::TerminalNode *SWITCHOVER();
    antlr4::tree::TerminalNode *PREPARE();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *CANCEL();
    antlr4::tree::TerminalNode *LOGICAL();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *SESSION();
    antlr4::tree::TerminalNode *SHUTDOWN();
    antlr4::tree::TerminalNode *WAIT();
    antlr4::tree::TerminalNode *NOWAIT();
    antlr4::tree::TerminalNode *PHYSICAL();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *WITHOUT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Commit_switchover_clauseContext* commit_switchover_clause();

  class  Start_standby_clauseContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *scn_value = nullptr;
    Start_standby_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *START();
    antlr4::tree::TerminalNode *LOGICAL();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *APPLY();
    antlr4::tree::TerminalNode *IMMEDIATE();
    antlr4::tree::TerminalNode *NODELAY();
    antlr4::tree::TerminalNode *NEW();
    antlr4::tree::TerminalNode *PRIMARY();
    Regular_idContext *regular_id();
    antlr4::tree::TerminalNode *INITIAL();
    antlr4::tree::TerminalNode *SKIP_();
    antlr4::tree::TerminalNode *FAILED();
    antlr4::tree::TerminalNode *TRANSACTION();
    antlr4::tree::TerminalNode *FINISH();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Start_standby_clauseContext* start_standby_clause();

  class  Stop_standby_clauseContext : public antlr4::ParserRuleContext {
  public:
    Stop_standby_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOGICAL();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *APPLY();
    antlr4::tree::TerminalNode *STOP();
    antlr4::tree::TerminalNode *ABORT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Stop_standby_clauseContext* stop_standby_clause();

  class  Convert_database_clauseContext : public antlr4::ParserRuleContext {
  public:
    Convert_database_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONVERT();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *PHYSICAL();
    antlr4::tree::TerminalNode *SNAPSHOT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Convert_database_clauseContext* convert_database_clause();

  class  Default_settings_clauseContext : public antlr4::ParserRuleContext {
  public:
    Default_settings_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *EDITION();
    antlr4::tree::TerminalNode *EQUALS_OP();
    Edition_nameContext *edition_name();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *TABLESPACE();
    antlr4::tree::TerminalNode *BIGFILE();
    antlr4::tree::TerminalNode *SMALLFILE();
    TablespaceContext *tablespace();
    antlr4::tree::TerminalNode *TEMPORARY();
    Tablespace_group_nameContext *tablespace_group_name();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *GLOBAL_NAME();
    antlr4::tree::TerminalNode *TO();
    DatabaseContext *database();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<DomainContext *> domain();
    DomainContext* domain(size_t i);
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *BLOCK();
    antlr4::tree::TerminalNode *CHANGE();
    antlr4::tree::TerminalNode *TRACKING();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *FILE();
    FilenameContext *filename();
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *DISABLE();
    Flashback_mode_clauseContext *flashback_mode_clause();
    Set_time_zone_clauseContext *set_time_zone_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Default_settings_clauseContext* default_settings_clause();

  class  Set_time_zone_clauseContext : public antlr4::ParserRuleContext {
  public:
    Set_time_zone_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *TIMEZONE();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Set_time_zone_clauseContext* set_time_zone_clause();

  class  Instance_clausesContext : public antlr4::ParserRuleContext {
  public:
    Instance_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Enable_or_disableContext *enable_or_disable();
    antlr4::tree::TerminalNode *INSTANCE();
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Instance_clausesContext* instance_clauses();

  class  Security_clauseContext : public antlr4::ParserRuleContext {
  public:
    Security_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GUARD();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *NONE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Security_clauseContext* security_clause();

  class  DomainContext : public antlr4::ParserRuleContext {
  public:
    DomainContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  DomainContext* domain();

  class  DatabaseContext : public antlr4::ParserRuleContext {
  public:
    DatabaseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  DatabaseContext* database();

  class  Edition_nameContext : public antlr4::ParserRuleContext {
  public:
    Edition_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Edition_nameContext* edition_name();

  class  FilenumberContext : public antlr4::ParserRuleContext {
  public:
    FilenumberContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  FilenumberContext* filenumber();

  class  FilenameContext : public antlr4::ParserRuleContext {
  public:
    FilenameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  FilenameContext* filename();

  class  Prepare_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *c = nullptr;
    Prepare_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PREPARE();
    std::vector<antlr4::tree::TerminalNode *> MIRROR();
    antlr4::tree::TerminalNode* MIRROR(size_t i);
    antlr4::tree::TerminalNode *COPY();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *REDUNDANCY();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *UNPROTECTED();
    antlr4::tree::TerminalNode *HIGH();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Prepare_clauseContext* prepare_clause();

  class  Drop_mirror_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *mn = nullptr;
    Drop_mirror_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *MIRROR();
    antlr4::tree::TerminalNode *COPY();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_mirror_clauseContext* drop_mirror_clause();

  class  Lost_write_protectionContext : public antlr4::ParserRuleContext {
  public:
    Lost_write_protectionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOST();
    antlr4::tree::TerminalNode *WRITE();
    antlr4::tree::TerminalNode *PROTECTION();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *DISABLE();
    antlr4::tree::TerminalNode *REMOVE();
    antlr4::tree::TerminalNode *SUSPEND();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lost_write_protectionContext* lost_write_protection();

  class  Cdb_fleet_clausesContext : public antlr4::ParserRuleContext {
  public:
    Cdb_fleet_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Lead_cdb_clauseContext *lead_cdb_clause();
    Lead_cdb_uri_clauseContext *lead_cdb_uri_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cdb_fleet_clausesContext* cdb_fleet_clauses();

  class  Lead_cdb_clauseContext : public antlr4::ParserRuleContext {
  public:
    Lead_cdb_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *LEAD_CDB();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *TRUE();
    antlr4::tree::TerminalNode *FALSE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lead_cdb_clauseContext* lead_cdb_clause();

  class  Lead_cdb_uri_clauseContext : public antlr4::ParserRuleContext {
  public:
    Lead_cdb_uri_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *LEAD_CDB_URI();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lead_cdb_uri_clauseContext* lead_cdb_uri_clause();

  class  Property_clausesContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *qcn = nullptr;
    Property_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PROPERTY();
    antlr4::tree::TerminalNode *DEFAULT_CREDENTIAL();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *REMOVE();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Property_clausesContext* property_clauses();

  class  Replay_upgrade_clausesContext : public antlr4::ParserRuleContext {
  public:
    Replay_upgrade_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UPGRADE();
    antlr4::tree::TerminalNode *SYNC();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *OFF();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Replay_upgrade_clausesContext* replay_upgrade_clauses();

  class  Alter_database_linkContext : public antlr4::ParserRuleContext {
  public:
    Alter_database_linkContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *LINK();
    Local_link_nameContext *local_link_name();
    antlr4::tree::TerminalNode *CONNECT();
    antlr4::tree::TerminalNode *TO();
    User_object_nameContext *user_object_name();
    antlr4::tree::TerminalNode *IDENTIFIED();
    antlr4::tree::TerminalNode *BY();
    Password_valueContext *password_value();
    Link_authenticationContext *link_authentication();
    antlr4::tree::TerminalNode *SHARED();
    antlr4::tree::TerminalNode *PUBLIC();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_database_linkContext* alter_database_link();

  class  Password_valueContext : public antlr4::ParserRuleContext {
  public:
    Password_valueContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();
    NumericContext *numeric();
    antlr4::tree::TerminalNode *VALUES();
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Password_valueContext* password_value();

  class  Link_authenticationContext : public antlr4::ParserRuleContext {
  public:
    Link_authenticationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AUTHENTICATED();
    std::vector<antlr4::tree::TerminalNode *> BY();
    antlr4::tree::TerminalNode* BY(size_t i);
    User_object_nameContext *user_object_name();
    antlr4::tree::TerminalNode *IDENTIFIED();
    Password_valueContext *password_value();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Link_authenticationContext* link_authentication();

  class  Create_schemaContext : public antlr4::ParserRuleContext {
  public:
    Create_schemaContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *SCHEMA();
    antlr4::tree::TerminalNode *AUTHORIZATION();
    Schema_nameContext *schema_name();
    std::vector<Create_tableContext *> create_table();
    Create_tableContext* create_table(size_t i);
    std::vector<Create_viewContext *> create_view();
    Create_viewContext* create_view(size_t i);
    std::vector<Grant_statementContext *> grant_statement();
    Grant_statementContext* grant_statement(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_schemaContext* create_schema();

  class  Create_databaseContext : public antlr4::ParserRuleContext {
  public:
    Create_databaseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *DATABASE();
    Database_nameContext *database_name();
    std::vector<antlr4::tree::TerminalNode *> USER();
    antlr4::tree::TerminalNode* USER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> IDENTIFIED();
    antlr4::tree::TerminalNode* IDENTIFIED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> BY();
    antlr4::tree::TerminalNode* BY(size_t i);
    std::vector<Password_valueContext *> password_value();
    Password_valueContext* password_value(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CONTROLFILE();
    antlr4::tree::TerminalNode* CONTROLFILE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> REUSE();
    antlr4::tree::TerminalNode* REUSE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CHARACTER();
    antlr4::tree::TerminalNode* CHARACTER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SET();
    antlr4::tree::TerminalNode* SET(size_t i);
    std::vector<Char_set_nameContext *> char_set_name();
    Char_set_nameContext* char_set_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DEFAULT();
    antlr4::tree::TerminalNode* DEFAULT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<Database_logging_clausesContext *> database_logging_clauses();
    Database_logging_clausesContext* database_logging_clauses(size_t i);
    std::vector<Tablespace_clausesContext *> tablespace_clauses();
    Tablespace_clausesContext* tablespace_clauses(size_t i);
    std::vector<Set_time_zone_clauseContext *> set_time_zone_clause();
    Set_time_zone_clauseContext* set_time_zone_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> USER_DATA();
    antlr4::tree::TerminalNode* USER_DATA(size_t i);
    std::vector<Tablespace_group_nameContext *> tablespace_group_name();
    Tablespace_group_nameContext* tablespace_group_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DATAFILE();
    antlr4::tree::TerminalNode* DATAFILE(size_t i);
    std::vector<Datafile_tempfile_specContext *> datafile_tempfile_spec();
    Datafile_tempfile_specContext* datafile_tempfile_spec(size_t i);
    std::vector<Enable_pluggable_databaseContext *> enable_pluggable_database();
    Enable_pluggable_databaseContext* enable_pluggable_database(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SYS();
    antlr4::tree::TerminalNode* SYS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SYSTEM();
    antlr4::tree::TerminalNode* SYSTEM(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MAXDATAFILES();
    antlr4::tree::TerminalNode* MAXDATAFILES(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MAXINSTANCES();
    antlr4::tree::TerminalNode* MAXINSTANCES(size_t i);
    std::vector<antlr4::tree::TerminalNode *> BIGFILE();
    antlr4::tree::TerminalNode* BIGFILE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SMALLFILE();
    antlr4::tree::TerminalNode* SMALLFILE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NATIONAL();
    antlr4::tree::TerminalNode* NATIONAL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_databaseContext* create_database();

  class  Database_logging_clausesContext : public antlr4::ParserRuleContext {
  public:
    Database_logging_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOGFILE();
    std::vector<Database_logging_sub_clauseContext *> database_logging_sub_clause();
    Database_logging_sub_clauseContext* database_logging_sub_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *MAXLOGFILES();
    antlr4::tree::TerminalNode *MAXLOGMEMBERS();
    antlr4::tree::TerminalNode *MAXLOGHISTORY();
    antlr4::tree::TerminalNode *ARCHIVELOG();
    antlr4::tree::TerminalNode *NOARCHIVELOG();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *LOGGING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Database_logging_clausesContext* database_logging_clauses();

  class  Database_logging_sub_clauseContext : public antlr4::ParserRuleContext {
  public:
    Database_logging_sub_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    File_specificationContext *file_specification();
    antlr4::tree::TerminalNode *GROUP();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Database_logging_sub_clauseContext* database_logging_sub_clause();

  class  Tablespace_clausesContext : public antlr4::ParserRuleContext {
  public:
    Tablespace_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXTENT();
    antlr4::tree::TerminalNode *MANAGEMENT();
    antlr4::tree::TerminalNode *LOCAL();
    antlr4::tree::TerminalNode *DATAFILE();
    std::vector<File_specificationContext *> file_specification();
    File_specificationContext* file_specification(size_t i);
    antlr4::tree::TerminalNode *SYSAUX();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Default_tablespaceContext *default_tablespace();
    Default_temp_tablespaceContext *default_temp_tablespace();
    Undo_tablespaceContext *undo_tablespace();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tablespace_clausesContext* tablespace_clauses();

  class  Enable_pluggable_databaseContext : public antlr4::ParserRuleContext {
  public:
    Enable_pluggable_databaseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *PLUGGABLE();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *SEED();
    Undo_mode_clauseContext *undo_mode_clause();
    File_name_convertContext *file_name_convert();
    antlr4::tree::TerminalNode *SYSTEM();
    std::vector<Tablespace_datafile_clausesContext *> tablespace_datafile_clauses();
    Tablespace_datafile_clausesContext* tablespace_datafile_clauses(size_t i);
    antlr4::tree::TerminalNode *SYSAUX();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Enable_pluggable_databaseContext* enable_pluggable_database();

  class  File_name_convertContext : public antlr4::ParserRuleContext {
  public:
    File_name_convertContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FILE_NAME_CONVERT();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Filename_convert_sub_clauseContext *> filename_convert_sub_clause();
    Filename_convert_sub_clauseContext* filename_convert_sub_clause(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *NONE();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  File_name_convertContext* file_name_convert();

  class  Filename_convert_sub_clauseContext : public antlr4::ParserRuleContext {
  public:
    Filename_convert_sub_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    antlr4::tree::TerminalNode *COMMA();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Filename_convert_sub_clauseContext* filename_convert_sub_clause();

  class  Tablespace_datafile_clausesContext : public antlr4::ParserRuleContext {
  public:
    Tablespace_datafile_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DATAFILES();
    std::vector<antlr4::tree::TerminalNode *> SIZE();
    antlr4::tree::TerminalNode* SIZE(size_t i);
    std::vector<Size_clauseContext *> size_clause();
    Size_clauseContext* size_clause(size_t i);
    std::vector<Autoextend_clauseContext *> autoextend_clause();
    Autoextend_clauseContext* autoextend_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tablespace_datafile_clausesContext* tablespace_datafile_clauses();

  class  Undo_mode_clauseContext : public antlr4::ParserRuleContext {
  public:
    Undo_mode_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOCAL();
    antlr4::tree::TerminalNode *UNDO();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *OFF();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Undo_mode_clauseContext* undo_mode_clause();

  class  Default_tablespaceContext : public antlr4::ParserRuleContext {
  public:
    Default_tablespaceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *TABLESPACE();
    TablespaceContext *tablespace();
    antlr4::tree::TerminalNode *DATAFILE();
    Datafile_tempfile_specContext *datafile_tempfile_spec();
    Extent_management_clauseContext *extent_management_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Default_tablespaceContext* default_tablespace();

  class  Default_temp_tablespaceContext : public antlr4::ParserRuleContext {
  public:
    Default_temp_tablespaceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEFAULT();
    TablespaceContext *tablespace();
    antlr4::tree::TerminalNode *TEMPORARY();
    antlr4::tree::TerminalNode *TABLESPACE();
    antlr4::tree::TerminalNode *LOCAL();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *LEAF();
    antlr4::tree::TerminalNode *TEMPFILE();
    std::vector<File_specificationContext *> file_specification();
    File_specificationContext* file_specification(size_t i);
    Extent_management_clauseContext *extent_management_clause();
    antlr4::tree::TerminalNode *BIGFILE();
    antlr4::tree::TerminalNode *SMALLFILE();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Default_temp_tablespaceContext* default_temp_tablespace();

  class  Undo_tablespaceContext : public antlr4::ParserRuleContext {
  public:
    Undo_tablespaceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNDO();
    antlr4::tree::TerminalNode *TABLESPACE();
    TablespaceContext *tablespace();
    antlr4::tree::TerminalNode *DATAFILE();
    std::vector<File_specificationContext *> file_specification();
    File_specificationContext* file_specification(size_t i);
    antlr4::tree::TerminalNode *BIGFILE();
    antlr4::tree::TerminalNode *SMALLFILE();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Undo_tablespaceContext* undo_tablespace();

  class  Drop_databaseContext : public antlr4::ParserRuleContext {
  public:
    Drop_databaseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *INCLUDING();
    antlr4::tree::TerminalNode *BACKUPS();
    antlr4::tree::TerminalNode *NOPROMPT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_databaseContext* drop_database();

  class  Create_database_linkContext : public antlr4::ParserRuleContext {
  public:
    Create_database_linkContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *LINK();
    Link_nameContext *link_name();
    antlr4::tree::TerminalNode *SHARED();
    antlr4::tree::TerminalNode *PUBLIC();
    std::vector<antlr4::tree::TerminalNode *> CONNECT();
    antlr4::tree::TerminalNode* CONNECT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TO();
    antlr4::tree::TerminalNode* TO(size_t i);
    std::vector<Link_authenticationContext *> link_authentication();
    Link_authenticationContext* link_authentication(size_t i);
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *CHAR_STRING();
    std::vector<antlr4::tree::TerminalNode *> CURRENT_USER();
    antlr4::tree::TerminalNode* CURRENT_USER(size_t i);
    std::vector<User_object_nameContext *> user_object_name();
    User_object_nameContext* user_object_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> IDENTIFIED();
    antlr4::tree::TerminalNode* IDENTIFIED(size_t i);
    std::vector<antlr4::tree::TerminalNode *> BY();
    antlr4::tree::TerminalNode* BY(size_t i);
    std::vector<Password_valueContext *> password_value();
    Password_valueContext* password_value(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Create_database_linkContext* create_database_link();

  class  Drop_database_linkContext : public antlr4::ParserRuleContext {
  public:
    Drop_database_linkContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *LINK();
    Link_nameContext *link_name();
    antlr4::tree::TerminalNode *PUBLIC();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_database_linkContext* drop_database_link();

  class  Alter_tablespace_setContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *tss = nullptr;
    Alter_tablespace_setContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *TABLESPACE();
    antlr4::tree::TerminalNode *SET();
    Alter_tablespace_attrsContext *alter_tablespace_attrs();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_tablespace_setContext* alter_tablespace_set();

  class  Alter_tablespace_attrsContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *nts = nullptr;
    Alter_tablespace_attrsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Default_tablespace_paramsContext *default_tablespace_params();
    antlr4::tree::TerminalNode *MINIMUM();
    antlr4::tree::TerminalNode *EXTENT();
    Size_clauseContext *size_clause();
    antlr4::tree::TerminalNode *RESIZE();
    antlr4::tree::TerminalNode *COALESCE();
    antlr4::tree::TerminalNode *SHRINK();
    antlr4::tree::TerminalNode *SPACE_KEYWORD();
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *TO();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *BACKUP();
    antlr4::tree::TerminalNode *BEGIN();
    antlr4::tree::TerminalNode *END();
    Datafile_tempfile_clausesContext *datafile_tempfile_clauses();
    Tablespace_logging_clausesContext *tablespace_logging_clauses();
    Tablespace_group_clauseContext *tablespace_group_clause();
    Tablespace_state_clausesContext *tablespace_state_clauses();
    Autoextend_clauseContext *autoextend_clause();
    Flashback_mode_clauseContext *flashback_mode_clause();
    Tablespace_retention_clauseContext *tablespace_retention_clause();
    Alter_tablespace_encryptionContext *alter_tablespace_encryption();
    Lost_write_protectionContext *lost_write_protection();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_tablespace_attrsContext* alter_tablespace_attrs();

  class  Alter_tablespace_encryptionContext : public antlr4::ParserRuleContext {
  public:
    Alter_tablespace_encryptionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ENCRYPTION();
    antlr4::tree::TerminalNode *OFFLINE();
    antlr4::tree::TerminalNode *ONLINE();
    antlr4::tree::TerminalNode *FINISH();
    antlr4::tree::TerminalNode *ENCRYPT();
    antlr4::tree::TerminalNode *REKEY();
    antlr4::tree::TerminalNode *DECRYPT();
    Ts_file_name_convertContext *ts_file_name_convert();
    Tablespace_encryption_specContext *tablespace_encryption_spec();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_tablespace_encryptionContext* alter_tablespace_encryption();

  class  Ts_file_name_convertContext : public antlr4::ParserRuleContext {
  public:
    Ts_file_name_convertContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FILE_NAME_CONVERT();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *KEEP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Ts_file_name_convertContext* ts_file_name_convert();

  class  Alter_roleContext : public antlr4::ParserRuleContext {
  public:
    Alter_roleContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *ROLE();
    Role_nameContext *role_name();
    Role_identified_clauseContext *role_identified_clause();
    Container_clauseContext *container_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_roleContext* alter_role();

  class  Role_identified_clauseContext : public antlr4::ParserRuleContext {
  public:
    Role_identified_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *IDENTIFIED();
    antlr4::tree::TerminalNode *BY();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *EXTERNALLY();
    antlr4::tree::TerminalNode *GLOBALLY();
    antlr4::tree::TerminalNode *PERIOD();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Role_identified_clauseContext* role_identified_clause();

  class  Alter_tableContext : public antlr4::ParserRuleContext {
  public:
    Alter_tableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALTER();
    std::vector<antlr4::tree::TerminalNode *> TABLE();
    antlr4::tree::TerminalNode* TABLE(size_t i);
    Tableview_nameContext *tableview_name();
    Alter_table_propertiesContext *alter_table_properties();
    Constraint_clausesContext *constraint_clauses();
    Column_clausesContext *column_clauses();
    Alter_table_partitioningContext *alter_table_partitioning();
    Move_table_clauseContext *move_table_clause();
    std::vector<Memoptimize_read_write_clauseContext *> memoptimize_read_write_clause();
    Memoptimize_read_write_clauseContext* memoptimize_read_write_clause(size_t i);
    std::vector<Enable_disable_clauseContext *> enable_disable_clause();
    Enable_disable_clauseContext* enable_disable_clause(size_t i);
    std::vector<Enable_or_disableContext *> enable_or_disable();
    Enable_or_disableContext* enable_or_disable(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LOCK();
    antlr4::tree::TerminalNode* LOCK(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ALL();
    antlr4::tree::TerminalNode* ALL(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TRIGGERS();
    antlr4::tree::TerminalNode* TRIGGERS(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_tableContext* alter_table();

  class  Memoptimize_read_write_clauseContext : public antlr4::ParserRuleContext {
  public:
    Memoptimize_read_write_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MEMOPTIMIZE();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *WRITE();
    antlr4::tree::TerminalNode *NO();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Memoptimize_read_write_clauseContext* memoptimize_read_write_clause();

  class  Alter_table_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Alter_table_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Alter_table_properties_1Context *alter_table_properties_1();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *TO();
    Tableview_nameContext *tableview_name();
    Shrink_clauseContext *shrink_clause();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *WRITE();
    antlr4::tree::TerminalNode *REKEY();
    antlr4::tree::TerminalNode *CHAR_STRING();
    Annotations_clauseContext *annotations_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_table_propertiesContext* alter_table_properties();

  class  Alter_table_partitioningContext : public antlr4::ParserRuleContext {
  public:
    Alter_table_partitioningContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Add_table_partitionContext *add_table_partition();
    Drop_table_partitionContext *drop_table_partition();
    Merge_table_partitionContext *merge_table_partition();
    Modify_table_partitionContext *modify_table_partition();
    Split_table_partitionContext *split_table_partition();
    Truncate_table_partitionContext *truncate_table_partition();
    Exchange_table_partitionContext *exchange_table_partition();
    Coalesce_table_partitionContext *coalesce_table_partition();
    Alter_interval_partitionContext *alter_interval_partition();
    Move_table_partitionContext *move_table_partition();
    Rename_table_partitionContext *rename_table_partition();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_table_partitioningContext* alter_table_partitioning();

  class  Add_table_partitionContext : public antlr4::ParserRuleContext {
  public:
    Add_table_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    Range_partition_descContext *range_partition_desc();
    List_partition_descContext *list_partition_desc();
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();
    antlr4::tree::TerminalNode *TABLESPACE();
    TablespaceContext *tablespace();
    Key_compressionContext *key_compression();
    antlr4::tree::TerminalNode *UNUSABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_table_partitionContext* add_table_partition();

  class  Drop_table_partitionContext : public antlr4::ParserRuleContext {
  public:
    Drop_table_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    Partition_extended_namesContext *partition_extended_names();
    Subpartition_extended_namesContext *subpartition_extended_names();
    Update_index_clausesContext *update_index_clauses();
    Parallel_clauseContext *parallel_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_table_partitionContext* drop_table_partition();

  class  Merge_table_partitionContext : public antlr4::ParserRuleContext {
  public:
    Merge_table_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MERGE();
    std::vector<antlr4::tree::TerminalNode *> PARTITION();
    antlr4::tree::TerminalNode* PARTITION(size_t i);
    std::vector<Partition_nameContext *> partition_name();
    Partition_nameContext* partition_name(size_t i);
    antlr4::tree::TerminalNode *AND();
    antlr4::tree::TerminalNode *INTO();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Merge_table_partitionContext* merge_table_partition();

  class  Modify_table_partitionContext : public antlr4::ParserRuleContext {
  public:
    Modify_table_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    Partition_nameContext *partition_name();
    Range_partitionsContext *range_partitions();
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *SUBPARTITION();
    List_values_clauseContext *list_values_clause();
    std::vector<antlr4::tree::TerminalNode *> ADD();
    antlr4::tree::TerminalNode* ADD(size_t i);
    Range_subpartition_descContext *range_subpartition_desc();
    antlr4::tree::TerminalNode *UNUSABLE();
    antlr4::tree::TerminalNode *LOCAL();
    antlr4::tree::TerminalNode *INDEXES();
    Shrink_clauseContext *shrink_clause();
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *REBUILD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_table_partitionContext* modify_table_partition();

  class  Split_table_partitionContext : public antlr4::ParserRuleContext {
  public:
    Split_table_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SPLIT();
    Partition_extended_namesContext *partition_extended_names();
    antlr4::tree::TerminalNode *AT();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<LiteralContext *> literal();
    LiteralContext* literal(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *INTO();
    std::vector<Range_partition_descContext *> range_partition_desc();
    Range_partition_descContext* range_partition_desc(size_t i);
    Update_global_index_clauseContext *update_global_index_clause();
    Update_index_clausesContext *update_index_clauses();
    antlr4::tree::TerminalNode *ONLINE();
    std::vector<List_partition_descContext *> list_partition_desc();
    List_partition_descContext* list_partition_desc(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Split_table_partitionContext* split_table_partition();

  class  Truncate_table_partitionContext : public antlr4::ParserRuleContext {
  public:
    Truncate_table_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TRUNCATE();
    Partition_extended_namesContext *partition_extended_names();
    Subpartition_extended_namesContext *subpartition_extended_names();
    antlr4::tree::TerminalNode *STORAGE();
    antlr4::tree::TerminalNode *CASCADE();
    Update_index_clausesContext *update_index_clauses();
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *REUSE();
    Parallel_clauseContext *parallel_clause();
    antlr4::tree::TerminalNode *ALL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Truncate_table_partitionContext* truncate_table_partition();

  class  Exchange_table_partitionContext : public antlr4::ParserRuleContext {
  public:
    Exchange_table_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXCHANGE();
    antlr4::tree::TerminalNode *PARTITION();
    Partition_nameContext *partition_name();
    std::vector<antlr4::tree::TerminalNode *> WITH();
    antlr4::tree::TerminalNode* WITH(size_t i);
    antlr4::tree::TerminalNode *TABLE();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *INDEXES();
    antlr4::tree::TerminalNode *VALIDATION();
    antlr4::tree::TerminalNode *INCLUDING();
    antlr4::tree::TerminalNode *EXCLUDING();
    antlr4::tree::TerminalNode *WITHOUT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Exchange_table_partitionContext* exchange_table_partition();

  class  Coalesce_table_partitionContext : public antlr4::ParserRuleContext {
  public:
    Coalesce_table_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COALESCE();
    antlr4::tree::TerminalNode *PARTITION();
    Parallel_clauseContext *parallel_clause();
    Allow_or_disallowContext *allow_or_disallow();
    antlr4::tree::TerminalNode *CLUSTERING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Coalesce_table_partitionContext* coalesce_table_partition();

  class  Alter_interval_partitionContext : public antlr4::ParserRuleContext {
  public:
    Alter_interval_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *INTERVAL();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    ConstantContext *constant();
    ExpressionContext *expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_interval_partitionContext* alter_interval_partition();

  class  Move_table_partitionContext : public antlr4::ParserRuleContext {
  public:
    Move_table_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MOVE();
    Partition_extended_namesContext *partition_extended_names();
    Table_partition_descriptionContext *table_partition_description();
    Subpartition_extended_namesContext *subpartition_extended_names();
    std::vector<Filter_conditionContext *> filter_condition();
    Filter_conditionContext* filter_condition(size_t i);
    std::vector<Update_index_clausesContext *> update_index_clauses();
    Update_index_clausesContext* update_index_clauses(size_t i);
    std::vector<Parallel_clauseContext *> parallel_clause();
    Parallel_clauseContext* parallel_clause(size_t i);
    std::vector<Allow_or_disallowContext *> allow_or_disallow();
    Allow_or_disallowContext* allow_or_disallow(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CLUSTERING();
    antlr4::tree::TerminalNode* CLUSTERING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ONLINE();
    antlr4::tree::TerminalNode* ONLINE(size_t i);
    antlr4::tree::TerminalNode *MAPPING();
    antlr4::tree::TerminalNode *TABLE();
    Indexing_clauseContext *indexing_clause();
    Partitioning_storage_clauseContext *partitioning_storage_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Move_table_partitionContext* move_table_partition();

  class  Filter_conditionContext : public antlr4::ParserRuleContext {
  public:
    Filter_conditionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INCLUDING();
    antlr4::tree::TerminalNode *ROWS();
    Where_clauseContext *where_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Filter_conditionContext* filter_condition();

  class  Rename_table_partitionContext : public antlr4::ParserRuleContext {
  public:
    Rename_table_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *TO();
    Partition_nameContext *partition_name();
    Partition_extended_namesContext *partition_extended_names();
    Subpartition_extended_namesContext *subpartition_extended_names();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Rename_table_partitionContext* rename_table_partition();

  class  Partition_extended_namesContext : public antlr4::ParserRuleContext {
  public:
    Partition_extended_namesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *PARTITIONS();
    std::vector<Partition_nameContext *> partition_name();
    Partition_nameContext* partition_name(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *FOR();
    std::vector<Partition_key_valueContext *> partition_key_value();
    Partition_key_valueContext* partition_key_value(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partition_extended_namesContext* partition_extended_names();

  class  Subpartition_extended_namesContext : public antlr4::ParserRuleContext {
  public:
    Subpartition_extended_namesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBPARTITION();
    antlr4::tree::TerminalNode *SUBPARTITIONS();
    std::vector<Partition_nameContext *> partition_name();
    Partition_nameContext* partition_name(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *FOR();
    std::vector<Subpartition_key_valueContext *> subpartition_key_value();
    Subpartition_key_valueContext* subpartition_key_value(size_t i);
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *INDEXES();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subpartition_extended_namesContext* subpartition_extended_names();

  class  Alter_table_properties_1Context : public antlr4::ParserRuleContext {
  public:
    Alter_table_properties_1Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<Logging_clauseContext *> logging_clause();
    Logging_clauseContext* logging_clause(size_t i);
    std::vector<Table_compressionContext *> table_compression();
    Table_compressionContext* table_compression(size_t i);
    std::vector<Inmemory_table_clauseContext *> inmemory_table_clause();
    Inmemory_table_clauseContext* inmemory_table_clause(size_t i);
    std::vector<Supplemental_table_loggingContext *> supplemental_table_logging();
    Supplemental_table_loggingContext* supplemental_table_logging(size_t i);
    std::vector<Allocate_extent_clauseContext *> allocate_extent_clause();
    Allocate_extent_clauseContext* allocate_extent_clause(size_t i);
    std::vector<Deallocate_unused_clauseContext *> deallocate_unused_clause();
    Deallocate_unused_clauseContext* deallocate_unused_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RESULT_CACHE();
    antlr4::tree::TerminalNode* RESULT_CACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MODE();
    antlr4::tree::TerminalNode* MODE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<Upgrade_table_clauseContext *> upgrade_table_clause();
    Upgrade_table_clauseContext* upgrade_table_clause(size_t i);
    std::vector<Records_per_block_clauseContext *> records_per_block_clause();
    Records_per_block_clauseContext* records_per_block_clause(size_t i);
    std::vector<Parallel_clauseContext *> parallel_clause();
    Parallel_clauseContext* parallel_clause(size_t i);
    std::vector<Row_movement_clauseContext *> row_movement_clause();
    Row_movement_clauseContext* row_movement_clause(size_t i);
    std::vector<Logical_replication_clauseContext *> logical_replication_clause();
    Logical_replication_clauseContext* logical_replication_clause(size_t i);
    std::vector<Flashback_archive_clauseContext *> flashback_archive_clause();
    Flashback_archive_clauseContext* flashback_archive_clause(size_t i);
    Alter_iot_clausesContext *alter_iot_clauses();
    std::vector<antlr4::tree::TerminalNode *> CACHE();
    antlr4::tree::TerminalNode* CACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NOCACHE();
    antlr4::tree::TerminalNode* NOCACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DEFAULT();
    antlr4::tree::TerminalNode* DEFAULT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FORCE();
    antlr4::tree::TerminalNode* FORCE(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_table_properties_1Context* alter_table_properties_1();

  class  Alter_iot_clausesContext : public antlr4::ParserRuleContext {
  public:
    Alter_iot_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Index_org_table_clauseContext *index_org_table_clause();
    Alter_overflow_clauseContext *alter_overflow_clause();
    Alter_mapping_table_clauseContext *alter_mapping_table_clause();
    antlr4::tree::TerminalNode *COALESCE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_iot_clausesContext* alter_iot_clauses();

  class  Alter_mapping_table_clauseContext : public antlr4::ParserRuleContext {
  public:
    Alter_mapping_table_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MAPPING();
    antlr4::tree::TerminalNode *TABLE();
    Allocate_extent_clauseContext *allocate_extent_clause();
    Deallocate_unused_clauseContext *deallocate_unused_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_mapping_table_clauseContext* alter_mapping_table_clause();

  class  Alter_overflow_clauseContext : public antlr4::ParserRuleContext {
  public:
    Alter_overflow_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Add_overflow_clauseContext *add_overflow_clause();
    antlr4::tree::TerminalNode *OVERFLOW_();
    std::vector<Segment_attributes_clauseContext *> segment_attributes_clause();
    Segment_attributes_clauseContext* segment_attributes_clause(size_t i);
    std::vector<Allocate_extent_clauseContext *> allocate_extent_clause();
    Allocate_extent_clauseContext* allocate_extent_clause(size_t i);
    std::vector<Shrink_clauseContext *> shrink_clause();
    Shrink_clauseContext* shrink_clause(size_t i);
    std::vector<Deallocate_unused_clauseContext *> deallocate_unused_clause();
    Deallocate_unused_clauseContext* deallocate_unused_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Alter_overflow_clauseContext* alter_overflow_clause();

  class  Add_overflow_clauseContext : public antlr4::ParserRuleContext {
  public:
    Add_overflow_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *OVERFLOW_();
    std::vector<Segment_attributes_clauseContext *> segment_attributes_clause();
    Segment_attributes_clauseContext* segment_attributes_clause(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> PARTITION();
    antlr4::tree::TerminalNode* PARTITION(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_overflow_clauseContext* add_overflow_clause();

  class  Update_index_clausesContext : public antlr4::ParserRuleContext {
  public:
    Update_index_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Update_global_index_clauseContext *update_global_index_clause();
    Update_all_indexes_clauseContext *update_all_indexes_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Update_index_clausesContext* update_index_clauses();

  class  Update_global_index_clauseContext : public antlr4::ParserRuleContext {
  public:
    Update_global_index_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GLOBAL();
    antlr4::tree::TerminalNode *INDEXES();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *INVALIDATE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Update_global_index_clauseContext* update_global_index_clause();

  class  Update_all_indexes_clauseContext : public antlr4::ParserRuleContext {
  public:
    Update_all_indexes_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *INDEXES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Update_all_indexes_index_clauseContext *update_all_indexes_index_clause();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Update_all_indexes_clauseContext* update_all_indexes_clause();

  class  Update_all_indexes_index_clauseContext : public antlr4::ParserRuleContext {
  public:
    Update_all_indexes_index_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Index_nameContext *index_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Update_index_partitionContext *update_index_partition();
    Update_index_subpartitionContext *update_index_subpartition();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Update_all_indexes_clauseContext *> update_all_indexes_clause();
    Update_all_indexes_clauseContext* update_all_indexes_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Update_all_indexes_index_clauseContext* update_all_indexes_index_clause();

  class  Update_index_partitionContext : public antlr4::ParserRuleContext {
  public:
    Update_index_partitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Index_partition_descriptionContext *index_partition_description();
    Index_subpartition_clauseContext *index_subpartition_clause();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Update_index_partitionContext *> update_index_partition();
    Update_index_partitionContext* update_index_partition(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Update_index_partitionContext* update_index_partition();

  class  Update_index_subpartitionContext : public antlr4::ParserRuleContext {
  public:
    Update_index_subpartitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBPARTITION();
    Subpartition_nameContext *subpartition_name();
    antlr4::tree::TerminalNode *TABLESPACE();
    TablespaceContext *tablespace();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Update_index_subpartitionContext *> update_index_subpartition();
    Update_index_subpartitionContext* update_index_subpartition(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Update_index_subpartitionContext* update_index_subpartition();

  class  Enable_disable_clauseContext : public antlr4::ParserRuleContext {
  public:
    Enable_disable_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *DISABLE();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();
    Using_index_clauseContext *using_index_clause();
    Exceptions_clauseContext *exceptions_clause();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *INDEX();
    antlr4::tree::TerminalNode *VALIDATE();
    antlr4::tree::TerminalNode *NOVALIDATE();
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *DROP();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Enable_disable_clauseContext* enable_disable_clause();

  class  Using_index_clauseContext : public antlr4::ParserRuleContext {
  public:
    Using_index_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *INDEX();
    Index_nameContext *index_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Create_indexContext *create_index();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Index_propertiesContext *index_properties();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Using_index_clauseContext* using_index_clause();

  class  Index_attributesContext : public antlr4::ParserRuleContext {
  public:
    Index_attributesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Physical_attributes_clauseContext *> physical_attributes_clause();
    Physical_attributes_clauseContext* physical_attributes_clause(size_t i);
    std::vector<Logging_clauseContext *> logging_clause();
    Logging_clauseContext* logging_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> TABLESPACE();
    antlr4::tree::TerminalNode* TABLESPACE(size_t i);
    std::vector<Key_compressionContext *> key_compression();
    Key_compressionContext* key_compression(size_t i);
    std::vector<Sort_or_nosortContext *> sort_or_nosort();
    Sort_or_nosortContext* sort_or_nosort(size_t i);
    std::vector<antlr4::tree::TerminalNode *> REVERSE();
    antlr4::tree::TerminalNode* REVERSE(size_t i);
    std::vector<Visible_or_invisibleContext *> visible_or_invisible();
    Visible_or_invisibleContext* visible_or_invisible(size_t i);
    std::vector<Parallel_clauseContext *> parallel_clause();
    Parallel_clauseContext* parallel_clause(size_t i);
    std::vector<TablespaceContext *> tablespace();
    TablespaceContext* tablespace(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DEFAULT();
    antlr4::tree::TerminalNode* DEFAULT(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_attributesContext* index_attributes();

  class  Sort_or_nosortContext : public antlr4::ParserRuleContext {
  public:
    Sort_or_nosortContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SORT();
    antlr4::tree::TerminalNode *NOSORT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sort_or_nosortContext* sort_or_nosort();

  class  Exceptions_clauseContext : public antlr4::ParserRuleContext {
  public:
    Exceptions_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXCEPTIONS();
    antlr4::tree::TerminalNode *INTO();
    Tableview_nameContext *tableview_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Exceptions_clauseContext* exceptions_clause();

  class  Move_table_clauseContext : public antlr4::ParserRuleContext {
  public:
    Move_table_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MOVE();
    antlr4::tree::TerminalNode *ONLINE();
    Segment_attributes_clauseContext *segment_attributes_clause();
    Table_compressionContext *table_compression();
    Index_org_table_clauseContext *index_org_table_clause();
    std::vector<Lob_storage_clauseContext *> lob_storage_clause();
    Lob_storage_clauseContext* lob_storage_clause(size_t i);
    std::vector<Varray_col_propertiesContext *> varray_col_properties();
    Varray_col_propertiesContext* varray_col_properties(size_t i);
    Parallel_clauseContext *parallel_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Move_table_clauseContext* move_table_clause();

  class  Index_org_table_clauseContext : public antlr4::ParserRuleContext {
  public:
    Index_org_table_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Mapping_table_clauseContext *> mapping_table_clause();
    Mapping_table_clauseContext* mapping_table_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PCTTHRESHOLD();
    antlr4::tree::TerminalNode* PCTTHRESHOLD(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<Key_compressionContext *> key_compression();
    Key_compressionContext* key_compression(size_t i);
    Index_org_overflow_clauseContext *index_org_overflow_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_org_table_clauseContext* index_org_table_clause();

  class  Mapping_table_clauseContext : public antlr4::ParserRuleContext {
  public:
    Mapping_table_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MAPPING();
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *NOMAPPING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Mapping_table_clauseContext* mapping_table_clause();

  class  Key_compressionContext : public antlr4::ParserRuleContext {
  public:
    Key_compressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NOCOMPRESS();
    antlr4::tree::TerminalNode *COMPRESS();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Key_compressionContext* key_compression();

  class  Index_org_overflow_clauseContext : public antlr4::ParserRuleContext {
  public:
    Index_org_overflow_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OVERFLOW_();
    antlr4::tree::TerminalNode *INCLUDING();
    Column_nameContext *column_name();
    Segment_attributes_clauseContext *segment_attributes_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_org_overflow_clauseContext* index_org_overflow_clause();

  class  Column_clausesContext : public antlr4::ParserRuleContext {
  public:
    Column_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Add_modify_drop_column_clausesContext *add_modify_drop_column_clauses();
    Rename_column_clauseContext *rename_column_clause();
    Modify_collection_retrievalContext *modify_collection_retrieval();
    Modify_lob_storage_clauseContext *modify_lob_storage_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_clausesContext* column_clauses();

  class  Modify_collection_retrievalContext : public antlr4::ParserRuleContext {
  public:
    Modify_collection_retrievalContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *NESTED();
    antlr4::tree::TerminalNode *TABLE();
    Collection_itemContext *collection_item();
    antlr4::tree::TerminalNode *RETURN();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *LOCATOR();
    antlr4::tree::TerminalNode *VALUE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_collection_retrievalContext* modify_collection_retrieval();

  class  Collection_itemContext : public antlr4::ParserRuleContext {
  public:
    Collection_itemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Tableview_nameContext *tableview_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Collection_itemContext* collection_item();

  class  Rename_column_clauseContext : public antlr4::ParserRuleContext {
  public:
    Rename_column_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *COLUMN();
    Old_column_nameContext *old_column_name();
    antlr4::tree::TerminalNode *TO();
    New_column_nameContext *new_column_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Rename_column_clauseContext* rename_column_clause();

  class  Old_column_nameContext : public antlr4::ParserRuleContext {
  public:
    Old_column_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Old_column_nameContext* old_column_name();

  class  New_column_nameContext : public antlr4::ParserRuleContext {
  public:
    New_column_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  New_column_nameContext* new_column_name();

  class  Add_modify_drop_column_clausesContext : public antlr4::ParserRuleContext {
  public:
    Add_modify_drop_column_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Constraint_clausesContext *> constraint_clauses();
    Constraint_clausesContext* constraint_clauses(size_t i);
    std::vector<Add_column_clauseContext *> add_column_clause();
    Add_column_clauseContext* add_column_clause(size_t i);
    std::vector<Modify_column_clausesContext *> modify_column_clauses();
    Modify_column_clausesContext* modify_column_clauses(size_t i);
    std::vector<Drop_column_clauseContext *> drop_column_clause();
    Drop_column_clauseContext* drop_column_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_modify_drop_column_clausesContext* add_modify_drop_column_clauses();

  class  Drop_column_clauseContext : public antlr4::ParserRuleContext {
  public:
    Drop_column_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *UNUSED();
    antlr4::tree::TerminalNode *COLUMN();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CASCADE();
    antlr4::tree::TerminalNode* CASCADE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CONSTRAINTS();
    antlr4::tree::TerminalNode* CONSTRAINTS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> INVALIDATE();
    antlr4::tree::TerminalNode* INVALIDATE(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *CHECKPOINT();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *COLUMNS();
    antlr4::tree::TerminalNode *CONTINUE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_column_clauseContext* drop_column_clause();

  class  Modify_column_clausesContext : public antlr4::ParserRuleContext {
  public:
    Modify_column_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Modify_col_propertiesContext *> modify_col_properties();
    Modify_col_propertiesContext* modify_col_properties(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Modify_col_visibilityContext *> modify_col_visibility();
    Modify_col_visibilityContext* modify_col_visibility(size_t i);
    Modify_col_substitutableContext *modify_col_substitutable();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_column_clausesContext* modify_column_clauses();

  class  Modify_col_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Modify_col_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    DatatypeContext *datatype();
    antlr4::tree::TerminalNode *DEFAULT();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *ENCRYPT();
    Encryption_specContext *encryption_spec();
    antlr4::tree::TerminalNode *DECRYPT();
    std::vector<Inline_constraintContext *> inline_constraint();
    Inline_constraintContext* inline_constraint(size_t i);
    Lob_storage_clauseContext *lob_storage_clause();
    Annotations_clauseContext *annotations_clause();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *NULL_();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_col_propertiesContext* modify_col_properties();

  class  Modify_col_visibilityContext : public antlr4::ParserRuleContext {
  public:
    Modify_col_visibilityContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *VISIBLE();
    antlr4::tree::TerminalNode *INVISIBLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_col_visibilityContext* modify_col_visibility();

  class  Modify_col_substitutableContext : public antlr4::ParserRuleContext {
  public:
    Modify_col_substitutableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COLUMN();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *SUBSTITUTABLE();
    antlr4::tree::TerminalNode *AT();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *LEVELS();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *FORCE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_col_substitutableContext* modify_col_substitutable();

  class  Add_column_clauseContext : public antlr4::ParserRuleContext {
  public:
    Add_column_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Column_propertiesContext *column_properties();
    std::vector<Column_definitionContext *> column_definition();
    Column_definitionContext* column_definition(size_t i);
    std::vector<Virtual_column_definitionContext *> virtual_column_definition();
    Virtual_column_definitionContext* virtual_column_definition(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_column_clauseContext* add_column_clause();

  class  Varray_col_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Varray_col_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VARRAY();
    Varray_itemContext *varray_item();
    Varray_storage_clauseContext *varray_storage_clause();
    Substitutable_column_clauseContext *substitutable_column_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Varray_col_propertiesContext* varray_col_properties();

  class  Varray_storage_clauseContext : public antlr4::ParserRuleContext {
  public:
    Varray_storage_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *LOB();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Lob_storage_parametersContext *lob_storage_parameters();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Lob_segnameContext *lob_segname();
    antlr4::tree::TerminalNode *SECUREFILE();
    antlr4::tree::TerminalNode *BASICFILE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Varray_storage_clauseContext* varray_storage_clause();

  class  Lob_segnameContext : public antlr4::ParserRuleContext {
  public:
    Lob_segnameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lob_segnameContext* lob_segname();

  class  Lob_itemContext : public antlr4::ParserRuleContext {
  public:
    Lob_itemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();
    Quoted_stringContext *quoted_string();
    antlr4::tree::TerminalNode *DELIMITED_ID();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lob_itemContext* lob_item();

  class  Lob_storage_parametersContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *tablespace_name = nullptr;
    Lob_storage_parametersContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLESPACE();
    Id_expressionContext *id_expression();
    Lob_parametersContext *lob_parameters();
    Storage_clauseContext *storage_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lob_storage_parametersContext* lob_storage_parameters();

  class  Lob_storage_clauseContext : public antlr4::ParserRuleContext {
  public:
    Lob_storage_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOB();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<Lob_itemContext *> lob_item();
    Lob_itemContext* lob_item(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *AS();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Lob_segnameContext *> lob_segname();
    Lob_segnameContext* lob_segname(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SECUREFILE();
    antlr4::tree::TerminalNode* SECUREFILE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> BASICFILE();
    antlr4::tree::TerminalNode* BASICFILE(size_t i);
    std::vector<Lob_storage_parametersContext *> lob_storage_parameters();
    Lob_storage_parametersContext* lob_storage_parameters(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lob_storage_clauseContext* lob_storage_clause();

  class  Modify_lob_storage_clauseContext : public antlr4::ParserRuleContext {
  public:
    Modify_lob_storage_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *LOB();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    Lob_itemContext *lob_item();
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    Modify_lob_parametersContext *modify_lob_parameters();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_lob_storage_clauseContext* modify_lob_storage_clause();

  class  Modify_lob_parametersContext : public antlr4::ParserRuleContext {
  public:
    Modify_lob_parametersContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Storage_clauseContext *> storage_clause();
    Storage_clauseContext* storage_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> REBUILD();
    antlr4::tree::TerminalNode* REBUILD(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FREEPOOLS();
    antlr4::tree::TerminalNode* FREEPOOLS(size_t i);
    std::vector<Lob_retention_clauseContext *> lob_retention_clause();
    Lob_retention_clauseContext* lob_retention_clause(size_t i);
    std::vector<Lob_deduplicate_clauseContext *> lob_deduplicate_clause();
    Lob_deduplicate_clauseContext* lob_deduplicate_clause(size_t i);
    std::vector<Lob_compression_clauseContext *> lob_compression_clause();
    Lob_compression_clauseContext* lob_compression_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ENCRYPT();
    antlr4::tree::TerminalNode* ENCRYPT(size_t i);
    std::vector<Encryption_specContext *> encryption_spec();
    Encryption_specContext* encryption_spec(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DECRYPT();
    antlr4::tree::TerminalNode* DECRYPT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CACHE();
    antlr4::tree::TerminalNode* CACHE(size_t i);
    std::vector<Allocate_extent_clauseContext *> allocate_extent_clause();
    Allocate_extent_clauseContext* allocate_extent_clause(size_t i);
    std::vector<Shrink_clauseContext *> shrink_clause();
    Shrink_clauseContext* shrink_clause(size_t i);
    std::vector<Deallocate_unused_clauseContext *> deallocate_unused_clause();
    Deallocate_unused_clauseContext* deallocate_unused_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PCTVERSION();
    antlr4::tree::TerminalNode* PCTVERSION(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NOCACHE();
    antlr4::tree::TerminalNode* NOCACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> READS();
    antlr4::tree::TerminalNode* READS(size_t i);
    std::vector<Logging_clauseContext *> logging_clause();
    Logging_clauseContext* logging_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Modify_lob_parametersContext* modify_lob_parameters();

  class  Lob_parametersContext : public antlr4::ParserRuleContext {
  public:
    Lob_parametersContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> STORAGE();
    antlr4::tree::TerminalNode* STORAGE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> IN();
    antlr4::tree::TerminalNode* IN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ROW();
    antlr4::tree::TerminalNode* ROW(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CHUNK();
    antlr4::tree::TerminalNode* CHUNK(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PCTVERSION();
    antlr4::tree::TerminalNode* PCTVERSION(size_t i);
    std::vector<antlr4::tree::TerminalNode *> FREEPOOLS();
    antlr4::tree::TerminalNode* FREEPOOLS(size_t i);
    std::vector<Lob_retention_clauseContext *> lob_retention_clause();
    Lob_retention_clauseContext* lob_retention_clause(size_t i);
    std::vector<Lob_deduplicate_clauseContext *> lob_deduplicate_clause();
    Lob_deduplicate_clauseContext* lob_deduplicate_clause(size_t i);
    std::vector<Lob_compression_clauseContext *> lob_compression_clause();
    Lob_compression_clauseContext* lob_compression_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ENCRYPT();
    antlr4::tree::TerminalNode* ENCRYPT(size_t i);
    std::vector<Encryption_specContext *> encryption_spec();
    Encryption_specContext* encryption_spec(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DECRYPT();
    antlr4::tree::TerminalNode* DECRYPT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ENABLE();
    antlr4::tree::TerminalNode* ENABLE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DISABLE();
    antlr4::tree::TerminalNode* DISABLE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> CACHE();
    antlr4::tree::TerminalNode* CACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NOCACHE();
    antlr4::tree::TerminalNode* NOCACHE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> READS();
    antlr4::tree::TerminalNode* READS(size_t i);
    std::vector<Logging_clauseContext *> logging_clause();
    Logging_clauseContext* logging_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lob_parametersContext* lob_parameters();

  class  Lob_deduplicate_clauseContext : public antlr4::ParserRuleContext {
  public:
    Lob_deduplicate_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEDUPLICATE();
    antlr4::tree::TerminalNode *KEEP_DUPLICATES();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lob_deduplicate_clauseContext* lob_deduplicate_clause();

  class  Lob_compression_clauseContext : public antlr4::ParserRuleContext {
  public:
    Lob_compression_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NOCOMPRESS();
    antlr4::tree::TerminalNode *COMPRESS();
    antlr4::tree::TerminalNode *HIGH();
    antlr4::tree::TerminalNode *MEDIUM();
    antlr4::tree::TerminalNode *LOW();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lob_compression_clauseContext* lob_compression_clause();

  class  Lob_retention_clauseContext : public antlr4::ParserRuleContext {
  public:
    Lob_retention_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RETENTION();
    antlr4::tree::TerminalNode *MAX();
    antlr4::tree::TerminalNode *MIN();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *AUTO();
    antlr4::tree::TerminalNode *NONE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lob_retention_clauseContext* lob_retention_clause();

  class  Encryption_specContext : public antlr4::ParserRuleContext {
  public:
    Encryption_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    antlr4::tree::TerminalNode *IDENTIFIED();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *REGULAR_ID();
    antlr4::tree::TerminalNode *SALT();
    antlr4::tree::TerminalNode *NO();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Encryption_specContext* encryption_spec();

  class  TablespaceContext : public antlr4::ParserRuleContext {
  public:
    TablespaceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  TablespaceContext* tablespace();

  class  Varray_itemContext : public antlr4::ParserRuleContext {
  public:
    Varray_itemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Varray_itemContext* varray_item();

  class  Column_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Column_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Object_type_col_propertiesContext *> object_type_col_properties();
    Object_type_col_propertiesContext* object_type_col_properties(size_t i);
    std::vector<Nested_table_col_propertiesContext *> nested_table_col_properties();
    Nested_table_col_propertiesContext* nested_table_col_properties(size_t i);
    std::vector<Xmltype_column_propertiesContext *> xmltype_column_properties();
    Xmltype_column_propertiesContext* xmltype_column_properties(size_t i);
    std::vector<Varray_col_propertiesContext *> varray_col_properties();
    Varray_col_propertiesContext* varray_col_properties(size_t i);
    std::vector<Lob_storage_clauseContext *> lob_storage_clause();
    Lob_storage_clauseContext* lob_storage_clause(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<Lob_partition_storageContext *> lob_partition_storage();
    Lob_partition_storageContext* lob_partition_storage(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_propertiesContext* column_properties();

  class  Lob_partition_storageContext : public antlr4::ParserRuleContext {
  public:
    Lob_partition_storageContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOB();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<Lob_itemContext *> lob_item();
    Lob_itemContext* lob_item(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *COMMA();
    std::vector<Lob_storage_parametersContext *> lob_storage_parameters();
    Lob_storage_parametersContext* lob_storage_parameters(size_t i);
    std::vector<Lob_segnameContext *> lob_segname();
    Lob_segnameContext* lob_segname(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SECUREFILE();
    antlr4::tree::TerminalNode* SECUREFILE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> BASICFILE();
    antlr4::tree::TerminalNode* BASICFILE(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lob_partition_storageContext* lob_partition_storage();

  class  Period_definitionContext : public antlr4::ParserRuleContext {
  public:
    Period_definitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *FOR();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Start_time_columnContext *start_time_column();
    antlr4::tree::TerminalNode *COMMA();
    End_time_columnContext *end_time_column();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Period_definitionContext* period_definition();

  class  Start_time_columnContext : public antlr4::ParserRuleContext {
  public:
    Start_time_columnContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Start_time_columnContext* start_time_column();

  class  End_time_columnContext : public antlr4::ParserRuleContext {
  public:
    End_time_columnContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  End_time_columnContext* end_time_column();

  class  Column_definitionContext : public antlr4::ParserRuleContext {
  public:
    Column_definitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *SORT();
    antlr4::tree::TerminalNode *DEFAULT();
    ExpressionContext *expression();
    Identity_clauseContext *identity_clause();
    antlr4::tree::TerminalNode *ENCRYPT();
    Encryption_specContext *encryption_spec();
    Inline_ref_constraintContext *inline_ref_constraint();
    Annotations_clauseContext *annotations_clause();
    antlr4::tree::TerminalNode *VISIBLE();
    antlr4::tree::TerminalNode *INVISIBLE();
    DatatypeContext *datatype();
    Type_nameContext *type_name();
    antlr4::tree::TerminalNode *COLLATE();
    Column_collation_nameContext *column_collation_name();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *NULL_();
    std::vector<Inline_constraintContext *> inline_constraint();
    Inline_constraintContext* inline_constraint(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_definitionContext* column_definition();

  class  Column_collation_nameContext : public antlr4::ParserRuleContext {
  public:
    Column_collation_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_collation_nameContext* column_collation_name();

  class  Identity_clauseContext : public antlr4::ParserRuleContext {
  public:
    Identity_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GENERATED();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *IDENTITY();
    antlr4::tree::TerminalNode *ALWAYS();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *DEFAULT();
    Identity_options_parenthesesContext *identity_options_parentheses();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *NULL_();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Identity_clauseContext* identity_clause();

  class  Identity_options_parenthesesContext : public antlr4::ParserRuleContext {
  public:
    Identity_options_parenthesesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Identity_optionsContext *> identity_options();
    Identity_optionsContext* identity_options(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Identity_options_parenthesesContext* identity_options_parentheses();

  class  Identity_optionsContext : public antlr4::ParserRuleContext {
  public:
    Identity_optionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *START();
    antlr4::tree::TerminalNode *WITH();
    NumericContext *numeric();
    antlr4::tree::TerminalNode *LIMIT();
    antlr4::tree::TerminalNode *VALUE();
    antlr4::tree::TerminalNode *INCREMENT();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *MAXVALUE();
    antlr4::tree::TerminalNode *NOMAXVALUE();
    antlr4::tree::TerminalNode *MINVALUE();
    antlr4::tree::TerminalNode *NOMINVALUE();
    antlr4::tree::TerminalNode *CYCLE();
    antlr4::tree::TerminalNode *NOCYCLE();
    antlr4::tree::TerminalNode *CACHE();
    antlr4::tree::TerminalNode *NOCACHE();
    antlr4::tree::TerminalNode *ORDER();
    antlr4::tree::TerminalNode *NOORDER();
    antlr4::tree::TerminalNode *SCALE();
    antlr4::tree::TerminalNode *EXTEND();
    antlr4::tree::TerminalNode *NOEXTEND();
    antlr4::tree::TerminalNode *NOSCALE();
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *NOKEEP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Identity_optionsContext* identity_options();

  class  Virtual_column_definitionContext : public antlr4::ParserRuleContext {
  public:
    Virtual_column_definitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    DatatypeContext *datatype();
    Virtual_column_expressionContext *virtual_column_expression();
    antlr4::tree::TerminalNode *VIRTUAL();
    Evaluation_edition_clauseContext *evaluation_edition_clause();
    std::vector<antlr4::tree::TerminalNode *> UNUSABLE();
    antlr4::tree::TerminalNode* UNUSABLE(size_t i);
    antlr4::tree::TerminalNode *BEFORE();
    antlr4::tree::TerminalNode *BEGINNING();
    antlr4::tree::TerminalNode *WITH();
    std::vector<Inline_constraintContext *> inline_constraint();
    Inline_constraintContext* inline_constraint(size_t i);
    By_user_for_statistics_clauseContext *by_user_for_statistics_clause();
    antlr4::tree::TerminalNode *VISIBLE();
    antlr4::tree::TerminalNode *INVISIBLE();
    std::vector<antlr4::tree::TerminalNode *> CURRENT();
    antlr4::tree::TerminalNode* CURRENT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> EDITION();
    antlr4::tree::TerminalNode* EDITION(size_t i);
    std::vector<Edition_nameContext *> edition_name();
    Edition_nameContext* edition_name(size_t i);
    antlr4::tree::TerminalNode *COLLATE();
    Column_collation_nameContext *column_collation_name();
    antlr4::tree::TerminalNode *NULL_();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Virtual_column_definitionContext* virtual_column_definition();

  class  Virtual_column_expressionContext : public antlr4::ParserRuleContext {
  public:
    Virtual_column_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Autogenerated_sequence_definitionContext *autogenerated_sequence_definition();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *GENERATED();
    antlr4::tree::TerminalNode *ALWAYS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Virtual_column_expressionContext* virtual_column_expression();

  class  Autogenerated_sequence_definitionContext : public antlr4::ParserRuleContext {
  public:
    Autogenerated_sequence_definitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GENERATED();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *IDENTITY();
    antlr4::tree::TerminalNode *ALWAYS();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *NULL_();
    std::vector<Sequence_start_clauseContext *> sequence_start_clause();
    Sequence_start_clauseContext* sequence_start_clause(size_t i);
    std::vector<Sequence_specContext *> sequence_spec();
    Sequence_specContext* sequence_spec(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Autogenerated_sequence_definitionContext* autogenerated_sequence_definition();

  class  By_user_for_statistics_clauseContext : public antlr4::ParserRuleContext {
  public:
    By_user_for_statistics_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *USER();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *STATISTICS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  By_user_for_statistics_clauseContext* by_user_for_statistics_clause();

  class  Evaluation_edition_clauseContext : public antlr4::ParserRuleContext {
  public:
    Evaluation_edition_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EVALUATE();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *EDITION();
    Edition_nameContext *edition_name();
    antlr4::tree::TerminalNode *CURRENT();
    antlr4::tree::TerminalNode *NULL_();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Evaluation_edition_clauseContext* evaluation_edition_clause();

  class  Nested_table_col_propertiesContext : public antlr4::ParserRuleContext {
  public:
    Nested_table_col_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NESTED();
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *STORE();
    std::vector<antlr4::tree::TerminalNode *> AS();
    antlr4::tree::TerminalNode* AS(size_t i);
    Tableview_nameContext *tableview_name();
    Nested_itemContext *nested_item();
    antlr4::tree::TerminalNode *COLUMN_VALUE();
    Substitutable_column_clauseContext *substitutable_column_clause();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *RETURN();
    antlr4::tree::TerminalNode *LOCAL();
    antlr4::tree::TerminalNode *GLOBAL();
    antlr4::tree::TerminalNode *LOCATOR();
    antlr4::tree::TerminalNode *VALUE();
    std::vector<Object_propertiesContext *> object_properties();
    Object_propertiesContext* object_properties(size_t i);
    std::vector<Physical_propertiesContext *> physical_properties();
    Physical_propertiesContext* physical_properties(size_t i);
    std::vector<Column_propertiesContext *> column_properties();
    Column_propertiesContext* column_properties(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Nested_table_col_propertiesContext* nested_table_col_properties();

  class  Nested_itemContext : public antlr4::ParserRuleContext {
  public:
    Nested_itemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Nested_itemContext* nested_item();

  class  Substitutable_column_clauseContext : public antlr4::ParserRuleContext {
  public:
    Substitutable_column_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *OF();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Type_nameContext *type_name();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *ELEMENT();
    antlr4::tree::TerminalNode *TYPE();
    antlr4::tree::TerminalNode *SUBSTITUTABLE();
    antlr4::tree::TerminalNode *AT();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *LEVELS();
    antlr4::tree::TerminalNode *NOT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Substitutable_column_clauseContext* substitutable_column_clause();

  class  Partition_nameContext : public antlr4::ParserRuleContext {
  public:
    Partition_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();
    antlr4::tree::TerminalNode *DELIMITED_ID();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partition_nameContext* partition_name();

  class  Supplemental_logging_propsContext : public antlr4::ParserRuleContext {
  public:
    Supplemental_logging_propsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUPPLEMENTAL();
    antlr4::tree::TerminalNode *LOG();
    Supplemental_log_grp_clauseContext *supplemental_log_grp_clause();
    Supplemental_id_key_clauseContext *supplemental_id_key_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Supplemental_logging_propsContext* supplemental_logging_props();

  class  Object_type_col_propertiesContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Regular_idContext *column = nullptr;
    Object_type_col_propertiesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COLUMN();
    Substitutable_column_clauseContext *substitutable_column_clause();
    Regular_idContext *regular_id();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_type_col_propertiesContext* object_type_col_properties();

  class  Constraint_clausesContext : public antlr4::ParserRuleContext {
  public:
    Constraint_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Out_of_line_constraintContext *> out_of_line_constraint();
    Out_of_line_constraintContext* out_of_line_constraint(size_t i);
    Out_of_line_ref_constraintContext *out_of_line_ref_constraint();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *MODIFY();
    Constraint_stateContext *constraint_state();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *UNIQUE();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *RENAME();
    Old_constraint_nameContext *old_constraint_name();
    antlr4::tree::TerminalNode *TO();
    New_constraint_nameContext *new_constraint_name();
    std::vector<Drop_constraint_clauseContext *> drop_constraint_clause();
    Drop_constraint_clauseContext* drop_constraint_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Constraint_clausesContext* constraint_clauses();

  class  Old_constraint_nameContext : public antlr4::ParserRuleContext {
  public:
    Old_constraint_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Constraint_nameContext *constraint_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Old_constraint_nameContext* old_constraint_name();

  class  New_constraint_nameContext : public antlr4::ParserRuleContext {
  public:
    New_constraint_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Constraint_nameContext *constraint_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  New_constraint_nameContext* new_constraint_name();

  class  Drop_constraint_clauseContext : public antlr4::ParserRuleContext {
  public:
    Drop_constraint_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> DROP();
    antlr4::tree::TerminalNode* DROP(size_t i);
    antlr4::tree::TerminalNode *PRIMARY();
    std::vector<antlr4::tree::TerminalNode *> KEY();
    antlr4::tree::TerminalNode* KEY(size_t i);
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *INDEX();
    antlr4::tree::TerminalNode *ONLINE();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Drop_constraint_clauseContext* drop_constraint_clause();

  class  Check_constraintContext : public antlr4::ParserRuleContext {
  public:
    Check_constraintContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHECK();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *DISABLE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Check_constraintContext* check_constraint();

  class  Foreign_key_clauseContext : public antlr4::ParserRuleContext {
  public:
    Foreign_key_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOREIGN();
    antlr4::tree::TerminalNode *KEY();
    Paren_column_listContext *paren_column_list();
    References_clauseContext *references_clause();
    On_delete_clauseContext *on_delete_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Foreign_key_clauseContext* foreign_key_clause();

  class  References_clauseContext : public antlr4::ParserRuleContext {
  public:
    References_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REFERENCES();
    Tableview_nameContext *tableview_name();
    Paren_column_listContext *paren_column_list();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *NULL_();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  References_clauseContext* references_clause();

  class  On_delete_clauseContext : public antlr4::ParserRuleContext {
  public:
    On_delete_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *NULL_();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  On_delete_clauseContext* on_delete_clause();

  class  Anonymous_blockContext : public antlr4::ParserRuleContext {
  public:
    Anonymous_blockContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BEGIN();
    Seq_of_statementsContext *seq_of_statements();
    antlr4::tree::TerminalNode *END();
    antlr4::tree::TerminalNode *DECLARE();
    antlr4::tree::TerminalNode *EXCEPTION();
    Seq_of_declare_specsContext *seq_of_declare_specs();
    std::vector<Exception_handlerContext *> exception_handler();
    Exception_handlerContext* exception_handler(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Anonymous_blockContext* anonymous_block();

  class  Invoker_rights_clauseContext : public antlr4::ParserRuleContext {
  public:
    Invoker_rights_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AUTHID();
    antlr4::tree::TerminalNode *CURRENT_USER();
    antlr4::tree::TerminalNode *DEFINER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Invoker_rights_clauseContext* invoker_rights_clause();

  class  Call_specContext : public antlr4::ParserRuleContext {
  public:
    Call_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Java_specContext *java_spec();
    C_specContext *c_spec();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Call_specContext* call_spec();

  class  Java_specContext : public antlr4::ParserRuleContext {
  public:
    Java_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LANGUAGE();
    antlr4::tree::TerminalNode *JAVA();
    antlr4::tree::TerminalNode *NAME();
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Java_specContext* java_spec();

  class  C_specContext : public antlr4::ParserRuleContext {
  public:
    C_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LANGUAGE();
    antlr4::tree::TerminalNode *C_LETTER();
    antlr4::tree::TerminalNode *EXTERNAL();
    antlr4::tree::TerminalNode *NAME();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *LIBRARY();
    IdentifierContext *identifier();
    C_agent_in_clauseContext *c_agent_in_clause();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *CONTEXT();
    C_parameters_clauseContext *c_parameters_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  C_specContext* c_spec();

  class  C_agent_in_clauseContext : public antlr4::ParserRuleContext {
  public:
    C_agent_in_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AGENT();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Expressions_Context *expressions_();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  C_agent_in_clauseContext* c_agent_in_clause();

  class  C_parameters_clauseContext : public antlr4::ParserRuleContext {
  public:
    C_parameters_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARAMETERS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<C_external_parameterContext *> c_external_parameter();
    C_external_parameterContext* c_external_parameter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  C_parameters_clauseContext* c_parameters_clause();

  class  C_external_parameterContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Regular_idContext *external_datatype = nullptr;
    C_external_parameterContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONTEXT();
    antlr4::tree::TerminalNode *SELF();
    antlr4::tree::TerminalNode *TDO();
    C_propertyContext *c_property();
    Parameter_nameContext *parameter_name();
    antlr4::tree::TerminalNode *RETURN();
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *REFERENCE();
    Regular_idContext *regular_id();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  C_external_parameterContext* c_external_parameter();

  class  C_propertyContext : public antlr4::ParserRuleContext {
  public:
    C_propertyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INDICATOR();
    antlr4::tree::TerminalNode *STRUCT();
    antlr4::tree::TerminalNode *TDO();
    antlr4::tree::TerminalNode *LENGTH();
    antlr4::tree::TerminalNode *DURATION();
    antlr4::tree::TerminalNode *MAXLEN();
    antlr4::tree::TerminalNode *CHARSETID();
    antlr4::tree::TerminalNode *CHARSETFORM();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  C_propertyContext* c_property();

  class  ParameterContext : public antlr4::ParserRuleContext {
  public:
    ParameterContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Parameter_nameContext *parameter_name();
    Type_specContext *type_spec();
    Default_value_partContext *default_value_part();
    std::vector<antlr4::tree::TerminalNode *> IN();
    antlr4::tree::TerminalNode* IN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> OUT();
    antlr4::tree::TerminalNode* OUT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> INOUT();
    antlr4::tree::TerminalNode* INOUT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NOCOPY();
    antlr4::tree::TerminalNode* NOCOPY(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ParameterContext* parameter();

  class  Default_value_partContext : public antlr4::ParserRuleContext {
  public:
    Default_value_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *ASSIGN_OP();
    antlr4::tree::TerminalNode *DEFAULT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Default_value_partContext* default_value_part();

  class  Seq_of_declare_specsContext : public antlr4::ParserRuleContext {
  public:
    Seq_of_declare_specsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Declare_specContext *> declare_spec();
    Declare_specContext* declare_spec(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Seq_of_declare_specsContext* seq_of_declare_specs();

  class  Declare_specContext : public antlr4::ParserRuleContext {
  public:
    Declare_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Pragma_declarationContext *pragma_declaration();
    Exception_declarationContext *exception_declaration();
    Procedure_specContext *procedure_spec();
    Function_specContext *function_spec();
    Variable_declarationContext *variable_declaration();
    Subtype_declarationContext *subtype_declaration();
    Cursor_declarationContext *cursor_declaration();
    Type_declarationContext *type_declaration();
    Procedure_bodyContext *procedure_body();
    Function_bodyContext *function_body();
    Selection_directiveContext *selection_directive();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Declare_specContext* declare_spec();

  class  Variable_declarationContext : public antlr4::ParserRuleContext {
  public:
    Variable_declarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *CONSTANT();
    antlr4::tree::TerminalNode *NULL_();
    Default_value_partContext *default_value_part();
    antlr4::tree::TerminalNode *NOT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Variable_declarationContext* variable_declaration();

  class  Subtype_declarationContext : public antlr4::ParserRuleContext {
  public:
    Subtype_declarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBTYPE();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *IS();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *RANGE();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *DOUBLE_PERIOD();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *NULL_();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subtype_declarationContext* subtype_declaration();

  class  Cursor_declarationContext : public antlr4::ParserRuleContext {
  public:
    Cursor_declarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CURSOR();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Parameter_specContext *> parameter_spec();
    Parameter_specContext* parameter_spec(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *RETURN();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *IS();
    Select_statementContext *select_statement();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cursor_declarationContext* cursor_declaration();

  class  Parameter_specContext : public antlr4::ParserRuleContext {
  public:
    Parameter_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Parameter_nameContext *parameter_name();
    Type_specContext *type_spec();
    Default_value_partContext *default_value_part();
    antlr4::tree::TerminalNode *IN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Parameter_specContext* parameter_spec();

  class  Exception_declarationContext : public antlr4::ParserRuleContext {
  public:
    Exception_declarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *EXCEPTION();
    antlr4::tree::TerminalNode *SEMICOLON();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Exception_declarationContext* exception_declaration();

  class  Pragma_declarationContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::IdentifierContext *id1 = nullptr;
    Pragma_declarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PRAGMA();
    antlr4::tree::TerminalNode *SEMICOLON();
    antlr4::tree::TerminalNode *SERIALLY_REUSABLE();
    antlr4::tree::TerminalNode *AUTONOMOUS_TRANSACTION();
    antlr4::tree::TerminalNode *EXCEPTION_INIT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Exception_nameContext *exception_name();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Numeric_negativeContext *numeric_negative();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *INLINE();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RESTRICT_REFERENCES();
    antlr4::tree::TerminalNode *DEPRECATE();
    std::vector<IdentifierContext *> identifier();
    IdentifierContext* identifier(size_t i);
    antlr4::tree::TerminalNode *UDF();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pragma_declarationContext* pragma_declaration();

  class  Record_type_defContext : public antlr4::ParserRuleContext {
  public:
    Record_type_defContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RECORD();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Field_specContext *> field_spec();
    Field_specContext* field_spec(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Record_type_defContext* record_type_def();

  class  Field_specContext : public antlr4::ParserRuleContext {
  public:
    Field_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *NULL_();
    Default_value_partContext *default_value_part();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Field_specContext* field_spec();

  class  Ref_cursor_type_defContext : public antlr4::ParserRuleContext {
  public:
    Ref_cursor_type_defContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REF();
    antlr4::tree::TerminalNode *CURSOR();
    antlr4::tree::TerminalNode *RETURN();
    Type_specContext *type_spec();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Ref_cursor_type_defContext* ref_cursor_type_def();

  class  Type_declarationContext : public antlr4::ParserRuleContext {
  public:
    Type_declarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TYPE();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *SEMICOLON();
    Table_type_defContext *table_type_def();
    Varray_type_defContext *varray_type_def();
    Record_type_defContext *record_type_def();
    Ref_cursor_type_defContext *ref_cursor_type_def();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Type_declarationContext* type_declaration();

  class  Table_type_defContext : public antlr4::ParserRuleContext {
  public:
    Table_type_defContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *OF();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *NULL_();
    Table_indexed_by_partContext *table_indexed_by_part();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_type_defContext* table_type_def();

  class  Table_indexed_by_partContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *idx1 = nullptr;
    antlr4::Token *idx2 = nullptr;
    Table_indexed_by_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BY();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *INDEXED();
    antlr4::tree::TerminalNode *INDEX();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_indexed_by_partContext* table_indexed_by_part();

  class  Varray_type_defContext : public antlr4::ParserRuleContext {
  public:
    Varray_type_defContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *OF();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *VARRAY();
    antlr4::tree::TerminalNode *ARRAY();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *VARYING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Varray_type_defContext* varray_type_def();

  class  Seq_of_statementsContext : public antlr4::ParserRuleContext {
  public:
    Seq_of_statementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<StatementContext *> statement();
    StatementContext* statement(size_t i);
    std::vector<Label_declarationContext *> label_declaration();
    Label_declarationContext* label_declaration(size_t i);
    std::vector<Selection_directiveContext *> selection_directive();
    Selection_directiveContext* selection_directive(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SEMICOLON();
    antlr4::tree::TerminalNode* SEMICOLON(size_t i);
    std::vector<antlr4::tree::TerminalNode *> EOF();
    antlr4::tree::TerminalNode* EOF(size_t i);
    std::vector<Pragma_declarationContext *> pragma_declaration();
    Pragma_declarationContext* pragma_declaration(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Seq_of_statementsContext* seq_of_statements();

  class  Label_declarationContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *ltp1 = nullptr;
    Label_declarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> LESS_THAN_OP();
    antlr4::tree::TerminalNode* LESS_THAN_OP(size_t i);
    Label_nameContext *label_name();
    std::vector<antlr4::tree::TerminalNode *> GREATER_THAN_OP();
    antlr4::tree::TerminalNode* GREATER_THAN_OP(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Label_declarationContext* label_declaration();

  class  StatementContext : public antlr4::ParserRuleContext {
  public:
    StatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BodyContext *body();
    BlockContext *block();
    Assignment_statementContext *assignment_statement();
    Continue_statementContext *continue_statement();
    Exit_statementContext *exit_statement();
    Goto_statementContext *goto_statement();
    If_statementContext *if_statement();
    Loop_statementContext *loop_statement();
    Forall_statementContext *forall_statement();
    Null_statementContext *null_statement();
    Raise_statementContext *raise_statement();
    Return_statementContext *return_statement();
    Case_statementContext *case_statement();
    Sql_statementContext *sql_statement();
    Call_statementContext *call_statement();
    Pipe_row_statementContext *pipe_row_statement();
    Grant_statementContext *grant_statement();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  StatementContext* statement();

  class  Assignment_statementContext : public antlr4::ParserRuleContext {
  public:
    Assignment_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ASSIGN_OP();
    ExpressionContext *expression();
    General_elementContext *general_element();
    Bind_variableContext *bind_variable();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Assignment_statementContext* assignment_statement();

  class  Continue_statementContext : public antlr4::ParserRuleContext {
  public:
    Continue_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONTINUE();
    Label_nameContext *label_name();
    antlr4::tree::TerminalNode *WHEN();
    ConditionContext *condition();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Continue_statementContext* continue_statement();

  class  Exit_statementContext : public antlr4::ParserRuleContext {
  public:
    Exit_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXIT();
    Label_nameContext *label_name();
    antlr4::tree::TerminalNode *WHEN();
    ConditionContext *condition();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Exit_statementContext* exit_statement();

  class  Goto_statementContext : public antlr4::ParserRuleContext {
  public:
    Goto_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GOTO();
    Label_nameContext *label_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Goto_statementContext* goto_statement();

  class  If_statementContext : public antlr4::ParserRuleContext {
  public:
    If_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> IF();
    antlr4::tree::TerminalNode* IF(size_t i);
    ConditionContext *condition();
    antlr4::tree::TerminalNode *THEN();
    Seq_of_statementsContext *seq_of_statements();
    antlr4::tree::TerminalNode *END();
    std::vector<Elsif_partContext *> elsif_part();
    Elsif_partContext* elsif_part(size_t i);
    Else_partContext *else_part();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  If_statementContext* if_statement();

  class  Elsif_partContext : public antlr4::ParserRuleContext {
  public:
    Elsif_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ELSIF();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *THEN();
    Seq_of_statementsContext *seq_of_statements();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Elsif_partContext* elsif_part();

  class  Else_partContext : public antlr4::ParserRuleContext {
  public:
    Else_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ELSE();
    Seq_of_statementsContext *seq_of_statements();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Else_partContext* else_part();

  class  Loop_statementContext : public antlr4::ParserRuleContext {
  public:
    Loop_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> LOOP();
    antlr4::tree::TerminalNode* LOOP(size_t i);
    Seq_of_statementsContext *seq_of_statements();
    antlr4::tree::TerminalNode *END();
    Label_declarationContext *label_declaration();
    antlr4::tree::TerminalNode *WHILE();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *FOR();
    Cursor_loop_paramContext *cursor_loop_param();
    Label_nameContext *label_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Loop_statementContext* loop_statement();

  class  Cursor_loop_paramContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *range_separator = nullptr;
    Cursor_loop_paramContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Index_nameContext *index_name();
    antlr4::tree::TerminalNode *IN();
    Lower_boundContext *lower_bound();
    Upper_boundContext *upper_bound();
    antlr4::tree::TerminalNode *DOUBLE_PERIOD();
    antlr4::tree::TerminalNode *REVERSE();
    Record_nameContext *record_name();
    Cursor_nameContext *cursor_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Select_statementContext *select_statement();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Expressions_Context *expressions_();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cursor_loop_paramContext* cursor_loop_param();

  class  Forall_statementContext : public antlr4::ParserRuleContext {
  public:
    Forall_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FORALL();
    Index_nameContext *index_name();
    antlr4::tree::TerminalNode *IN();
    Bounds_clauseContext *bounds_clause();
    Data_manipulation_language_statementsContext *data_manipulation_language_statements();
    Execute_immediateContext *execute_immediate();
    antlr4::tree::TerminalNode *SAVE();
    antlr4::tree::TerminalNode *EXCEPTIONS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Forall_statementContext* forall_statement();

  class  Bounds_clauseContext : public antlr4::ParserRuleContext {
  public:
    Bounds_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Lower_boundContext *lower_bound();
    antlr4::tree::TerminalNode *DOUBLE_PERIOD();
    Upper_boundContext *upper_bound();
    antlr4::tree::TerminalNode *INDICES();
    antlr4::tree::TerminalNode *OF();
    General_elementContext *general_element();
    Between_boundContext *between_bound();
    antlr4::tree::TerminalNode *VALUES();
    Index_nameContext *index_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Bounds_clauseContext* bounds_clause();

  class  Between_boundContext : public antlr4::ParserRuleContext {
  public:
    Between_boundContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BETWEEN();
    Lower_boundContext *lower_bound();
    antlr4::tree::TerminalNode *AND();
    Upper_boundContext *upper_bound();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Between_boundContext* between_bound();

  class  Lower_boundContext : public antlr4::ParserRuleContext {
  public:
    Lower_boundContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ConcatenationContext *concatenation();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lower_boundContext* lower_bound();

  class  Upper_boundContext : public antlr4::ParserRuleContext {
  public:
    Upper_boundContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ConcatenationContext *concatenation();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Upper_boundContext* upper_bound();

  class  Null_statementContext : public antlr4::ParserRuleContext {
  public:
    Null_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NULL_();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Null_statementContext* null_statement();

  class  Raise_statementContext : public antlr4::ParserRuleContext {
  public:
    Raise_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RAISE();
    Exception_nameContext *exception_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Raise_statementContext* raise_statement();

  class  Return_statementContext : public antlr4::ParserRuleContext {
  public:
    Return_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RETURN();
    ExpressionContext *expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Return_statementContext* return_statement();

  class  Call_statementContext : public antlr4::ParserRuleContext {
  public:
    Call_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Routine_nameContext *> routine_name();
    Routine_nameContext* routine_name(size_t i);
    antlr4::tree::TerminalNode *CALL();
    std::vector<Function_argumentContext *> function_argument();
    Function_argumentContext* function_argument(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    antlr4::tree::TerminalNode *INTO();
    Bind_variableContext *bind_variable();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Call_statementContext* call_statement();

  class  Pipe_row_statementContext : public antlr4::ParserRuleContext {
  public:
    Pipe_row_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PIPE();
    antlr4::tree::TerminalNode *ROW();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pipe_row_statementContext* pipe_row_statement();

  class  Selection_directiveContext : public antlr4::ParserRuleContext {
  public:
    Selection_directiveContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DOLLAR_IF();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *DOLLAR_THEN();
    std::vector<Selection_directive_bodyContext *> selection_directive_body();
    Selection_directive_bodyContext* selection_directive_body(size_t i);
    antlr4::tree::TerminalNode *DOLLAR_END();
    std::vector<antlr4::tree::TerminalNode *> DOLLAR_ELSIF();
    antlr4::tree::TerminalNode* DOLLAR_ELSIF(size_t i);
    antlr4::tree::TerminalNode *DOLLAR_ELSE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Selection_directiveContext* selection_directive();

  class  Error_directiveContext : public antlr4::ParserRuleContext {
  public:
    Error_directiveContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DOLLAR_ERROR();
    ConcatenationContext *concatenation();
    antlr4::tree::TerminalNode *DOLLAR_END();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Error_directiveContext* error_directive();

  class  Selection_directive_bodyContext : public antlr4::ParserRuleContext {
  public:
    Selection_directive_bodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<StatementContext *> statement();
    StatementContext* statement(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SEMICOLON();
    antlr4::tree::TerminalNode* SEMICOLON(size_t i);
    std::vector<Variable_declarationContext *> variable_declaration();
    Variable_declarationContext* variable_declaration(size_t i);
    std::vector<Error_directiveContext *> error_directive();
    Error_directiveContext* error_directive(size_t i);
    std::vector<Function_bodyContext *> function_body();
    Function_bodyContext* function_body(size_t i);
    std::vector<Procedure_bodyContext *> procedure_body();
    Procedure_bodyContext* procedure_body(size_t i);
    std::vector<Pragma_declarationContext *> pragma_declaration();
    Pragma_declarationContext* pragma_declaration(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Selection_directive_bodyContext* selection_directive_body();

  class  BodyContext : public antlr4::ParserRuleContext {
  public:
    BodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BEGIN();
    Seq_of_statementsContext *seq_of_statements();
    antlr4::tree::TerminalNode *END();
    antlr4::tree::TerminalNode *EXCEPTION();
    Label_nameContext *label_name();
    std::vector<Exception_handlerContext *> exception_handler();
    Exception_handlerContext* exception_handler(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  BodyContext* body();

  class  Exception_handlerContext : public antlr4::ParserRuleContext {
  public:
    Exception_handlerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    std::vector<Exception_nameContext *> exception_name();
    Exception_nameContext* exception_name(size_t i);
    antlr4::tree::TerminalNode *THEN();
    Seq_of_statementsContext *seq_of_statements();
    std::vector<antlr4::tree::TerminalNode *> OR();
    antlr4::tree::TerminalNode* OR(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Exception_handlerContext* exception_handler();

  class  Trigger_blockContext : public antlr4::ParserRuleContext {
  public:
    Trigger_blockContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BodyContext *body();
    antlr4::tree::TerminalNode *DECLARE();
    std::vector<Declare_specContext *> declare_spec();
    Declare_specContext* declare_spec(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Trigger_blockContext* trigger_block();

  class  Tps_blockContext : public antlr4::ParserRuleContext {
  public:
    Tps_blockContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BodyContext *body();
    std::vector<Declare_specContext *> declare_spec();
    Declare_specContext* declare_spec(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tps_blockContext* tps_block();

  class  BlockContext : public antlr4::ParserRuleContext {
  public:
    BlockContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BodyContext *body();
    antlr4::tree::TerminalNode *DECLARE();
    std::vector<Declare_specContext *> declare_spec();
    Declare_specContext* declare_spec(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  BlockContext* block();

  class  Sql_statementContext : public antlr4::ParserRuleContext {
  public:
    Sql_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Execute_immediateContext *execute_immediate();
    Data_manipulation_language_statementsContext *data_manipulation_language_statements();
    Cursor_manipulation_statementsContext *cursor_manipulation_statements();
    Transaction_control_statementsContext *transaction_control_statements();
    Collection_method_callContext *collection_method_call();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sql_statementContext* sql_statement();

  class  Execute_immediateContext : public antlr4::ParserRuleContext {
  public:
    Execute_immediateContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXECUTE();
    antlr4::tree::TerminalNode *IMMEDIATE();
    ExpressionContext *expression();
    Into_clauseContext *into_clause();
    Using_clauseContext *using_clause();
    Dynamic_returning_clauseContext *dynamic_returning_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Execute_immediateContext* execute_immediate();

  class  Dynamic_returning_clauseContext : public antlr4::ParserRuleContext {
  public:
    Dynamic_returning_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Into_clauseContext *into_clause();
    antlr4::tree::TerminalNode *RETURNING();
    antlr4::tree::TerminalNode *RETURN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dynamic_returning_clauseContext* dynamic_returning_clause();

  class  Data_manipulation_language_statementsContext : public antlr4::ParserRuleContext {
  public:
    Data_manipulation_language_statementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Merge_statementContext *merge_statement();
    Lock_table_statementContext *lock_table_statement();
    Select_statementContext *select_statement();
    Update_statementContext *update_statement();
    Delete_statementContext *delete_statement();
    Insert_statementContext *insert_statement();
    Explain_statementContext *explain_statement();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Data_manipulation_language_statementsContext* data_manipulation_language_statements();

  class  Cursor_manipulation_statementsContext : public antlr4::ParserRuleContext {
  public:
    Cursor_manipulation_statementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Close_statementContext *close_statement();
    Open_statementContext *open_statement();
    Fetch_statementContext *fetch_statement();
    Open_for_statementContext *open_for_statement();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cursor_manipulation_statementsContext* cursor_manipulation_statements();

  class  Close_statementContext : public antlr4::ParserRuleContext {
  public:
    Close_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CLOSE();
    Cursor_nameContext *cursor_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Close_statementContext* close_statement();

  class  Open_statementContext : public antlr4::ParserRuleContext {
  public:
    Open_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OPEN();
    Cursor_nameContext *cursor_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Expressions_Context *expressions_();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Open_statementContext* open_statement();

  class  Fetch_statementContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *it1 = nullptr;
    Fetch_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FETCH();
    Cursor_nameContext *cursor_name();
    std::vector<Variable_or_collectionContext *> variable_or_collection();
    Variable_or_collectionContext* variable_or_collection(size_t i);
    antlr4::tree::TerminalNode *BULK();
    antlr4::tree::TerminalNode *COLLECT();
    antlr4::tree::TerminalNode *INTO();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *LIMIT();
    NumericContext *numeric();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Fetch_statementContext* fetch_statement();

  class  Variable_or_collectionContext : public antlr4::ParserRuleContext {
  public:
    Variable_or_collectionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Variable_nameContext *variable_name();
    Collection_expressionContext *collection_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Variable_or_collectionContext* variable_or_collection();

  class  Open_for_statementContext : public antlr4::ParserRuleContext {
  public:
    Open_for_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OPEN();
    Variable_nameContext *variable_name();
    antlr4::tree::TerminalNode *FOR();
    Select_statementContext *select_statement();
    ExpressionContext *expression();
    Using_clauseContext *using_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Open_for_statementContext* open_for_statement();

  class  Transaction_control_statementsContext : public antlr4::ParserRuleContext {
  public:
    Transaction_control_statementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Set_transaction_commandContext *set_transaction_command();
    Set_constraint_commandContext *set_constraint_command();
    Commit_statementContext *commit_statement();
    Rollback_statementContext *rollback_statement();
    Savepoint_statementContext *savepoint_statement();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Transaction_control_statementsContext* transaction_control_statements();

  class  Set_transaction_commandContext : public antlr4::ParserRuleContext {
  public:
    Set_transaction_commandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *TRANSACTION();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *ISOLATION();
    antlr4::tree::TerminalNode *LEVEL();
    antlr4::tree::TerminalNode *USE();
    antlr4::tree::TerminalNode *ROLLBACK();
    antlr4::tree::TerminalNode *SEGMENT();
    Rollback_segment_nameContext *rollback_segment_name();
    antlr4::tree::TerminalNode *NAME();
    Quoted_stringContext *quoted_string();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *WRITE();
    antlr4::tree::TerminalNode *SERIALIZABLE();
    antlr4::tree::TerminalNode *COMMITTED();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Set_transaction_commandContext* set_transaction_command();

  class  Set_constraint_commandContext : public antlr4::ParserRuleContext {
  public:
    Set_constraint_commandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *CONSTRAINT();
    antlr4::tree::TerminalNode *CONSTRAINTS();
    antlr4::tree::TerminalNode *IMMEDIATE();
    antlr4::tree::TerminalNode *DEFERRED();
    antlr4::tree::TerminalNode *ALL();
    std::vector<Constraint_nameContext *> constraint_name();
    Constraint_nameContext* constraint_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Set_constraint_commandContext* set_constraint_command();

  class  Commit_statementContext : public antlr4::ParserRuleContext {
  public:
    Commit_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *WORK();
    std::vector<Write_clauseContext *> write_clause();
    Write_clauseContext* write_clause(size_t i);
    antlr4::tree::TerminalNode *COMMENT();
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *CORRUPT_XID();
    antlr4::tree::TerminalNode *CORRUPT_XID_ALL();
    antlr4::tree::TerminalNode *COMMA();
    NumericContext *numeric();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Commit_statementContext* commit_statement();

  class  Write_clauseContext : public antlr4::ParserRuleContext {
  public:
    Write_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WRITE();
    std::vector<antlr4::tree::TerminalNode *> IMMEDIATE();
    antlr4::tree::TerminalNode* IMMEDIATE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> BATCH();
    antlr4::tree::TerminalNode* BATCH(size_t i);
    std::vector<antlr4::tree::TerminalNode *> WAIT();
    antlr4::tree::TerminalNode* WAIT(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NOWAIT();
    antlr4::tree::TerminalNode* NOWAIT(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Write_clauseContext* write_clause();

  class  Rollback_statementContext : public antlr4::ParserRuleContext {
  public:
    Rollback_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ROLLBACK();
    antlr4::tree::TerminalNode *WORK();
    antlr4::tree::TerminalNode *TO();
    Savepoint_nameContext *savepoint_name();
    antlr4::tree::TerminalNode *FORCE();
    Quoted_stringContext *quoted_string();
    antlr4::tree::TerminalNode *SAVEPOINT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Rollback_statementContext* rollback_statement();

  class  Savepoint_statementContext : public antlr4::ParserRuleContext {
  public:
    Savepoint_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SAVEPOINT();
    Savepoint_nameContext *savepoint_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Savepoint_statementContext* savepoint_statement();

  class  Collection_method_callContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::ExpressionContext *expressionContext = nullptr;
    std::vector<ExpressionContext *> index;
    Collection_method_callContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *TRIM();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *EXTEND();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Collection_method_callContext* collection_method_call();

  class  Explain_statementContext : public antlr4::ParserRuleContext {
  public:
    Explain_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXPLAIN();
    antlr4::tree::TerminalNode *PLAN();
    antlr4::tree::TerminalNode *FOR();
    Select_statementContext *select_statement();
    Update_statementContext *update_statement();
    Delete_statementContext *delete_statement();
    Insert_statementContext *insert_statement();
    Merge_statementContext *merge_statement();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *STATEMENT_ID();
    antlr4::tree::TerminalNode *EQUALS_OP();
    Quoted_stringContext *quoted_string();
    antlr4::tree::TerminalNode *INTO();
    Tableview_nameContext *tableview_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Explain_statementContext* explain_statement();

  class  Select_only_statementContext : public antlr4::ParserRuleContext {
  public:
    Select_only_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SubqueryContext *subquery();
    With_clauseContext *with_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Select_only_statementContext* select_only_statement();

  class  Select_statementContext : public antlr4::ParserRuleContext {
  public:
    Select_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Select_only_statementContext *select_only_statement();
    std::vector<For_update_clauseContext *> for_update_clause();
    For_update_clauseContext* for_update_clause(size_t i);
    std::vector<Order_by_clauseContext *> order_by_clause();
    Order_by_clauseContext* order_by_clause(size_t i);
    std::vector<Offset_clauseContext *> offset_clause();
    Offset_clauseContext* offset_clause(size_t i);
    std::vector<Fetch_clauseContext *> fetch_clause();
    Fetch_clauseContext* fetch_clause(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Select_statementContext* select_statement();

  class  With_clauseContext : public antlr4::ParserRuleContext {
  public:
    With_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WITH();
    std::vector<With_factoring_clauseContext *> with_factoring_clause();
    With_factoring_clauseContext* with_factoring_clause(size_t i);
    std::vector<Function_bodyContext *> function_body();
    Function_bodyContext* function_body(size_t i);
    std::vector<Procedure_bodyContext *> procedure_body();
    Procedure_bodyContext* procedure_body(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  With_clauseContext* with_clause();

  class  With_factoring_clauseContext : public antlr4::ParserRuleContext {
  public:
    With_factoring_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Subquery_factoring_clauseContext *subquery_factoring_clause();
    Subav_factoring_clauseContext *subav_factoring_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  With_factoring_clauseContext* with_factoring_clause();

  class  Subquery_factoring_clauseContext : public antlr4::ParserRuleContext {
  public:
    Subquery_factoring_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Query_nameContext *query_name();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Paren_column_listContext *paren_column_list();
    Order_by_clauseContext *order_by_clause();
    Search_clauseContext *search_clause();
    Cycle_clauseContext *cycle_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subquery_factoring_clauseContext* subquery_factoring_clause();

  class  Search_clauseContext : public antlr4::ParserRuleContext {
  public:
    Search_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SEARCH();
    std::vector<antlr4::tree::TerminalNode *> FIRST();
    antlr4::tree::TerminalNode* FIRST(size_t i);
    antlr4::tree::TerminalNode *BY();
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *DEPTH();
    antlr4::tree::TerminalNode *BREADTH();
    std::vector<antlr4::tree::TerminalNode *> ASC();
    antlr4::tree::TerminalNode* ASC(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DESC();
    antlr4::tree::TerminalNode* DESC(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NULLS();
    antlr4::tree::TerminalNode* NULLS(size_t i);
    std::vector<antlr4::tree::TerminalNode *> LAST();
    antlr4::tree::TerminalNode* LAST(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Search_clauseContext* search_clause();

  class  Cycle_clauseContext : public antlr4::ParserRuleContext {
  public:
    Cycle_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CYCLE();
    Column_listContext *column_list();
    antlr4::tree::TerminalNode *SET();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *TO();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *DEFAULT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cycle_clauseContext* cycle_clause();

  class  Subav_factoring_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *subav_name = nullptr;
    Subav_factoring_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ANALYTIC();
    antlr4::tree::TerminalNode *VIEW();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Subav_clauseContext *subav_clause();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subav_factoring_clauseContext* subav_factoring_clause();

  class  Subav_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Object_nameContext *subav_name = nullptr;
    Subav_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    Object_nameContext *object_name();
    Hierarchies_clauseContext *hierarchies_clause();
    Filter_clausesContext *filter_clauses();
    Add_calcs_clauseContext *add_calcs_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subav_clauseContext* subav_clause();

  class  Hierarchies_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Object_nameContext *object_nameContext = nullptr;
    std::vector<Object_nameContext *> hier_alias;
    Hierarchies_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *HIERARCHIES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Object_nameContext *> object_name();
    Object_nameContext* object_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hierarchies_clauseContext* hierarchies_clause();

  class  Filter_clausesContext : public antlr4::ParserRuleContext {
  public:
    Filter_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FILTER();
    antlr4::tree::TerminalNode *FACT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Filter_clauseContext *> filter_clause();
    Filter_clauseContext* filter_clause(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Filter_clausesContext* filter_clauses();

  class  Filter_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Object_nameContext *hier_alias = nullptr;
    Filter_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TO();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *MEASURES();
    Object_nameContext *object_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Filter_clauseContext* filter_clause();

  class  Add_calcs_clauseContext : public antlr4::ParserRuleContext {
  public:
    Add_calcs_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *MEASURES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Add_calc_meas_clauseContext *> add_calc_meas_clause();
    Add_calc_meas_clauseContext* add_calc_meas_clause(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_calcs_clauseContext* add_calcs_clause();

  class  Add_calc_meas_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *meas_name = nullptr;
    Add_calc_meas_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Add_calc_meas_clauseContext* add_calc_meas_clause();

  class  SubqueryContext : public antlr4::ParserRuleContext {
  public:
    SubqueryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Subquery_basic_elementsContext *subquery_basic_elements();
    std::vector<Subquery_operation_partContext *> subquery_operation_part();
    Subquery_operation_partContext* subquery_operation_part(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  SubqueryContext* subquery();

  class  Subquery_basic_elementsContext : public antlr4::ParserRuleContext {
  public:
    Subquery_basic_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Query_blockContext *query_block();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subquery_basic_elementsContext* subquery_basic_elements();

  class  Subquery_operation_partContext : public antlr4::ParserRuleContext {
  public:
    Subquery_operation_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Subquery_basic_elementsContext *subquery_basic_elements();
    antlr4::tree::TerminalNode *UNION();
    antlr4::tree::TerminalNode *INTERSECT();
    antlr4::tree::TerminalNode *MINUS();
    antlr4::tree::TerminalNode *ALL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subquery_operation_partContext* subquery_operation_part();

  class  Query_blockContext : public antlr4::ParserRuleContext {
  public:
    Query_blockContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SELECT();
    Selected_listContext *selected_list();
    Into_clauseContext *into_clause();
    From_clauseContext *from_clause();
    Where_clauseContext *where_clause();
    std::vector<Hierarchical_query_clauseContext *> hierarchical_query_clause();
    Hierarchical_query_clauseContext* hierarchical_query_clause(size_t i);
    std::vector<Group_by_clauseContext *> group_by_clause();
    Group_by_clauseContext* group_by_clause(size_t i);
    Model_clauseContext *model_clause();
    Order_by_clauseContext *order_by_clause();
    Offset_clauseContext *offset_clause();
    Fetch_clauseContext *fetch_clause();
    antlr4::tree::TerminalNode *DISTINCT();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *ALL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Query_blockContext* query_block();

  class  Selected_listContext : public antlr4::ParserRuleContext {
  public:
    Selected_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ASTERISK();
    std::vector<Select_list_elementsContext *> select_list_elements();
    Select_list_elementsContext* select_list_elements(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Selected_listContext* selected_list();

  class  From_clauseContext : public antlr4::ParserRuleContext {
  public:
    From_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FROM();
    Table_ref_listContext *table_ref_list();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  From_clauseContext* from_clause();

  class  Select_list_elementsContext : public antlr4::ParserRuleContext {
  public:
    Select_list_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *ASTERISK();
    ExpressionContext *expression();
    Column_aliasContext *column_alias();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Select_list_elementsContext* select_list_elements();

  class  Table_ref_listContext : public antlr4::ParserRuleContext {
  public:
    Table_ref_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Table_refContext *> table_ref();
    Table_refContext* table_ref(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_ref_listContext* table_ref_list();

  class  Table_refContext : public antlr4::ParserRuleContext {
  public:
    Table_refContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Table_ref_auxContext *table_ref_aux();
    std::vector<Join_clauseContext *> join_clause();
    Join_clauseContext* join_clause(size_t i);
    Pivot_clauseContext *pivot_clause();
    Unpivot_clauseContext *unpivot_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_refContext* table_ref();

  class  Table_ref_auxContext : public antlr4::ParserRuleContext {
  public:
    Table_ref_auxContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Table_ref_aux_internalContext *table_ref_aux_internal();
    std::vector<Flashback_query_clauseContext *> flashback_query_clause();
    Flashback_query_clauseContext* flashback_query_clause(size_t i);
    Table_aliasContext *table_alias();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_ref_auxContext* table_ref_aux();

  class  Table_ref_aux_internalContext : public antlr4::ParserRuleContext {
  public:
    Table_ref_aux_internalContext(antlr4::ParserRuleContext *parent, size_t invokingState);
   
    Table_ref_aux_internalContext() = default;
    void copyFrom(Table_ref_aux_internalContext *context);
    using antlr4::ParserRuleContext::copyFrom;

    virtual size_t getRuleIndex() const override;

   
  };

  class  Table_ref_aux_internal_oneContext : public Table_ref_aux_internalContext {
  public:
    Table_ref_aux_internal_oneContext(Table_ref_aux_internalContext *ctx);

    Dml_table_expression_clauseContext *dml_table_expression_clause();
    Pivot_clauseContext *pivot_clause();
    Unpivot_clauseContext *unpivot_clause();

    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
  };

  class  Table_ref_aux_internal_threContext : public Table_ref_aux_internalContext {
  public:
    Table_ref_aux_internal_threContext(Table_ref_aux_internalContext *ctx);

    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Dml_table_expression_clauseContext *dml_table_expression_clause();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
  };

  class  Table_ref_aux_internal_twoContext : public Table_ref_aux_internalContext {
  public:
    Table_ref_aux_internal_twoContext(Table_ref_aux_internalContext *ctx);

    antlr4::tree::TerminalNode *LEFT_PAREN();
    Table_refContext *table_ref();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Subquery_operation_partContext *> subquery_operation_part();
    Subquery_operation_partContext* subquery_operation_part(size_t i);
    Pivot_clauseContext *pivot_clause();
    Unpivot_clauseContext *unpivot_clause();

    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
  };

  Table_ref_aux_internalContext* table_ref_aux_internal();

  class  Join_clauseContext : public antlr4::ParserRuleContext {
  public:
    Join_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *JOIN();
    Table_ref_auxContext *table_ref_aux();
    std::vector<Query_partition_clauseContext *> query_partition_clause();
    Query_partition_clauseContext* query_partition_clause(size_t i);
    antlr4::tree::TerminalNode *INNER();
    Outer_join_typeContext *outer_join_type();
    std::vector<Join_on_partContext *> join_on_part();
    Join_on_partContext* join_on_part(size_t i);
    std::vector<Join_using_partContext *> join_using_part();
    Join_using_partContext* join_using_part(size_t i);
    antlr4::tree::TerminalNode *CROSS();
    antlr4::tree::TerminalNode *NATURAL();
    antlr4::tree::TerminalNode *APPLY();
    antlr4::tree::TerminalNode *OUTER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Join_clauseContext* join_clause();

  class  Join_on_partContext : public antlr4::ParserRuleContext {
  public:
    Join_on_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ON();
    ConditionContext *condition();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Join_on_partContext* join_on_part();

  class  Join_using_partContext : public antlr4::ParserRuleContext {
  public:
    Join_using_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    Paren_column_listContext *paren_column_list();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Join_using_partContext* join_using_part();

  class  Outer_join_typeContext : public antlr4::ParserRuleContext {
  public:
    Outer_join_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FULL();
    antlr4::tree::TerminalNode *LEFT();
    antlr4::tree::TerminalNode *RIGHT();
    antlr4::tree::TerminalNode *OUTER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Outer_join_typeContext* outer_join_type();

  class  Query_partition_clauseContext : public antlr4::ParserRuleContext {
  public:
    Query_partition_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *BY();
    Expressions_Context *expressions_();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    SubqueryContext *subquery();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Query_partition_clauseContext* query_partition_clause();

  class  Flashback_query_clauseContext : public antlr4::ParserRuleContext {
  public:
    Flashback_query_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VERSIONS();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *AND();
    antlr4::tree::TerminalNode *PERIOD_KEYWORD();
    antlr4::tree::TerminalNode *FOR();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *BETWEEN();
    antlr4::tree::TerminalNode *SCN();
    antlr4::tree::TerminalNode *TIMESTAMP();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *OF();
    antlr4::tree::TerminalNode *SNAPSHOT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Flashback_query_clauseContext* flashback_query_clause();

  class  Pivot_clauseContext : public antlr4::ParserRuleContext {
  public:
    Pivot_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PIVOT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Pivot_elementContext *> pivot_element();
    Pivot_elementContext* pivot_element(size_t i);
    Pivot_for_clauseContext *pivot_for_clause();
    Pivot_in_clauseContext *pivot_in_clause();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *XML();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Table_aliasContext *table_alias();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pivot_clauseContext* pivot_clause();

  class  Pivot_elementContext : public antlr4::ParserRuleContext {
  public:
    Pivot_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Numeric_functionContext *numeric_function();
    Aggregate_function_nameContext *aggregate_function_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Column_aliasContext *column_alias();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pivot_elementContext* pivot_element();

  class  Pivot_for_clauseContext : public antlr4::ParserRuleContext {
  public:
    Pivot_for_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOR();
    Column_nameContext *column_name();
    Paren_column_listContext *paren_column_list();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pivot_for_clauseContext* pivot_for_clause();

  class  Pivot_in_clauseContext : public antlr4::ParserRuleContext {
  public:
    Pivot_in_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    SubqueryContext *subquery();
    std::vector<antlr4::tree::TerminalNode *> ANY();
    antlr4::tree::TerminalNode* ANY(size_t i);
    std::vector<Pivot_in_clause_elementContext *> pivot_in_clause_element();
    Pivot_in_clause_elementContext* pivot_in_clause_element(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pivot_in_clauseContext* pivot_in_clause();

  class  Pivot_in_clause_elementContext : public antlr4::ParserRuleContext {
  public:
    Pivot_in_clause_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Pivot_in_clause_elementsContext *pivot_in_clause_elements();
    Column_aliasContext *column_alias();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pivot_in_clause_elementContext* pivot_in_clause_element();

  class  Pivot_in_clause_elementsContext : public antlr4::ParserRuleContext {
  public:
    Pivot_in_clause_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Expressions_Context *expressions_();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Pivot_in_clause_elementsContext* pivot_in_clause_elements();

  class  Unpivot_clauseContext : public antlr4::ParserRuleContext {
  public:
    Unpivot_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNPIVOT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Pivot_for_clauseContext *pivot_for_clause();
    Unpivot_in_clauseContext *unpivot_in_clause();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Column_nameContext *column_name();
    Paren_column_listContext *paren_column_list();
    antlr4::tree::TerminalNode *NULLS();
    Table_aliasContext *table_alias();
    antlr4::tree::TerminalNode *INCLUDE();
    antlr4::tree::TerminalNode *EXCLUDE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unpivot_clauseContext* unpivot_clause();

  class  Unpivot_in_clauseContext : public antlr4::ParserRuleContext {
  public:
    Unpivot_in_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Unpivot_in_elementsContext *> unpivot_in_elements();
    Unpivot_in_elementsContext* unpivot_in_elements(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unpivot_in_clauseContext* unpivot_in_clause();

  class  Unpivot_in_elementsContext : public antlr4::ParserRuleContext {
  public:
    Unpivot_in_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    Paren_column_listContext *paren_column_list();
    antlr4::tree::TerminalNode *AS();
    std::vector<ConstantContext *> constant();
    ConstantContext* constant(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unpivot_in_elementsContext* unpivot_in_elements();

  class  Hierarchical_query_clauseContext : public antlr4::ParserRuleContext {
  public:
    Hierarchical_query_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONNECT();
    antlr4::tree::TerminalNode *BY();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *NOCYCLE();
    Start_partContext *start_part();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Hierarchical_query_clauseContext* hierarchical_query_clause();

  class  Start_partContext : public antlr4::ParserRuleContext {
  public:
    Start_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *START();
    antlr4::tree::TerminalNode *WITH();
    ConditionContext *condition();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Start_partContext* start_part();

  class  Group_by_clauseContext : public antlr4::ParserRuleContext {
  public:
    Group_by_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GROUP();
    antlr4::tree::TerminalNode *BY();
    std::vector<Group_by_elementsContext *> group_by_elements();
    Group_by_elementsContext* group_by_elements(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Having_clauseContext *having_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Group_by_clauseContext* group_by_clause();

  class  Group_by_elementsContext : public antlr4::ParserRuleContext {
  public:
    Group_by_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Grouping_sets_clauseContext *grouping_sets_clause();
    Rollup_cube_clauseContext *rollup_cube_clause();
    ExpressionContext *expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Group_by_elementsContext* group_by_elements();

  class  Rollup_cube_clauseContext : public antlr4::ParserRuleContext {
  public:
    Rollup_cube_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Grouping_sets_elementsContext *> grouping_sets_elements();
    Grouping_sets_elementsContext* grouping_sets_elements(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *ROLLUP();
    antlr4::tree::TerminalNode *CUBE();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Rollup_cube_clauseContext* rollup_cube_clause();

  class  Grouping_sets_clauseContext : public antlr4::ParserRuleContext {
  public:
    Grouping_sets_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GROUPING();
    antlr4::tree::TerminalNode *SETS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Grouping_sets_elementsContext *> grouping_sets_elements();
    Grouping_sets_elementsContext* grouping_sets_elements(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Grouping_sets_clauseContext* grouping_sets_clause();

  class  Grouping_sets_elementsContext : public antlr4::ParserRuleContext {
  public:
    Grouping_sets_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Rollup_cube_clauseContext *rollup_cube_clause();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Expressions_Context *expressions_();
    ExpressionContext *expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Grouping_sets_elementsContext* grouping_sets_elements();

  class  Having_clauseContext : public antlr4::ParserRuleContext {
  public:
    Having_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *HAVING();
    ConditionContext *condition();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Having_clauseContext* having_clause();

  class  Model_clauseContext : public antlr4::ParserRuleContext {
  public:
    Model_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MODEL();
    Main_modelContext *main_model();
    std::vector<Cell_reference_optionsContext *> cell_reference_options();
    Cell_reference_optionsContext* cell_reference_options(size_t i);
    Return_rows_clauseContext *return_rows_clause();
    std::vector<Reference_modelContext *> reference_model();
    Reference_modelContext* reference_model(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_clauseContext* model_clause();

  class  Cell_reference_optionsContext : public antlr4::ParserRuleContext {
  public:
    Cell_reference_optionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NAV();
    antlr4::tree::TerminalNode *IGNORE();
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *DIMENSION();
    antlr4::tree::TerminalNode *SINGLE();
    antlr4::tree::TerminalNode *REFERENCE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cell_reference_optionsContext* cell_reference_options();

  class  Return_rows_clauseContext : public antlr4::ParserRuleContext {
  public:
    Return_rows_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RETURN();
    antlr4::tree::TerminalNode *ROWS();
    antlr4::tree::TerminalNode *UPDATED();
    antlr4::tree::TerminalNode *ALL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Return_rows_clauseContext* return_rows_clause();

  class  Reference_modelContext : public antlr4::ParserRuleContext {
  public:
    Reference_modelContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REFERENCE();
    Reference_model_nameContext *reference_model_name();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Model_column_clausesContext *model_column_clauses();
    std::vector<Cell_reference_optionsContext *> cell_reference_options();
    Cell_reference_optionsContext* cell_reference_options(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Reference_modelContext* reference_model();

  class  Main_modelContext : public antlr4::ParserRuleContext {
  public:
    Main_modelContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Model_column_clausesContext *model_column_clauses();
    Model_rules_clauseContext *model_rules_clause();
    antlr4::tree::TerminalNode *MAIN();
    Main_model_nameContext *main_model_name();
    std::vector<Cell_reference_optionsContext *> cell_reference_options();
    Cell_reference_optionsContext* cell_reference_options(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Main_modelContext* main_model();

  class  Model_column_clausesContext : public antlr4::ParserRuleContext {
  public:
    Model_column_clausesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DIMENSION();
    antlr4::tree::TerminalNode *BY();
    std::vector<Model_column_listContext *> model_column_list();
    Model_column_listContext* model_column_list(size_t i);
    antlr4::tree::TerminalNode *MEASURES();
    Model_column_partition_partContext *model_column_partition_part();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_column_clausesContext* model_column_clauses();

  class  Model_column_partition_partContext : public antlr4::ParserRuleContext {
  public:
    Model_column_partition_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *BY();
    Model_column_listContext *model_column_list();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_column_partition_partContext* model_column_partition_part();

  class  Model_column_listContext : public antlr4::ParserRuleContext {
  public:
    Model_column_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Model_columnContext *> model_column();
    Model_columnContext* model_column(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_column_listContext* model_column_list();

  class  Model_columnContext : public antlr4::ParserRuleContext {
  public:
    Model_columnContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    Query_blockContext *query_block();
    Column_aliasContext *column_alias();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_columnContext* model_column();

  class  Model_rules_clauseContext : public antlr4::ParserRuleContext {
  public:
    Model_rules_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Model_rules_partContext *model_rules_part();
    std::vector<Model_rules_elementContext *> model_rules_element();
    Model_rules_elementContext* model_rules_element(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_rules_clauseContext* model_rules_clause();

  class  Model_rules_partContext : public antlr4::ParserRuleContext {
  public:
    Model_rules_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RULES();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *UPSERT();
    antlr4::tree::TerminalNode *ORDER();
    Model_iterate_clauseContext *model_iterate_clause();
    antlr4::tree::TerminalNode *AUTOMATIC();
    antlr4::tree::TerminalNode *SEQUENTIAL();
    antlr4::tree::TerminalNode *ALL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_rules_partContext* model_rules_part();

  class  Model_rules_elementContext : public antlr4::ParserRuleContext {
  public:
    Model_rules_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Cell_assignmentContext *cell_assignment();
    antlr4::tree::TerminalNode *EQUALS_OP();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *UPSERT();
    Order_by_clauseContext *order_by_clause();
    antlr4::tree::TerminalNode *ALL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_rules_elementContext* model_rules_element();

  class  Cell_assignmentContext : public antlr4::ParserRuleContext {
  public:
    Cell_assignmentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Model_expressionContext *model_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cell_assignmentContext* cell_assignment();

  class  Model_iterate_clauseContext : public antlr4::ParserRuleContext {
  public:
    Model_iterate_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ITERATE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Until_partContext *until_part();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_iterate_clauseContext* model_iterate_clause();

  class  Until_partContext : public antlr4::ParserRuleContext {
  public:
    Until_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNTIL();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Until_partContext* until_part();

  class  Order_by_clauseContext : public antlr4::ParserRuleContext {
  public:
    Order_by_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ORDER();
    antlr4::tree::TerminalNode *BY();
    std::vector<Order_by_elementsContext *> order_by_elements();
    Order_by_elementsContext* order_by_elements(size_t i);
    antlr4::tree::TerminalNode *SIBLINGS();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Order_by_clauseContext* order_by_clause();

  class  Order_by_elementsContext : public antlr4::ParserRuleContext {
  public:
    Order_by_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *NULLS();
    antlr4::tree::TerminalNode *ASC();
    antlr4::tree::TerminalNode *DESC();
    antlr4::tree::TerminalNode *FIRST();
    antlr4::tree::TerminalNode *LAST();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Order_by_elementsContext* order_by_elements();

  class  Offset_clauseContext : public antlr4::ParserRuleContext {
  public:
    Offset_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OFFSET();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *ROW();
    antlr4::tree::TerminalNode *ROWS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Offset_clauseContext* offset_clause();

  class  Fetch_clauseContext : public antlr4::ParserRuleContext {
  public:
    Fetch_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FETCH();
    antlr4::tree::TerminalNode *FIRST();
    antlr4::tree::TerminalNode *NEXT();
    antlr4::tree::TerminalNode *ROW();
    antlr4::tree::TerminalNode *ROWS();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *TIES();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *PERCENT_KEYWORD();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Fetch_clauseContext* fetch_clause();

  class  For_update_clauseContext : public antlr4::ParserRuleContext {
  public:
    For_update_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *UPDATE();
    For_update_of_partContext *for_update_of_part();
    For_update_optionsContext *for_update_options();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  For_update_clauseContext* for_update_clause();

  class  For_update_of_partContext : public antlr4::ParserRuleContext {
  public:
    For_update_of_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OF();
    Column_listContext *column_list();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  For_update_of_partContext* for_update_of_part();

  class  For_update_optionsContext : public antlr4::ParserRuleContext {
  public:
    For_update_optionsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SKIP_();
    antlr4::tree::TerminalNode *LOCKED();
    antlr4::tree::TerminalNode *NOWAIT();
    antlr4::tree::TerminalNode *WAIT();
    ExpressionContext *expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  For_update_optionsContext* for_update_options();

  class  Update_statementContext : public antlr4::ParserRuleContext {
  public:
    Update_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UPDATE();
    General_table_refContext *general_table_ref();
    Update_set_clauseContext *update_set_clause();
    Where_clauseContext *where_clause();
    Static_returning_clauseContext *static_returning_clause();
    Error_logging_clauseContext *error_logging_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Update_statementContext* update_statement();

  class  Update_set_clauseContext : public antlr4::ParserRuleContext {
  public:
    Update_set_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    std::vector<Column_based_update_set_clauseContext *> column_based_update_set_clause();
    Column_based_update_set_clauseContext* column_based_update_set_clause(size_t i);
    antlr4::tree::TerminalNode *VALUE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *EQUALS_OP();
    ExpressionContext *expression();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Update_set_clauseContext* update_set_clause();

  class  Column_based_update_set_clauseContext : public antlr4::ParserRuleContext {
  public:
    Column_based_update_set_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *EQUALS_OP();
    ExpressionContext *expression();
    Paren_column_listContext *paren_column_list();
    SubqueryContext *subquery();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_based_update_set_clauseContext* column_based_update_set_clause();

  class  Delete_statementContext : public antlr4::ParserRuleContext {
  public:
    Delete_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DELETE();
    General_table_refContext *general_table_ref();
    antlr4::tree::TerminalNode *FROM();
    Where_clauseContext *where_clause();
    Static_returning_clauseContext *static_returning_clause();
    Error_logging_clauseContext *error_logging_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Delete_statementContext* delete_statement();

  class  Insert_statementContext : public antlr4::ParserRuleContext {
  public:
    Insert_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INSERT();
    Single_table_insertContext *single_table_insert();
    Multi_table_insertContext *multi_table_insert();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Insert_statementContext* insert_statement();

  class  Single_table_insertContext : public antlr4::ParserRuleContext {
  public:
    Single_table_insertContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Insert_into_clauseContext *insert_into_clause();
    Values_clauseContext *values_clause();
    Select_statementContext *select_statement();
    Error_logging_clauseContext *error_logging_clause();
    Static_returning_clauseContext *static_returning_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Single_table_insertContext* single_table_insert();

  class  Multi_table_insertContext : public antlr4::ParserRuleContext {
  public:
    Multi_table_insertContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Select_statementContext *select_statement();
    antlr4::tree::TerminalNode *ALL();
    Conditional_insert_clauseContext *conditional_insert_clause();
    std::vector<Multi_table_elementContext *> multi_table_element();
    Multi_table_elementContext* multi_table_element(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Multi_table_insertContext* multi_table_insert();

  class  Multi_table_elementContext : public antlr4::ParserRuleContext {
  public:
    Multi_table_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Insert_into_clauseContext *insert_into_clause();
    Values_clauseContext *values_clause();
    Error_logging_clauseContext *error_logging_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Multi_table_elementContext* multi_table_element();

  class  Conditional_insert_clauseContext : public antlr4::ParserRuleContext {
  public:
    Conditional_insert_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Conditional_insert_when_partContext *> conditional_insert_when_part();
    Conditional_insert_when_partContext* conditional_insert_when_part(size_t i);
    Conditional_insert_else_partContext *conditional_insert_else_part();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *FIRST();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Conditional_insert_clauseContext* conditional_insert_clause();

  class  Conditional_insert_when_partContext : public antlr4::ParserRuleContext {
  public:
    Conditional_insert_when_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *THEN();
    std::vector<Multi_table_elementContext *> multi_table_element();
    Multi_table_elementContext* multi_table_element(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Conditional_insert_when_partContext* conditional_insert_when_part();

  class  Conditional_insert_else_partContext : public antlr4::ParserRuleContext {
  public:
    Conditional_insert_else_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ELSE();
    std::vector<Multi_table_elementContext *> multi_table_element();
    Multi_table_elementContext* multi_table_element(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Conditional_insert_else_partContext* conditional_insert_else_part();

  class  Insert_into_clauseContext : public antlr4::ParserRuleContext {
  public:
    Insert_into_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INTO();
    General_table_refContext *general_table_ref();
    antlr4::tree::TerminalNode *FIELDS();
    Paren_column_listContext *paren_column_list();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Insert_into_clauseContext* insert_into_clause();

  class  Values_clauseContext : public antlr4::ParserRuleContext {
  public:
    Values_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VALUES();
    antlr4::tree::TerminalNode *REGULAR_ID();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Expressions_Context *expressions_();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Collection_expressionContext *collection_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Values_clauseContext* values_clause();

  class  Merge_statementContext : public antlr4::ParserRuleContext {
  public:
    Merge_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MERGE();
    antlr4::tree::TerminalNode *INTO();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *USING();
    Selected_tableviewContext *selected_tableview();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ConditionContext *condition();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Table_aliasContext *table_alias();
    Merge_update_clauseContext *merge_update_clause();
    Merge_insert_clauseContext *merge_insert_clause();
    Error_logging_clauseContext *error_logging_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Merge_statementContext* merge_statement();

  class  Merge_update_clauseContext : public antlr4::ParserRuleContext {
  public:
    Merge_update_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    antlr4::tree::TerminalNode *MATCHED();
    antlr4::tree::TerminalNode *THEN();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *SET();
    std::vector<Merge_elementContext *> merge_element();
    Merge_elementContext* merge_element(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Where_clauseContext *where_clause();
    Merge_update_delete_partContext *merge_update_delete_part();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Merge_update_clauseContext* merge_update_clause();

  class  Merge_elementContext : public antlr4::ParserRuleContext {
  public:
    Merge_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *EQUALS_OP();
    ExpressionContext *expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Merge_elementContext* merge_element();

  class  Merge_update_delete_partContext : public antlr4::ParserRuleContext {
  public:
    Merge_update_delete_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DELETE();
    Where_clauseContext *where_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Merge_update_delete_partContext* merge_update_delete_part();

  class  Merge_insert_clauseContext : public antlr4::ParserRuleContext {
  public:
    Merge_insert_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *MATCHED();
    antlr4::tree::TerminalNode *THEN();
    antlr4::tree::TerminalNode *INSERT();
    Values_clauseContext *values_clause();
    Paren_column_listContext *paren_column_list();
    Where_clauseContext *where_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Merge_insert_clauseContext* merge_insert_clause();

  class  Selected_tableviewContext : public antlr4::ParserRuleContext {
  public:
    Selected_tableviewContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Select_statementContext *select_statement();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Table_collection_expressionContext *table_collection_expression();
    Table_aliasContext *table_alias();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Selected_tableviewContext* selected_tableview();

  class  Lock_table_statementContext : public antlr4::ParserRuleContext {
  public:
    Lock_table_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOCK();
    antlr4::tree::TerminalNode *TABLE();
    std::vector<Lock_table_elementContext *> lock_table_element();
    Lock_table_elementContext* lock_table_element(size_t i);
    antlr4::tree::TerminalNode *IN();
    Lock_modeContext *lock_mode();
    antlr4::tree::TerminalNode *MODE();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Wait_nowait_partContext *wait_nowait_part();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lock_table_statementContext* lock_table_statement();

  class  Wait_nowait_partContext : public antlr4::ParserRuleContext {
  public:
    Wait_nowait_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WAIT();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *NOWAIT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Wait_nowait_partContext* wait_nowait_part();

  class  Lock_table_elementContext : public antlr4::ParserRuleContext {
  public:
    Lock_table_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Tableview_nameContext *tableview_name();
    Partition_extension_clauseContext *partition_extension_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lock_table_elementContext* lock_table_element();

  class  Lock_modeContext : public antlr4::ParserRuleContext {
  public:
    Lock_modeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ROW();
    antlr4::tree::TerminalNode *SHARE();
    antlr4::tree::TerminalNode *EXCLUSIVE();
    antlr4::tree::TerminalNode *UPDATE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Lock_modeContext* lock_mode();

  class  General_table_refContext : public antlr4::ParserRuleContext {
  public:
    General_table_refContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Dml_table_expression_clauseContext *dml_table_expression_clause();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Table_aliasContext *table_alias();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  General_table_refContext* general_table_ref();

  class  Static_returning_clauseContext : public antlr4::ParserRuleContext {
  public:
    Static_returning_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Expressions_Context *expressions_();
    Into_clauseContext *into_clause();
    antlr4::tree::TerminalNode *RETURNING();
    antlr4::tree::TerminalNode *RETURN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Static_returning_clauseContext* static_returning_clause();

  class  Error_logging_clauseContext : public antlr4::ParserRuleContext {
  public:
    Error_logging_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOG();
    antlr4::tree::TerminalNode *ERRORS();
    Error_logging_into_partContext *error_logging_into_part();
    ExpressionContext *expression();
    Error_logging_reject_partContext *error_logging_reject_part();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Error_logging_clauseContext* error_logging_clause();

  class  Error_logging_into_partContext : public antlr4::ParserRuleContext {
  public:
    Error_logging_into_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INTO();
    Tableview_nameContext *tableview_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Error_logging_into_partContext* error_logging_into_part();

  class  Error_logging_reject_partContext : public antlr4::ParserRuleContext {
  public:
    Error_logging_reject_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REJECT();
    antlr4::tree::TerminalNode *LIMIT();
    antlr4::tree::TerminalNode *UNLIMITED();
    ExpressionContext *expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Error_logging_reject_partContext* error_logging_reject_part();

  class  Dml_table_expression_clauseContext : public antlr4::ParserRuleContext {
  public:
    Dml_table_expression_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Table_collection_expressionContext *table_collection_expression();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Select_statementContext *select_statement();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Subquery_restriction_clauseContext *subquery_restriction_clause();
    Tableview_nameContext *tableview_name();
    Hierarchies_clauseContext *hierarchies_clause();
    Sample_clauseContext *sample_clause();
    Json_table_clauseContext *json_table_clause();
    antlr4::tree::TerminalNode *AS();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *LATERAL();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RELATIONAL();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *XMLTYPE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dml_table_expression_clauseContext* dml_table_expression_clause();

  class  Table_collection_expressionContext : public antlr4::ParserRuleContext {
  public:
    Table_collection_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *THE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    ExpressionContext *expression();
    Outer_join_signContext *outer_join_sign();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_collection_expressionContext* table_collection_expression();

  class  Subquery_restriction_clauseContext : public antlr4::ParserRuleContext {
  public:
    Subquery_restriction_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *CHECK();
    antlr4::tree::TerminalNode *OPTION();
    antlr4::tree::TerminalNode *CONSTRAINT();
    Constraint_nameContext *constraint_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Subquery_restriction_clauseContext* subquery_restriction_clause();

  class  Sample_clauseContext : public antlr4::ParserRuleContext {
  public:
    Sample_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SAMPLE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *BLOCK();
    antlr4::tree::TerminalNode *COMMA();
    Seed_partContext *seed_part();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sample_clauseContext* sample_clause();

  class  Seed_partContext : public antlr4::ParserRuleContext {
  public:
    Seed_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SEED();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Seed_partContext* seed_part();

  class  ConditionContext : public antlr4::ParserRuleContext {
  public:
    ConditionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *JSON_EQUAL();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Expressions_Context *expressions_();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ConditionContext* condition();

  class  Expressions_Context : public antlr4::ParserRuleContext {
  public:
    Expressions_Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Expressions_Context* expressions_();

  class  ExpressionContext : public antlr4::ParserRuleContext {
  public:
    ExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Cursor_expressionContext *cursor_expression();
    Logical_expressionContext *logical_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ExpressionContext* expression();

  class  Cursor_expressionContext : public antlr4::ParserRuleContext {
  public:
    Cursor_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CURSOR();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cursor_expressionContext* cursor_expression();

  class  Logical_expressionContext : public antlr4::ParserRuleContext {
  public:
    Logical_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Unary_logical_expressionContext *unary_logical_expression();
    std::vector<Logical_expressionContext *> logical_expression();
    Logical_expressionContext* logical_expression(size_t i);
    antlr4::tree::TerminalNode *AND();
    antlr4::tree::TerminalNode *OR();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Logical_expressionContext* logical_expression();
  Logical_expressionContext* logical_expression(int precedence);
  class  Unary_logical_expressionContext : public antlr4::ParserRuleContext {
  public:
    Unary_logical_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Multiset_expressionContext *multiset_expression();
    antlr4::tree::TerminalNode *NOT();
    Unary_logical_operationContext *unary_logical_operation();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unary_logical_expressionContext* unary_logical_expression();

  class  Unary_logical_operationContext : public antlr4::ParserRuleContext {
  public:
    Unary_logical_operationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IS();
    Logical_operationContext *logical_operation();
    antlr4::tree::TerminalNode *NOT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unary_logical_operationContext* unary_logical_operation();

  class  Logical_operationContext : public antlr4::ParserRuleContext {
  public:
    Logical_operationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *NAN_();
    antlr4::tree::TerminalNode *PRESENT();
    antlr4::tree::TerminalNode *INFINITE();
    antlr4::tree::TerminalNode *A_LETTER();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *EMPTY_();
    antlr4::tree::TerminalNode *OF();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Type_specContext *> type_spec();
    Type_specContext* type_spec(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> JSON();
    antlr4::tree::TerminalNode* JSON(size_t i);
    antlr4::tree::TerminalNode *TYPE();
    antlr4::tree::TerminalNode *ONLY();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *FORMAT();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *KEYS();
    antlr4::tree::TerminalNode *STRICT();
    antlr4::tree::TerminalNode *LAX();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *WITHOUT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Logical_operationContext* logical_operation();

  class  Multiset_expressionContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *multiset_type = nullptr;
    antlr4::Token *multiset_operator = nullptr;
    Multiset_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Relational_expressionContext *relational_expression();
    ConcatenationContext *concatenation();
    antlr4::tree::TerminalNode *MEMBER();
    antlr4::tree::TerminalNode *SUBMULTISET();
    antlr4::tree::TerminalNode *OF();
    antlr4::tree::TerminalNode *NOT();
    Multiset_expressionContext *multiset_expression();
    antlr4::tree::TerminalNode *MULTISET();
    antlr4::tree::TerminalNode *EXCEPT();
    antlr4::tree::TerminalNode *INTERSECT();
    antlr4::tree::TerminalNode *UNION();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *DISTINCT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Multiset_expressionContext* multiset_expression();
  Multiset_expressionContext* multiset_expression(int precedence);
  class  Relational_expressionContext : public antlr4::ParserRuleContext {
  public:
    Relational_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Compound_expressionContext *compound_expression();
    std::vector<Relational_expressionContext *> relational_expression();
    Relational_expressionContext* relational_expression(size_t i);
    Relational_operatorContext *relational_operator();
    antlr4::tree::TerminalNode *IN();
    In_elementsContext *in_elements();
    antlr4::tree::TerminalNode *NOT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Relational_expressionContext* relational_expression();
  Relational_expressionContext* relational_expression(int precedence);
  class  Compound_expressionContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *like_type = nullptr;
    Compound_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    antlr4::tree::TerminalNode *IN();
    In_elementsContext *in_elements();
    antlr4::tree::TerminalNode *BETWEEN();
    Between_elementsContext *between_elements();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *LIKE();
    antlr4::tree::TerminalNode *LIKEC();
    antlr4::tree::TerminalNode *LIKE2();
    antlr4::tree::TerminalNode *LIKE4();
    antlr4::tree::TerminalNode *ESCAPE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Compound_expressionContext* compound_expression();

  class  Relational_operatorContext : public antlr4::ParserRuleContext {
  public:
    Relational_operatorContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *NOT_EQUAL_OP();
    antlr4::tree::TerminalNode *LESS_THAN_OP();
    antlr4::tree::TerminalNode *GREATER_THAN_OP();
    antlr4::tree::TerminalNode *EXCLAMATION_OPERATOR_PART();
    antlr4::tree::TerminalNode *CARRET_OPERATOR_PART();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Relational_operatorContext* relational_operator();

  class  In_elementsContext : public antlr4::ParserRuleContext {
  public:
    In_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    ConstantContext *constant();
    Bind_variableContext *bind_variable();
    General_elementContext *general_element();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  In_elementsContext* in_elements();

  class  Between_elementsContext : public antlr4::ParserRuleContext {
  public:
    Between_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    antlr4::tree::TerminalNode *AND();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Between_elementsContext* between_elements();

  class  ConcatenationContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *op = nullptr;
    ConcatenationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Model_expressionContext *model_expression();
    antlr4::tree::TerminalNode *AT();
    Interval_expressionContext *interval_expression();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *OVERFLOW_();
    antlr4::tree::TerminalNode *TRUNCATE();
    antlr4::tree::TerminalNode *ERROR();
    antlr4::tree::TerminalNode *LOCAL();
    antlr4::tree::TerminalNode *TIME();
    antlr4::tree::TerminalNode *ZONE();
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    antlr4::tree::TerminalNode *DOUBLE_ASTERISK();
    antlr4::tree::TerminalNode *ASTERISK();
    antlr4::tree::TerminalNode *SOLIDUS();
    antlr4::tree::TerminalNode *MOD();
    antlr4::tree::TerminalNode *PLUS_SIGN();
    antlr4::tree::TerminalNode *MINUS_SIGN();
    std::vector<antlr4::tree::TerminalNode *> BAR();
    antlr4::tree::TerminalNode* BAR(size_t i);
    antlr4::tree::TerminalNode *COLLATE();
    Column_collation_nameContext *column_collation_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ConcatenationContext* concatenation();
  ConcatenationContext* concatenation(int precedence);
  class  Interval_expressionContext : public antlr4::ParserRuleContext {
  public:
    Interval_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DAY();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *SECOND();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *YEAR();
    antlr4::tree::TerminalNode *MONTH();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Interval_expressionContext* interval_expression();

  class  Model_expressionContext : public antlr4::ParserRuleContext {
  public:
    Model_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Unary_expressionContext *unary_expression();
    antlr4::tree::TerminalNode *LEFT_BRACKET();
    Model_expression_elementContext *model_expression_element();
    antlr4::tree::TerminalNode *RIGHT_BRACKET();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_expressionContext* model_expression();

  class  Model_expression_elementContext : public antlr4::ParserRuleContext {
  public:
    Model_expression_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> ANY();
    antlr4::tree::TerminalNode* ANY(size_t i);
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Single_column_for_loopContext *> single_column_for_loop();
    Single_column_for_loopContext* single_column_for_loop(size_t i);
    Multi_column_for_loopContext *multi_column_for_loop();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Model_expression_elementContext* model_expression_element();

  class  Single_column_for_loopContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::ExpressionContext *fromExpr = nullptr;
    PlSqlParser::ExpressionContext *toExpr = nullptr;
    antlr4::Token *action_type = nullptr;
    PlSqlParser::ExpressionContext *action_expr = nullptr;
    Single_column_for_loopContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOR();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *IN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *FROM();
    antlr4::tree::TerminalNode *TO();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *INCREMENT();
    antlr4::tree::TerminalNode *DECREMENT();
    Expressions_Context *expressions_();
    antlr4::tree::TerminalNode *LIKE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Single_column_for_loopContext* single_column_for_loop();

  class  Multi_column_for_loopContext : public antlr4::ParserRuleContext {
  public:
    Multi_column_for_loopContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOR();
    Paren_column_listContext *paren_column_list();
    antlr4::tree::TerminalNode *IN();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    SubqueryContext *subquery();
    Expressions_Context *expressions_();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Multi_column_for_loopContext* multi_column_for_loop();

  class  Unary_expressionContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::ExpressionContext *expressionContext = nullptr;
    std::vector<ExpressionContext *> index;
    Unary_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Unary_expressionContext *unary_expression();
    antlr4::tree::TerminalNode *MINUS_SIGN();
    antlr4::tree::TerminalNode *PLUS_SIGN();
    antlr4::tree::TerminalNode *PRIOR();
    antlr4::tree::TerminalNode *CONNECT_BY_ROOT();
    antlr4::tree::TerminalNode *NEW();
    antlr4::tree::TerminalNode *DISTINCT();
    antlr4::tree::TerminalNode *ALL();
    Case_expressionContext *case_expression();
    Quantified_expressionContext *quantified_expression();
    Standard_functionContext *standard_function();
    AtomContext *atom();
    Implicit_cursor_expressionContext *implicit_cursor_expression();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *COUNT();
    antlr4::tree::TerminalNode *FIRST();
    antlr4::tree::TerminalNode *LAST();
    antlr4::tree::TerminalNode *LIMIT();
    antlr4::tree::TerminalNode *EXISTS();
    antlr4::tree::TerminalNode *NEXT();
    ExpressionContext *expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Unary_expressionContext* unary_expression();
  Unary_expressionContext* unary_expression(int precedence);
  class  Implicit_cursor_expressionContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::ExpressionContext *index = nullptr;
    Implicit_cursor_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SQL();
    antlr4::tree::TerminalNode *PERCENT_BULK_ROWCOUNT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *PERCENT_BULK_EXCEPTIONS();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *COUNT();
    antlr4::tree::TerminalNode *ERROR_INDEX();
    antlr4::tree::TerminalNode *ERROR_CODE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Implicit_cursor_expressionContext* implicit_cursor_expression();

  class  Collection_expressionContext : public antlr4::ParserRuleContext {
  public:
    Collection_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Collation_nameContext *collation_name();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<General_element_partContext *> general_element_part();
    General_element_partContext* general_element_part(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Collection_expressionContext* collection_expression();

  class  Case_statementContext : public antlr4::ParserRuleContext {
  public:
    Case_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Searched_case_statementContext *searched_case_statement();
    Simple_case_statementContext *simple_case_statement();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Case_statementContext* case_statement();

  class  Simple_case_statementContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *ck1 = nullptr;
    Simple_case_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *END();
    std::vector<antlr4::tree::TerminalNode *> CASE();
    antlr4::tree::TerminalNode* CASE(size_t i);
    Label_declarationContext *label_declaration();
    std::vector<Case_when_part_statementContext *> case_when_part_statement();
    Case_when_part_statementContext* case_when_part_statement(size_t i);
    Case_else_part_statementContext *case_else_part_statement();
    Label_nameContext *label_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Simple_case_statementContext* simple_case_statement();

  class  Searched_case_statementContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *ck1 = nullptr;
    Searched_case_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *END();
    std::vector<antlr4::tree::TerminalNode *> CASE();
    antlr4::tree::TerminalNode* CASE(size_t i);
    Label_declarationContext *label_declaration();
    std::vector<Case_when_part_statementContext *> case_when_part_statement();
    Case_when_part_statementContext* case_when_part_statement(size_t i);
    Case_else_part_statementContext *case_else_part_statement();
    Label_nameContext *label_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Searched_case_statementContext* searched_case_statement();

  class  Case_when_part_statementContext : public antlr4::ParserRuleContext {
  public:
    Case_when_part_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *THEN();
    Seq_of_statementsContext *seq_of_statements();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Case_when_part_statementContext* case_when_part_statement();

  class  Case_else_part_statementContext : public antlr4::ParserRuleContext {
  public:
    Case_else_part_statementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ELSE();
    Seq_of_statementsContext *seq_of_statements();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Case_else_part_statementContext* case_else_part_statement();

  class  Case_expressionContext : public antlr4::ParserRuleContext {
  public:
    Case_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Searched_case_expressionContext *searched_case_expression();
    Simple_case_expressionContext *simple_case_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Case_expressionContext* case_expression();

  class  Simple_case_expressionContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *ck1 = nullptr;
    Simple_case_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *END();
    std::vector<antlr4::tree::TerminalNode *> CASE();
    antlr4::tree::TerminalNode* CASE(size_t i);
    std::vector<Case_when_part_expressionContext *> case_when_part_expression();
    Case_when_part_expressionContext* case_when_part_expression(size_t i);
    Case_else_part_expressionContext *case_else_part_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Simple_case_expressionContext* simple_case_expression();

  class  Searched_case_expressionContext : public antlr4::ParserRuleContext {
  public:
    antlr4::Token *ck1 = nullptr;
    Searched_case_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *END();
    std::vector<antlr4::tree::TerminalNode *> CASE();
    antlr4::tree::TerminalNode* CASE(size_t i);
    std::vector<Case_when_part_expressionContext *> case_when_part_expression();
    Case_when_part_expressionContext* case_when_part_expression(size_t i);
    Case_else_part_expressionContext *case_else_part_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Searched_case_expressionContext* searched_case_expression();

  class  Case_when_part_expressionContext : public antlr4::ParserRuleContext {
  public:
    Case_when_part_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *THEN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Case_when_part_expressionContext* case_when_part_expression();

  class  Case_else_part_expressionContext : public antlr4::ParserRuleContext {
  public:
    Case_else_part_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ELSE();
    ExpressionContext *expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Case_else_part_expressionContext* case_else_part_expression();

  class  AtomContext : public antlr4::ParserRuleContext {
  public:
    AtomContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Bind_variableContext *bind_variable();
    ConstantContext *constant();
    Inquiry_directiveContext *inquiry_directive();
    General_elementContext *general_element();
    Outer_join_signContext *outer_join_sign();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<Subquery_operation_partContext *> subquery_operation_part();
    Subquery_operation_partContext* subquery_operation_part(size_t i);
    Expressions_Context *expressions_();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  AtomContext* atom();

  class  Quantified_expressionContext : public antlr4::ParserRuleContext {
  public:
    Quantified_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SOME();
    antlr4::tree::TerminalNode *EXISTS();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *ANY();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Select_only_statementContext *select_only_statement();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Quantified_expressionContext* quantified_expression();

  class  String_functionContext : public antlr4::ParserRuleContext {
  public:
    String_functionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBSTR();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *TO_CHAR();
    Table_elementContext *table_element();
    Standard_functionContext *standard_function();
    std::vector<Quoted_stringContext *> quoted_string();
    Quoted_stringContext* quoted_string(size_t i);
    antlr4::tree::TerminalNode *DECODE();
    Expressions_Context *expressions_();
    antlr4::tree::TerminalNode *CHR();
    ConcatenationContext *concatenation();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *NCHAR_CS();
    antlr4::tree::TerminalNode *NVL();
    antlr4::tree::TerminalNode *TRIM();
    antlr4::tree::TerminalNode *FROM();
    antlr4::tree::TerminalNode *LEADING();
    antlr4::tree::TerminalNode *TRAILING();
    antlr4::tree::TerminalNode *BOTH();
    antlr4::tree::TerminalNode *TO_DATE();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *CONVERSION();
    antlr4::tree::TerminalNode *ERROR();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  String_functionContext* string_function();

  class  Standard_functionContext : public antlr4::ParserRuleContext {
  public:
    Standard_functionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    String_functionContext *string_function();
    Numeric_function_wrapperContext *numeric_function_wrapper();
    Json_functionContext *json_function();
    Other_functionContext *other_function();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Standard_functionContext* standard_function();

  class  Json_functionContext : public antlr4::ParserRuleContext {
  public:
    Json_functionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *JSON_ARRAY();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<Json_array_elementContext *> json_array_element();
    Json_array_elementContext* json_array_element(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Json_on_null_clauseContext *json_on_null_clause();
    Json_return_clauseContext *json_return_clause();
    antlr4::tree::TerminalNode *STRICT();
    antlr4::tree::TerminalNode *JSON_ARRAYAGG();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *FORMAT();
    antlr4::tree::TerminalNode *JSON();
    Order_by_clauseContext *order_by_clause();
    antlr4::tree::TerminalNode *JSON_OBJECT();
    Json_object_contentContext *json_object_content();
    antlr4::tree::TerminalNode *JSON_OBJECTAGG();
    antlr4::tree::TerminalNode *VALUE();
    antlr4::tree::TerminalNode *KEY();
    std::vector<antlr4::tree::TerminalNode *> ON();
    antlr4::tree::TerminalNode* ON(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NULL_();
    antlr4::tree::TerminalNode* NULL_(size_t i);
    antlr4::tree::TerminalNode *RETURNING();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *KEYS();
    antlr4::tree::TerminalNode *ABSENT();
    antlr4::tree::TerminalNode *VARCHAR2();
    antlr4::tree::TerminalNode *CLOB();
    antlr4::tree::TerminalNode *BLOB();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *BYTE();
    antlr4::tree::TerminalNode *CHAR();
    antlr4::tree::TerminalNode *JSON_QUERY();
    antlr4::tree::TerminalNode *CHAR_STRING();
    Json_query_returning_clauseContext *json_query_returning_clause();
    Json_query_wrapper_clauseContext *json_query_wrapper_clause();
    Json_query_on_error_clauseContext *json_query_on_error_clause();
    Json_query_on_empty_clauseContext *json_query_on_empty_clause();
    antlr4::tree::TerminalNode *JSON_SERIALIZE();
    Json_query_return_typeContext *json_query_return_type();
    antlr4::tree::TerminalNode *PRETTY();
    antlr4::tree::TerminalNode *ASCII();
    antlr4::tree::TerminalNode *TRUNCATE();
    std::vector<antlr4::tree::TerminalNode *> ERROR();
    antlr4::tree::TerminalNode* ERROR(size_t i);
    antlr4::tree::TerminalNode *EMPTY_();
    antlr4::tree::TerminalNode *ARRAY();
    antlr4::tree::TerminalNode *OBJECT();
    antlr4::tree::TerminalNode *JSON_TRANSFORM();
    std::vector<Json_transform_opContext *> json_transform_op();
    Json_transform_opContext* json_transform_op(size_t i);
    antlr4::tree::TerminalNode *JSON_VALUE();
    Json_value_return_clauseContext *json_value_return_clause();
    Json_value_on_mismatch_clauseContext *json_value_on_mismatch_clause();
    std::vector<antlr4::tree::TerminalNode *> DEFAULT();
    antlr4::tree::TerminalNode* DEFAULT(size_t i);
    std::vector<LiteralContext *> literal();
    LiteralContext* literal(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Json_functionContext* json_function();

  class  Json_object_contentContext : public antlr4::ParserRuleContext {
  public:
    Json_object_contentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Json_object_entryContext *> json_object_entry();
    Json_object_entryContext* json_object_entry(size_t i);
    antlr4::tree::TerminalNode *ASTERISK();
    Json_on_null_clauseContext *json_on_null_clause();
    Json_return_clauseContext *json_return_clause();
    antlr4::tree::TerminalNode *STRICT();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *KEYS();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Json_object_contentContext* json_object_content();

  class  Json_object_entryContext : public antlr4::ParserRuleContext {
  public:
    Json_object_entryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *COLON();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *FORMAT();
    antlr4::tree::TerminalNode *JSON();
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *VALUE();
    antlr4::tree::TerminalNode *IS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Json_object_entryContext* json_object_entry();

  class  Json_table_clauseContext : public antlr4::ParserRuleContext {
  public:
    Json_table_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *JSON_TABLE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *FORMAT();
    antlr4::tree::TerminalNode *JSON();
    antlr4::tree::TerminalNode *COMMA();
    antlr4::tree::TerminalNode *CHAR_STRING();
    std::vector<antlr4::tree::TerminalNode *> ON();
    antlr4::tree::TerminalNode* ON(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ERROR();
    antlr4::tree::TerminalNode* ERROR(size_t i);
    std::vector<antlr4::tree::TerminalNode *> EMPTY_();
    antlr4::tree::TerminalNode* EMPTY_(size_t i);
    Json_column_clauseContext *json_column_clause();
    std::vector<antlr4::tree::TerminalNode *> NULL_();
    antlr4::tree::TerminalNode* NULL_(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Json_table_clauseContext* json_table_clause();

  class  Json_array_elementContext : public antlr4::ParserRuleContext {
  public:
    Json_array_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    Json_functionContext *json_function();
    antlr4::tree::TerminalNode *FORMAT();
    antlr4::tree::TerminalNode *JSON();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Json_array_elementContext* json_array_element();

  class  Json_on_null_clauseContext : public antlr4::ParserRuleContext {
  public:
    Json_on_null_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ON();
    std::vector<antlr4::tree::TerminalNode *> NULL_();
    antlr4::tree::TerminalNode* NULL_(size_t i);
    antlr4::tree::TerminalNode *ABSENT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Json_on_null_clauseContext* json_on_null_clause();

  class  Json_return_clauseContext : public antlr4::ParserRuleContext {
  public:
    Json_return_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RETURNING();
    antlr4::tree::TerminalNode *VARCHAR2();
    antlr4::tree::TerminalNode *CLOB();
    antlr4::tree::TerminalNode *BLOB();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *BYTE();
    antlr4::tree::TerminalNode *CHAR();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Json_return_clauseContext* json_return_clause();

  class  Json_transform_opContext : public antlr4::ParserRuleContext {
  public:
    Json_transform_opContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REMOVE();
    std::vector<antlr4::tree::TerminalNode *> CHAR_STRING();
    antlr4::tree::TerminalNode* CHAR_STRING(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ON();
    antlr4::tree::TerminalNode* ON(size_t i);
    antlr4::tree::TerminalNode *MISSING();
    std::vector<antlr4::tree::TerminalNode *> IGNORE();
    antlr4::tree::TerminalNode* IGNORE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ERROR();
    antlr4::tree::TerminalNode* ERROR(size_t i);
    antlr4::tree::TerminalNode *INSERT();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *EXISTING();
    std::vector<antlr4::tree::TerminalNode *> NULL_();
    antlr4::tree::TerminalNode* NULL_(size_t i);
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *CREATE();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *FORMAT();
    antlr4::tree::TerminalNode *JSON();
    antlr4::tree::TerminalNode *APPEND();
    antlr4::tree::TerminalNode *SET();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Json_transform_opContext* json_transform_op();

  class  Json_column_clauseContext : public antlr4::ParserRuleContext {
  public:
    Json_column_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COLUMNS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Json_column_definitionContext *> json_column_definition();
    Json_column_definitionContext* json_column_definition(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Json_column_clauseContext* json_column_clause();

  class  Json_column_definitionContext : public antlr4::ParserRuleContext {
  public:
    Json_column_definitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    Json_value_return_typeContext *json_value_return_type();
    antlr4::tree::TerminalNode *PATH();
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *TRUNCATE();
    Json_query_on_error_clauseContext *json_query_on_error_clause();
    Json_query_on_empty_clauseContext *json_query_on_empty_clause();
    antlr4::tree::TerminalNode *EXISTS();
    antlr4::tree::TerminalNode *FORMAT();
    antlr4::tree::TerminalNode *JSON();
    Json_query_return_typeContext *json_query_return_type();
    Json_query_wrapper_clauseContext *json_query_wrapper_clause();
    antlr4::tree::TerminalNode *NESTED();
    Json_column_clauseContext *json_column_clause();
    antlr4::tree::TerminalNode *LEFT_BRACKET();
    antlr4::tree::TerminalNode *ASTERISK();
    antlr4::tree::TerminalNode *RIGHT_BRACKET();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *ORDINALITY();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Json_column_definitionContext* json_column_definition();

  class  Json_query_returning_clauseContext : public antlr4::ParserRuleContext {
  public:
    Json_query_returning_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RETURNING();
    Json_query_return_typeContext *json_query_return_type();
    antlr4::tree::TerminalNode *PRETTY();
    antlr4::tree::TerminalNode *ASCII();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Json_query_returning_clauseContext* json_query_returning_clause();

  class  Json_query_return_typeContext : public antlr4::ParserRuleContext {
  public:
    Json_query_return_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VARCHAR2();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *BYTE();
    antlr4::tree::TerminalNode *CHAR();
    antlr4::tree::TerminalNode *CLOB();
    antlr4::tree::TerminalNode *BLOB();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Json_query_return_typeContext* json_query_return_type();

  class  Json_query_wrapper_clauseContext : public antlr4::ParserRuleContext {
  public:
    Json_query_wrapper_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WITHOUT();
    antlr4::tree::TerminalNode *WRAPPER();
    antlr4::tree::TerminalNode *ARRAY();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *UNCONDITIONAL();
    antlr4::tree::TerminalNode *CONDITIONAL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Json_query_wrapper_clauseContext* json_query_wrapper_clause();

  class  Json_query_on_error_clauseContext : public antlr4::ParserRuleContext {
  public:
    Json_query_on_error_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ON();
    std::vector<antlr4::tree::TerminalNode *> ERROR();
    antlr4::tree::TerminalNode* ERROR(size_t i);
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *EMPTY_();
    antlr4::tree::TerminalNode *ARRAY();
    antlr4::tree::TerminalNode *OBJECT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Json_query_on_error_clauseContext* json_query_on_error_clause();

  class  Json_query_on_empty_clauseContext : public antlr4::ParserRuleContext {
  public:
    Json_query_on_empty_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ON();
    std::vector<antlr4::tree::TerminalNode *> EMPTY_();
    antlr4::tree::TerminalNode* EMPTY_(size_t i);
    antlr4::tree::TerminalNode *ERROR();
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *ARRAY();
    antlr4::tree::TerminalNode *OBJECT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Json_query_on_empty_clauseContext* json_query_on_empty_clause();

  class  Json_value_return_clauseContext : public antlr4::ParserRuleContext {
  public:
    Json_value_return_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RETURNING();
    Json_value_return_typeContext *json_value_return_type();
    antlr4::tree::TerminalNode *ASCII();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Json_value_return_clauseContext* json_value_return_clause();

  class  Json_value_return_typeContext : public antlr4::ParserRuleContext {
  public:
    Json_value_return_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VARCHAR2();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *TRUNCATE();
    antlr4::tree::TerminalNode *BYTE();
    antlr4::tree::TerminalNode *CHAR();
    antlr4::tree::TerminalNode *CLOB();
    antlr4::tree::TerminalNode *DATE();
    antlr4::tree::TerminalNode *NUMBER();
    std::vector<antlr4::tree::TerminalNode *> INTEGER();
    antlr4::tree::TerminalNode* INTEGER(size_t i);
    antlr4::tree::TerminalNode *COMMA();
    antlr4::tree::TerminalNode *TIMESTAMP();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *TIMEZONE();
    antlr4::tree::TerminalNode *SDO_GEOMETRY();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *CASESENSITIVE();
    antlr4::tree::TerminalNode *MAPPING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Json_value_return_typeContext* json_value_return_type();

  class  Json_value_on_mismatch_clauseContext : public antlr4::ParserRuleContext {
  public:
    Json_value_on_mismatch_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *MISMATCH();
    antlr4::tree::TerminalNode *IGNORE();
    std::vector<antlr4::tree::TerminalNode *> ERROR();
    antlr4::tree::TerminalNode* ERROR(size_t i);
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *MISSING();
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *EXTRA();
    antlr4::tree::TerminalNode *TYPE();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Json_value_on_mismatch_clauseContext* json_value_on_mismatch_clause();

  class  LiteralContext : public antlr4::ParserRuleContext {
  public:
    LiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();
    String_functionContext *string_function();
    NumericContext *numeric();
    Numeric_negativeContext *numeric_negative();
    antlr4::tree::TerminalNode *MAXVALUE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  LiteralContext* literal();

  class  Numeric_function_wrapperContext : public antlr4::ParserRuleContext {
  public:
    Numeric_function_wrapperContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Numeric_functionContext *numeric_function();
    Single_column_for_loopContext *single_column_for_loop();
    Multi_column_for_loopContext *multi_column_for_loop();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Numeric_function_wrapperContext* numeric_function_wrapper();

  class  Numeric_functionContext : public antlr4::ParserRuleContext {
  public:
    Numeric_functionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUM();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *DISTINCT();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *COUNT();
    antlr4::tree::TerminalNode *ASTERISK();
    Over_clauseContext *over_clause();
    ConcatenationContext *concatenation();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *ROUND();
    antlr4::tree::TerminalNode *COMMA();
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *AVG();
    antlr4::tree::TerminalNode *MAX();
    antlr4::tree::TerminalNode *LEAST();
    Expressions_Context *expressions_();
    antlr4::tree::TerminalNode *GREATEST();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Numeric_functionContext* numeric_function();

  class  Listagg_overflow_clauseContext : public antlr4::ParserRuleContext {
  public:
    Listagg_overflow_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *OVERFLOW_();
    antlr4::tree::TerminalNode *ERROR();
    antlr4::tree::TerminalNode *TRUNCATE();
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *COUNT();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *WITHOUT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Listagg_overflow_clauseContext* listagg_overflow_clause();

  class  Other_functionContext : public antlr4::ParserRuleContext {
  public:
    Other_functionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Over_clause_keywordContext *over_clause_keyword();
    Function_argument_analyticContext *function_argument_analytic();
    Over_clauseContext *over_clause();
    Regular_idContext *regular_id();
    Function_argument_modelingContext *function_argument_modeling();
    Using_clauseContext *using_clause();
    antlr4::tree::TerminalNode *COUNT();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *ASTERISK();
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    antlr4::tree::TerminalNode *DISTINCT();
    antlr4::tree::TerminalNode *UNIQUE();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *AS();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *CAST();
    antlr4::tree::TerminalNode *XMLCAST();
    antlr4::tree::TerminalNode *MULTISET();
    SubqueryContext *subquery();
    antlr4::tree::TerminalNode *DEFAULT();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *CONVERSION();
    antlr4::tree::TerminalNode *ERROR();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Quoted_stringContext *> quoted_string();
    Quoted_stringContext* quoted_string(size_t i);
    antlr4::tree::TerminalNode *COALESCE();
    Table_elementContext *table_element();
    NumericContext *numeric();
    antlr4::tree::TerminalNode *COLLECT();
    Collect_order_by_partContext *collect_order_by_part();
    Within_or_over_clause_keywordContext *within_or_over_clause_keyword();
    Function_argumentContext *function_argument();
    std::vector<Within_or_over_partContext *> within_or_over_part();
    Within_or_over_partContext* within_or_over_part(size_t i);
    antlr4::tree::TerminalNode *LISTAGG();
    ArgumentContext *argument();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    Listagg_overflow_clauseContext *listagg_overflow_clause();
    antlr4::tree::TerminalNode *WITHIN();
    antlr4::tree::TerminalNode *GROUP();
    Order_by_clauseContext *order_by_clause();
    Cursor_nameContext *cursor_name();
    antlr4::tree::TerminalNode *PERCENT_ISOPEN();
    antlr4::tree::TerminalNode *PERCENT_FOUND();
    antlr4::tree::TerminalNode *PERCENT_NOTFOUND();
    antlr4::tree::TerminalNode *PERCENT_ROWCOUNT();
    antlr4::tree::TerminalNode *DECOMPOSE();
    antlr4::tree::TerminalNode *CANONICAL();
    antlr4::tree::TerminalNode *COMPATIBILITY();
    antlr4::tree::TerminalNode *EXTRACT();
    antlr4::tree::TerminalNode *FROM();
    antlr4::tree::TerminalNode *FIRST_VALUE();
    antlr4::tree::TerminalNode *LAST_VALUE();
    Respect_or_ignore_nullsContext *respect_or_ignore_nulls();
    antlr4::tree::TerminalNode *LEAD();
    antlr4::tree::TerminalNode *LAG();
    Standard_prediction_function_keywordContext *standard_prediction_function_keyword();
    Expressions_Context *expressions_();
    Cost_matrix_clauseContext *cost_matrix_clause();
    antlr4::tree::TerminalNode *TO_BINARY_DOUBLE();
    antlr4::tree::TerminalNode *TO_BINARY_FLOAT();
    antlr4::tree::TerminalNode *TO_NUMBER();
    antlr4::tree::TerminalNode *TO_TIMESTAMP();
    antlr4::tree::TerminalNode *TO_TIMESTAMP_TZ();
    antlr4::tree::TerminalNode *TO_DSINTERVAL();
    antlr4::tree::TerminalNode *TO_YMINTERVAL();
    antlr4::tree::TerminalNode *TRANSLATE();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *CHAR_CS();
    antlr4::tree::TerminalNode *NCHAR_CS();
    antlr4::tree::TerminalNode *TREAT();
    antlr4::tree::TerminalNode *REF();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<General_element_partContext *> general_element_part();
    General_element_partContext* general_element_part(size_t i);
    antlr4::tree::TerminalNode *TRIM();
    antlr4::tree::TerminalNode *LEADING();
    antlr4::tree::TerminalNode *TRAILING();
    antlr4::tree::TerminalNode *BOTH();
    antlr4::tree::TerminalNode *VALIDATE_CONVERSION();
    antlr4::tree::TerminalNode *XMLAGG();
    std::vector<Xml_multiuse_expression_elementContext *> xml_multiuse_expression_element();
    Xml_multiuse_expression_elementContext* xml_multiuse_expression_element(size_t i);
    antlr4::tree::TerminalNode *XMLCOLATTVAL();
    antlr4::tree::TerminalNode *XMLFOREST();
    antlr4::tree::TerminalNode *XMLELEMENT();
    Xml_attributes_clauseContext *xml_attributes_clause();
    antlr4::tree::TerminalNode *ENTITYESCAPING();
    antlr4::tree::TerminalNode *NOENTITYESCAPING();
    antlr4::tree::TerminalNode *NAME();
    antlr4::tree::TerminalNode *EVALNAME();
    std::vector<Column_aliasContext *> column_alias();
    Column_aliasContext* column_alias(size_t i);
    antlr4::tree::TerminalNode *XMLEXISTS();
    Xml_passing_clauseContext *xml_passing_clause();
    antlr4::tree::TerminalNode *XMLPARSE();
    antlr4::tree::TerminalNode *DOCUMENT();
    antlr4::tree::TerminalNode *CONTENT();
    antlr4::tree::TerminalNode *WELLFORMED();
    antlr4::tree::TerminalNode *XMLPI();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *XMLQUERY();
    antlr4::tree::TerminalNode *RETURNING();
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *EMPTY_();
    antlr4::tree::TerminalNode *XMLROOT();
    Xmlroot_param_version_partContext *xmlroot_param_version_part();
    Xmlroot_param_standalone_partContext *xmlroot_param_standalone_part();
    antlr4::tree::TerminalNode *XMLSERIALIZE();
    Xmlserialize_param_enconding_partContext *xmlserialize_param_enconding_part();
    Xmlserialize_param_version_partContext *xmlserialize_param_version_part();
    Xmlserialize_param_ident_partContext *xmlserialize_param_ident_part();
    antlr4::tree::TerminalNode *DEFAULTS();
    antlr4::tree::TerminalNode *HIDE();
    antlr4::tree::TerminalNode *SHOW();
    antlr4::tree::TerminalNode *TIME();
    antlr4::tree::TerminalNode *CHAR_STRING();
    XmltableContext *xmltable();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Other_functionContext* other_function();

  class  Over_clause_keywordContext : public antlr4::ParserRuleContext {
  public:
    Over_clause_keywordContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AVG();
    antlr4::tree::TerminalNode *CORR();
    antlr4::tree::TerminalNode *LAG_DIFF();
    antlr4::tree::TerminalNode *LAG_DIFF_PERCENT();
    antlr4::tree::TerminalNode *MAX();
    antlr4::tree::TerminalNode *MEDIAN();
    antlr4::tree::TerminalNode *MIN();
    antlr4::tree::TerminalNode *NTH_VALUE();
    antlr4::tree::TerminalNode *NTILE();
    antlr4::tree::TerminalNode *RATIO_TO_REPORT();
    antlr4::tree::TerminalNode *ROW_NUMBER();
    antlr4::tree::TerminalNode *SUM();
    antlr4::tree::TerminalNode *VARIANCE();
    antlr4::tree::TerminalNode *REGR_();
    antlr4::tree::TerminalNode *STDDEV();
    antlr4::tree::TerminalNode *VAR_();
    antlr4::tree::TerminalNode *VAR_POP();
    antlr4::tree::TerminalNode *COVAR_();
    antlr4::tree::TerminalNode *WM_CONCAT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Over_clause_keywordContext* over_clause_keyword();

  class  Within_or_over_clause_keywordContext : public antlr4::ParserRuleContext {
  public:
    Within_or_over_clause_keywordContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CUME_DIST();
    antlr4::tree::TerminalNode *DENSE_RANK();
    antlr4::tree::TerminalNode *PERCENT_RANK();
    antlr4::tree::TerminalNode *PERCENTILE_CONT();
    antlr4::tree::TerminalNode *PERCENTILE_DISC();
    antlr4::tree::TerminalNode *RANK();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Within_or_over_clause_keywordContext* within_or_over_clause_keyword();

  class  Standard_prediction_function_keywordContext : public antlr4::ParserRuleContext {
  public:
    Standard_prediction_function_keywordContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PREDICTION();
    antlr4::tree::TerminalNode *PREDICTION_BOUNDS();
    antlr4::tree::TerminalNode *PREDICTION_COST();
    antlr4::tree::TerminalNode *PREDICTION_DETAILS();
    antlr4::tree::TerminalNode *PREDICTION_PROBABILITY();
    antlr4::tree::TerminalNode *PREDICTION_SET();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Standard_prediction_function_keywordContext* standard_prediction_function_keyword();

  class  Over_clauseContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *th = nullptr;
    Over_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OVER();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *HIERARCHY();
    antlr4::tree::TerminalNode *OFFSET();
    NumericContext *numeric();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    Query_partition_clauseContext *query_partition_clause();
    Order_by_clauseContext *order_by_clause();
    antlr4::tree::TerminalNode *ACROSS();
    antlr4::tree::TerminalNode *ANCESTOR();
    antlr4::tree::TerminalNode *AT();
    antlr4::tree::TerminalNode *LEVEL();
    Windowing_clauseContext *windowing_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Over_clauseContext* over_clause();

  class  Windowing_clauseContext : public antlr4::ParserRuleContext {
  public:
    Windowing_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Windowing_typeContext *windowing_type();
    antlr4::tree::TerminalNode *BETWEEN();
    std::vector<Windowing_elementsContext *> windowing_elements();
    Windowing_elementsContext* windowing_elements(size_t i);
    antlr4::tree::TerminalNode *AND();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Windowing_clauseContext* windowing_clause();

  class  Windowing_typeContext : public antlr4::ParserRuleContext {
  public:
    Windowing_typeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ROWS();
    antlr4::tree::TerminalNode *RANGE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Windowing_typeContext* windowing_type();

  class  Windowing_elementsContext : public antlr4::ParserRuleContext {
  public:
    Windowing_elementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNBOUNDED();
    antlr4::tree::TerminalNode *PRECEDING();
    antlr4::tree::TerminalNode *CURRENT();
    antlr4::tree::TerminalNode *ROW();
    ConcatenationContext *concatenation();
    antlr4::tree::TerminalNode *FOLLOWING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Windowing_elementsContext* windowing_elements();

  class  Using_clauseContext : public antlr4::ParserRuleContext {
  public:
    Using_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *ASTERISK();
    std::vector<Using_elementContext *> using_element();
    Using_elementContext* using_element(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Using_clauseContext* using_clause();

  class  Using_elementContext : public antlr4::ParserRuleContext {
  public:
    Using_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IN();
    ExpressionContext *expression();
    antlr4::tree::TerminalNode *OUT();
    Assignable_elementContext *assignable_element();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Using_elementContext* using_element();

  class  Assignable_elementContext : public antlr4::ParserRuleContext {
  public:
    Assignable_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    General_elementContext *general_element();
    Bind_variableContext *bind_variable();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Assignable_elementContext* assignable_element();

  class  Collect_order_by_partContext : public antlr4::ParserRuleContext {
  public:
    Collect_order_by_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ORDER();
    antlr4::tree::TerminalNode *BY();
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Collect_order_by_partContext* collect_order_by_part();

  class  Within_or_over_partContext : public antlr4::ParserRuleContext {
  public:
    Within_or_over_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WITHIN();
    antlr4::tree::TerminalNode *GROUP();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Order_by_clauseContext *order_by_clause();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Over_clauseContext *over_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Within_or_over_partContext* within_or_over_part();

  class  String_delimiterContext : public antlr4::ParserRuleContext {
  public:
    String_delimiterContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();
    String_functionContext *string_function();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<String_delimiterContext *> string_delimiter();
    String_delimiterContext* string_delimiter(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Id_expressionContext *id_expression();
    std::vector<antlr4::tree::TerminalNode *> BAR();
    antlr4::tree::TerminalNode* BAR(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  String_delimiterContext* string_delimiter();
  String_delimiterContext* string_delimiter(int precedence);
  class  Cost_matrix_clauseContext : public antlr4::ParserRuleContext {
  public:
    Cost_matrix_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COST();
    antlr4::tree::TerminalNode *MODEL();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<Cost_class_nameContext *> cost_class_name();
    Cost_class_nameContext* cost_class_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *VALUES();
    antlr4::tree::TerminalNode *AUTO();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Expressions_Context *expressions_();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cost_matrix_clauseContext* cost_matrix_clause();

  class  Xml_passing_clauseContext : public antlr4::ParserRuleContext {
  public:
    Xml_passing_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PASSING();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    antlr4::tree::TerminalNode *BY();
    antlr4::tree::TerminalNode *VALUE();
    std::vector<Column_aliasContext *> column_alias();
    Column_aliasContext* column_alias(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_passing_clauseContext* xml_passing_clause();

  class  Xml_attributes_clauseContext : public antlr4::ParserRuleContext {
  public:
    Xml_attributes_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *XMLATTRIBUTES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<Xml_multiuse_expression_elementContext *> xml_multiuse_expression_element();
    Xml_multiuse_expression_elementContext* xml_multiuse_expression_element(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *ENTITYESCAPING();
    antlr4::tree::TerminalNode *NOENTITYESCAPING();
    antlr4::tree::TerminalNode *SCHEMACHECK();
    antlr4::tree::TerminalNode *NOSCHEMACHECK();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_attributes_clauseContext* xml_attributes_clause();

  class  Xml_namespaces_clauseContext : public antlr4::ParserRuleContext {
  public:
    Xml_namespaces_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *XMLNAMESPACES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<ConcatenationContext *> concatenation();
    ConcatenationContext* concatenation(size_t i);
    std::vector<Column_aliasContext *> column_alias();
    Column_aliasContext* column_alias(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Xml_general_default_partContext *xml_general_default_part();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_namespaces_clauseContext* xml_namespaces_clause();

  class  Xml_table_columnContext : public antlr4::ParserRuleContext {
  public:
    Xml_table_columnContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Xml_column_nameContext *xml_column_name();
    antlr4::tree::TerminalNode *FOR();
    antlr4::tree::TerminalNode *ORDINALITY();
    Type_specContext *type_spec();
    antlr4::tree::TerminalNode *PATH();
    ConcatenationContext *concatenation();
    Xml_general_default_partContext *xml_general_default_part();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_table_columnContext* xml_table_column();

  class  Xml_general_default_partContext : public antlr4::ParserRuleContext {
  public:
    Xml_general_default_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DEFAULT();
    ConcatenationContext *concatenation();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_general_default_partContext* xml_general_default_part();

  class  Xml_multiuse_expression_elementContext : public antlr4::ParserRuleContext {
  public:
    Xml_multiuse_expression_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *EVALNAME();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_multiuse_expression_elementContext* xml_multiuse_expression_element();

  class  Xmlroot_param_version_partContext : public antlr4::ParserRuleContext {
  public:
    Xmlroot_param_version_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VERSION();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *VALUE();
    ExpressionContext *expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmlroot_param_version_partContext* xmlroot_param_version_part();

  class  Xmlroot_param_standalone_partContext : public antlr4::ParserRuleContext {
  public:
    Xmlroot_param_standalone_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *STANDALONE();
    antlr4::tree::TerminalNode *YES();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *VALUE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmlroot_param_standalone_partContext* xmlroot_param_standalone_part();

  class  Xmlserialize_param_enconding_partContext : public antlr4::ParserRuleContext {
  public:
    Xmlserialize_param_enconding_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ENCODING();
    ConcatenationContext *concatenation();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmlserialize_param_enconding_partContext* xmlserialize_param_enconding_part();

  class  Xmlserialize_param_version_partContext : public antlr4::ParserRuleContext {
  public:
    Xmlserialize_param_version_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VERSION();
    ConcatenationContext *concatenation();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmlserialize_param_version_partContext* xmlserialize_param_version_part();

  class  Xmlserialize_param_ident_partContext : public antlr4::ParserRuleContext {
  public:
    Xmlserialize_param_ident_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *INDENT();
    antlr4::tree::TerminalNode *SIZE();
    antlr4::tree::TerminalNode *EQUALS_OP();
    ConcatenationContext *concatenation();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xmlserialize_param_ident_partContext* xmlserialize_param_ident_part();

  class  Annotations_clauseContext : public antlr4::ParserRuleContext {
  public:
    Annotations_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ANNOTATIONS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Annotations_listContext *annotations_list();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Annotations_clauseContext* annotations_clause();

  class  Annotations_listContext : public antlr4::ParserRuleContext {
  public:
    Annotations_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    AnnotationContext *annotation();
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *REPLACE();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    std::vector<Annotations_listContext *> annotations_list();
    Annotations_listContext* annotations_list(size_t i);
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *EXISTS();
    antlr4::tree::TerminalNode *OR();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Annotations_listContext* annotations_list();

  class  AnnotationContext : public antlr4::ParserRuleContext {
  public:
    AnnotationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *CHAR_STRING();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  AnnotationContext* annotation();

  class  Sql_plus_command_no_semicolonContext : public antlr4::ParserRuleContext {
  public:
    Sql_plus_command_no_semicolonContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Set_commandContext *set_command();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sql_plus_command_no_semicolonContext* sql_plus_command_no_semicolon();

  class  Sql_plus_commandContext : public antlr4::ParserRuleContext {
  public:
    Sql_plus_commandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXIT();
    antlr4::tree::TerminalNode *PROMPT_MESSAGE();
    antlr4::tree::TerminalNode *SHOW();
    antlr4::tree::TerminalNode *ERR();
    antlr4::tree::TerminalNode *ERRORS();
    Whenever_commandContext *whenever_command();
    Timing_commandContext *timing_command();
    Start_commandContext *start_command();
    Set_commandContext *set_command();
    Clear_commandContext *clear_command();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sql_plus_commandContext* sql_plus_command();

  class  Start_commandContext : public antlr4::ParserRuleContext {
  public:
    Start_commandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *START_CMD();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *SQL();
    antlr4::tree::TerminalNode *FILE_EXT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Start_commandContext* start_command();

  class  Whenever_commandContext : public antlr4::ParserRuleContext {
  public:
    Whenever_commandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHENEVER();
    antlr4::tree::TerminalNode *SQLERROR();
    antlr4::tree::TerminalNode *OSERROR();
    antlr4::tree::TerminalNode *EXIT();
    antlr4::tree::TerminalNode *CONTINUE();
    antlr4::tree::TerminalNode *SUCCESS();
    antlr4::tree::TerminalNode *FAILURE();
    antlr4::tree::TerminalNode *WARNING();
    Variable_nameContext *variable_name();
    NumericContext *numeric();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *ROLLBACK();
    antlr4::tree::TerminalNode *NONE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Whenever_commandContext* whenever_command();

  class  Set_commandContext : public antlr4::ParserRuleContext {
  public:
    Set_commandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    std::vector<Regular_idContext *> regular_id();
    Regular_idContext* regular_id(size_t i);
    std::vector<antlr4::tree::TerminalNode *> ON();
    antlr4::tree::TerminalNode* ON(size_t i);
    std::vector<antlr4::tree::TerminalNode *> OFF();
    antlr4::tree::TerminalNode* OFF(size_t i);
    antlr4::tree::TerminalNode *CHAR_STRING();
    NumericContext *numeric();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Set_commandContext* set_command();

  class  Timing_commandContext : public antlr4::ParserRuleContext {
  public:
    PlSqlParser::Id_expressionContext *timing_text = nullptr;
    Timing_commandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TIMING();
    antlr4::tree::TerminalNode *START();
    antlr4::tree::TerminalNode *SHOW();
    antlr4::tree::TerminalNode *STOP();
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Timing_commandContext* timing_command();

  class  Clear_commandContext : public antlr4::ParserRuleContext {
  public:
    Clear_commandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CLEAR();
    Regular_idContext *regular_id();
    antlr4::tree::TerminalNode *COLUMN();
    antlr4::tree::TerminalNode *ALL();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Clear_commandContext* clear_command();

  class  Partition_extension_clauseContext : public antlr4::ParserRuleContext {
  public:
    Partition_extension_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *SUBPARTITION();
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *FOR();
    Expressions_Context *expressions_();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Partition_extension_clauseContext* partition_extension_clause();

  class  Column_aliasContext : public antlr4::ParserRuleContext {
  public:
    Column_aliasContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    Quoted_stringContext *quoted_string();
    antlr4::tree::TerminalNode *AS();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_aliasContext* column_alias();

  class  Table_aliasContext : public antlr4::ParserRuleContext {
  public:
    Table_aliasContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    Quoted_stringContext *quoted_string();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_aliasContext* table_alias();

  class  Where_clauseContext : public antlr4::ParserRuleContext {
  public:
    Where_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHERE();
    antlr4::tree::TerminalNode *CURRENT();
    antlr4::tree::TerminalNode *OF();
    Cursor_nameContext *cursor_name();
    ConditionContext *condition();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Where_clauseContext* where_clause();

  class  Into_clauseContext : public antlr4::ParserRuleContext {
  public:
    Into_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INTO();
    std::vector<General_elementContext *> general_element();
    General_elementContext* general_element(size_t i);
    std::vector<Bind_variableContext *> bind_variable();
    Bind_variableContext* bind_variable(size_t i);
    antlr4::tree::TerminalNode *BULK();
    antlr4::tree::TerminalNode *COLLECT();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Into_clauseContext* into_clause();

  class  Xml_column_nameContext : public antlr4::ParserRuleContext {
  public:
    Xml_column_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    Quoted_stringContext *quoted_string();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Xml_column_nameContext* xml_column_name();

  class  Cost_class_nameContext : public antlr4::ParserRuleContext {
  public:
    Cost_class_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cost_class_nameContext* cost_class_name();

  class  Attribute_nameContext : public antlr4::ParserRuleContext {
  public:
    Attribute_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Attribute_nameContext* attribute_name();

  class  Savepoint_nameContext : public antlr4::ParserRuleContext {
  public:
    Savepoint_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Savepoint_nameContext* savepoint_name();

  class  Rollback_segment_nameContext : public antlr4::ParserRuleContext {
  public:
    Rollback_segment_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Rollback_segment_nameContext* rollback_segment_name();

  class  Schema_nameContext : public antlr4::ParserRuleContext {
  public:
    Schema_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Schema_nameContext* schema_name();

  class  Routine_nameContext : public antlr4::ParserRuleContext {
  public:
    Routine_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *AT_SIGN();
    Link_nameContext *link_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Routine_nameContext* routine_name();

  class  Package_nameContext : public antlr4::ParserRuleContext {
  public:
    Package_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Package_nameContext* package_name();

  class  Implementation_type_nameContext : public antlr4::ParserRuleContext {
  public:
    Implementation_type_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *PERIOD();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Implementation_type_nameContext* implementation_type_name();

  class  Parameter_nameContext : public antlr4::ParserRuleContext {
  public:
    Parameter_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Parameter_nameContext* parameter_name();

  class  Reference_model_nameContext : public antlr4::ParserRuleContext {
  public:
    Reference_model_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Reference_model_nameContext* reference_model_name();

  class  Main_model_nameContext : public antlr4::ParserRuleContext {
  public:
    Main_model_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Main_model_nameContext* main_model_name();

  class  Container_tableview_nameContext : public antlr4::ParserRuleContext {
  public:
    Container_tableview_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *PERIOD();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Container_tableview_nameContext* container_tableview_name();

  class  Aggregate_function_nameContext : public antlr4::ParserRuleContext {
  public:
    Aggregate_function_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Aggregate_function_nameContext* aggregate_function_name();

  class  Query_nameContext : public antlr4::ParserRuleContext {
  public:
    Query_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Query_nameContext* query_name();

  class  Grantee_nameContext : public antlr4::ParserRuleContext {
  public:
    Grantee_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();
    Identified_byContext *identified_by();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Grantee_nameContext* grantee_name();

  class  Role_nameContext : public antlr4::ParserRuleContext {
  public:
    Role_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *CONNECT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Role_nameContext* role_name();

  class  Constraint_nameContext : public antlr4::ParserRuleContext {
  public:
    Constraint_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *AT_SIGN();
    Link_nameContext *link_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Constraint_nameContext* constraint_name();

  class  Label_nameContext : public antlr4::ParserRuleContext {
  public:
    Label_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Label_nameContext* label_name();

  class  Type_nameContext : public antlr4::ParserRuleContext {
  public:
    Type_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Type_nameContext* type_name();

  class  Sequence_nameContext : public antlr4::ParserRuleContext {
  public:
    Sequence_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Sequence_nameContext* sequence_name();

  class  Exception_nameContext : public antlr4::ParserRuleContext {
  public:
    Exception_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Exception_nameContext* exception_name();

  class  Function_nameContext : public antlr4::ParserRuleContext {
  public:
    Function_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *PERIOD();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Function_nameContext* function_name();

  class  Procedure_nameContext : public antlr4::ParserRuleContext {
  public:
    Procedure_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *PERIOD();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Procedure_nameContext* procedure_name();

  class  Trigger_nameContext : public antlr4::ParserRuleContext {
  public:
    Trigger_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *PERIOD();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Trigger_nameContext* trigger_name();

  class  Variable_nameContext : public antlr4::ParserRuleContext {
  public:
    Variable_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *INTRODUCER();
    Char_set_nameContext *char_set_name();
    antlr4::tree::TerminalNode *PERIOD();
    Bind_variableContext *bind_variable();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Variable_nameContext* variable_name();

  class  Index_nameContext : public antlr4::ParserRuleContext {
  public:
    Index_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *PERIOD();
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Index_nameContext* index_name();

  class  Cursor_nameContext : public antlr4::ParserRuleContext {
  public:
    Cursor_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    General_elementContext *general_element();
    Bind_variableContext *bind_variable();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Cursor_nameContext* cursor_name();

  class  Record_nameContext : public antlr4::ParserRuleContext {
  public:
    Record_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    Bind_variableContext *bind_variable();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Record_nameContext* record_name();

  class  Link_nameContext : public antlr4::ParserRuleContext {
  public:
    Link_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    DatabaseContext *database();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<DomainContext *> domain();
    DomainContext* domain(size_t i);
    antlr4::tree::TerminalNode *AT_SIGN();
    Connection_qualifierContext *connection_qualifier();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Link_nameContext* link_name();

  class  Local_link_nameContext : public antlr4::ParserRuleContext {
  public:
    Local_link_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Local_link_nameContext* local_link_name();

  class  Connection_qualifierContext : public antlr4::ParserRuleContext {
  public:
    Connection_qualifierContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Connection_qualifierContext* connection_qualifier();

  class  Column_nameContext : public antlr4::ParserRuleContext {
  public:
    Column_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_nameContext* column_name();

  class  Tableview_nameContext : public antlr4::ParserRuleContext {
  public:
    Tableview_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *PERIOD();
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *AT_SIGN();
    Link_nameContext *link_name();
    Partition_extension_clauseContext *partition_extension_clause();
    XmltableContext *xmltable();
    Outer_join_signContext *outer_join_sign();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Tableview_nameContext* tableview_name();

  class  XmltableContext : public antlr4::ParserRuleContext {
  public:
    XmltableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *XMLTABLE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ConcatenationContext *concatenation();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Xml_namespaces_clauseContext *xml_namespaces_clause();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Xml_passing_clauseContext *xml_passing_clause();
    antlr4::tree::TerminalNode *COLUMNS();
    std::vector<Xml_table_columnContext *> xml_table_column();
    Xml_table_columnContext* xml_table_column(size_t i);
    antlr4::tree::TerminalNode *PERIOD();
    General_element_partContext *general_element_part();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  XmltableContext* xmltable();

  class  Char_set_nameContext : public antlr4::ParserRuleContext {
  public:
    Char_set_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Char_set_nameContext* char_set_name();

  class  Synonym_nameContext : public antlr4::ParserRuleContext {
  public:
    Synonym_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Synonym_nameContext* synonym_name();

  class  Schema_object_nameContext : public antlr4::ParserRuleContext {
  public:
    Schema_object_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Schema_object_nameContext* schema_object_name();

  class  Dir_object_nameContext : public antlr4::ParserRuleContext {
  public:
    Dir_object_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Dir_object_nameContext* dir_object_name();

  class  User_object_nameContext : public antlr4::ParserRuleContext {
  public:
    User_object_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  User_object_nameContext* user_object_name();

  class  Grant_object_nameContext : public antlr4::ParserRuleContext {
  public:
    Grant_object_nameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *USER();
    std::vector<User_object_nameContext *> user_object_name();
    User_object_nameContext* user_object_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *DIRECTORY();
    Dir_object_nameContext *dir_object_name();
    antlr4::tree::TerminalNode *EDITION();
    Schema_object_nameContext *schema_object_name();
    antlr4::tree::TerminalNode *MINING();
    antlr4::tree::TerminalNode *MODEL();
    antlr4::tree::TerminalNode *JAVA();
    antlr4::tree::TerminalNode *SOURCE();
    antlr4::tree::TerminalNode *RESOURCE();
    antlr4::tree::TerminalNode *SQL();
    antlr4::tree::TerminalNode *TRANSLATION();
    antlr4::tree::TerminalNode *PROFILE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Grant_object_nameContext* grant_object_name();

  class  Column_listContext : public antlr4::ParserRuleContext {
  public:
    Column_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Column_nameContext *> column_name();
    Column_nameContext* column_name(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Column_listContext* column_list();

  class  Paren_column_listContext : public antlr4::ParserRuleContext {
  public:
    Paren_column_listContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Column_listContext *column_list();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Paren_column_listContext* paren_column_list();

  class  Keep_clauseContext : public antlr4::ParserRuleContext {
  public:
    Keep_clauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *DENSE_RANK();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *FIRST();
    antlr4::tree::TerminalNode *LAST();
    Query_partition_clauseContext *query_partition_clause();
    Order_by_clauseContext *order_by_clause();
    Over_clauseContext *over_clause();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Keep_clauseContext* keep_clause();

  class  Function_argumentContext : public antlr4::ParserRuleContext {
  public:
    Function_argumentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<ArgumentContext *> argument();
    ArgumentContext* argument(size_t i);
    Keep_clauseContext *keep_clause();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Function_argumentContext* function_argument();

  class  Function_argument_analyticContext : public antlr4::ParserRuleContext {
  public:
    Function_argument_analyticContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<ArgumentContext *> argument();
    ArgumentContext* argument(size_t i);
    Keep_clauseContext *keep_clause();
    std::vector<Respect_or_ignore_nullsContext *> respect_or_ignore_nulls();
    Respect_or_ignore_nullsContext* respect_or_ignore_nulls(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Function_argument_analyticContext* function_argument_analytic();

  class  Function_argument_modelingContext : public antlr4::ParserRuleContext {
  public:
    Function_argument_modelingContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    Column_nameContext *column_name();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    Tableview_nameContext *tableview_name();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *ASTERISK();
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    Keep_clauseContext *keep_clause();
    std::vector<NumericContext *> numeric();
    NumericContext* numeric(size_t i);
    std::vector<antlr4::tree::TerminalNode *> NULL_();
    antlr4::tree::TerminalNode* NULL_(size_t i);
    std::vector<Column_aliasContext *> column_alias();
    Column_aliasContext* column_alias(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Function_argument_modelingContext* function_argument_modeling();

  class  Respect_or_ignore_nullsContext : public antlr4::ParserRuleContext {
  public:
    Respect_or_ignore_nullsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NULLS();
    antlr4::tree::TerminalNode *RESPECT();
    antlr4::tree::TerminalNode *IGNORE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Respect_or_ignore_nullsContext* respect_or_ignore_nulls();

  class  ArgumentContext : public antlr4::ParserRuleContext {
  public:
    ArgumentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExpressionContext *expression();
    IdentifierContext *identifier();
    antlr4::tree::TerminalNode *EQUALS_OP();
    antlr4::tree::TerminalNode *GREATER_THAN_OP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ArgumentContext* argument();

  class  Type_specContext : public antlr4::ParserRuleContext {
  public:
    Type_specContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    DatatypeContext *datatype();
    Type_nameContext *type_name();
    antlr4::tree::TerminalNode *REF();
    antlr4::tree::TerminalNode *PERCENT_ROWTYPE();
    antlr4::tree::TerminalNode *PERCENT_TYPE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Type_specContext* type_spec();

  class  DatatypeContext : public antlr4::ParserRuleContext {
  public:
    DatatypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Native_datatype_elementContext *native_datatype_element();
    Precision_partContext *precision_part();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *TIME();
    antlr4::tree::TerminalNode *ZONE();
    antlr4::tree::TerminalNode *CHARACTER();
    antlr4::tree::TerminalNode *SET();
    Char_set_nameContext *char_set_name();
    antlr4::tree::TerminalNode *LOCAL();
    antlr4::tree::TerminalNode *INTERVAL();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *YEAR();
    antlr4::tree::TerminalNode *DAY();
    antlr4::tree::TerminalNode *MONTH();
    antlr4::tree::TerminalNode *SECOND();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<ExpressionContext *> expression();
    ExpressionContext* expression(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  DatatypeContext* datatype();

  class  Precision_partContext : public antlr4::ParserRuleContext {
  public:
    Precision_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<NumericContext *> numeric();
    NumericContext* numeric(size_t i);
    antlr4::tree::TerminalNode *ASTERISK();
    antlr4::tree::TerminalNode *COMMA();
    antlr4::tree::TerminalNode *CHAR();
    antlr4::tree::TerminalNode *BYTE();
    Numeric_negativeContext *numeric_negative();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Precision_partContext* precision_part();

  class  Native_datatype_elementContext : public antlr4::ParserRuleContext {
  public:
    Native_datatype_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BINARY_INTEGER();
    antlr4::tree::TerminalNode *PLS_INTEGER();
    antlr4::tree::TerminalNode *NATURAL();
    antlr4::tree::TerminalNode *BINARY_FLOAT();
    antlr4::tree::TerminalNode *BINARY_DOUBLE();
    antlr4::tree::TerminalNode *NATURALN();
    antlr4::tree::TerminalNode *POSITIVE();
    antlr4::tree::TerminalNode *POSITIVEN();
    antlr4::tree::TerminalNode *SIGNTYPE();
    antlr4::tree::TerminalNode *SIMPLE_INTEGER();
    antlr4::tree::TerminalNode *NVARCHAR2();
    antlr4::tree::TerminalNode *DEC();
    antlr4::tree::TerminalNode *INTEGER();
    antlr4::tree::TerminalNode *INT();
    antlr4::tree::TerminalNode *NUMERIC();
    antlr4::tree::TerminalNode *SMALLINT();
    antlr4::tree::TerminalNode *NUMBER();
    antlr4::tree::TerminalNode *DECIMAL();
    antlr4::tree::TerminalNode *DOUBLE();
    antlr4::tree::TerminalNode *PRECISION();
    antlr4::tree::TerminalNode *FLOAT();
    antlr4::tree::TerminalNode *REAL();
    antlr4::tree::TerminalNode *NCHAR();
    antlr4::tree::TerminalNode *LONG();
    antlr4::tree::TerminalNode *RAW();
    antlr4::tree::TerminalNode *CHAR();
    antlr4::tree::TerminalNode *CHARACTER();
    antlr4::tree::TerminalNode *VARYING();
    antlr4::tree::TerminalNode *VARCHAR2();
    antlr4::tree::TerminalNode *VARCHAR();
    antlr4::tree::TerminalNode *STRING();
    antlr4::tree::TerminalNode *BOOLEAN();
    antlr4::tree::TerminalNode *DATE();
    antlr4::tree::TerminalNode *ROWID();
    antlr4::tree::TerminalNode *UROWID();
    antlr4::tree::TerminalNode *YEAR();
    antlr4::tree::TerminalNode *MONTH();
    antlr4::tree::TerminalNode *DAY();
    antlr4::tree::TerminalNode *HOUR();
    antlr4::tree::TerminalNode *MINUTE();
    antlr4::tree::TerminalNode *SECOND();
    antlr4::tree::TerminalNode *SDO_GEOMETRY();
    antlr4::tree::TerminalNode *TIMEZONE_HOUR();
    antlr4::tree::TerminalNode *TIMEZONE_MINUTE();
    antlr4::tree::TerminalNode *TIMEZONE_REGION();
    antlr4::tree::TerminalNode *TIMEZONE_ABBR();
    antlr4::tree::TerminalNode *TIMESTAMP();
    antlr4::tree::TerminalNode *TIMESTAMP_UNCONSTRAINED();
    antlr4::tree::TerminalNode *TIMESTAMP_TZ_UNCONSTRAINED();
    antlr4::tree::TerminalNode *TIMESTAMP_LTZ_UNCONSTRAINED();
    antlr4::tree::TerminalNode *YMINTERVAL_UNCONSTRAINED();
    antlr4::tree::TerminalNode *DSINTERVAL_UNCONSTRAINED();
    antlr4::tree::TerminalNode *BFILE();
    antlr4::tree::TerminalNode *BLOB();
    antlr4::tree::TerminalNode *CLOB();
    antlr4::tree::TerminalNode *NCLOB();
    antlr4::tree::TerminalNode *MLSLABEL();
    antlr4::tree::TerminalNode *XMLTYPE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Native_datatype_elementContext* native_datatype_element();

  class  Bind_variableContext : public antlr4::ParserRuleContext {
  public:
    Bind_variableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> BINDVAR();
    antlr4::tree::TerminalNode* BINDVAR(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COLON();
    antlr4::tree::TerminalNode* COLON(size_t i);
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);
    std::vector<General_element_partContext *> general_element_part();
    General_element_partContext* general_element_part(size_t i);
    antlr4::tree::TerminalNode *INDICATOR();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Bind_variableContext* bind_variable();

  class  General_elementContext : public antlr4::ParserRuleContext {
  public:
    General_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<General_element_partContext *> general_element_part();
    General_element_partContext* general_element_part(size_t i);
    antlr4::tree::TerminalNode *LEFT_PAREN();
    General_elementContext *general_element();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  General_elementContext* general_element();
  General_elementContext* general_element(int precedence);
  class  General_element_partContext : public antlr4::ParserRuleContext {
  public:
    General_element_partContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *INTRODUCER();
    Char_set_nameContext *char_set_name();
    antlr4::tree::TerminalNode *AT_SIGN();
    Link_nameContext *link_name();
    std::vector<Function_argumentContext *> function_argument();
    Function_argumentContext* function_argument(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  General_element_partContext* general_element_part();

  class  Table_elementContext : public antlr4::ParserRuleContext {
  public:
    Table_elementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<Id_expressionContext *> id_expression();
    Id_expressionContext* id_expression(size_t i);
    antlr4::tree::TerminalNode *INTRODUCER();
    Char_set_nameContext *char_set_name();
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Table_elementContext* table_element();

  class  Object_privilegeContext : public antlr4::ParserRuleContext {
  public:
    Object_privilegeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *PRIVILEGES();
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *DEBUG();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *EXECUTE();
    antlr4::tree::TerminalNode *FLASHBACK();
    antlr4::tree::TerminalNode *ARCHIVE();
    antlr4::tree::TerminalNode *INDEX();
    antlr4::tree::TerminalNode *INHERIT();
    antlr4::tree::TerminalNode *REMOTE();
    antlr4::tree::TerminalNode *INSERT();
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *SEQUENCE();
    antlr4::tree::TerminalNode *MERGE();
    antlr4::tree::TerminalNode *VIEW();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *REFRESH();
    antlr4::tree::TerminalNode *QUERY();
    antlr4::tree::TerminalNode *REWRITE();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *REFERENCES();
    antlr4::tree::TerminalNode *SELECT();
    antlr4::tree::TerminalNode *TRANSLATE();
    antlr4::tree::TerminalNode *SQL();
    antlr4::tree::TerminalNode *UNDER();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *USE();
    antlr4::tree::TerminalNode *WRITE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Object_privilegeContext* object_privilege();

  class  System_privilegeContext : public antlr4::ParserRuleContext {
  public:
    System_privilegeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *PRIVILEGES();
    antlr4::tree::TerminalNode *ADVISOR();
    antlr4::tree::TerminalNode *ADMINISTER();
    antlr4::tree::TerminalNode *SQL();
    antlr4::tree::TerminalNode *TUNING();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *ANY();
    antlr4::tree::TerminalNode *PROFILE();
    antlr4::tree::TerminalNode *ALTER();
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *MANAGEMENT();
    antlr4::tree::TerminalNode *OBJECT();
    antlr4::tree::TerminalNode *CLUSTER();
    antlr4::tree::TerminalNode *CONTEXT();
    antlr4::tree::TerminalNode *EXEMPT();
    antlr4::tree::TerminalNode *REDACTION();
    antlr4::tree::TerminalNode *POLICY();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *LINK();
    antlr4::tree::TerminalNode *PUBLIC();
    antlr4::tree::TerminalNode *DEBUG();
    antlr4::tree::TerminalNode *CONNECT();
    antlr4::tree::TerminalNode *SESSION();
    antlr4::tree::TerminalNode *PROCEDURE();
    antlr4::tree::TerminalNode *ANALYZE();
    antlr4::tree::TerminalNode *DICTIONARY();
    antlr4::tree::TerminalNode *DIMENSION();
    antlr4::tree::TerminalNode *DIRECTORY();
    antlr4::tree::TerminalNode *EDITION();
    antlr4::tree::TerminalNode *FLASHBACK();
    antlr4::tree::TerminalNode *ARCHIVE();
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *INDEX();
    antlr4::tree::TerminalNode *INDEXTYPE();
    antlr4::tree::TerminalNode *EXECUTE();
    antlr4::tree::TerminalNode *JOB();
    antlr4::tree::TerminalNode *EXTERNAL();
    antlr4::tree::TerminalNode *CLASS();
    antlr4::tree::TerminalNode *PROGRAM();
    antlr4::tree::TerminalNode *MANAGE();
    antlr4::tree::TerminalNode *SCHEDULER();
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *LIBRARY();
    antlr4::tree::TerminalNode *LOGMINING();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *VIEW();
    antlr4::tree::TerminalNode *QUERY();
    antlr4::tree::TerminalNode *REWRITE();
    antlr4::tree::TerminalNode *GLOBAL();
    antlr4::tree::TerminalNode *ON();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *REFRESH();
    antlr4::tree::TerminalNode *MINING();
    antlr4::tree::TerminalNode *MODEL();
    antlr4::tree::TerminalNode *SELECT();
    antlr4::tree::TerminalNode *COMMENT();
    antlr4::tree::TerminalNode *CUBE();
    antlr4::tree::TerminalNode *UPDATE();
    antlr4::tree::TerminalNode *MEASURE();
    antlr4::tree::TerminalNode *FOLDER();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *INSERT();
    antlr4::tree::TerminalNode *BUILD();
    antlr4::tree::TerminalNode *PROCESS();
    antlr4::tree::TerminalNode *OPERATOR();
    antlr4::tree::TerminalNode *OUTLINE();
    antlr4::tree::TerminalNode *PLUGGABLE();
    antlr4::tree::TerminalNode *CONTAINER();
    antlr4::tree::TerminalNode *ROLE();
    antlr4::tree::TerminalNode *GRANT();
    antlr4::tree::TerminalNode *ROLLBACK();
    antlr4::tree::TerminalNode *SEGMENT();
    antlr4::tree::TerminalNode *SEQUENCE();
    antlr4::tree::TerminalNode *RESTRICTED();
    antlr4::tree::TerminalNode *RESOURCE();
    antlr4::tree::TerminalNode *COST();
    antlr4::tree::TerminalNode *TRANSLATION();
    antlr4::tree::TerminalNode *USE();
    antlr4::tree::TerminalNode *TRANSLATE();
    antlr4::tree::TerminalNode *SYNONYM();
    antlr4::tree::TerminalNode *BACKUP();
    antlr4::tree::TerminalNode *LOCK();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *TABLESPACE();
    antlr4::tree::TerminalNode *UNLIMITED();
    antlr4::tree::TerminalNode *TRIGGER();
    antlr4::tree::TerminalNode *TYPE();
    antlr4::tree::TerminalNode *UNDER();
    antlr4::tree::TerminalNode *USER();
    antlr4::tree::TerminalNode *MERGE();
    antlr4::tree::TerminalNode *AUDIT();
    antlr4::tree::TerminalNode *BECOME();
    antlr4::tree::TerminalNode *CHANGE();
    antlr4::tree::TerminalNode *NOTIFICATION();
    antlr4::tree::TerminalNode *ACCESS();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *TRANSACTION();
    antlr4::tree::TerminalNode *PRIVILEGE();
    antlr4::tree::TerminalNode *INHERIT();
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *DATE();
    antlr4::tree::TerminalNode *TIME();
    antlr4::tree::TerminalNode *SYSGUID();
    antlr4::tree::TerminalNode *PURGE();
    antlr4::tree::TerminalNode *DBA_RECYCLEBIN();
    antlr4::tree::TerminalNode *RESUMABLE();
    antlr4::tree::TerminalNode *SYSBACKUP();
    antlr4::tree::TerminalNode *SYSDBA();
    antlr4::tree::TerminalNode *SYSDG();
    antlr4::tree::TerminalNode *SYSKM();
    antlr4::tree::TerminalNode *SYSOPER();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  System_privilegeContext* system_privilege();

  class  ConstantContext : public antlr4::ParserRuleContext {
  public:
    ConstantContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TIMESTAMP();
    std::vector<Quoted_stringContext *> quoted_string();
    Quoted_stringContext* quoted_string(size_t i);
    std::vector<Bind_variableContext *> bind_variable();
    Bind_variableContext* bind_variable(size_t i);
    antlr4::tree::TerminalNode *AT();
    antlr4::tree::TerminalNode *TIME();
    antlr4::tree::TerminalNode *ZONE();
    antlr4::tree::TerminalNode *INTERVAL();
    antlr4::tree::TerminalNode *YEAR();
    std::vector<antlr4::tree::TerminalNode *> MONTH();
    antlr4::tree::TerminalNode* MONTH(size_t i);
    std::vector<antlr4::tree::TerminalNode *> DAY();
    antlr4::tree::TerminalNode* DAY(size_t i);
    std::vector<antlr4::tree::TerminalNode *> HOUR();
    antlr4::tree::TerminalNode* HOUR(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MINUTE();
    antlr4::tree::TerminalNode* MINUTE(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SECOND();
    antlr4::tree::TerminalNode* SECOND(size_t i);
    General_element_partContext *general_element_part();
    std::vector<antlr4::tree::TerminalNode *> LEFT_PAREN();
    antlr4::tree::TerminalNode* LEFT_PAREN(size_t i);
    std::vector<antlr4::tree::TerminalNode *> RIGHT_PAREN();
    antlr4::tree::TerminalNode* RIGHT_PAREN(size_t i);
    antlr4::tree::TerminalNode *TO();
    std::vector<antlr4::tree::TerminalNode *> UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode* UNSIGNED_INTEGER(size_t i);
    antlr4::tree::TerminalNode *COMMA();
    NumericContext *numeric();
    antlr4::tree::TerminalNode *DATE();
    antlr4::tree::TerminalNode *NULL_();
    antlr4::tree::TerminalNode *TRUE();
    antlr4::tree::TerminalNode *FALSE();
    antlr4::tree::TerminalNode *DBTIMEZONE();
    antlr4::tree::TerminalNode *SESSIONTIMEZONE();
    antlr4::tree::TerminalNode *MINVALUE();
    antlr4::tree::TerminalNode *MAXVALUE();
    antlr4::tree::TerminalNode *DEFAULT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  ConstantContext* constant();

  class  NumericContext : public antlr4::ParserRuleContext {
  public:
    NumericContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_INTEGER();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *APPROXIMATE_NUM_LIT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  NumericContext* numeric();

  class  Numeric_negativeContext : public antlr4::ParserRuleContext {
  public:
    Numeric_negativeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MINUS_SIGN();
    NumericContext *numeric();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Numeric_negativeContext* numeric_negative();

  class  Quoted_stringContext : public antlr4::ParserRuleContext {
  public:
    Quoted_stringContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CHAR_STRING();
    antlr4::tree::TerminalNode *NATIONAL_CHAR_STRING_LIT();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Quoted_stringContext* quoted_string();

  class  IdentifierContext : public antlr4::ParserRuleContext {
  public:
    IdentifierContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Id_expressionContext *id_expression();
    antlr4::tree::TerminalNode *INTRODUCER();
    Char_set_nameContext *char_set_name();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  IdentifierContext* identifier();

  class  Id_expressionContext : public antlr4::ParserRuleContext {
  public:
    Id_expressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Regular_idContext *regular_id();
    antlr4::tree::TerminalNode *DELIMITED_ID();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Id_expressionContext* id_expression();

  class  Inquiry_directiveContext : public antlr4::ParserRuleContext {
  public:
    Inquiry_directiveContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INQUIRY_DIRECTIVE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Inquiry_directiveContext* inquiry_directive();

  class  Outer_join_signContext : public antlr4::ParserRuleContext {
  public:
    Outer_join_signContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *PLUS_SIGN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Outer_join_signContext* outer_join_sign();

  class  Regular_idContext : public antlr4::ParserRuleContext {
  public:
    Regular_idContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    Non_reserved_keywords_pre12cContext *non_reserved_keywords_pre12c();
    Non_reserved_keywords_in_12cContext *non_reserved_keywords_in_12c();
    Non_reserved_keywords_in_18cContext *non_reserved_keywords_in_18c();
    antlr4::tree::TerminalNode *REGULAR_ID();
    antlr4::tree::TerminalNode *AUDIT();
    antlr4::tree::TerminalNode *ITEMS();
    antlr4::tree::TerminalNode *BYTES();
    antlr4::tree::TerminalNode *LINES();
    antlr4::tree::TerminalNode *RECORDS();
    antlr4::tree::TerminalNode *NEWLINE_();
    antlr4::tree::TerminalNode *FIELD();
    antlr4::tree::TerminalNode *MASK();
    antlr4::tree::TerminalNode *ABSENT();
    antlr4::tree::TerminalNode *A_LETTER();
    antlr4::tree::TerminalNode *AGENT();
    antlr4::tree::TerminalNode *AGGREGATE();
    antlr4::tree::TerminalNode *ANALYZE();
    antlr4::tree::TerminalNode *AUTONOMOUS_TRANSACTION();
    antlr4::tree::TerminalNode *BACKINGFILE();
    antlr4::tree::TerminalNode *BATCH();
    antlr4::tree::TerminalNode *BINARY_INTEGER();
    antlr4::tree::TerminalNode *BOOLEAN();
    antlr4::tree::TerminalNode *C_LETTER();
    antlr4::tree::TerminalNode *CHAR();
    antlr4::tree::TerminalNode *CHARSETID();
    antlr4::tree::TerminalNode *CHARSETFORM();
    antlr4::tree::TerminalNode *CLUSTER();
    antlr4::tree::TerminalNode *CONSTRUCTOR();
    antlr4::tree::TerminalNode *CUSTOMDATUM();
    antlr4::tree::TerminalNode *CASESENSITIVE();
    antlr4::tree::TerminalNode *DECIMAL();
    antlr4::tree::TerminalNode *DELETE();
    antlr4::tree::TerminalNode *DEPRECATE();
    antlr4::tree::TerminalNode *DETERMINISTIC();
    antlr4::tree::TerminalNode *DSINTERVAL_UNCONSTRAINED();
    antlr4::tree::TerminalNode *DURATION();
    antlr4::tree::TerminalNode *E_LETTER();
    antlr4::tree::TerminalNode *ENABLED();
    antlr4::tree::TerminalNode *ERROR_INDEX();
    antlr4::tree::TerminalNode *ERROR_CODE();
    antlr4::tree::TerminalNode *ERR();
    antlr4::tree::TerminalNode *EXCEPTION();
    antlr4::tree::TerminalNode *EXCEPTION_INIT();
    antlr4::tree::TerminalNode *EXCEPTIONS();
    antlr4::tree::TerminalNode *EXISTS();
    antlr4::tree::TerminalNode *EXIT();
    antlr4::tree::TerminalNode *EXTEND();
    antlr4::tree::TerminalNode *FILESTORE();
    antlr4::tree::TerminalNode *FLOAT();
    antlr4::tree::TerminalNode *FORALL();
    antlr4::tree::TerminalNode *G_LETTER();
    antlr4::tree::TerminalNode *INDICES();
    antlr4::tree::TerminalNode *INOUT();
    antlr4::tree::TerminalNode *INTEGER();
    antlr4::tree::TerminalNode *JSON_TRANSFORM();
    antlr4::tree::TerminalNode *K_LETTER();
    antlr4::tree::TerminalNode *LANGUAGE();
    antlr4::tree::TerminalNode *LONG();
    antlr4::tree::TerminalNode *LOOP();
    antlr4::tree::TerminalNode *MAXLEN();
    antlr4::tree::TerminalNode *MOUNTPOINT();
    antlr4::tree::TerminalNode *M_LETTER();
    antlr4::tree::TerminalNode *MISSING();
    antlr4::tree::TerminalNode *MISMATCH();
    antlr4::tree::TerminalNode *NUMBER();
    antlr4::tree::TerminalNode *ORADATA();
    antlr4::tree::TerminalNode *OSERROR();
    antlr4::tree::TerminalNode *OUT();
    antlr4::tree::TerminalNode *OVERRIDING();
    antlr4::tree::TerminalNode *P_LETTER();
    antlr4::tree::TerminalNode *PARALLEL_ENABLE();
    antlr4::tree::TerminalNode *PIPELINED();
    antlr4::tree::TerminalNode *PLS_INTEGER();
    antlr4::tree::TerminalNode *PMEM();
    antlr4::tree::TerminalNode *POSITIVE();
    antlr4::tree::TerminalNode *POSITIVEN();
    antlr4::tree::TerminalNode *PRAGMA();
    antlr4::tree::TerminalNode *PUBLIC();
    antlr4::tree::TerminalNode *RAISE();
    antlr4::tree::TerminalNode *RAW();
    antlr4::tree::TerminalNode *RECORD();
    antlr4::tree::TerminalNode *REF();
    antlr4::tree::TerminalNode *RENAME();
    antlr4::tree::TerminalNode *RESTRICT_REFERENCES();
    antlr4::tree::TerminalNode *RESULT();
    antlr4::tree::TerminalNode *SDO_GEOMETRY();
    antlr4::tree::TerminalNode *SELF();
    antlr4::tree::TerminalNode *SERIALLY_REUSABLE();
    antlr4::tree::TerminalNode *SET();
    antlr4::tree::TerminalNode *SEQ();
    antlr4::tree::TerminalNode *SHARDSPACE();
    antlr4::tree::TerminalNode *SIGNTYPE();
    antlr4::tree::TerminalNode *SIMPLE_INTEGER();
    antlr4::tree::TerminalNode *SMALLINT();
    antlr4::tree::TerminalNode *STRUCT();
    antlr4::tree::TerminalNode *SQLDATA();
    antlr4::tree::TerminalNode *SQLERROR();
    antlr4::tree::TerminalNode *SUBTYPE();
    antlr4::tree::TerminalNode *T_LETTER();
    antlr4::tree::TerminalNode *TDO();
    antlr4::tree::TerminalNode *TIMESTAMP_LTZ_UNCONSTRAINED();
    antlr4::tree::TerminalNode *TIMESTAMP_TZ_UNCONSTRAINED();
    antlr4::tree::TerminalNode *TIMESTAMP_UNCONSTRAINED();
    antlr4::tree::TerminalNode *TIMEZONE();
    antlr4::tree::TerminalNode *TRIGGER();
    antlr4::tree::TerminalNode *UDF();
    antlr4::tree::TerminalNode *VARCHAR();
    antlr4::tree::TerminalNode *VARCHAR2();
    antlr4::tree::TerminalNode *VARIABLE();
    antlr4::tree::TerminalNode *WARNING();
    antlr4::tree::TerminalNode *WHILE();
    antlr4::tree::TerminalNode *WM_CONCAT();
    antlr4::tree::TerminalNode *XMLAGG();
    antlr4::tree::TerminalNode *YMINTERVAL_UNCONSTRAINED();
    antlr4::tree::TerminalNode *REGR_();
    antlr4::tree::TerminalNode *VAR_();
    antlr4::tree::TerminalNode *VALUE();
    antlr4::tree::TerminalNode *COVAR_();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Regular_idContext* regular_id();

  class  Non_reserved_keywords_in_18cContext : public antlr4::ParserRuleContext {
  public:
    Non_reserved_keywords_in_18cContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PERSISTABLE();
    antlr4::tree::TerminalNode *POLYMORPHIC();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Non_reserved_keywords_in_18cContext* non_reserved_keywords_in_18c();

  class  Non_reserved_keywords_in_12cContext : public antlr4::ParserRuleContext {
  public:
    Non_reserved_keywords_in_12cContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ACL();
    antlr4::tree::TerminalNode *ACCESSIBLE();
    antlr4::tree::TerminalNode *ACROSS();
    antlr4::tree::TerminalNode *ACTION();
    antlr4::tree::TerminalNode *ACTIONS();
    antlr4::tree::TerminalNode *ACTIVE();
    antlr4::tree::TerminalNode *ACTIVE_DATA();
    antlr4::tree::TerminalNode *ACTIVITY();
    antlr4::tree::TerminalNode *ADAPTIVE_PLAN();
    antlr4::tree::TerminalNode *ADVANCED();
    antlr4::tree::TerminalNode *AFD_DISKSTRING();
    antlr4::tree::TerminalNode *ALTERNATE();
    antlr4::tree::TerminalNode *ALGORITHM();
    antlr4::tree::TerminalNode *ANALYTIC();
    antlr4::tree::TerminalNode *ANCESTOR();
    antlr4::tree::TerminalNode *ANOMALY();
    antlr4::tree::TerminalNode *ANSI_REARCH();
    antlr4::tree::TerminalNode *APPLICATION();
    antlr4::tree::TerminalNode *APPROX_COUNT_DISTINCT();
    antlr4::tree::TerminalNode *ARCHIVAL();
    antlr4::tree::TerminalNode *ARCHIVED();
    antlr4::tree::TerminalNode *ASIS();
    antlr4::tree::TerminalNode *ASSIGN();
    antlr4::tree::TerminalNode *AUTO_LOGIN();
    antlr4::tree::TerminalNode *AUTO_REOPTIMIZE();
    antlr4::tree::TerminalNode *AVRO();
    antlr4::tree::TerminalNode *BACKGROUND();
    antlr4::tree::TerminalNode *BACKUPS();
    antlr4::tree::TerminalNode *BATCHSIZE();
    antlr4::tree::TerminalNode *BATCH_TABLE_ACCESS_BY_ROWID();
    antlr4::tree::TerminalNode *BEGINNING();
    antlr4::tree::TerminalNode *BEQUEATH();
    antlr4::tree::TerminalNode *BITMAP_AND();
    antlr4::tree::TerminalNode *BLOCKCHAIN();
    antlr4::tree::TerminalNode *BSON();
    antlr4::tree::TerminalNode *CACHING();
    antlr4::tree::TerminalNode *CALCULATED();
    antlr4::tree::TerminalNode *CALLBACK();
    antlr4::tree::TerminalNode *CAPACITY();
    antlr4::tree::TerminalNode *CAPTION();
    antlr4::tree::TerminalNode *CDBDEFAULT();
    antlr4::tree::TerminalNode *CLASSIFICATION();
    antlr4::tree::TerminalNode *CLASSIFIER();
    antlr4::tree::TerminalNode *CLAUSE();
    antlr4::tree::TerminalNode *CLEAN();
    antlr4::tree::TerminalNode *CLEANUP();
    antlr4::tree::TerminalNode *CLIENT();
    antlr4::tree::TerminalNode *CLUSTERING();
    antlr4::tree::TerminalNode *CLUSTER_DETAILS();
    antlr4::tree::TerminalNode *CLUSTER_DISTANCE();
    antlr4::tree::TerminalNode *COLLATE();
    antlr4::tree::TerminalNode *COLLATION();
    antlr4::tree::TerminalNode *COMMON();
    antlr4::tree::TerminalNode *COMMON_DATA();
    antlr4::tree::TerminalNode *COMPONENT();
    antlr4::tree::TerminalNode *COMPONENTS();
    antlr4::tree::TerminalNode *CONDITION();
    antlr4::tree::TerminalNode *CONDITIONAL();
    antlr4::tree::TerminalNode *CONTAINERS();
    antlr4::tree::TerminalNode *CONTAINERS_DEFAULT();
    antlr4::tree::TerminalNode *CONTAINER_DATA();
    antlr4::tree::TerminalNode *CONTAINER_MAP();
    antlr4::tree::TerminalNode *CONVERSION();
    antlr4::tree::TerminalNode *CON_DBID_TO_ID();
    antlr4::tree::TerminalNode *CON_GUID_TO_ID();
    antlr4::tree::TerminalNode *CON_ID();
    antlr4::tree::TerminalNode *CON_NAME_TO_ID();
    antlr4::tree::TerminalNode *CON_UID_TO_ID();
    antlr4::tree::TerminalNode *COOKIE();
    antlr4::tree::TerminalNode *COPY();
    antlr4::tree::TerminalNode *CREATE_FILE_DEST();
    antlr4::tree::TerminalNode *CREDENTIAL();
    antlr4::tree::TerminalNode *CRITICAL();
    antlr4::tree::TerminalNode *CUBE_AJ();
    antlr4::tree::TerminalNode *CUBE_SJ();
    antlr4::tree::TerminalNode *DATAMOVEMENT();
    antlr4::tree::TerminalNode *DATAOBJ_TO_MAT_PARTITION();
    antlr4::tree::TerminalNode *DATAPUMP();
    antlr4::tree::TerminalNode *DATA_SECURITY_REWRITE_LIMIT();
    antlr4::tree::TerminalNode *DAYS();
    antlr4::tree::TerminalNode *DB_UNIQUE_NAME();
    antlr4::tree::TerminalNode *DECORRELATE();
    antlr4::tree::TerminalNode *DEFAULT_CREDENTIAL();
    antlr4::tree::TerminalNode *DEFAULT_COLLATION();
    antlr4::tree::TerminalNode *DEFINE();
    antlr4::tree::TerminalNode *DEFINITION();
    antlr4::tree::TerminalNode *DELEGATE();
    antlr4::tree::TerminalNode *DELETE_ALL();
    antlr4::tree::TerminalNode *DESCRIPTION();
    antlr4::tree::TerminalNode *DESTROY();
    antlr4::tree::TerminalNode *DIMENSIONS();
    antlr4::tree::TerminalNode *DISABLE_ALL();
    antlr4::tree::TerminalNode *DISABLE_PARALLEL_DML();
    antlr4::tree::TerminalNode *DISCARD();
    antlr4::tree::TerminalNode *DISTRIBUTE();
    antlr4::tree::TerminalNode *DUPLICATE();
    antlr4::tree::TerminalNode *DUPLICATED();
    antlr4::tree::TerminalNode *DV();
    antlr4::tree::TerminalNode *EDITIONABLE();
    antlr4::tree::TerminalNode *ELIM_GROUPBY();
    antlr4::tree::TerminalNode *EM();
    antlr4::tree::TerminalNode *ENABLE_ALL();
    antlr4::tree::TerminalNode *ENABLE_PARALLEL_DML();
    antlr4::tree::TerminalNode *EQUIPART();
    antlr4::tree::TerminalNode *EVAL();
    antlr4::tree::TerminalNode *EVALUATE();
    antlr4::tree::TerminalNode *EXISTING();
    antlr4::tree::TerminalNode *EXPRESS();
    antlr4::tree::TerminalNode *EXTENDED();
    antlr4::tree::TerminalNode *EXTRACTCLOBXML();
    antlr4::tree::TerminalNode *FACTOR();
    antlr4::tree::TerminalNode *FAILOVER();
    antlr4::tree::TerminalNode *FAILURE();
    antlr4::tree::TerminalNode *FAMILY();
    antlr4::tree::TerminalNode *FAR();
    antlr4::tree::TerminalNode *FASTSTART();
    antlr4::tree::TerminalNode *FEATURE();
    antlr4::tree::TerminalNode *FEATURE_DETAILS();
    antlr4::tree::TerminalNode *FETCH();
    antlr4::tree::TerminalNode *FILE_NAME_CONVERT();
    antlr4::tree::TerminalNode *FILEGROUP();
    antlr4::tree::TerminalNode *FIXED_VIEW_DATA();
    antlr4::tree::TerminalNode *FLEX();
    antlr4::tree::TerminalNode *FORMAT();
    antlr4::tree::TerminalNode *FTP();
    antlr4::tree::TerminalNode *GATHER_OPTIMIZER_STATISTICS();
    antlr4::tree::TerminalNode *GET();
    antlr4::tree::TerminalNode *HALF_YEARS();
    antlr4::tree::TerminalNode *HASHING();
    antlr4::tree::TerminalNode *HIER_ORDER();
    antlr4::tree::TerminalNode *HIERARCHICAL();
    antlr4::tree::TerminalNode *HOURS();
    antlr4::tree::TerminalNode *HTTP();
    antlr4::tree::TerminalNode *H_LETTER();
    antlr4::tree::TerminalNode *IDLE();
    antlr4::tree::TerminalNode *ILM();
    antlr4::tree::TerminalNode *IMMUTABLE();
    antlr4::tree::TerminalNode *INACTIVE();
    antlr4::tree::TerminalNode *INACTIVE_ACCOUNT_TIME();
    antlr4::tree::TerminalNode *INDEXING();
    antlr4::tree::TerminalNode *INHERIT();
    antlr4::tree::TerminalNode *INMEMORY();
    antlr4::tree::TerminalNode *INMEMORY_PRUNING();
    antlr4::tree::TerminalNode *INPLACE();
    antlr4::tree::TerminalNode *INTERLEAVED();
    antlr4::tree::TerminalNode *INVALIDATION();
    antlr4::tree::TerminalNode *ISOLATE();
    antlr4::tree::TerminalNode *IS_LEAF();
    antlr4::tree::TerminalNode *JSON();
    antlr4::tree::TerminalNode *JSONGET();
    antlr4::tree::TerminalNode *JSONPARSE();
    antlr4::tree::TerminalNode *JSON_ARRAY();
    antlr4::tree::TerminalNode *JSON_ARRAYAGG();
    antlr4::tree::TerminalNode *JSON_EQUAL();
    antlr4::tree::TerminalNode *JSON_EXISTS();
    antlr4::tree::TerminalNode *JSON_EXISTS2();
    antlr4::tree::TerminalNode *JSON_OBJECT();
    antlr4::tree::TerminalNode *JSON_OBJECTAGG();
    antlr4::tree::TerminalNode *JSON_QUERY();
    antlr4::tree::TerminalNode *JSON_SERIALIZE();
    antlr4::tree::TerminalNode *JSON_TABLE();
    antlr4::tree::TerminalNode *JSON_TEXTCONTAINS();
    antlr4::tree::TerminalNode *JSON_TEXTCONTAINS2();
    antlr4::tree::TerminalNode *JSON_VALUE();
    antlr4::tree::TerminalNode *KEYSTORE();
    antlr4::tree::TerminalNode *LABEL();
    antlr4::tree::TerminalNode *LAX();
    antlr4::tree::TerminalNode *LEAD_CDB();
    antlr4::tree::TerminalNode *LEAD_CDB_URI();
    antlr4::tree::TerminalNode *LEVEL_NAME();
    antlr4::tree::TerminalNode *LIFECYCLE();
    antlr4::tree::TerminalNode *LINEAR();
    antlr4::tree::TerminalNode *LOCKDOWN();
    antlr4::tree::TerminalNode *LOCKING();
    antlr4::tree::TerminalNode *LOGMINING();
    antlr4::tree::TerminalNode *LOST();
    antlr4::tree::TerminalNode *MANDATORY();
    antlr4::tree::TerminalNode *MAP();
    antlr4::tree::TerminalNode *MATCH();
    antlr4::tree::TerminalNode *MATCHES();
    antlr4::tree::TerminalNode *MATCH_NUMBER();
    antlr4::tree::TerminalNode *MATCH_RECOGNIZE();
    antlr4::tree::TerminalNode *MAX_SHARED_TEMP_SIZE();
    antlr4::tree::TerminalNode *MEMCOMPRESS();
    antlr4::tree::TerminalNode *METADATA();
    antlr4::tree::TerminalNode *MEMBER_CAPTION();
    antlr4::tree::TerminalNode *MEMBER_DESCRIPTION();
    antlr4::tree::TerminalNode *MEMBER_NAME();
    antlr4::tree::TerminalNode *MEMBER_UNIQUE_NAME();
    antlr4::tree::TerminalNode *MEMOPTIMIZE();
    antlr4::tree::TerminalNode *MINUTES();
    antlr4::tree::TerminalNode *MODEL_NB();
    antlr4::tree::TerminalNode *MODEL_SV();
    antlr4::tree::TerminalNode *MODIFICATION();
    antlr4::tree::TerminalNode *MODULE();
    antlr4::tree::TerminalNode *MONTHS();
    antlr4::tree::TerminalNode *MULTIDIMENSIONAL();
    antlr4::tree::TerminalNode *NEG();
    antlr4::tree::TerminalNode *NOCOPY();
    antlr4::tree::TerminalNode *NOKEEP();
    antlr4::tree::TerminalNode *NONEDITIONABLE();
    antlr4::tree::TerminalNode *NOPARTITION();
    antlr4::tree::TerminalNode *NORELOCATE();
    antlr4::tree::TerminalNode *NOREPLAY();
    antlr4::tree::TerminalNode *NO_ADAPTIVE_PLAN();
    antlr4::tree::TerminalNode *NO_ANSI_REARCH();
    antlr4::tree::TerminalNode *NO_AUTO_REOPTIMIZE();
    antlr4::tree::TerminalNode *NO_BATCH_TABLE_ACCESS_BY_ROWID();
    antlr4::tree::TerminalNode *NO_CLUSTERING();
    antlr4::tree::TerminalNode *NO_COMMON_DATA();
    antlr4::tree::TerminalNode *NO_DATA_SECURITY_REWRITE();
    antlr4::tree::TerminalNode *NO_DECORRELATE();
    antlr4::tree::TerminalNode *NO_ELIM_GROUPBY();
    antlr4::tree::TerminalNode *NO_GATHER_OPTIMIZER_STATISTICS();
    antlr4::tree::TerminalNode *NO_INMEMORY();
    antlr4::tree::TerminalNode *NO_INMEMORY_PRUNING();
    antlr4::tree::TerminalNode *NO_OBJECT_LINK();
    antlr4::tree::TerminalNode *NO_PARTIAL_JOIN();
    antlr4::tree::TerminalNode *NO_PARTIAL_ROLLUP_PUSHDOWN();
    antlr4::tree::TerminalNode *NO_PQ_CONCURRENT_UNION();
    antlr4::tree::TerminalNode *NO_PQ_REPLICATE();
    antlr4::tree::TerminalNode *NO_PQ_SKEW();
    antlr4::tree::TerminalNode *NOPROMPT();
    antlr4::tree::TerminalNode *NO_PX_FAULT_TOLERANCE();
    antlr4::tree::TerminalNode *NO_ROOT_SW_FOR_LOCAL();
    antlr4::tree::TerminalNode *NO_SQL_TRANSLATION();
    antlr4::tree::TerminalNode *NO_USE_CUBE();
    antlr4::tree::TerminalNode *NO_USE_VECTOR_AGGREGATION();
    antlr4::tree::TerminalNode *NO_VECTOR_TRANSFORM();
    antlr4::tree::TerminalNode *NO_VECTOR_TRANSFORM_DIMS();
    antlr4::tree::TerminalNode *NO_VECTOR_TRANSFORM_FACT();
    antlr4::tree::TerminalNode *NO_ZONEMAP();
    antlr4::tree::TerminalNode *OBJ_ID();
    antlr4::tree::TerminalNode *OFFSET();
    antlr4::tree::TerminalNode *OLS();
    antlr4::tree::TerminalNode *OMIT();
    antlr4::tree::TerminalNode *ONE();
    antlr4::tree::TerminalNode *ORACLE_DATAPUMP();
    antlr4::tree::TerminalNode *ORACLE_HDFS();
    antlr4::tree::TerminalNode *ORACLE_HIVE();
    antlr4::tree::TerminalNode *ORACLE_LOADER();
    antlr4::tree::TerminalNode *ORA_CHECK_ACL();
    antlr4::tree::TerminalNode *ORA_CHECK_PRIVILEGE();
    antlr4::tree::TerminalNode *ORA_CLUSTERING();
    antlr4::tree::TerminalNode *ORA_INVOKING_USER();
    antlr4::tree::TerminalNode *ORA_INVOKING_USERID();
    antlr4::tree::TerminalNode *ORA_INVOKING_XS_USER();
    antlr4::tree::TerminalNode *ORA_INVOKING_XS_USER_GUID();
    antlr4::tree::TerminalNode *ORA_RAWCOMPARE();
    antlr4::tree::TerminalNode *ORA_RAWCONCAT();
    antlr4::tree::TerminalNode *ORA_WRITE_TIME();
    antlr4::tree::TerminalNode *PARENT_LEVEL_NAME();
    antlr4::tree::TerminalNode *PARENT_UNIQUE_NAME();
    antlr4::tree::TerminalNode *PASSWORD_ROLLOVER_TIME();
    antlr4::tree::TerminalNode *PARTIAL();
    antlr4::tree::TerminalNode *PARTIAL_JOIN();
    antlr4::tree::TerminalNode *PARTIAL_ROLLUP_PUSHDOWN();
    antlr4::tree::TerminalNode *PAST();
    antlr4::tree::TerminalNode *PATCH();
    antlr4::tree::TerminalNode *PATH_PREFIX();
    antlr4::tree::TerminalNode *PATTERN();
    antlr4::tree::TerminalNode *PER();
    antlr4::tree::TerminalNode *PERIOD();
    antlr4::tree::TerminalNode *PERIOD_KEYWORD();
    antlr4::tree::TerminalNode *PERMUTE();
    antlr4::tree::TerminalNode *PLUGGABLE();
    antlr4::tree::TerminalNode *POOL_16K();
    antlr4::tree::TerminalNode *POOL_2K();
    antlr4::tree::TerminalNode *POOL_32K();
    antlr4::tree::TerminalNode *POOL_4K();
    antlr4::tree::TerminalNode *POOL_8K();
    antlr4::tree::TerminalNode *PQ_CONCURRENT_UNION();
    antlr4::tree::TerminalNode *PQ_DISTRIBUTE_WINDOW();
    antlr4::tree::TerminalNode *PQ_FILTER();
    antlr4::tree::TerminalNode *PQ_REPLICATE();
    antlr4::tree::TerminalNode *PQ_SKEW();
    antlr4::tree::TerminalNode *PRELOAD();
    antlr4::tree::TerminalNode *PRETTY();
    antlr4::tree::TerminalNode *PREV();
    antlr4::tree::TerminalNode *PRINTBLOBTOCLOB();
    antlr4::tree::TerminalNode *PRIORITY();
    antlr4::tree::TerminalNode *PRIVILEGED();
    antlr4::tree::TerminalNode *PROPERTY();
    antlr4::tree::TerminalNode *PROTOCOL();
    antlr4::tree::TerminalNode *PROXY();
    antlr4::tree::TerminalNode *PRUNING();
    antlr4::tree::TerminalNode *PX_FAULT_TOLERANCE();
    antlr4::tree::TerminalNode *QUARTERS();
    antlr4::tree::TerminalNode *QUOTAGROUP();
    antlr4::tree::TerminalNode *REALM();
    antlr4::tree::TerminalNode *REDEFINE();
    antlr4::tree::TerminalNode *RELOCATE();
    antlr4::tree::TerminalNode *REMOTE();
    antlr4::tree::TerminalNode *RESTART();
    antlr4::tree::TerminalNode *ROLESET();
    antlr4::tree::TerminalNode *ROWID_MAPPING_TABLE();
    antlr4::tree::TerminalNode *RUNNING();
    antlr4::tree::TerminalNode *SAVE();
    antlr4::tree::TerminalNode *SCRUB();
    antlr4::tree::TerminalNode *SDO_GEOM_MBR();
    antlr4::tree::TerminalNode *SECONDS();
    antlr4::tree::TerminalNode *SECRET();
    antlr4::tree::TerminalNode *SERIAL();
    antlr4::tree::TerminalNode *SERVICES();
    antlr4::tree::TerminalNode *SERVICE_NAME_CONVERT();
    antlr4::tree::TerminalNode *SHARDED();
    antlr4::tree::TerminalNode *SHARING();
    antlr4::tree::TerminalNode *SHELFLIFE();
    antlr4::tree::TerminalNode *SITE();
    antlr4::tree::TerminalNode *SOURCE_FILE_DIRECTORY();
    antlr4::tree::TerminalNode *SOURCE_FILE_NAME_CONVERT();
    antlr4::tree::TerminalNode *SQL_TRANSLATION_PROFILE();
    antlr4::tree::TerminalNode *STANDARD();
    antlr4::tree::TerminalNode *STANDARD_HASH();
    antlr4::tree::TerminalNode *STANDBYS();
    antlr4::tree::TerminalNode *STATE();
    antlr4::tree::TerminalNode *STATEMENT();
    antlr4::tree::TerminalNode *STREAM();
    antlr4::tree::TerminalNode *SUBSCRIBE();
    antlr4::tree::TerminalNode *SUBSET();
    antlr4::tree::TerminalNode *SUCCESS();
    antlr4::tree::TerminalNode *SYS();
    antlr4::tree::TerminalNode *SYSBACKUP();
    antlr4::tree::TerminalNode *SYSDG();
    antlr4::tree::TerminalNode *SYSGUID();
    antlr4::tree::TerminalNode *SYSKM();
    antlr4::tree::TerminalNode *SYSOBJ();
    antlr4::tree::TerminalNode *SYS_CHECK_PRIVILEGE();
    antlr4::tree::TerminalNode *SYS_GET_COL_ACLIDS();
    antlr4::tree::TerminalNode *SYS_MKXTI();
    antlr4::tree::TerminalNode *SYS_OP_CYCLED_SEQ();
    antlr4::tree::TerminalNode *SYS_OP_HASH();
    antlr4::tree::TerminalNode *SYS_OP_KEY_VECTOR_CREATE();
    antlr4::tree::TerminalNode *SYS_OP_KEY_VECTOR_FILTER();
    antlr4::tree::TerminalNode *SYS_OP_KEY_VECTOR_FILTER_LIST();
    antlr4::tree::TerminalNode *SYS_OP_KEY_VECTOR_SUCCEEDED();
    antlr4::tree::TerminalNode *SYS_OP_KEY_VECTOR_USE();
    antlr4::tree::TerminalNode *SYS_OP_PART_ID();
    antlr4::tree::TerminalNode *SYS_OP_ZONE_ID();
    antlr4::tree::TerminalNode *SYS_RAW_TO_XSID();
    antlr4::tree::TerminalNode *SYS_XSID_TO_RAW();
    antlr4::tree::TerminalNode *SYS_ZMAP_FILTER();
    antlr4::tree::TerminalNode *SYS_ZMAP_REFRESH();
    antlr4::tree::TerminalNode *TAG();
    antlr4::tree::TerminalNode *TEXT();
    antlr4::tree::TerminalNode *TIER();
    antlr4::tree::TerminalNode *TIES();
    antlr4::tree::TerminalNode *TO_ACLID();
    antlr4::tree::TerminalNode *TRANSFORM();
    antlr4::tree::TerminalNode *TRANSLATION();
    antlr4::tree::TerminalNode *TRUST();
    antlr4::tree::TerminalNode *UCS2();
    antlr4::tree::TerminalNode *UNCONDITIONAL();
    antlr4::tree::TerminalNode *UNITE();
    antlr4::tree::TerminalNode *UNMATCHED();
    antlr4::tree::TerminalNode *UNPLUG();
    antlr4::tree::TerminalNode *UNSUBSCRIBE();
    antlr4::tree::TerminalNode *USABLE();
    antlr4::tree::TerminalNode *USER_DATA();
    antlr4::tree::TerminalNode *USER_TABLESPACES();
    antlr4::tree::TerminalNode *USE_CUBE();
    antlr4::tree::TerminalNode *USE_HIDDEN_PARTITIONS();
    antlr4::tree::TerminalNode *USE_VECTOR_AGGREGATION();
    antlr4::tree::TerminalNode *USING_NO_EXPAND();
    antlr4::tree::TerminalNode *USING_NLS_COMP();
    antlr4::tree::TerminalNode *UTF16BE();
    antlr4::tree::TerminalNode *UTF16LE();
    antlr4::tree::TerminalNode *UTF32();
    antlr4::tree::TerminalNode *UTF8();
    antlr4::tree::TerminalNode *V1();
    antlr4::tree::TerminalNode *V2();
    antlr4::tree::TerminalNode *VALIDATE_CONVERSION();
    antlr4::tree::TerminalNode *VALID_TIME_END();
    antlr4::tree::TerminalNode *VECTOR_TRANSFORM();
    antlr4::tree::TerminalNode *VECTOR_TRANSFORM_DIMS();
    antlr4::tree::TerminalNode *VECTOR_TRANSFORM_FACT();
    antlr4::tree::TerminalNode *VERIFIER();
    antlr4::tree::TerminalNode *VIOLATION();
    antlr4::tree::TerminalNode *VISIBILITY();
    antlr4::tree::TerminalNode *WEEK();
    antlr4::tree::TerminalNode *WEEKS();
    antlr4::tree::TerminalNode *WITH_PLSQL();
    antlr4::tree::TerminalNode *WRAPPER();
    antlr4::tree::TerminalNode *XS();
    antlr4::tree::TerminalNode *YEARS();
    antlr4::tree::TerminalNode *ZONEMAP();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Non_reserved_keywords_in_12cContext* non_reserved_keywords_in_12c();

  class  Non_reserved_keywords_pre12cContext : public antlr4::ParserRuleContext {
  public:
    Non_reserved_keywords_pre12cContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ABORT();
    antlr4::tree::TerminalNode *ABS();
    antlr4::tree::TerminalNode *ACCESSED();
    antlr4::tree::TerminalNode *ACCESS();
    antlr4::tree::TerminalNode *ACCOUNT();
    antlr4::tree::TerminalNode *ACOS();
    antlr4::tree::TerminalNode *ACTIVATE();
    antlr4::tree::TerminalNode *ACTIVE_COMPONENT();
    antlr4::tree::TerminalNode *ACTIVE_FUNCTION();
    antlr4::tree::TerminalNode *ACTIVE_TAG();
    antlr4::tree::TerminalNode *ADD_COLUMN();
    antlr4::tree::TerminalNode *ADD_GROUP();
    antlr4::tree::TerminalNode *ADD_MONTHS();
    antlr4::tree::TerminalNode *ADD();
    antlr4::tree::TerminalNode *ADJ_DATE();
    antlr4::tree::TerminalNode *ADMINISTER();
    antlr4::tree::TerminalNode *ADMINISTRATOR();
    antlr4::tree::TerminalNode *ADMIN();
    antlr4::tree::TerminalNode *ADVISE();
    antlr4::tree::TerminalNode *ADVISOR();
    antlr4::tree::TerminalNode *AFTER();
    antlr4::tree::TerminalNode *ALIAS();
    antlr4::tree::TerminalNode *ALLOCATE();
    antlr4::tree::TerminalNode *ALLOW();
    antlr4::tree::TerminalNode *ALL_ROWS();
    antlr4::tree::TerminalNode *ALWAYS();
    antlr4::tree::TerminalNode *ANALYZE();
    antlr4::tree::TerminalNode *ANCILLARY();
    antlr4::tree::TerminalNode *AND_EQUAL();
    antlr4::tree::TerminalNode *ANTIJOIN();
    antlr4::tree::TerminalNode *ANYSCHEMA();
    antlr4::tree::TerminalNode *APPENDCHILDXML();
    antlr4::tree::TerminalNode *APPEND();
    antlr4::tree::TerminalNode *APPEND_VALUES();
    antlr4::tree::TerminalNode *APPLY();
    antlr4::tree::TerminalNode *ARCHIVELOG();
    antlr4::tree::TerminalNode *ARCHIVE();
    antlr4::tree::TerminalNode *ARRAY();
    antlr4::tree::TerminalNode *ASCII();
    antlr4::tree::TerminalNode *ASCIISTR();
    antlr4::tree::TerminalNode *ASIN();
    antlr4::tree::TerminalNode *ASSEMBLY();
    antlr4::tree::TerminalNode *ASSOCIATE();
    antlr4::tree::TerminalNode *ASYNCHRONOUS();
    antlr4::tree::TerminalNode *ASYNC();
    antlr4::tree::TerminalNode *ATAN2();
    antlr4::tree::TerminalNode *ATAN();
    antlr4::tree::TerminalNode *AT();
    antlr4::tree::TerminalNode *ATTRIBUTE();
    antlr4::tree::TerminalNode *ATTRIBUTES();
    antlr4::tree::TerminalNode *AUTHENTICATED();
    antlr4::tree::TerminalNode *AUTHENTICATION();
    antlr4::tree::TerminalNode *AUTHID();
    antlr4::tree::TerminalNode *AUTHORIZATION();
    antlr4::tree::TerminalNode *AUTOALLOCATE();
    antlr4::tree::TerminalNode *AUTOEXTEND();
    antlr4::tree::TerminalNode *AUTOMATIC();
    antlr4::tree::TerminalNode *AUTO();
    antlr4::tree::TerminalNode *AVAILABILITY();
    antlr4::tree::TerminalNode *AVG();
    antlr4::tree::TerminalNode *BACKUP();
    antlr4::tree::TerminalNode *BASICFILE();
    antlr4::tree::TerminalNode *BASIC();
    antlr4::tree::TerminalNode *BATCH();
    antlr4::tree::TerminalNode *BECOME();
    antlr4::tree::TerminalNode *BEFORE();
    antlr4::tree::TerminalNode *BEGIN();
    antlr4::tree::TerminalNode *BEGIN_OUTLINE_DATA();
    antlr4::tree::TerminalNode *BEHALF();
    antlr4::tree::TerminalNode *BFILE();
    antlr4::tree::TerminalNode *BFILENAME();
    antlr4::tree::TerminalNode *BIGFILE();
    antlr4::tree::TerminalNode *BINARY_DOUBLE_INFINITY();
    antlr4::tree::TerminalNode *BINARY_DOUBLE();
    antlr4::tree::TerminalNode *BINARY_DOUBLE_NAN();
    antlr4::tree::TerminalNode *BINARY_FLOAT_INFINITY();
    antlr4::tree::TerminalNode *BINARY_FLOAT();
    antlr4::tree::TerminalNode *BINARY_FLOAT_NAN();
    antlr4::tree::TerminalNode *BINARY();
    antlr4::tree::TerminalNode *BIND_AWARE();
    antlr4::tree::TerminalNode *BINDING();
    antlr4::tree::TerminalNode *BIN_TO_NUM();
    antlr4::tree::TerminalNode *BITAND();
    antlr4::tree::TerminalNode *BITMAP();
    antlr4::tree::TerminalNode *BITMAPS();
    antlr4::tree::TerminalNode *BITMAP_TREE();
    antlr4::tree::TerminalNode *BITS();
    antlr4::tree::TerminalNode *BLOB();
    antlr4::tree::TerminalNode *BLOCK();
    antlr4::tree::TerminalNode *BLOCK_RANGE();
    antlr4::tree::TerminalNode *BLOCKSIZE();
    antlr4::tree::TerminalNode *BLOCKS();
    antlr4::tree::TerminalNode *BODY();
    antlr4::tree::TerminalNode *BOTH();
    antlr4::tree::TerminalNode *BOUND();
    antlr4::tree::TerminalNode *BRANCH();
    antlr4::tree::TerminalNode *BREADTH();
    antlr4::tree::TerminalNode *BROADCAST();
    antlr4::tree::TerminalNode *BUFFER_CACHE();
    antlr4::tree::TerminalNode *BUFFER();
    antlr4::tree::TerminalNode *BUFFER_POOL();
    antlr4::tree::TerminalNode *BUILD();
    antlr4::tree::TerminalNode *BULK();
    antlr4::tree::TerminalNode *BYPASS_RECURSIVE_CHECK();
    antlr4::tree::TerminalNode *BYPASS_UJVC();
    antlr4::tree::TerminalNode *BYTE();
    antlr4::tree::TerminalNode *CACHE_CB();
    antlr4::tree::TerminalNode *CACHE_INSTANCES();
    antlr4::tree::TerminalNode *CACHE();
    antlr4::tree::TerminalNode *CACHE_TEMP_TABLE();
    antlr4::tree::TerminalNode *CALL();
    antlr4::tree::TerminalNode *CANCEL();
    antlr4::tree::TerminalNode *CARDINALITY();
    antlr4::tree::TerminalNode *CASCADE();
    antlr4::tree::TerminalNode *CASE();
    antlr4::tree::TerminalNode *CAST();
    antlr4::tree::TerminalNode *CATEGORY();
    antlr4::tree::TerminalNode *CEIL();
    antlr4::tree::TerminalNode *CELL_FLASH_CACHE();
    antlr4::tree::TerminalNode *CERTIFICATE();
    antlr4::tree::TerminalNode *CFILE();
    antlr4::tree::TerminalNode *CHAINED();
    antlr4::tree::TerminalNode *CHANGE_DUPKEY_ERROR_INDEX();
    antlr4::tree::TerminalNode *CHANGE();
    antlr4::tree::TerminalNode *CHARACTER();
    antlr4::tree::TerminalNode *CHAR_CS();
    antlr4::tree::TerminalNode *CHARTOROWID();
    antlr4::tree::TerminalNode *CHECK_ACL_REWRITE();
    antlr4::tree::TerminalNode *CHECKPOINT();
    antlr4::tree::TerminalNode *CHILD();
    antlr4::tree::TerminalNode *CHOOSE();
    antlr4::tree::TerminalNode *CHR();
    antlr4::tree::TerminalNode *CHUNK();
    antlr4::tree::TerminalNode *CLASS();
    antlr4::tree::TerminalNode *CLEAR();
    antlr4::tree::TerminalNode *CLOB();
    antlr4::tree::TerminalNode *CLONE();
    antlr4::tree::TerminalNode *CLOSE_CACHED_OPEN_CURSORS();
    antlr4::tree::TerminalNode *CLOSE();
    antlr4::tree::TerminalNode *CLUSTER_BY_ROWID();
    antlr4::tree::TerminalNode *CLUSTER_ID();
    antlr4::tree::TerminalNode *CLUSTERING_FACTOR();
    antlr4::tree::TerminalNode *CLUSTER_PROBABILITY();
    antlr4::tree::TerminalNode *CLUSTER_SET();
    antlr4::tree::TerminalNode *COALESCE();
    antlr4::tree::TerminalNode *COALESCE_SQ();
    antlr4::tree::TerminalNode *COARSE();
    antlr4::tree::TerminalNode *CO_AUTH_IND();
    antlr4::tree::TerminalNode *COLD();
    antlr4::tree::TerminalNode *COLLECT();
    antlr4::tree::TerminalNode *COLUMNAR();
    antlr4::tree::TerminalNode *COLUMN_AUTH_INDICATOR();
    antlr4::tree::TerminalNode *COLUMN();
    antlr4::tree::TerminalNode *COLUMNS();
    antlr4::tree::TerminalNode *COLUMN_STATS();
    antlr4::tree::TerminalNode *COLUMN_VALUE();
    antlr4::tree::TerminalNode *COMMENT();
    antlr4::tree::TerminalNode *COMMIT();
    antlr4::tree::TerminalNode *COMMITTED();
    antlr4::tree::TerminalNode *COMPACT();
    antlr4::tree::TerminalNode *COMPATIBILITY();
    antlr4::tree::TerminalNode *COMPILE();
    antlr4::tree::TerminalNode *COMPLETE();
    antlr4::tree::TerminalNode *COMPLIANCE();
    antlr4::tree::TerminalNode *COMPOSE();
    antlr4::tree::TerminalNode *COMPOSITE_LIMIT();
    antlr4::tree::TerminalNode *COMPOSITE();
    antlr4::tree::TerminalNode *COMPOUND();
    antlr4::tree::TerminalNode *COMPUTE();
    antlr4::tree::TerminalNode *CONCAT();
    antlr4::tree::TerminalNode *CONFIRM();
    antlr4::tree::TerminalNode *CONFORMING();
    antlr4::tree::TerminalNode *CONNECT_BY_CB_WHR_ONLY();
    antlr4::tree::TerminalNode *CONNECT_BY_COMBINE_SW();
    antlr4::tree::TerminalNode *CONNECT_BY_COST_BASED();
    antlr4::tree::TerminalNode *CONNECT_BY_ELIM_DUPS();
    antlr4::tree::TerminalNode *CONNECT_BY_FILTERING();
    antlr4::tree::TerminalNode *CONNECT_BY_ISCYCLE();
    antlr4::tree::TerminalNode *CONNECT_BY_ISLEAF();
    antlr4::tree::TerminalNode *CONNECT_BY_ROOT();
    antlr4::tree::TerminalNode *CONNECT_TIME();
    antlr4::tree::TerminalNode *CONSIDER();
    antlr4::tree::TerminalNode *CONSISTENT();
    antlr4::tree::TerminalNode *CONSTANT();
    antlr4::tree::TerminalNode *CONST();
    antlr4::tree::TerminalNode *CONSTRAINT();
    antlr4::tree::TerminalNode *CONSTRAINTS();
    antlr4::tree::TerminalNode *CONTAINER();
    antlr4::tree::TerminalNode *CONTENT();
    antlr4::tree::TerminalNode *CONTENTS();
    antlr4::tree::TerminalNode *CONTEXT();
    antlr4::tree::TerminalNode *CONTINUE();
    antlr4::tree::TerminalNode *CONTROLFILE();
    antlr4::tree::TerminalNode *CONVERT();
    antlr4::tree::TerminalNode *CORR_K();
    antlr4::tree::TerminalNode *CORR();
    antlr4::tree::TerminalNode *CORR_S();
    antlr4::tree::TerminalNode *CORRUPTION();
    antlr4::tree::TerminalNode *CORRUPT_XID_ALL();
    antlr4::tree::TerminalNode *CORRUPT_XID();
    antlr4::tree::TerminalNode *COSH();
    antlr4::tree::TerminalNode *COS();
    antlr4::tree::TerminalNode *COST();
    antlr4::tree::TerminalNode *COST_XML_QUERY_REWRITE();
    antlr4::tree::TerminalNode *COUNT();
    antlr4::tree::TerminalNode *COVAR_POP();
    antlr4::tree::TerminalNode *COVAR_SAMP();
    antlr4::tree::TerminalNode *CPU_COSTING();
    antlr4::tree::TerminalNode *CPU_PER_CALL();
    antlr4::tree::TerminalNode *CPU_PER_SESSION();
    antlr4::tree::TerminalNode *CRASH();
    antlr4::tree::TerminalNode *CREATE_STORED_OUTLINES();
    antlr4::tree::TerminalNode *CREATION();
    antlr4::tree::TerminalNode *CROSSEDITION();
    antlr4::tree::TerminalNode *CROSS();
    antlr4::tree::TerminalNode *CSCONVERT();
    antlr4::tree::TerminalNode *CUBE_GB();
    antlr4::tree::TerminalNode *CUBE();
    antlr4::tree::TerminalNode *CUME_DISTM();
    antlr4::tree::TerminalNode *CUME_DIST();
    antlr4::tree::TerminalNode *CURRENT_DATE();
    antlr4::tree::TerminalNode *CURRENT();
    antlr4::tree::TerminalNode *CURRENT_SCHEMA();
    antlr4::tree::TerminalNode *CURRENT_TIME();
    antlr4::tree::TerminalNode *CURRENT_TIMESTAMP();
    antlr4::tree::TerminalNode *CURRENT_USER();
    antlr4::tree::TerminalNode *CURRENTV();
    antlr4::tree::TerminalNode *CURSOR();
    antlr4::tree::TerminalNode *CURSOR_SHARING_EXACT();
    antlr4::tree::TerminalNode *CURSOR_SPECIFIC_SEGMENT();
    antlr4::tree::TerminalNode *CV();
    antlr4::tree::TerminalNode *CYCLE();
    antlr4::tree::TerminalNode *DANGLING();
    antlr4::tree::TerminalNode *DATABASE();
    antlr4::tree::TerminalNode *DATAFILE();
    antlr4::tree::TerminalNode *DATAFILES();
    antlr4::tree::TerminalNode *DATA();
    antlr4::tree::TerminalNode *DATAOBJNO();
    antlr4::tree::TerminalNode *DATAOBJ_TO_PARTITION();
    antlr4::tree::TerminalNode *DATE_MODE();
    antlr4::tree::TerminalNode *DAY();
    antlr4::tree::TerminalNode *DBA();
    antlr4::tree::TerminalNode *DBA_RECYCLEBIN();
    antlr4::tree::TerminalNode *DBLINK();
    antlr4::tree::TerminalNode *DBMS_STATS();
    antlr4::tree::TerminalNode *DB_ROLE_CHANGE();
    antlr4::tree::TerminalNode *DBTIMEZONE();
    antlr4::tree::TerminalNode *DB_VERSION();
    antlr4::tree::TerminalNode *DDL();
    antlr4::tree::TerminalNode *DEALLOCATE();
    antlr4::tree::TerminalNode *DEBUGGER();
    antlr4::tree::TerminalNode *DEBUG();
    antlr4::tree::TerminalNode *DECLARE();
    antlr4::tree::TerminalNode *DEC();
    antlr4::tree::TerminalNode *DECOMPOSE();
    antlr4::tree::TerminalNode *DECREMENT();
    antlr4::tree::TerminalNode *DECR();
    antlr4::tree::TerminalNode *DECRYPT();
    antlr4::tree::TerminalNode *DEDUPLICATE();
    antlr4::tree::TerminalNode *DEFAULTS();
    antlr4::tree::TerminalNode *DEFERRABLE();
    antlr4::tree::TerminalNode *DEFERRED();
    antlr4::tree::TerminalNode *DEFINED();
    antlr4::tree::TerminalNode *DEFINER();
    antlr4::tree::TerminalNode *DEGREE();
    antlr4::tree::TerminalNode *DELAY();
    antlr4::tree::TerminalNode *DELETEXML();
    antlr4::tree::TerminalNode *DEMAND();
    antlr4::tree::TerminalNode *DENSE_RANKM();
    antlr4::tree::TerminalNode *DENSE_RANK();
    antlr4::tree::TerminalNode *DEPENDENT();
    antlr4::tree::TerminalNode *DEPTH();
    antlr4::tree::TerminalNode *DEQUEUE();
    antlr4::tree::TerminalNode *DEREF();
    antlr4::tree::TerminalNode *DEREF_NO_REWRITE();
    antlr4::tree::TerminalNode *DETACHED();
    antlr4::tree::TerminalNode *DETERMINES();
    antlr4::tree::TerminalNode *DICTIONARY();
    antlr4::tree::TerminalNode *DIMENSION();
    antlr4::tree::TerminalNode *DIRECT_LOAD();
    antlr4::tree::TerminalNode *DIRECTORY();
    antlr4::tree::TerminalNode *DIRECT_PATH();
    antlr4::tree::TerminalNode *DISABLE();
    antlr4::tree::TerminalNode *DISABLE_PRESET();
    antlr4::tree::TerminalNode *DISABLE_RPKE();
    antlr4::tree::TerminalNode *DISALLOW();
    antlr4::tree::TerminalNode *DISASSOCIATE();
    antlr4::tree::TerminalNode *DISCONNECT();
    antlr4::tree::TerminalNode *DISKGROUP();
    antlr4::tree::TerminalNode *DISK();
    antlr4::tree::TerminalNode *DISKS();
    antlr4::tree::TerminalNode *DISMOUNT();
    antlr4::tree::TerminalNode *DISTINGUISHED();
    antlr4::tree::TerminalNode *DISTRIBUTED();
    antlr4::tree::TerminalNode *DML();
    antlr4::tree::TerminalNode *DML_UPDATE();
    antlr4::tree::TerminalNode *DOCFIDELITY();
    antlr4::tree::TerminalNode *DOCUMENT();
    antlr4::tree::TerminalNode *DOMAIN_INDEX_FILTER();
    antlr4::tree::TerminalNode *DOMAIN_INDEX_NO_SORT();
    antlr4::tree::TerminalNode *DOMAIN_INDEX_SORT();
    antlr4::tree::TerminalNode *DOUBLE();
    antlr4::tree::TerminalNode *DOWNGRADE();
    antlr4::tree::TerminalNode *DRIVING_SITE();
    antlr4::tree::TerminalNode *DROP_COLUMN();
    antlr4::tree::TerminalNode *DROP_GROUP();
    antlr4::tree::TerminalNode *DST_UPGRADE_INSERT_CONV();
    antlr4::tree::TerminalNode *DUMP();
    antlr4::tree::TerminalNode *DYNAMIC();
    antlr4::tree::TerminalNode *DYNAMIC_SAMPLING_EST_CDN();
    antlr4::tree::TerminalNode *DYNAMIC_SAMPLING();
    antlr4::tree::TerminalNode *EACH();
    antlr4::tree::TerminalNode *EDITIONING();
    antlr4::tree::TerminalNode *EDITION();
    antlr4::tree::TerminalNode *EDITIONS();
    antlr4::tree::TerminalNode *ELEMENT();
    antlr4::tree::TerminalNode *ELIMINATE_JOIN();
    antlr4::tree::TerminalNode *ELIMINATE_OBY();
    antlr4::tree::TerminalNode *ELIMINATE_OUTER_JOIN();
    antlr4::tree::TerminalNode *EMPTY_BLOB();
    antlr4::tree::TerminalNode *EMPTY_CLOB();
    antlr4::tree::TerminalNode *EMPTY_();
    antlr4::tree::TerminalNode *ENABLE();
    antlr4::tree::TerminalNode *ENABLE_PRESET();
    antlr4::tree::TerminalNode *ENCODING();
    antlr4::tree::TerminalNode *ENCRYPTION();
    antlr4::tree::TerminalNode *ENCRYPT();
    antlr4::tree::TerminalNode *END_OUTLINE_DATA();
    antlr4::tree::TerminalNode *ENFORCED();
    antlr4::tree::TerminalNode *ENFORCE();
    antlr4::tree::TerminalNode *ENQUEUE();
    antlr4::tree::TerminalNode *ENTERPRISE();
    antlr4::tree::TerminalNode *ENTITYESCAPING();
    antlr4::tree::TerminalNode *ENTRY();
    antlr4::tree::TerminalNode *ERROR_ARGUMENT();
    antlr4::tree::TerminalNode *ERROR();
    antlr4::tree::TerminalNode *ERROR_ON_OVERLAP_TIME();
    antlr4::tree::TerminalNode *ERRORS();
    antlr4::tree::TerminalNode *ESCAPE();
    antlr4::tree::TerminalNode *ESTIMATE();
    antlr4::tree::TerminalNode *EVALNAME();
    antlr4::tree::TerminalNode *EVALUATION();
    antlr4::tree::TerminalNode *EVENTS();
    antlr4::tree::TerminalNode *EVERY();
    antlr4::tree::TerminalNode *EXCEPTIONS();
    antlr4::tree::TerminalNode *EXCEPT();
    antlr4::tree::TerminalNode *EXCHANGE();
    antlr4::tree::TerminalNode *EXCLUDE();
    antlr4::tree::TerminalNode *EXCLUDING();
    antlr4::tree::TerminalNode *EXECUTE();
    antlr4::tree::TerminalNode *EXEMPT();
    antlr4::tree::TerminalNode *EXISTSNODE();
    antlr4::tree::TerminalNode *EXPAND_GSET_TO_UNION();
    antlr4::tree::TerminalNode *EXPAND_TABLE();
    antlr4::tree::TerminalNode *EXPIRE();
    antlr4::tree::TerminalNode *EXPLAIN();
    antlr4::tree::TerminalNode *EXPLOSION();
    antlr4::tree::TerminalNode *EXP();
    antlr4::tree::TerminalNode *EXPORT();
    antlr4::tree::TerminalNode *EXPR_CORR_CHECK();
    antlr4::tree::TerminalNode *EXTENDS();
    antlr4::tree::TerminalNode *EXTENT();
    antlr4::tree::TerminalNode *EXTENTS();
    antlr4::tree::TerminalNode *EXTERNALLY();
    antlr4::tree::TerminalNode *EXTERNAL();
    antlr4::tree::TerminalNode *EXTRACT();
    antlr4::tree::TerminalNode *EXTRACTVALUE();
    antlr4::tree::TerminalNode *EXTRA();
    antlr4::tree::TerminalNode *FACILITY();
    antlr4::tree::TerminalNode *FACT();
    antlr4::tree::TerminalNode *FACTORIZE_JOIN();
    antlr4::tree::TerminalNode *FAILED_LOGIN_ATTEMPTS();
    antlr4::tree::TerminalNode *FAILED();
    antlr4::tree::TerminalNode *FAILGROUP();
    antlr4::tree::TerminalNode *FALSE();
    antlr4::tree::TerminalNode *FAST();
    antlr4::tree::TerminalNode *FBTSCAN();
    antlr4::tree::TerminalNode *FEATURE_ID();
    antlr4::tree::TerminalNode *FEATURE_SET();
    antlr4::tree::TerminalNode *FEATURE_VALUE();
    antlr4::tree::TerminalNode *FILE();
    antlr4::tree::TerminalNode *FILESYSTEM_LIKE_LOGGING();
    antlr4::tree::TerminalNode *FILTER();
    antlr4::tree::TerminalNode *FINAL();
    antlr4::tree::TerminalNode *FINE();
    antlr4::tree::TerminalNode *FINISH();
    antlr4::tree::TerminalNode *FIRSTM();
    antlr4::tree::TerminalNode *FIRST();
    antlr4::tree::TerminalNode *FIRST_ROWS();
    antlr4::tree::TerminalNode *FIRST_VALUE();
    antlr4::tree::TerminalNode *FLAGGER();
    antlr4::tree::TerminalNode *FLASHBACK();
    antlr4::tree::TerminalNode *FLASH_CACHE();
    antlr4::tree::TerminalNode *FLOB();
    antlr4::tree::TerminalNode *FLOOR();
    antlr4::tree::TerminalNode *FLUSH();
    antlr4::tree::TerminalNode *FOLDER();
    antlr4::tree::TerminalNode *FOLLOWING();
    antlr4::tree::TerminalNode *FOLLOWS();
    antlr4::tree::TerminalNode *FORCE();
    antlr4::tree::TerminalNode *FORCE_XML_QUERY_REWRITE();
    antlr4::tree::TerminalNode *FOREIGN();
    antlr4::tree::TerminalNode *FOREVER();
    antlr4::tree::TerminalNode *FORWARD();
    antlr4::tree::TerminalNode *FRAGMENT_NUMBER();
    antlr4::tree::TerminalNode *FREELIST();
    antlr4::tree::TerminalNode *FREELISTS();
    antlr4::tree::TerminalNode *FREEPOOLS();
    antlr4::tree::TerminalNode *FRESH();
    antlr4::tree::TerminalNode *FROM_TZ();
    antlr4::tree::TerminalNode *FULL();
    antlr4::tree::TerminalNode *FULL_OUTER_JOIN_TO_OUTER();
    antlr4::tree::TerminalNode *FUNCTION();
    antlr4::tree::TerminalNode *FUNCTIONS();
    antlr4::tree::TerminalNode *GATHER_PLAN_STATISTICS();
    antlr4::tree::TerminalNode *GBY_CONC_ROLLUP();
    antlr4::tree::TerminalNode *GBY_PUSHDOWN();
    antlr4::tree::TerminalNode *GENERATED();
    antlr4::tree::TerminalNode *GLOBALLY();
    antlr4::tree::TerminalNode *GLOBAL();
    antlr4::tree::TerminalNode *GLOBAL_NAME();
    antlr4::tree::TerminalNode *GLOBAL_TOPIC_ENABLED();
    antlr4::tree::TerminalNode *GREATEST();
    antlr4::tree::TerminalNode *GROUP_BY();
    antlr4::tree::TerminalNode *GROUP_ID();
    antlr4::tree::TerminalNode *GROUPING_ID();
    antlr4::tree::TerminalNode *GROUPING();
    antlr4::tree::TerminalNode *GROUPS();
    antlr4::tree::TerminalNode *GUARANTEED();
    antlr4::tree::TerminalNode *GUARANTEE();
    antlr4::tree::TerminalNode *GUARD();
    antlr4::tree::TerminalNode *HASH_AJ();
    antlr4::tree::TerminalNode *HASHKEYS();
    antlr4::tree::TerminalNode *HASH();
    antlr4::tree::TerminalNode *HASH_SJ();
    antlr4::tree::TerminalNode *HEADER();
    antlr4::tree::TerminalNode *HEAP();
    antlr4::tree::TerminalNode *HELP();
    antlr4::tree::TerminalNode *HEXTORAW();
    antlr4::tree::TerminalNode *HEXTOREF();
    antlr4::tree::TerminalNode *HIDDEN_KEYWORD();
    antlr4::tree::TerminalNode *HIDE();
    antlr4::tree::TerminalNode *HIERARCHY();
    antlr4::tree::TerminalNode *HIGH();
    antlr4::tree::TerminalNode *HINTSET_BEGIN();
    antlr4::tree::TerminalNode *HINTSET_END();
    antlr4::tree::TerminalNode *HOT();
    antlr4::tree::TerminalNode *HOUR();
    antlr4::tree::TerminalNode *HWM_BROKERED();
    antlr4::tree::TerminalNode *HYBRID();
    antlr4::tree::TerminalNode *IDENTIFIER();
    antlr4::tree::TerminalNode *IDENTITY();
    antlr4::tree::TerminalNode *IDGENERATORS();
    antlr4::tree::TerminalNode *IDLE_TIME();
    antlr4::tree::TerminalNode *ID();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *IGNORE();
    antlr4::tree::TerminalNode *IGNORE_OPTIM_EMBEDDED_HINTS();
    antlr4::tree::TerminalNode *IGNORE_ROW_ON_DUPKEY_INDEX();
    antlr4::tree::TerminalNode *IGNORE_WHERE_CLAUSE();
    antlr4::tree::TerminalNode *IMMEDIATE();
    antlr4::tree::TerminalNode *IMPACT();
    antlr4::tree::TerminalNode *IMPORT();
    antlr4::tree::TerminalNode *INCLUDE();
    antlr4::tree::TerminalNode *INCLUDE_VERSION();
    antlr4::tree::TerminalNode *INCLUDING();
    antlr4::tree::TerminalNode *INCREMENTAL();
    antlr4::tree::TerminalNode *INCREMENT();
    antlr4::tree::TerminalNode *INCR();
    antlr4::tree::TerminalNode *INDENT();
    antlr4::tree::TerminalNode *INDEX_ASC();
    antlr4::tree::TerminalNode *INDEX_COMBINE();
    antlr4::tree::TerminalNode *INDEX_DESC();
    antlr4::tree::TerminalNode *INDEXED();
    antlr4::tree::TerminalNode *INDEXES();
    antlr4::tree::TerminalNode *INDEX_FFS();
    antlr4::tree::TerminalNode *INDEX_FILTER();
    antlr4::tree::TerminalNode *INDEX_JOIN();
    antlr4::tree::TerminalNode *INDEX_ROWS();
    antlr4::tree::TerminalNode *INDEX_RRS();
    antlr4::tree::TerminalNode *INDEX_RS_ASC();
    antlr4::tree::TerminalNode *INDEX_RS_DESC();
    antlr4::tree::TerminalNode *INDEX_RS();
    antlr4::tree::TerminalNode *INDEX_SCAN();
    antlr4::tree::TerminalNode *INDEX_SKIP_SCAN();
    antlr4::tree::TerminalNode *INDEX_SS_ASC();
    antlr4::tree::TerminalNode *INDEX_SS_DESC();
    antlr4::tree::TerminalNode *INDEX_SS();
    antlr4::tree::TerminalNode *INDEX_STATS();
    antlr4::tree::TerminalNode *INDEXTYPE();
    antlr4::tree::TerminalNode *INDEXTYPES();
    antlr4::tree::TerminalNode *INDICATOR();
    antlr4::tree::TerminalNode *INFINITE();
    antlr4::tree::TerminalNode *INFORMATIONAL();
    antlr4::tree::TerminalNode *INITCAP();
    antlr4::tree::TerminalNode *INITIALIZED();
    antlr4::tree::TerminalNode *INITIALLY();
    antlr4::tree::TerminalNode *INITIAL();
    antlr4::tree::TerminalNode *INITRANS();
    antlr4::tree::TerminalNode *INLINE();
    antlr4::tree::TerminalNode *INLINE_XMLTYPE_NT();
    antlr4::tree::TerminalNode *IN_MEMORY_METADATA();
    antlr4::tree::TerminalNode *INNER();
    antlr4::tree::TerminalNode *INSERTCHILDXMLAFTER();
    antlr4::tree::TerminalNode *INSERTCHILDXMLBEFORE();
    antlr4::tree::TerminalNode *INSERTCHILDXML();
    antlr4::tree::TerminalNode *INSERTXMLAFTER();
    antlr4::tree::TerminalNode *INSERTXMLBEFORE();
    antlr4::tree::TerminalNode *INSTANCE();
    antlr4::tree::TerminalNode *INSTANCES();
    antlr4::tree::TerminalNode *INSTANTIABLE();
    antlr4::tree::TerminalNode *INSTANTLY();
    antlr4::tree::TerminalNode *INSTEAD();
    antlr4::tree::TerminalNode *INSTR2();
    antlr4::tree::TerminalNode *INSTR4();
    antlr4::tree::TerminalNode *INSTRB();
    antlr4::tree::TerminalNode *INSTRC();
    antlr4::tree::TerminalNode *INSTR();
    antlr4::tree::TerminalNode *INTERMEDIATE();
    antlr4::tree::TerminalNode *INTERNAL_CONVERT();
    antlr4::tree::TerminalNode *INTERNAL_USE();
    antlr4::tree::TerminalNode *INTERPRETED();
    antlr4::tree::TerminalNode *INTERVAL();
    antlr4::tree::TerminalNode *INT();
    antlr4::tree::TerminalNode *INVALIDATE();
    antlr4::tree::TerminalNode *INVISIBLE();
    antlr4::tree::TerminalNode *IN_XQUERY();
    antlr4::tree::TerminalNode *ISOLATION_LEVEL();
    antlr4::tree::TerminalNode *ISOLATION();
    antlr4::tree::TerminalNode *ITERATE();
    antlr4::tree::TerminalNode *ITERATION_NUMBER();
    antlr4::tree::TerminalNode *JAVA();
    antlr4::tree::TerminalNode *JOB();
    antlr4::tree::TerminalNode *JOIN();
    antlr4::tree::TerminalNode *KEEP_DUPLICATES();
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *KERBEROS();
    antlr4::tree::TerminalNode *KEY_LENGTH();
    antlr4::tree::TerminalNode *KEY();
    antlr4::tree::TerminalNode *KEYSIZE();
    antlr4::tree::TerminalNode *KEYS();
    antlr4::tree::TerminalNode *KILL();
    antlr4::tree::TerminalNode *LAG();
    antlr4::tree::TerminalNode *LAST_DAY();
    antlr4::tree::TerminalNode *LAST();
    antlr4::tree::TerminalNode *LAST_VALUE();
    antlr4::tree::TerminalNode *LATERAL();
    antlr4::tree::TerminalNode *LAYER();
    antlr4::tree::TerminalNode *LDAP_REGISTRATION_ENABLED();
    antlr4::tree::TerminalNode *LDAP_REGISTRATION();
    antlr4::tree::TerminalNode *LDAP_REG_SYNC_INTERVAL();
    antlr4::tree::TerminalNode *LEADING();
    antlr4::tree::TerminalNode *LEAD();
    antlr4::tree::TerminalNode *LEAF();
    antlr4::tree::TerminalNode *LEAST();
    antlr4::tree::TerminalNode *LEFT();
    antlr4::tree::TerminalNode *LENGTH2();
    antlr4::tree::TerminalNode *LENGTH4();
    antlr4::tree::TerminalNode *LENGTHB();
    antlr4::tree::TerminalNode *LENGTHC();
    antlr4::tree::TerminalNode *LENGTH();
    antlr4::tree::TerminalNode *LESS();
    antlr4::tree::TerminalNode *LEVEL();
    antlr4::tree::TerminalNode *LEVELS();
    antlr4::tree::TerminalNode *LIBRARY();
    antlr4::tree::TerminalNode *LIFE();
    antlr4::tree::TerminalNode *LIFETIME();
    antlr4::tree::TerminalNode *LIKE2();
    antlr4::tree::TerminalNode *LIKE4();
    antlr4::tree::TerminalNode *LIKEC();
    antlr4::tree::TerminalNode *LIKE_EXPAND();
    antlr4::tree::TerminalNode *LIMIT();
    antlr4::tree::TerminalNode *LINK();
    antlr4::tree::TerminalNode *LISTAGG();
    antlr4::tree::TerminalNode *LIST();
    antlr4::tree::TerminalNode *LN();
    antlr4::tree::TerminalNode *LNNVL();
    antlr4::tree::TerminalNode *LOAD();
    antlr4::tree::TerminalNode *LOB();
    antlr4::tree::TerminalNode *LOBNVL();
    antlr4::tree::TerminalNode *LOBS();
    antlr4::tree::TerminalNode *LOCAL_INDEXES();
    antlr4::tree::TerminalNode *LOCAL();
    antlr4::tree::TerminalNode *LOCALTIME();
    antlr4::tree::TerminalNode *LOCALTIMESTAMP();
    antlr4::tree::TerminalNode *LOCATION();
    antlr4::tree::TerminalNode *LOCATOR();
    antlr4::tree::TerminalNode *LOCKED();
    antlr4::tree::TerminalNode *LOGFILE();
    antlr4::tree::TerminalNode *LOGFILES();
    antlr4::tree::TerminalNode *LOGGING();
    antlr4::tree::TerminalNode *LOGICAL();
    antlr4::tree::TerminalNode *LOGICAL_READS_PER_CALL();
    antlr4::tree::TerminalNode *LOGICAL_READS_PER_SESSION();
    antlr4::tree::TerminalNode *LOG();
    antlr4::tree::TerminalNode *LOGOFF();
    antlr4::tree::TerminalNode *LOGON();
    antlr4::tree::TerminalNode *LOG_READ_ONLY_VIOLATIONS();
    antlr4::tree::TerminalNode *LOWER();
    antlr4::tree::TerminalNode *LOW();
    antlr4::tree::TerminalNode *LPAD();
    antlr4::tree::TerminalNode *LTRIM();
    antlr4::tree::TerminalNode *MAIN();
    antlr4::tree::TerminalNode *MAKE_REF();
    antlr4::tree::TerminalNode *MANAGED();
    antlr4::tree::TerminalNode *MANAGEMENT();
    antlr4::tree::TerminalNode *MANAGE();
    antlr4::tree::TerminalNode *MANAGER();
    antlr4::tree::TerminalNode *MANUAL();
    antlr4::tree::TerminalNode *MAPPING();
    antlr4::tree::TerminalNode *MASTER();
    antlr4::tree::TerminalNode *MATCHED();
    antlr4::tree::TerminalNode *MATERIALIZED();
    antlr4::tree::TerminalNode *MATERIALIZE();
    antlr4::tree::TerminalNode *MAXARCHLOGS();
    antlr4::tree::TerminalNode *MAXDATAFILES();
    antlr4::tree::TerminalNode *MAXEXTENTS();
    antlr4::tree::TerminalNode *MAXIMIZE();
    antlr4::tree::TerminalNode *MAXINSTANCES();
    antlr4::tree::TerminalNode *MAXLOGFILES();
    antlr4::tree::TerminalNode *MAXLOGHISTORY();
    antlr4::tree::TerminalNode *MAXLOGMEMBERS();
    antlr4::tree::TerminalNode *MAX();
    antlr4::tree::TerminalNode *MAXSIZE();
    antlr4::tree::TerminalNode *MAXTRANS();
    antlr4::tree::TerminalNode *MAXVALUE();
    antlr4::tree::TerminalNode *MEASURE();
    antlr4::tree::TerminalNode *MEASURES();
    antlr4::tree::TerminalNode *MEDIAN();
    antlr4::tree::TerminalNode *MEDIUM();
    antlr4::tree::TerminalNode *MEMBER();
    antlr4::tree::TerminalNode *MEMOPTIMIZE();
    antlr4::tree::TerminalNode *MEMORY();
    antlr4::tree::TerminalNode *MERGEACTIONS();
    antlr4::tree::TerminalNode *MERGE_AJ();
    antlr4::tree::TerminalNode *MERGE_CONST_ON();
    antlr4::tree::TerminalNode *MERGE();
    antlr4::tree::TerminalNode *MERGE_SJ();
    antlr4::tree::TerminalNode *METHOD();
    antlr4::tree::TerminalNode *MIGRATE();
    antlr4::tree::TerminalNode *MIGRATION();
    antlr4::tree::TerminalNode *MINEXTENTS();
    antlr4::tree::TerminalNode *MINIMIZE();
    antlr4::tree::TerminalNode *MINIMUM();
    antlr4::tree::TerminalNode *MINING();
    antlr4::tree::TerminalNode *MIN();
    antlr4::tree::TerminalNode *MINUS_NULL();
    antlr4::tree::TerminalNode *MINUTE();
    antlr4::tree::TerminalNode *MINVALUE();
    antlr4::tree::TerminalNode *MIRRORCOLD();
    antlr4::tree::TerminalNode *MIRRORHOT();
    antlr4::tree::TerminalNode *MIRROR();
    antlr4::tree::TerminalNode *MLSLABEL();
    antlr4::tree::TerminalNode *MODEL_COMPILE_SUBQUERY();
    antlr4::tree::TerminalNode *MODEL_DONTVERIFY_UNIQUENESS();
    antlr4::tree::TerminalNode *MODEL_DYNAMIC_SUBQUERY();
    antlr4::tree::TerminalNode *MODEL_MIN_ANALYSIS();
    antlr4::tree::TerminalNode *MODEL();
    antlr4::tree::TerminalNode *MODEL_NO_ANALYSIS();
    antlr4::tree::TerminalNode *MODEL_PBY();
    antlr4::tree::TerminalNode *MODEL_PUSH_REF();
    antlr4::tree::TerminalNode *MODIFY_COLUMN_TYPE();
    antlr4::tree::TerminalNode *MODIFY();
    antlr4::tree::TerminalNode *MOD();
    antlr4::tree::TerminalNode *MONITORING();
    antlr4::tree::TerminalNode *MONITOR();
    antlr4::tree::TerminalNode *MONTH();
    antlr4::tree::TerminalNode *MONTHS_BETWEEN();
    antlr4::tree::TerminalNode *MOUNT();
    antlr4::tree::TerminalNode *MOUNTPATH();
    antlr4::tree::TerminalNode *MOVEMENT();
    antlr4::tree::TerminalNode *MOVE();
    antlr4::tree::TerminalNode *MULTISET();
    antlr4::tree::TerminalNode *MV_MERGE();
    antlr4::tree::TerminalNode *NAMED();
    antlr4::tree::TerminalNode *NAME();
    antlr4::tree::TerminalNode *NAMESPACE();
    antlr4::tree::TerminalNode *NAN_();
    antlr4::tree::TerminalNode *NANVL();
    antlr4::tree::TerminalNode *NATIONAL();
    antlr4::tree::TerminalNode *NATIVE_FULL_OUTER_JOIN();
    antlr4::tree::TerminalNode *NATIVE();
    antlr4::tree::TerminalNode *NATURAL();
    antlr4::tree::TerminalNode *NAV();
    antlr4::tree::TerminalNode *NCHAR_CS();
    antlr4::tree::TerminalNode *NCHAR();
    antlr4::tree::TerminalNode *NCHR();
    antlr4::tree::TerminalNode *NCLOB();
    antlr4::tree::TerminalNode *NEEDED();
    antlr4::tree::TerminalNode *NESTED();
    antlr4::tree::TerminalNode *NESTED_TABLE_FAST_INSERT();
    antlr4::tree::TerminalNode *NESTED_TABLE_GET_REFS();
    antlr4::tree::TerminalNode *NESTED_TABLE_ID();
    antlr4::tree::TerminalNode *NESTED_TABLE_SET_REFS();
    antlr4::tree::TerminalNode *NESTED_TABLE_SET_SETID();
    antlr4::tree::TerminalNode *NETWORK();
    antlr4::tree::TerminalNode *NEVER();
    antlr4::tree::TerminalNode *NEW();
    antlr4::tree::TerminalNode *NEW_TIME();
    antlr4::tree::TerminalNode *NEXT_DAY();
    antlr4::tree::TerminalNode *NEXT();
    antlr4::tree::TerminalNode *NL_AJ();
    antlr4::tree::TerminalNode *NLJ_BATCHING();
    antlr4::tree::TerminalNode *NLJ_INDEX_FILTER();
    antlr4::tree::TerminalNode *NLJ_INDEX_SCAN();
    antlr4::tree::TerminalNode *NLJ_PREFETCH();
    antlr4::tree::TerminalNode *NLS_CALENDAR();
    antlr4::tree::TerminalNode *NLS_CHARACTERSET();
    antlr4::tree::TerminalNode *NLS_CHARSET_DECL_LEN();
    antlr4::tree::TerminalNode *NLS_CHARSET_ID();
    antlr4::tree::TerminalNode *NLS_CHARSET_NAME();
    antlr4::tree::TerminalNode *NLS_COMP();
    antlr4::tree::TerminalNode *NLS_CURRENCY();
    antlr4::tree::TerminalNode *NLS_DATE_FORMAT();
    antlr4::tree::TerminalNode *NLS_DATE_LANGUAGE();
    antlr4::tree::TerminalNode *NLS_INITCAP();
    antlr4::tree::TerminalNode *NLS_ISO_CURRENCY();
    antlr4::tree::TerminalNode *NL_SJ();
    antlr4::tree::TerminalNode *NLS_LANG();
    antlr4::tree::TerminalNode *NLS_LANGUAGE();
    antlr4::tree::TerminalNode *NLS_LENGTH_SEMANTICS();
    antlr4::tree::TerminalNode *NLS_LOWER();
    antlr4::tree::TerminalNode *NLS_NCHAR_CONV_EXCP();
    antlr4::tree::TerminalNode *NLS_NUMERIC_CHARACTERS();
    antlr4::tree::TerminalNode *NLS_SORT();
    antlr4::tree::TerminalNode *NLSSORT();
    antlr4::tree::TerminalNode *NLS_SPECIAL_CHARS();
    antlr4::tree::TerminalNode *NLS_TERRITORY();
    antlr4::tree::TerminalNode *NLS_UPPER();
    antlr4::tree::TerminalNode *NO_ACCESS();
    antlr4::tree::TerminalNode *NOAPPEND();
    antlr4::tree::TerminalNode *NOARCHIVELOG();
    antlr4::tree::TerminalNode *NOAUDIT();
    antlr4::tree::TerminalNode *NO_BASETABLE_MULTIMV_REWRITE();
    antlr4::tree::TerminalNode *NO_BIND_AWARE();
    antlr4::tree::TerminalNode *NO_BUFFER();
    antlr4::tree::TerminalNode *NOCACHE();
    antlr4::tree::TerminalNode *NO_CARTESIAN();
    antlr4::tree::TerminalNode *NO_CHECK_ACL_REWRITE();
    antlr4::tree::TerminalNode *NO_CLUSTER_BY_ROWID();
    antlr4::tree::TerminalNode *NO_COALESCE_SQ();
    antlr4::tree::TerminalNode *NO_CONNECT_BY_CB_WHR_ONLY();
    antlr4::tree::TerminalNode *NO_CONNECT_BY_COMBINE_SW();
    antlr4::tree::TerminalNode *NO_CONNECT_BY_COST_BASED();
    antlr4::tree::TerminalNode *NO_CONNECT_BY_ELIM_DUPS();
    antlr4::tree::TerminalNode *NO_CONNECT_BY_FILTERING();
    antlr4::tree::TerminalNode *NO_COST_XML_QUERY_REWRITE();
    antlr4::tree::TerminalNode *NO_CPU_COSTING();
    antlr4::tree::TerminalNode *NOCPU_COSTING();
    antlr4::tree::TerminalNode *NOCYCLE();
    antlr4::tree::TerminalNode *NODELAY();
    antlr4::tree::TerminalNode *NO_DOMAIN_INDEX_FILTER();
    antlr4::tree::TerminalNode *NO_DST_UPGRADE_INSERT_CONV();
    antlr4::tree::TerminalNode *NO_ELIMINATE_JOIN();
    antlr4::tree::TerminalNode *NO_ELIMINATE_OBY();
    antlr4::tree::TerminalNode *NO_ELIMINATE_OUTER_JOIN();
    antlr4::tree::TerminalNode *NOENTITYESCAPING();
    antlr4::tree::TerminalNode *NO_EXPAND_GSET_TO_UNION();
    antlr4::tree::TerminalNode *NO_EXPAND();
    antlr4::tree::TerminalNode *NO_EXPAND_TABLE();
    antlr4::tree::TerminalNode *NO_FACT();
    antlr4::tree::TerminalNode *NO_FACTORIZE_JOIN();
    antlr4::tree::TerminalNode *NO_FILTERING();
    antlr4::tree::TerminalNode *NOFORCE();
    antlr4::tree::TerminalNode *NO_FULL_OUTER_JOIN_TO_OUTER();
    antlr4::tree::TerminalNode *NO_GBY_PUSHDOWN();
    antlr4::tree::TerminalNode *NOGUARANTEE();
    antlr4::tree::TerminalNode *NO_INDEX_FFS();
    antlr4::tree::TerminalNode *NO_INDEX();
    antlr4::tree::TerminalNode *NO_INDEX_SS();
    antlr4::tree::TerminalNode *NO_LOAD();
    antlr4::tree::TerminalNode *NOLOCAL();
    antlr4::tree::TerminalNode *NOLOGGING();
    antlr4::tree::TerminalNode *NOMAPPING();
    antlr4::tree::TerminalNode *NOMAXVALUE();
    antlr4::tree::TerminalNode *NO_MERGE();
    antlr4::tree::TerminalNode *NOMINIMIZE();
    antlr4::tree::TerminalNode *NOMINVALUE();
    antlr4::tree::TerminalNode *NO_MODEL_PUSH_REF();
    antlr4::tree::TerminalNode *NO_MONITORING();
    antlr4::tree::TerminalNode *NOMONITORING();
    antlr4::tree::TerminalNode *NO_MONITOR();
    antlr4::tree::TerminalNode *NO_MULTIMV_REWRITE();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *NO_NATIVE_FULL_OUTER_JOIN();
    antlr4::tree::TerminalNode *NONBLOCKING();
    antlr4::tree::TerminalNode *NONE();
    antlr4::tree::TerminalNode *NO_NLJ_BATCHING();
    antlr4::tree::TerminalNode *NO_NLJ_PREFETCH();
    antlr4::tree::TerminalNode *NONSCHEMA();
    antlr4::tree::TerminalNode *NOORDER();
    antlr4::tree::TerminalNode *NO_ORDER_ROLLUPS();
    antlr4::tree::TerminalNode *NO_OUTER_JOIN_TO_ANTI();
    antlr4::tree::TerminalNode *NO_OUTER_JOIN_TO_INNER();
    antlr4::tree::TerminalNode *NOOVERRIDE();
    antlr4::tree::TerminalNode *NO_PARALLEL_INDEX();
    antlr4::tree::TerminalNode *NOPARALLEL_INDEX();
    antlr4::tree::TerminalNode *NO_PARALLEL();
    antlr4::tree::TerminalNode *NOPARALLEL();
    antlr4::tree::TerminalNode *NO_PARTIAL_COMMIT();
    antlr4::tree::TerminalNode *NO_PLACE_DISTINCT();
    antlr4::tree::TerminalNode *NO_PLACE_GROUP_BY();
    antlr4::tree::TerminalNode *NO_PQ_MAP();
    antlr4::tree::TerminalNode *NO_PRUNE_GSETS();
    antlr4::tree::TerminalNode *NO_PULL_PRED();
    antlr4::tree::TerminalNode *NO_PUSH_PRED();
    antlr4::tree::TerminalNode *NO_PUSH_SUBQ();
    antlr4::tree::TerminalNode *NO_PX_JOIN_FILTER();
    antlr4::tree::TerminalNode *NO_QKN_BUFF();
    antlr4::tree::TerminalNode *NO_QUERY_TRANSFORMATION();
    antlr4::tree::TerminalNode *NO_REF_CASCADE();
    antlr4::tree::TerminalNode *NORELY();
    antlr4::tree::TerminalNode *NOREPAIR();
    antlr4::tree::TerminalNode *NORESETLOGS();
    antlr4::tree::TerminalNode *NO_RESULT_CACHE();
    antlr4::tree::TerminalNode *NOREVERSE();
    antlr4::tree::TerminalNode *NO_REWRITE();
    antlr4::tree::TerminalNode *NOREWRITE();
    antlr4::tree::TerminalNode *NORMAL();
    antlr4::tree::TerminalNode *NOROWDEPENDENCIES();
    antlr4::tree::TerminalNode *NOSCHEMACHECK();
    antlr4::tree::TerminalNode *NOSEGMENT();
    antlr4::tree::TerminalNode *NO_SEMIJOIN();
    antlr4::tree::TerminalNode *NO_SEMI_TO_INNER();
    antlr4::tree::TerminalNode *NO_SET_TO_JOIN();
    antlr4::tree::TerminalNode *NOSORT();
    antlr4::tree::TerminalNode *NO_SQL_TUNE();
    antlr4::tree::TerminalNode *NO_STAR_TRANSFORMATION();
    antlr4::tree::TerminalNode *NO_STATEMENT_QUEUING();
    antlr4::tree::TerminalNode *NO_STATS_GSETS();
    antlr4::tree::TerminalNode *NOSTRICT();
    antlr4::tree::TerminalNode *NO_SUBQUERY_PRUNING();
    antlr4::tree::TerminalNode *NO_SUBSTRB_PAD();
    antlr4::tree::TerminalNode *NO_SWAP_JOIN_INPUTS();
    antlr4::tree::TerminalNode *NOSWITCH();
    antlr4::tree::TerminalNode *NO_TABLE_LOOKUP_BY_NL();
    antlr4::tree::TerminalNode *NO_TEMP_TABLE();
    antlr4::tree::TerminalNode *NOTHING();
    antlr4::tree::TerminalNode *NOTIFICATION();
    antlr4::tree::TerminalNode *NO_TRANSFORM_DISTINCT_AGG();
    antlr4::tree::TerminalNode *NO_UNNEST();
    antlr4::tree::TerminalNode *NO_USE_HASH_AGGREGATION();
    antlr4::tree::TerminalNode *NO_USE_HASH_GBY_FOR_PUSHDOWN();
    antlr4::tree::TerminalNode *NO_USE_HASH();
    antlr4::tree::TerminalNode *NO_USE_INVISIBLE_INDEXES();
    antlr4::tree::TerminalNode *NO_USE_MERGE();
    antlr4::tree::TerminalNode *NO_USE_NL();
    antlr4::tree::TerminalNode *NOVALIDATE();
    antlr4::tree::TerminalNode *NO_XDB_FASTPATH_INSERT();
    antlr4::tree::TerminalNode *NO_XML_DML_REWRITE();
    antlr4::tree::TerminalNode *NO_XMLINDEX_REWRITE_IN_SELECT();
    antlr4::tree::TerminalNode *NO_XMLINDEX_REWRITE();
    antlr4::tree::TerminalNode *NO_XML_QUERY_REWRITE();
    antlr4::tree::TerminalNode *NTH_VALUE();
    antlr4::tree::TerminalNode *NTILE();
    antlr4::tree::TerminalNode *NULLIF();
    antlr4::tree::TerminalNode *NULLS();
    antlr4::tree::TerminalNode *NUMERIC();
    antlr4::tree::TerminalNode *NUM_INDEX_KEYS();
    antlr4::tree::TerminalNode *NUMTODSINTERVAL();
    antlr4::tree::TerminalNode *NUMTOYMINTERVAL();
    antlr4::tree::TerminalNode *NVARCHAR2();
    antlr4::tree::TerminalNode *NVL2();
    antlr4::tree::TerminalNode *NVL();
    antlr4::tree::TerminalNode *OBJECT2XML();
    antlr4::tree::TerminalNode *OBJECT();
    antlr4::tree::TerminalNode *OBJNO();
    antlr4::tree::TerminalNode *OBJNO_REUSE();
    antlr4::tree::TerminalNode *OCCURENCES();
    antlr4::tree::TerminalNode *OFFLINE();
    antlr4::tree::TerminalNode *OFF();
    antlr4::tree::TerminalNode *OIDINDEX();
    antlr4::tree::TerminalNode *OID();
    antlr4::tree::TerminalNode *OLAP();
    antlr4::tree::TerminalNode *OLD();
    antlr4::tree::TerminalNode *OLD_PUSH_PRED();
    antlr4::tree::TerminalNode *OLTP();
    antlr4::tree::TerminalNode *ONLINE();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *OPAQUE();
    antlr4::tree::TerminalNode *OPAQUE_TRANSFORM();
    antlr4::tree::TerminalNode *OPAQUE_XCANONICAL();
    antlr4::tree::TerminalNode *OPCODE();
    antlr4::tree::TerminalNode *OPEN();
    antlr4::tree::TerminalNode *OPERATIONS();
    antlr4::tree::TerminalNode *OPERATOR();
    antlr4::tree::TerminalNode *OPT_ESTIMATE();
    antlr4::tree::TerminalNode *OPTIMAL();
    antlr4::tree::TerminalNode *OPTIMIZE();
    antlr4::tree::TerminalNode *OPTIMIZER_FEATURES_ENABLE();
    antlr4::tree::TerminalNode *OPTIMIZER_GOAL();
    antlr4::tree::TerminalNode *OPT_PARAM();
    antlr4::tree::TerminalNode *ORA_BRANCH();
    antlr4::tree::TerminalNode *ORADEBUG();
    antlr4::tree::TerminalNode *ORA_DST_AFFECTED();
    antlr4::tree::TerminalNode *ORA_DST_CONVERT();
    antlr4::tree::TerminalNode *ORA_DST_ERROR();
    antlr4::tree::TerminalNode *ORA_GET_ACLIDS();
    antlr4::tree::TerminalNode *ORA_GET_PRIVILEGES();
    antlr4::tree::TerminalNode *ORA_HASH();
    antlr4::tree::TerminalNode *ORA_ROWSCN();
    antlr4::tree::TerminalNode *ORA_ROWSCN_RAW();
    antlr4::tree::TerminalNode *ORA_ROWVERSION();
    antlr4::tree::TerminalNode *ORA_TABVERSION();
    antlr4::tree::TerminalNode *ORDERED();
    antlr4::tree::TerminalNode *ORDERED_PREDICATES();
    antlr4::tree::TerminalNode *ORDINALITY();
    antlr4::tree::TerminalNode *OR_EXPAND();
    antlr4::tree::TerminalNode *ORGANIZATION();
    antlr4::tree::TerminalNode *OR_PREDICATES();
    antlr4::tree::TerminalNode *OTHER();
    antlr4::tree::TerminalNode *OUTER_JOIN_TO_ANTI();
    antlr4::tree::TerminalNode *OUTER_JOIN_TO_INNER();
    antlr4::tree::TerminalNode *OUTER();
    antlr4::tree::TerminalNode *OUTLINE_LEAF();
    antlr4::tree::TerminalNode *OUTLINE();
    antlr4::tree::TerminalNode *OUT_OF_LINE();
    antlr4::tree::TerminalNode *OVERFLOW_();
    antlr4::tree::TerminalNode *OVERFLOW_NOMOVE();
    antlr4::tree::TerminalNode *OVERLAPS();
    antlr4::tree::TerminalNode *OVER();
    antlr4::tree::TerminalNode *OWNER();
    antlr4::tree::TerminalNode *OWNERSHIP();
    antlr4::tree::TerminalNode *OWN();
    antlr4::tree::TerminalNode *PACKAGE();
    antlr4::tree::TerminalNode *PACKAGES();
    antlr4::tree::TerminalNode *PARALLEL_INDEX();
    antlr4::tree::TerminalNode *PARALLEL();
    antlr4::tree::TerminalNode *PARAMETERS();
    antlr4::tree::TerminalNode *PARAM();
    antlr4::tree::TerminalNode *PARENT();
    antlr4::tree::TerminalNode *PARITY();
    antlr4::tree::TerminalNode *PARTIALLY();
    antlr4::tree::TerminalNode *PARTITION_HASH();
    antlr4::tree::TerminalNode *PARTITION_LIST();
    antlr4::tree::TerminalNode *PARTITION();
    antlr4::tree::TerminalNode *PARTITION_RANGE();
    antlr4::tree::TerminalNode *PARTITIONS();
    antlr4::tree::TerminalNode *PARTNUMINST();
    antlr4::tree::TerminalNode *PASSING();
    antlr4::tree::TerminalNode *PASSWORD_GRACE_TIME();
    antlr4::tree::TerminalNode *PASSWORD_LIFE_TIME();
    antlr4::tree::TerminalNode *PASSWORD_LOCK_TIME();
    antlr4::tree::TerminalNode *PASSWORD();
    antlr4::tree::TerminalNode *PASSWORD_REUSE_MAX();
    antlr4::tree::TerminalNode *PASSWORD_REUSE_TIME();
    antlr4::tree::TerminalNode *PASSWORD_VERIFY_FUNCTION();
    antlr4::tree::TerminalNode *PATH();
    antlr4::tree::TerminalNode *PATHS();
    antlr4::tree::TerminalNode *PBL_HS_BEGIN();
    antlr4::tree::TerminalNode *PBL_HS_END();
    antlr4::tree::TerminalNode *PCTINCREASE();
    antlr4::tree::TerminalNode *PCTTHRESHOLD();
    antlr4::tree::TerminalNode *PCTUSED();
    antlr4::tree::TerminalNode *PCTVERSION();
    antlr4::tree::TerminalNode *PENDING();
    antlr4::tree::TerminalNode *PERCENTILE_CONT();
    antlr4::tree::TerminalNode *PERCENTILE_DISC();
    antlr4::tree::TerminalNode *PERCENT_KEYWORD();
    antlr4::tree::TerminalNode *PERCENT_RANKM();
    antlr4::tree::TerminalNode *PERCENT_RANK();
    antlr4::tree::TerminalNode *PERFORMANCE();
    antlr4::tree::TerminalNode *PERMANENT();
    antlr4::tree::TerminalNode *PERMISSION();
    antlr4::tree::TerminalNode *PFILE();
    antlr4::tree::TerminalNode *PHYSICAL();
    antlr4::tree::TerminalNode *PIKEY();
    antlr4::tree::TerminalNode *PIV_GB();
    antlr4::tree::TerminalNode *PIVOT();
    antlr4::tree::TerminalNode *PIV_SSF();
    antlr4::tree::TerminalNode *PLACE_DISTINCT();
    antlr4::tree::TerminalNode *PLACE_GROUP_BY();
    antlr4::tree::TerminalNode *PLAN();
    antlr4::tree::TerminalNode *PLSCOPE_SETTINGS();
    antlr4::tree::TerminalNode *PLSQL_CCFLAGS();
    antlr4::tree::TerminalNode *PLSQL_CODE_TYPE();
    antlr4::tree::TerminalNode *PLSQL_DEBUG();
    antlr4::tree::TerminalNode *PLSQL_OPTIMIZE_LEVEL();
    antlr4::tree::TerminalNode *PLSQL_WARNINGS();
    antlr4::tree::TerminalNode *POINT();
    antlr4::tree::TerminalNode *POLICY();
    antlr4::tree::TerminalNode *POST_TRANSACTION();
    antlr4::tree::TerminalNode *POWERMULTISET_BY_CARDINALITY();
    antlr4::tree::TerminalNode *POWERMULTISET();
    antlr4::tree::TerminalNode *POWER();
    antlr4::tree::TerminalNode *POSITION();
    antlr4::tree::TerminalNode *PQ_DISTRIBUTE();
    antlr4::tree::TerminalNode *PQ_MAP();
    antlr4::tree::TerminalNode *PQ_NOMAP();
    antlr4::tree::TerminalNode *PREBUILT();
    antlr4::tree::TerminalNode *PRECEDES();
    antlr4::tree::TerminalNode *PRECEDING();
    antlr4::tree::TerminalNode *PRECISION();
    antlr4::tree::TerminalNode *PRECOMPUTE_SUBQUERY();
    antlr4::tree::TerminalNode *PREDICATE_REORDERS();
    antlr4::tree::TerminalNode *PREDICTION_BOUNDS();
    antlr4::tree::TerminalNode *PREDICTION_COST();
    antlr4::tree::TerminalNode *PREDICTION_DETAILS();
    antlr4::tree::TerminalNode *PREDICTION();
    antlr4::tree::TerminalNode *PREDICTION_PROBABILITY();
    antlr4::tree::TerminalNode *PREDICTION_SET();
    antlr4::tree::TerminalNode *PREPARE();
    antlr4::tree::TerminalNode *PRESENT();
    antlr4::tree::TerminalNode *PRESENTNNV();
    antlr4::tree::TerminalNode *PRESENTV();
    antlr4::tree::TerminalNode *PRESERVE();
    antlr4::tree::TerminalNode *PRESERVE_OID();
    antlr4::tree::TerminalNode *PREVIOUS();
    antlr4::tree::TerminalNode *PRIMARY();
    antlr4::tree::TerminalNode *PRIVATE();
    antlr4::tree::TerminalNode *PRIVATE_SGA();
    antlr4::tree::TerminalNode *PRIVILEGE();
    antlr4::tree::TerminalNode *PRIVILEGES();
    antlr4::tree::TerminalNode *PROCEDURAL();
    antlr4::tree::TerminalNode *PROCEDURE();
    antlr4::tree::TerminalNode *PROCESS();
    antlr4::tree::TerminalNode *PROFILE();
    antlr4::tree::TerminalNode *PROGRAM();
    antlr4::tree::TerminalNode *PROJECT();
    antlr4::tree::TerminalNode *PROPAGATE();
    antlr4::tree::TerminalNode *PROTECTED();
    antlr4::tree::TerminalNode *PROTECTION();
    antlr4::tree::TerminalNode *PULL_PRED();
    antlr4::tree::TerminalNode *PURGE();
    antlr4::tree::TerminalNode *PUSH_PRED();
    antlr4::tree::TerminalNode *PUSH_SUBQ();
    antlr4::tree::TerminalNode *PX_GRANULE();
    antlr4::tree::TerminalNode *PX_JOIN_FILTER();
    antlr4::tree::TerminalNode *QB_NAME();
    antlr4::tree::TerminalNode *QUERY_BLOCK();
    antlr4::tree::TerminalNode *QUERY();
    antlr4::tree::TerminalNode *QUEUE_CURR();
    antlr4::tree::TerminalNode *QUEUE();
    antlr4::tree::TerminalNode *QUEUE_ROWP();
    antlr4::tree::TerminalNode *QUIESCE();
    antlr4::tree::TerminalNode *QUORUM();
    antlr4::tree::TerminalNode *QUOTA();
    antlr4::tree::TerminalNode *RANDOM_LOCAL();
    antlr4::tree::TerminalNode *RANDOM();
    antlr4::tree::TerminalNode *RANGE();
    antlr4::tree::TerminalNode *RANKM();
    antlr4::tree::TerminalNode *RANK();
    antlr4::tree::TerminalNode *RAPIDLY();
    antlr4::tree::TerminalNode *RATIO_TO_REPORT();
    antlr4::tree::TerminalNode *RAWTOHEX();
    antlr4::tree::TerminalNode *RAWTONHEX();
    antlr4::tree::TerminalNode *RBA();
    antlr4::tree::TerminalNode *RBO_OUTLINE();
    antlr4::tree::TerminalNode *RDBA();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *READS();
    antlr4::tree::TerminalNode *REAL();
    antlr4::tree::TerminalNode *REBALANCE();
    antlr4::tree::TerminalNode *REBUILD();
    antlr4::tree::TerminalNode *RECORDS_PER_BLOCK();
    antlr4::tree::TerminalNode *RECOVERABLE();
    antlr4::tree::TerminalNode *RECOVER();
    antlr4::tree::TerminalNode *RECOVERY();
    antlr4::tree::TerminalNode *RECYCLEBIN();
    antlr4::tree::TerminalNode *RECYCLE();
    antlr4::tree::TerminalNode *REDACTION();
    antlr4::tree::TerminalNode *REDO();
    antlr4::tree::TerminalNode *REDUCED();
    antlr4::tree::TerminalNode *REDUNDANCY();
    antlr4::tree::TerminalNode *REF_CASCADE_CURSOR();
    antlr4::tree::TerminalNode *REFERENCED();
    antlr4::tree::TerminalNode *REFERENCE();
    antlr4::tree::TerminalNode *REFERENCES();
    antlr4::tree::TerminalNode *REFERENCING();
    antlr4::tree::TerminalNode *REF();
    antlr4::tree::TerminalNode *REFRESH();
    antlr4::tree::TerminalNode *REFTOHEX();
    antlr4::tree::TerminalNode *REGEXP_COUNT();
    antlr4::tree::TerminalNode *REGEXP_INSTR();
    antlr4::tree::TerminalNode *REGEXP_LIKE();
    antlr4::tree::TerminalNode *REGEXP_REPLACE();
    antlr4::tree::TerminalNode *REGEXP_SUBSTR();
    antlr4::tree::TerminalNode *REGISTER();
    antlr4::tree::TerminalNode *REGR_AVGX();
    antlr4::tree::TerminalNode *REGR_AVGY();
    antlr4::tree::TerminalNode *REGR_COUNT();
    antlr4::tree::TerminalNode *REGR_INTERCEPT();
    antlr4::tree::TerminalNode *REGR_R2();
    antlr4::tree::TerminalNode *REGR_SLOPE();
    antlr4::tree::TerminalNode *REGR_SXX();
    antlr4::tree::TerminalNode *REGR_SXY();
    antlr4::tree::TerminalNode *REGR_SYY();
    antlr4::tree::TerminalNode *REGULAR();
    antlr4::tree::TerminalNode *REJECT();
    antlr4::tree::TerminalNode *REKEY();
    antlr4::tree::TerminalNode *RELATIONAL();
    antlr4::tree::TerminalNode *RELY();
    antlr4::tree::TerminalNode *REMAINDER();
    antlr4::tree::TerminalNode *REMOTE_MAPPED();
    antlr4::tree::TerminalNode *REMOVE();
    antlr4::tree::TerminalNode *REPAIR();
    antlr4::tree::TerminalNode *REPEAT();
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *REPLICATION();
    antlr4::tree::TerminalNode *REQUIRED();
    antlr4::tree::TerminalNode *RESETLOGS();
    antlr4::tree::TerminalNode *RESET();
    antlr4::tree::TerminalNode *RESIZE();
    antlr4::tree::TerminalNode *RESOLVE();
    antlr4::tree::TerminalNode *RESOLVER();
    antlr4::tree::TerminalNode *RESPECT();
    antlr4::tree::TerminalNode *RESTORE_AS_INTERVALS();
    antlr4::tree::TerminalNode *RESTORE();
    antlr4::tree::TerminalNode *RESTRICT_ALL_REF_CONS();
    antlr4::tree::TerminalNode *RESTRICTED();
    antlr4::tree::TerminalNode *RESTRICT();
    antlr4::tree::TerminalNode *RESULT_CACHE();
    antlr4::tree::TerminalNode *RESUMABLE();
    antlr4::tree::TerminalNode *RESUME();
    antlr4::tree::TerminalNode *RETENTION();
    antlr4::tree::TerminalNode *RETRY_ON_ROW_CHANGE();
    antlr4::tree::TerminalNode *RETURNING();
    antlr4::tree::TerminalNode *RETURN();
    antlr4::tree::TerminalNode *REUSE();
    antlr4::tree::TerminalNode *REVERSE();
    antlr4::tree::TerminalNode *REWRITE();
    antlr4::tree::TerminalNode *REWRITE_OR_ERROR();
    antlr4::tree::TerminalNode *RIGHT();
    antlr4::tree::TerminalNode *ROLE();
    antlr4::tree::TerminalNode *ROLES();
    antlr4::tree::TerminalNode *ROLLBACK();
    antlr4::tree::TerminalNode *ROLLING();
    antlr4::tree::TerminalNode *ROLLUP();
    antlr4::tree::TerminalNode *ROOT();
    antlr4::tree::TerminalNode *ROUND();
    antlr4::tree::TerminalNode *ROWDEPENDENCIES();
    antlr4::tree::TerminalNode *ROWID();
    antlr4::tree::TerminalNode *ROWIDTOCHAR();
    antlr4::tree::TerminalNode *ROWIDTONCHAR();
    antlr4::tree::TerminalNode *ROW_LENGTH();
    antlr4::tree::TerminalNode *ROW();
    antlr4::tree::TerminalNode *ROW_NUMBER();
    antlr4::tree::TerminalNode *ROWNUM();
    antlr4::tree::TerminalNode *ROWS();
    antlr4::tree::TerminalNode *RPAD();
    antlr4::tree::TerminalNode *RTRIM();
    antlr4::tree::TerminalNode *RULE();
    antlr4::tree::TerminalNode *RULES();
    antlr4::tree::TerminalNode *SALT();
    antlr4::tree::TerminalNode *SAMPLE();
    antlr4::tree::TerminalNode *SAVE_AS_INTERVALS();
    antlr4::tree::TerminalNode *SAVEPOINT();
    antlr4::tree::TerminalNode *SB4();
    antlr4::tree::TerminalNode *SCALE();
    antlr4::tree::TerminalNode *SCALE_ROWS();
    antlr4::tree::TerminalNode *SCAN_INSTANCES();
    antlr4::tree::TerminalNode *SCAN();
    antlr4::tree::TerminalNode *SCHEDULER();
    antlr4::tree::TerminalNode *SCHEMACHECK();
    antlr4::tree::TerminalNode *SCHEMA();
    antlr4::tree::TerminalNode *SCN_ASCENDING();
    antlr4::tree::TerminalNode *SCN();
    antlr4::tree::TerminalNode *SCOPE();
    antlr4::tree::TerminalNode *SD_ALL();
    antlr4::tree::TerminalNode *SD_INHIBIT();
    antlr4::tree::TerminalNode *SD_SHOW();
    antlr4::tree::TerminalNode *SEARCH();
    antlr4::tree::TerminalNode *SECOND();
    antlr4::tree::TerminalNode *SECUREFILE_DBA();
    antlr4::tree::TerminalNode *SECUREFILE();
    antlr4::tree::TerminalNode *SECURITY();
    antlr4::tree::TerminalNode *SEED();
    antlr4::tree::TerminalNode *SEG_BLOCK();
    antlr4::tree::TerminalNode *SEG_FILE();
    antlr4::tree::TerminalNode *SEGMENT();
    antlr4::tree::TerminalNode *SELECTIVITY();
    antlr4::tree::TerminalNode *SEMIJOIN_DRIVER();
    antlr4::tree::TerminalNode *SEMIJOIN();
    antlr4::tree::TerminalNode *SEMI_TO_INNER();
    antlr4::tree::TerminalNode *SEQUENCED();
    antlr4::tree::TerminalNode *SEQUENCE();
    antlr4::tree::TerminalNode *SEQUENTIAL();
    antlr4::tree::TerminalNode *SERIALIZABLE();
    antlr4::tree::TerminalNode *SERVERERROR();
    antlr4::tree::TerminalNode *SERVICE();
    antlr4::tree::TerminalNode *SESSION_CACHED_CURSORS();
    antlr4::tree::TerminalNode *SESSION();
    antlr4::tree::TerminalNode *SESSIONS_PER_USER();
    antlr4::tree::TerminalNode *SESSIONTIMEZONE();
    antlr4::tree::TerminalNode *SESSIONTZNAME();
    antlr4::tree::TerminalNode *SETS();
    antlr4::tree::TerminalNode *SETTINGS();
    antlr4::tree::TerminalNode *SET_TO_JOIN();
    antlr4::tree::TerminalNode *SEVERE();
    antlr4::tree::TerminalNode *SHARED();
    antlr4::tree::TerminalNode *SHARED_POOL();
    antlr4::tree::TerminalNode *SHOW();
    antlr4::tree::TerminalNode *SHRINK();
    antlr4::tree::TerminalNode *SHUTDOWN();
    antlr4::tree::TerminalNode *SIBLINGS();
    antlr4::tree::TerminalNode *SID();
    antlr4::tree::TerminalNode *SIGNAL_COMPONENT();
    antlr4::tree::TerminalNode *SIGNAL_FUNCTION();
    antlr4::tree::TerminalNode *SIGN();
    antlr4::tree::TerminalNode *SIMPLE();
    antlr4::tree::TerminalNode *SINGLE();
    antlr4::tree::TerminalNode *SINGLETASK();
    antlr4::tree::TerminalNode *SINH();
    antlr4::tree::TerminalNode *SIN();
    antlr4::tree::TerminalNode *SKIP_EXT_OPTIMIZER();
    antlr4::tree::TerminalNode *SKIP_();
    antlr4::tree::TerminalNode *SKIP_UNQ_UNUSABLE_IDX();
    antlr4::tree::TerminalNode *SKIP_UNUSABLE_INDEXES();
    antlr4::tree::TerminalNode *SMALLFILE();
    antlr4::tree::TerminalNode *SNAPSHOT();
    antlr4::tree::TerminalNode *SOME();
    antlr4::tree::TerminalNode *SORT();
    antlr4::tree::TerminalNode *SOUNDEX();
    antlr4::tree::TerminalNode *SOURCE();
    antlr4::tree::TerminalNode *SPACE_KEYWORD();
    antlr4::tree::TerminalNode *SPECIFICATION();
    antlr4::tree::TerminalNode *SPFILE();
    antlr4::tree::TerminalNode *SPLIT();
    antlr4::tree::TerminalNode *SPREADSHEET();
    antlr4::tree::TerminalNode *SQLLDR();
    antlr4::tree::TerminalNode *SQL();
    antlr4::tree::TerminalNode *SQL_TRACE();
    antlr4::tree::TerminalNode *SQL_MACRO();
    antlr4::tree::TerminalNode *SQRT();
    antlr4::tree::TerminalNode *STALE();
    antlr4::tree::TerminalNode *STANDALONE();
    antlr4::tree::TerminalNode *STANDBY_MAX_DATA_DELAY();
    antlr4::tree::TerminalNode *STANDBY();
    antlr4::tree::TerminalNode *STAR();
    antlr4::tree::TerminalNode *STAR_TRANSFORMATION();
    antlr4::tree::TerminalNode *STARTUP();
    antlr4::tree::TerminalNode *STATEMENT_ID();
    antlr4::tree::TerminalNode *STATEMENT_QUEUING();
    antlr4::tree::TerminalNode *STATEMENTS();
    antlr4::tree::TerminalNode *STATIC();
    antlr4::tree::TerminalNode *STATISTICS();
    antlr4::tree::TerminalNode *STATS_BINOMIAL_TEST();
    antlr4::tree::TerminalNode *STATS_CROSSTAB();
    antlr4::tree::TerminalNode *STATS_F_TEST();
    antlr4::tree::TerminalNode *STATS_KS_TEST();
    antlr4::tree::TerminalNode *STATS_MODE();
    antlr4::tree::TerminalNode *STATS_MW_TEST();
    antlr4::tree::TerminalNode *STATS_ONE_WAY_ANOVA();
    antlr4::tree::TerminalNode *STATS_T_TEST_INDEP();
    antlr4::tree::TerminalNode *STATS_T_TEST_INDEPU();
    antlr4::tree::TerminalNode *STATS_T_TEST_ONE();
    antlr4::tree::TerminalNode *STATS_T_TEST_PAIRED();
    antlr4::tree::TerminalNode *STATS_WSR_TEST();
    antlr4::tree::TerminalNode *STDDEV();
    antlr4::tree::TerminalNode *STDDEV_POP();
    antlr4::tree::TerminalNode *STDDEV_SAMP();
    antlr4::tree::TerminalNode *STOP();
    antlr4::tree::TerminalNode *STORAGE();
    antlr4::tree::TerminalNode *STORE();
    antlr4::tree::TerminalNode *STREAMS();
    antlr4::tree::TerminalNode *STRICT();
    antlr4::tree::TerminalNode *STRING();
    antlr4::tree::TerminalNode *STRIPE_COLUMNS();
    antlr4::tree::TerminalNode *STRIPE_WIDTH();
    antlr4::tree::TerminalNode *STRIP();
    antlr4::tree::TerminalNode *STRUCTURE();
    antlr4::tree::TerminalNode *SUBMULTISET();
    antlr4::tree::TerminalNode *SUBPARTITION();
    antlr4::tree::TerminalNode *SUBPARTITION_REL();
    antlr4::tree::TerminalNode *SUBPARTITIONS();
    antlr4::tree::TerminalNode *SUBQUERIES();
    antlr4::tree::TerminalNode *SUBQUERY_PRUNING();
    antlr4::tree::TerminalNode *SUBSTITUTABLE();
    antlr4::tree::TerminalNode *SUBSTR2();
    antlr4::tree::TerminalNode *SUBSTR4();
    antlr4::tree::TerminalNode *SUBSTRB();
    antlr4::tree::TerminalNode *SUBSTRC();
    antlr4::tree::TerminalNode *SUBSTR();
    antlr4::tree::TerminalNode *SUCCESSFUL();
    antlr4::tree::TerminalNode *SUMMARY();
    antlr4::tree::TerminalNode *SUM();
    antlr4::tree::TerminalNode *SUPPLEMENTAL();
    antlr4::tree::TerminalNode *SUSPEND();
    antlr4::tree::TerminalNode *SWAP_JOIN_INPUTS();
    antlr4::tree::TerminalNode *SWITCH();
    antlr4::tree::TerminalNode *SWITCHOVER();
    antlr4::tree::TerminalNode *SYNCHRONOUS();
    antlr4::tree::TerminalNode *SYNC();
    antlr4::tree::TerminalNode *SYS();
    antlr4::tree::TerminalNode *SYSASM();
    antlr4::tree::TerminalNode *SYS_AUDIT();
    antlr4::tree::TerminalNode *SYSAUX();
    antlr4::tree::TerminalNode *SYS_CHECKACL();
    antlr4::tree::TerminalNode *SYS_CONNECT_BY_PATH();
    antlr4::tree::TerminalNode *SYS_CONTEXT();
    antlr4::tree::TerminalNode *SYSDATE();
    antlr4::tree::TerminalNode *SYSDBA();
    antlr4::tree::TerminalNode *SYS_DBURIGEN();
    antlr4::tree::TerminalNode *SYS_DL_CURSOR();
    antlr4::tree::TerminalNode *SYS_DM_RXFORM_CHR();
    antlr4::tree::TerminalNode *SYS_DM_RXFORM_NUM();
    antlr4::tree::TerminalNode *SYS_DOM_COMPARE();
    antlr4::tree::TerminalNode *SYS_DST_PRIM2SEC();
    antlr4::tree::TerminalNode *SYS_DST_SEC2PRIM();
    antlr4::tree::TerminalNode *SYS_ET_BFILE_TO_RAW();
    antlr4::tree::TerminalNode *SYS_ET_BLOB_TO_IMAGE();
    antlr4::tree::TerminalNode *SYS_ET_IMAGE_TO_BLOB();
    antlr4::tree::TerminalNode *SYS_ET_RAW_TO_BFILE();
    antlr4::tree::TerminalNode *SYS_EXTPDTXT();
    antlr4::tree::TerminalNode *SYS_EXTRACT_UTC();
    antlr4::tree::TerminalNode *SYS_FBT_INSDEL();
    antlr4::tree::TerminalNode *SYS_FILTER_ACLS();
    antlr4::tree::TerminalNode *SYS_FNMATCHES();
    antlr4::tree::TerminalNode *SYS_FNREPLACE();
    antlr4::tree::TerminalNode *SYS_GET_ACLIDS();
    antlr4::tree::TerminalNode *SYS_GET_PRIVILEGES();
    antlr4::tree::TerminalNode *SYS_GETTOKENID();
    antlr4::tree::TerminalNode *SYS_GETXTIVAL();
    antlr4::tree::TerminalNode *SYS_GUID();
    antlr4::tree::TerminalNode *SYS_MAKEXML();
    antlr4::tree::TerminalNode *SYS_MAKE_XMLNODEID();
    antlr4::tree::TerminalNode *SYS_MKXMLATTR();
    antlr4::tree::TerminalNode *SYS_OP_ADT2BIN();
    antlr4::tree::TerminalNode *SYS_OP_ADTCONS();
    antlr4::tree::TerminalNode *SYS_OP_ALSCRVAL();
    antlr4::tree::TerminalNode *SYS_OP_ATG();
    antlr4::tree::TerminalNode *SYS_OP_BIN2ADT();
    antlr4::tree::TerminalNode *SYS_OP_BITVEC();
    antlr4::tree::TerminalNode *SYS_OP_BL2R();
    antlr4::tree::TerminalNode *SYS_OP_BLOOM_FILTER_LIST();
    antlr4::tree::TerminalNode *SYS_OP_BLOOM_FILTER();
    antlr4::tree::TerminalNode *SYS_OP_C2C();
    antlr4::tree::TerminalNode *SYS_OP_CAST();
    antlr4::tree::TerminalNode *SYS_OP_CEG();
    antlr4::tree::TerminalNode *SYS_OP_CL2C();
    antlr4::tree::TerminalNode *SYS_OP_COMBINED_HASH();
    antlr4::tree::TerminalNode *SYS_OP_COMP();
    antlr4::tree::TerminalNode *SYS_OP_CONVERT();
    antlr4::tree::TerminalNode *SYS_OP_COUNTCHG();
    antlr4::tree::TerminalNode *SYS_OP_CSCONV();
    antlr4::tree::TerminalNode *SYS_OP_CSCONVTEST();
    antlr4::tree::TerminalNode *SYS_OP_CSR();
    antlr4::tree::TerminalNode *SYS_OP_CSX_PATCH();
    antlr4::tree::TerminalNode *SYS_OP_DECOMP();
    antlr4::tree::TerminalNode *SYS_OP_DESCEND();
    antlr4::tree::TerminalNode *SYS_OP_DISTINCT();
    antlr4::tree::TerminalNode *SYS_OP_DRA();
    antlr4::tree::TerminalNode *SYS_OP_DUMP();
    antlr4::tree::TerminalNode *SYS_OP_DV_CHECK();
    antlr4::tree::TerminalNode *SYS_OP_ENFORCE_NOT_NULL();
    antlr4::tree::TerminalNode *SYSOPER();
    antlr4::tree::TerminalNode *SYS_OP_EXTRACT();
    antlr4::tree::TerminalNode *SYS_OP_GROUPING();
    antlr4::tree::TerminalNode *SYS_OP_GUID();
    antlr4::tree::TerminalNode *SYS_OP_IIX();
    antlr4::tree::TerminalNode *SYS_OP_ITR();
    antlr4::tree::TerminalNode *SYS_OP_LBID();
    antlr4::tree::TerminalNode *SYS_OP_LOBLOC2BLOB();
    antlr4::tree::TerminalNode *SYS_OP_LOBLOC2CLOB();
    antlr4::tree::TerminalNode *SYS_OP_LOBLOC2ID();
    antlr4::tree::TerminalNode *SYS_OP_LOBLOC2NCLOB();
    antlr4::tree::TerminalNode *SYS_OP_LOBLOC2TYP();
    antlr4::tree::TerminalNode *SYS_OP_LSVI();
    antlr4::tree::TerminalNode *SYS_OP_LVL();
    antlr4::tree::TerminalNode *SYS_OP_MAKEOID();
    antlr4::tree::TerminalNode *SYS_OP_MAP_NONNULL();
    antlr4::tree::TerminalNode *SYS_OP_MSR();
    antlr4::tree::TerminalNode *SYS_OP_NICOMBINE();
    antlr4::tree::TerminalNode *SYS_OP_NIEXTRACT();
    antlr4::tree::TerminalNode *SYS_OP_NII();
    antlr4::tree::TerminalNode *SYS_OP_NIX();
    antlr4::tree::TerminalNode *SYS_OP_NOEXPAND();
    antlr4::tree::TerminalNode *SYS_OP_NTCIMG();
    antlr4::tree::TerminalNode *SYS_OP_NUMTORAW();
    antlr4::tree::TerminalNode *SYS_OP_OIDVALUE();
    antlr4::tree::TerminalNode *SYS_OP_OPNSIZE();
    antlr4::tree::TerminalNode *SYS_OP_PAR_1();
    antlr4::tree::TerminalNode *SYS_OP_PARGID_1();
    antlr4::tree::TerminalNode *SYS_OP_PARGID();
    antlr4::tree::TerminalNode *SYS_OP_PAR();
    antlr4::tree::TerminalNode *SYS_OP_PIVOT();
    antlr4::tree::TerminalNode *SYS_OP_R2O();
    antlr4::tree::TerminalNode *SYS_OP_RAWTONUM();
    antlr4::tree::TerminalNode *SYS_OP_RDTM();
    antlr4::tree::TerminalNode *SYS_OP_REF();
    antlr4::tree::TerminalNode *SYS_OP_RMTD();
    antlr4::tree::TerminalNode *SYS_OP_ROWIDTOOBJ();
    antlr4::tree::TerminalNode *SYS_OP_RPB();
    antlr4::tree::TerminalNode *SYS_OPTLOBPRBSC();
    antlr4::tree::TerminalNode *SYS_OP_TOSETID();
    antlr4::tree::TerminalNode *SYS_OP_TPR();
    antlr4::tree::TerminalNode *SYS_OP_TRTB();
    antlr4::tree::TerminalNode *SYS_OPTXICMP();
    antlr4::tree::TerminalNode *SYS_OPTXQCASTASNQ();
    antlr4::tree::TerminalNode *SYS_OP_UNDESCEND();
    antlr4::tree::TerminalNode *SYS_OP_VECAND();
    antlr4::tree::TerminalNode *SYS_OP_VECBIT();
    antlr4::tree::TerminalNode *SYS_OP_VECOR();
    antlr4::tree::TerminalNode *SYS_OP_VECXOR();
    antlr4::tree::TerminalNode *SYS_OP_VERSION();
    antlr4::tree::TerminalNode *SYS_OP_VREF();
    antlr4::tree::TerminalNode *SYS_OP_VVD();
    antlr4::tree::TerminalNode *SYS_OP_XMLCONS_FOR_CSX();
    antlr4::tree::TerminalNode *SYS_OP_XPTHATG();
    antlr4::tree::TerminalNode *SYS_OP_XPTHIDX();
    antlr4::tree::TerminalNode *SYS_OP_XPTHOP();
    antlr4::tree::TerminalNode *SYS_OP_XTXT2SQLT();
    antlr4::tree::TerminalNode *SYS_ORDERKEY_DEPTH();
    antlr4::tree::TerminalNode *SYS_ORDERKEY_MAXCHILD();
    antlr4::tree::TerminalNode *SYS_ORDERKEY_PARENT();
    antlr4::tree::TerminalNode *SYS_PARALLEL_TXN();
    antlr4::tree::TerminalNode *SYS_PATHID_IS_ATTR();
    antlr4::tree::TerminalNode *SYS_PATHID_IS_NMSPC();
    antlr4::tree::TerminalNode *SYS_PATHID_LASTNAME();
    antlr4::tree::TerminalNode *SYS_PATHID_LASTNMSPC();
    antlr4::tree::TerminalNode *SYS_PATH_REVERSE();
    antlr4::tree::TerminalNode *SYS_PXQEXTRACT();
    antlr4::tree::TerminalNode *SYS_RID_ORDER();
    antlr4::tree::TerminalNode *SYS_ROW_DELTA();
    antlr4::tree::TerminalNode *SYS_SC_2_XMLT();
    antlr4::tree::TerminalNode *SYS_SYNRCIREDO();
    antlr4::tree::TerminalNode *SYSTEM_DEFINED();
    antlr4::tree::TerminalNode *SYSTEM();
    antlr4::tree::TerminalNode *SYSTIMESTAMP();
    antlr4::tree::TerminalNode *SYS_TYPEID();
    antlr4::tree::TerminalNode *SYS_UMAKEXML();
    antlr4::tree::TerminalNode *SYS_XMLANALYZE();
    antlr4::tree::TerminalNode *SYS_XMLCONTAINS();
    antlr4::tree::TerminalNode *SYS_XMLCONV();
    antlr4::tree::TerminalNode *SYS_XMLEXNSURI();
    antlr4::tree::TerminalNode *SYS_XMLGEN();
    antlr4::tree::TerminalNode *SYS_XMLI_LOC_ISNODE();
    antlr4::tree::TerminalNode *SYS_XMLI_LOC_ISTEXT();
    antlr4::tree::TerminalNode *SYS_XMLINSTR();
    antlr4::tree::TerminalNode *SYS_XMLLOCATOR_GETSVAL();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETCID();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETLOCATOR();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETOKEY();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETPATHID();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETPTRID();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETRID();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETSVAL();
    antlr4::tree::TerminalNode *SYS_XMLNODEID_GETTID();
    antlr4::tree::TerminalNode *SYS_XMLNODEID();
    antlr4::tree::TerminalNode *SYS_XMLT_2_SC();
    antlr4::tree::TerminalNode *SYS_XMLTRANSLATE();
    antlr4::tree::TerminalNode *SYS_XMLTYPE2SQL();
    antlr4::tree::TerminalNode *SYS_XQ_ASQLCNV();
    antlr4::tree::TerminalNode *SYS_XQ_ATOMCNVCHK();
    antlr4::tree::TerminalNode *SYS_XQBASEURI();
    antlr4::tree::TerminalNode *SYS_XQCASTABLEERRH();
    antlr4::tree::TerminalNode *SYS_XQCODEP2STR();
    antlr4::tree::TerminalNode *SYS_XQCODEPEQ();
    antlr4::tree::TerminalNode *SYS_XQCON2SEQ();
    antlr4::tree::TerminalNode *SYS_XQCONCAT();
    antlr4::tree::TerminalNode *SYS_XQDELETE();
    antlr4::tree::TerminalNode *SYS_XQDFLTCOLATION();
    antlr4::tree::TerminalNode *SYS_XQDOC();
    antlr4::tree::TerminalNode *SYS_XQDOCURI();
    antlr4::tree::TerminalNode *SYS_XQDURDIV();
    antlr4::tree::TerminalNode *SYS_XQED4URI();
    antlr4::tree::TerminalNode *SYS_XQENDSWITH();
    antlr4::tree::TerminalNode *SYS_XQERRH();
    antlr4::tree::TerminalNode *SYS_XQERR();
    antlr4::tree::TerminalNode *SYS_XQESHTMLURI();
    antlr4::tree::TerminalNode *SYS_XQEXLOBVAL();
    antlr4::tree::TerminalNode *SYS_XQEXSTWRP();
    antlr4::tree::TerminalNode *SYS_XQEXTRACT();
    antlr4::tree::TerminalNode *SYS_XQEXTRREF();
    antlr4::tree::TerminalNode *SYS_XQEXVAL();
    antlr4::tree::TerminalNode *SYS_XQFB2STR();
    antlr4::tree::TerminalNode *SYS_XQFNBOOL();
    antlr4::tree::TerminalNode *SYS_XQFNCMP();
    antlr4::tree::TerminalNode *SYS_XQFNDATIM();
    antlr4::tree::TerminalNode *SYS_XQFNLNAME();
    antlr4::tree::TerminalNode *SYS_XQFNNM();
    antlr4::tree::TerminalNode *SYS_XQFNNSURI();
    antlr4::tree::TerminalNode *SYS_XQFNPREDTRUTH();
    antlr4::tree::TerminalNode *SYS_XQFNQNM();
    antlr4::tree::TerminalNode *SYS_XQFNROOT();
    antlr4::tree::TerminalNode *SYS_XQFORMATNUM();
    antlr4::tree::TerminalNode *SYS_XQFTCONTAIN();
    antlr4::tree::TerminalNode *SYS_XQFUNCR();
    antlr4::tree::TerminalNode *SYS_XQGETCONTENT();
    antlr4::tree::TerminalNode *SYS_XQINDXOF();
    antlr4::tree::TerminalNode *SYS_XQINSERT();
    antlr4::tree::TerminalNode *SYS_XQINSPFX();
    antlr4::tree::TerminalNode *SYS_XQIRI2URI();
    antlr4::tree::TerminalNode *SYS_XQLANG();
    antlr4::tree::TerminalNode *SYS_XQLLNMFRMQNM();
    antlr4::tree::TerminalNode *SYS_XQMKNODEREF();
    antlr4::tree::TerminalNode *SYS_XQNILLED();
    antlr4::tree::TerminalNode *SYS_XQNODENAME();
    antlr4::tree::TerminalNode *SYS_XQNORMSPACE();
    antlr4::tree::TerminalNode *SYS_XQNORMUCODE();
    antlr4::tree::TerminalNode *SYS_XQ_NRNG();
    antlr4::tree::TerminalNode *SYS_XQNSP4PFX();
    antlr4::tree::TerminalNode *SYS_XQNSPFRMQNM();
    antlr4::tree::TerminalNode *SYS_XQPFXFRMQNM();
    antlr4::tree::TerminalNode *SYS_XQ_PKSQL2XML();
    antlr4::tree::TerminalNode *SYS_XQPOLYABS();
    antlr4::tree::TerminalNode *SYS_XQPOLYADD();
    antlr4::tree::TerminalNode *SYS_XQPOLYCEL();
    antlr4::tree::TerminalNode *SYS_XQPOLYCSTBL();
    antlr4::tree::TerminalNode *SYS_XQPOLYCST();
    antlr4::tree::TerminalNode *SYS_XQPOLYDIV();
    antlr4::tree::TerminalNode *SYS_XQPOLYFLR();
    antlr4::tree::TerminalNode *SYS_XQPOLYMOD();
    antlr4::tree::TerminalNode *SYS_XQPOLYMUL();
    antlr4::tree::TerminalNode *SYS_XQPOLYRND();
    antlr4::tree::TerminalNode *SYS_XQPOLYSQRT();
    antlr4::tree::TerminalNode *SYS_XQPOLYSUB();
    antlr4::tree::TerminalNode *SYS_XQPOLYUMUS();
    antlr4::tree::TerminalNode *SYS_XQPOLYUPLS();
    antlr4::tree::TerminalNode *SYS_XQPOLYVEQ();
    antlr4::tree::TerminalNode *SYS_XQPOLYVGE();
    antlr4::tree::TerminalNode *SYS_XQPOLYVGT();
    antlr4::tree::TerminalNode *SYS_XQPOLYVLE();
    antlr4::tree::TerminalNode *SYS_XQPOLYVLT();
    antlr4::tree::TerminalNode *SYS_XQPOLYVNE();
    antlr4::tree::TerminalNode *SYS_XQREF2VAL();
    antlr4::tree::TerminalNode *SYS_XQRENAME();
    antlr4::tree::TerminalNode *SYS_XQREPLACE();
    antlr4::tree::TerminalNode *SYS_XQRESVURI();
    antlr4::tree::TerminalNode *SYS_XQRNDHALF2EVN();
    antlr4::tree::TerminalNode *SYS_XQRSLVQNM();
    antlr4::tree::TerminalNode *SYS_XQRYENVPGET();
    antlr4::tree::TerminalNode *SYS_XQRYVARGET();
    antlr4::tree::TerminalNode *SYS_XQRYWRP();
    antlr4::tree::TerminalNode *SYS_XQSEQ2CON4XC();
    antlr4::tree::TerminalNode *SYS_XQSEQ2CON();
    antlr4::tree::TerminalNode *SYS_XQSEQDEEPEQ();
    antlr4::tree::TerminalNode *SYS_XQSEQINSB();
    antlr4::tree::TerminalNode *SYS_XQSEQRM();
    antlr4::tree::TerminalNode *SYS_XQSEQRVS();
    antlr4::tree::TerminalNode *SYS_XQSEQSUB();
    antlr4::tree::TerminalNode *SYS_XQSEQTYPMATCH();
    antlr4::tree::TerminalNode *SYS_XQSTARTSWITH();
    antlr4::tree::TerminalNode *SYS_XQSTATBURI();
    antlr4::tree::TerminalNode *SYS_XQSTR2CODEP();
    antlr4::tree::TerminalNode *SYS_XQSTRJOIN();
    antlr4::tree::TerminalNode *SYS_XQSUBSTRAFT();
    antlr4::tree::TerminalNode *SYS_XQSUBSTRBEF();
    antlr4::tree::TerminalNode *SYS_XQTOKENIZE();
    antlr4::tree::TerminalNode *SYS_XQTREATAS();
    antlr4::tree::TerminalNode *SYS_XQ_UPKXML2SQL();
    antlr4::tree::TerminalNode *SYS_XQXFORM();
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *TABLE_LOOKUP_BY_NL();
    antlr4::tree::TerminalNode *TABLES();
    antlr4::tree::TerminalNode *TABLESPACE();
    antlr4::tree::TerminalNode *TABLESPACE_NO();
    antlr4::tree::TerminalNode *TABLE_STATS();
    antlr4::tree::TerminalNode *TABNO();
    antlr4::tree::TerminalNode *TANH();
    antlr4::tree::TerminalNode *TAN();
    antlr4::tree::TerminalNode *TBLORIDXPARTNUM();
    antlr4::tree::TerminalNode *TEMPFILE();
    antlr4::tree::TerminalNode *TEMPLATE();
    antlr4::tree::TerminalNode *TEMPLATE_TABLE();
    antlr4::tree::TerminalNode *TEMPORARY();
    antlr4::tree::TerminalNode *TEMP_TABLE();
    antlr4::tree::TerminalNode *TEST();
    antlr4::tree::TerminalNode *THAN();
    antlr4::tree::TerminalNode *THE();
    antlr4::tree::TerminalNode *THEN();
    antlr4::tree::TerminalNode *THREAD();
    antlr4::tree::TerminalNode *THROUGH();
    antlr4::tree::TerminalNode *TIME();
    antlr4::tree::TerminalNode *TIMING();
    antlr4::tree::TerminalNode *TIMEOUT();
    antlr4::tree::TerminalNode *TIMES();
    antlr4::tree::TerminalNode *TIMESTAMP();
    antlr4::tree::TerminalNode *TIMEZONE();
    antlr4::tree::TerminalNode *TIMEZONE_ABBR();
    antlr4::tree::TerminalNode *TIMEZONE_HOUR();
    antlr4::tree::TerminalNode *TIMEZONE_MINUTE();
    antlr4::tree::TerminalNode *TIME_ZONE();
    antlr4::tree::TerminalNode *TIMEZONE_OFFSET();
    antlr4::tree::TerminalNode *TIMEZONE_REGION();
    antlr4::tree::TerminalNode *TIV_GB();
    antlr4::tree::TerminalNode *TIV_SSF();
    antlr4::tree::TerminalNode *TO_BINARY_DOUBLE();
    antlr4::tree::TerminalNode *TO_BINARY_FLOAT();
    antlr4::tree::TerminalNode *TO_BLOB();
    antlr4::tree::TerminalNode *TO_CHAR();
    antlr4::tree::TerminalNode *TO_CLOB();
    antlr4::tree::TerminalNode *TO_DATE();
    antlr4::tree::TerminalNode *TO_DSINTERVAL();
    antlr4::tree::TerminalNode *TO_LOB();
    antlr4::tree::TerminalNode *TO_MULTI_BYTE();
    antlr4::tree::TerminalNode *TO_NCHAR();
    antlr4::tree::TerminalNode *TO_NCLOB();
    antlr4::tree::TerminalNode *TO_NUMBER();
    antlr4::tree::TerminalNode *TOPLEVEL();
    antlr4::tree::TerminalNode *TO_SINGLE_BYTE();
    antlr4::tree::TerminalNode *TO_TIME();
    antlr4::tree::TerminalNode *TO_TIMESTAMP();
    antlr4::tree::TerminalNode *TO_TIMESTAMP_TZ();
    antlr4::tree::TerminalNode *TO_TIME_TZ();
    antlr4::tree::TerminalNode *TO_YMINTERVAL();
    antlr4::tree::TerminalNode *TRACE();
    antlr4::tree::TerminalNode *TRACING();
    antlr4::tree::TerminalNode *TRACKING();
    antlr4::tree::TerminalNode *TRAILING();
    antlr4::tree::TerminalNode *TRANSACTION();
    antlr4::tree::TerminalNode *TRANSFORM_DISTINCT_AGG();
    antlr4::tree::TerminalNode *TRANSITIONAL();
    antlr4::tree::TerminalNode *TRANSITION();
    antlr4::tree::TerminalNode *TRANSLATE();
    antlr4::tree::TerminalNode *TREAT();
    antlr4::tree::TerminalNode *TRIGGERS();
    antlr4::tree::TerminalNode *TRIM();
    antlr4::tree::TerminalNode *TRUE();
    antlr4::tree::TerminalNode *TRUNCATE();
    antlr4::tree::TerminalNode *TRUNC();
    antlr4::tree::TerminalNode *TRUSTED();
    antlr4::tree::TerminalNode *TUNING();
    antlr4::tree::TerminalNode *TX();
    antlr4::tree::TerminalNode *TYPE();
    antlr4::tree::TerminalNode *TYPES();
    antlr4::tree::TerminalNode *TZ_OFFSET();
    antlr4::tree::TerminalNode *UB2();
    antlr4::tree::TerminalNode *UBA();
    antlr4::tree::TerminalNode *UID();
    antlr4::tree::TerminalNode *UNARCHIVED();
    antlr4::tree::TerminalNode *UNBOUNDED();
    antlr4::tree::TerminalNode *UNBOUND();
    antlr4::tree::TerminalNode *UNDER();
    antlr4::tree::TerminalNode *UNDO();
    antlr4::tree::TerminalNode *UNDROP();
    antlr4::tree::TerminalNode *UNIFORM();
    antlr4::tree::TerminalNode *UNISTR();
    antlr4::tree::TerminalNode *UNLIMITED();
    antlr4::tree::TerminalNode *UNLOAD();
    antlr4::tree::TerminalNode *UNLOCK();
    antlr4::tree::TerminalNode *UNNEST_INNERJ_DISTINCT_VIEW();
    antlr4::tree::TerminalNode *UNNEST();
    antlr4::tree::TerminalNode *UNNEST_NOSEMIJ_NODISTINCTVIEW();
    antlr4::tree::TerminalNode *UNNEST_SEMIJ_VIEW();
    antlr4::tree::TerminalNode *UNPACKED();
    antlr4::tree::TerminalNode *UNPIVOT();
    antlr4::tree::TerminalNode *UNPROTECTED();
    antlr4::tree::TerminalNode *UNQUIESCE();
    antlr4::tree::TerminalNode *UNRECOVERABLE();
    antlr4::tree::TerminalNode *UNRESTRICTED();
    antlr4::tree::TerminalNode *UNTIL();
    antlr4::tree::TerminalNode *UNUSABLE();
    antlr4::tree::TerminalNode *UNUSED();
    antlr4::tree::TerminalNode *UPDATABLE();
    antlr4::tree::TerminalNode *UPDATED();
    antlr4::tree::TerminalNode *UPDATEXML();
    antlr4::tree::TerminalNode *UPD_INDEXES();
    antlr4::tree::TerminalNode *UPD_JOININDEX();
    antlr4::tree::TerminalNode *UPGRADE();
    antlr4::tree::TerminalNode *UPPER();
    antlr4::tree::TerminalNode *UPSERT();
    antlr4::tree::TerminalNode *UROWID();
    antlr4::tree::TerminalNode *USAGE();
    antlr4::tree::TerminalNode *USE_ANTI();
    antlr4::tree::TerminalNode *USE_CONCAT();
    antlr4::tree::TerminalNode *USE_HASH_AGGREGATION();
    antlr4::tree::TerminalNode *USE_HASH_GBY_FOR_PUSHDOWN();
    antlr4::tree::TerminalNode *USE_HASH();
    antlr4::tree::TerminalNode *USE_INVISIBLE_INDEXES();
    antlr4::tree::TerminalNode *USE_MERGE_CARTESIAN();
    antlr4::tree::TerminalNode *USE_MERGE();
    antlr4::tree::TerminalNode *USE();
    antlr4::tree::TerminalNode *USE_NL();
    antlr4::tree::TerminalNode *USE_NL_WITH_INDEX();
    antlr4::tree::TerminalNode *USE_PRIVATE_OUTLINES();
    antlr4::tree::TerminalNode *USER_DEFINED();
    antlr4::tree::TerminalNode *USERENV();
    antlr4::tree::TerminalNode *USERGROUP();
    antlr4::tree::TerminalNode *USER();
    antlr4::tree::TerminalNode *USER_RECYCLEBIN();
    antlr4::tree::TerminalNode *USERS();
    antlr4::tree::TerminalNode *USE_SEMI();
    antlr4::tree::TerminalNode *USE_STORED_OUTLINES();
    antlr4::tree::TerminalNode *USE_TTT_FOR_GSETS();
    antlr4::tree::TerminalNode *USE_WEAK_NAME_RESL();
    antlr4::tree::TerminalNode *USING();
    antlr4::tree::TerminalNode *VALIDATE();
    antlr4::tree::TerminalNode *VALIDATION();
    antlr4::tree::TerminalNode *VALUE();
    antlr4::tree::TerminalNode *VARIANCE();
    antlr4::tree::TerminalNode *VAR_POP();
    antlr4::tree::TerminalNode *VARRAY();
    antlr4::tree::TerminalNode *VARRAYS();
    antlr4::tree::TerminalNode *VAR_SAMP();
    antlr4::tree::TerminalNode *VARYING();
    antlr4::tree::TerminalNode *VECTOR_READ();
    antlr4::tree::TerminalNode *VECTOR_READ_TRACE();
    antlr4::tree::TerminalNode *VERIFY();
    antlr4::tree::TerminalNode *VERSIONING();
    antlr4::tree::TerminalNode *VERSION();
    antlr4::tree::TerminalNode *VERSIONS_ENDSCN();
    antlr4::tree::TerminalNode *VERSIONS_ENDTIME();
    antlr4::tree::TerminalNode *VERSIONS();
    antlr4::tree::TerminalNode *VERSIONS_OPERATION();
    antlr4::tree::TerminalNode *VERSIONS_STARTSCN();
    antlr4::tree::TerminalNode *VERSIONS_STARTTIME();
    antlr4::tree::TerminalNode *VERSIONS_XID();
    antlr4::tree::TerminalNode *VIRTUAL();
    antlr4::tree::TerminalNode *VISIBLE();
    antlr4::tree::TerminalNode *VOLUME();
    antlr4::tree::TerminalNode *VSIZE();
    antlr4::tree::TerminalNode *WAIT();
    antlr4::tree::TerminalNode *WALLET();
    antlr4::tree::TerminalNode *WELLFORMED();
    antlr4::tree::TerminalNode *WHENEVER();
    antlr4::tree::TerminalNode *WHEN();
    antlr4::tree::TerminalNode *WHITESPACE();
    antlr4::tree::TerminalNode *WIDTH_BUCKET();
    antlr4::tree::TerminalNode *WITHIN();
    antlr4::tree::TerminalNode *WITHOUT();
    antlr4::tree::TerminalNode *WORK();
    antlr4::tree::TerminalNode *WRAPPED();
    antlr4::tree::TerminalNode *WRITE();
    antlr4::tree::TerminalNode *XDB_FASTPATH_INSERT();
    antlr4::tree::TerminalNode *X_DYN_PRUNE();
    antlr4::tree::TerminalNode *XID();
    antlr4::tree::TerminalNode *XML2OBJECT();
    antlr4::tree::TerminalNode *XMLATTRIBUTES();
    antlr4::tree::TerminalNode *XMLCAST();
    antlr4::tree::TerminalNode *XMLCDATA();
    antlr4::tree::TerminalNode *XMLCOLATTVAL();
    antlr4::tree::TerminalNode *XMLCOMMENT();
    antlr4::tree::TerminalNode *XMLCONCAT();
    antlr4::tree::TerminalNode *XMLDIFF();
    antlr4::tree::TerminalNode *XML_DML_RWT_STMT();
    antlr4::tree::TerminalNode *XMLELEMENT();
    antlr4::tree::TerminalNode *XMLEXISTS2();
    antlr4::tree::TerminalNode *XMLEXISTS();
    antlr4::tree::TerminalNode *XMLFOREST();
    antlr4::tree::TerminalNode *XMLINDEX_REWRITE_IN_SELECT();
    antlr4::tree::TerminalNode *XMLINDEX_REWRITE();
    antlr4::tree::TerminalNode *XMLINDEX_SEL_IDX_TBL();
    antlr4::tree::TerminalNode *XMLISNODE();
    antlr4::tree::TerminalNode *XMLISVALID();
    antlr4::tree::TerminalNode *XML();
    antlr4::tree::TerminalNode *XMLNAMESPACES();
    antlr4::tree::TerminalNode *XMLPARSE();
    antlr4::tree::TerminalNode *XMLPATCH();
    antlr4::tree::TerminalNode *XMLPI();
    antlr4::tree::TerminalNode *XMLQUERY();
    antlr4::tree::TerminalNode *XMLQUERYVAL();
    antlr4::tree::TerminalNode *XMLROOT();
    antlr4::tree::TerminalNode *XMLSCHEMA();
    antlr4::tree::TerminalNode *XMLSERIALIZE();
    antlr4::tree::TerminalNode *XMLTABLE();
    antlr4::tree::TerminalNode *XMLTRANSFORMBLOB();
    antlr4::tree::TerminalNode *XMLTRANSFORM();
    antlr4::tree::TerminalNode *XMLTYPE();
    antlr4::tree::TerminalNode *XPATHTABLE();
    antlr4::tree::TerminalNode *XS_SYS_CONTEXT();
    antlr4::tree::TerminalNode *YEAR();
    antlr4::tree::TerminalNode *YES();
    antlr4::tree::TerminalNode *ZONE();


    virtual std::any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
   
  };

  Non_reserved_keywords_pre12cContext* non_reserved_keywords_pre12c();


  bool sempred(antlr4::RuleContext *_localctx, size_t ruleIndex, size_t predicateIndex) override;

  bool unified_auditingSempred(Unified_auditingContext *_localctx, size_t predicateIndex);
  bool audit_direct_pathSempred(Audit_direct_pathContext *_localctx, size_t predicateIndex);
  bool audit_container_clauseSempred(Audit_container_clauseContext *_localctx, size_t predicateIndex);
  bool auditing_on_clauseSempred(Auditing_on_clauseContext *_localctx, size_t predicateIndex);
  bool sql_statement_shortcutSempred(Sql_statement_shortcutContext *_localctx, size_t predicateIndex);
  bool library_editionableSempred(Library_editionableContext *_localctx, size_t predicateIndex);
  bool library_debugSempred(Library_debugContext *_localctx, size_t predicateIndex);
  bool alter_view_editionableSempred(Alter_view_editionableContext *_localctx, size_t predicateIndex);
  bool external_table_condition_clauseSempred(External_table_condition_clauseContext *_localctx, size_t predicateIndex);
  bool partial_database_recovery_10gSempred(Partial_database_recovery_10gContext *_localctx, size_t predicateIndex);
  bool period_definitionSempred(Period_definitionContext *_localctx, size_t predicateIndex);
  bool dml_table_expression_clauseSempred(Dml_table_expression_clauseContext *_localctx, size_t predicateIndex);
  bool logical_expressionSempred(Logical_expressionContext *_localctx, size_t predicateIndex);
  bool multiset_expressionSempred(Multiset_expressionContext *_localctx, size_t predicateIndex);
  bool relational_expressionSempred(Relational_expressionContext *_localctx, size_t predicateIndex);
  bool concatenationSempred(ConcatenationContext *_localctx, size_t predicateIndex);
  bool unary_expressionSempred(Unary_expressionContext *_localctx, size_t predicateIndex);
  bool string_delimiterSempred(String_delimiterContext *_localctx, size_t predicateIndex);
  bool general_elementSempred(General_elementContext *_localctx, size_t predicateIndex);

  // By default the static state used to implement the parser is lazily initialized during the first
  // call to the constructor. You can call this function if you wish to initialize the static state
  // ahead of time.
  static void initialize();

private:
};

