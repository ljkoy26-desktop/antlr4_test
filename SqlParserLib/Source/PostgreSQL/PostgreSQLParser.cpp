
// Generated from PostgreSQLParser.g4 by ANTLR 4.13.2


#include "PostgreSQLParserVisitor.h"

#include "PostgreSQLParser.h"


using namespace antlrcpp;
using namespace antlrcpp_postgresql;

using namespace antlr4;

namespace {

struct PostgreSQLParserStaticData final {
  PostgreSQLParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  PostgreSQLParserStaticData(const PostgreSQLParserStaticData&) = delete;
  PostgreSQLParserStaticData(PostgreSQLParserStaticData&&) = delete;
  PostgreSQLParserStaticData& operator=(const PostgreSQLParserStaticData&) = delete;
  PostgreSQLParserStaticData& operator=(PostgreSQLParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag postgresqlparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
std::unique_ptr<PostgreSQLParserStaticData> postgresqlparserParserStaticData = nullptr;

void postgresqlparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (postgresqlparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(postgresqlparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<PostgreSQLParserStaticData>(
    std::vector<std::string>{
      "root", "stmtblock", "stmtmulti", "stmt", "callstmt", "createrolestmt", 
      "with_", "optrolelist", "alteroptrolelist", "alteroptroleelem", "createoptroleelem", 
      "createuserstmt", "alterrolestmt", "in_database_", "alterrolesetstmt", 
      "droprolestmt", "creategroupstmt", "altergroupstmt", "add_drop", "createschemastmt", 
      "optschemaname", "optschemaeltlist", "schema_stmt", "variablesetstmt", 
      "set_rest", "generic_set", "set_rest_more", "var_name", "var_list", 
      "var_value", "iso_level", "boolean_or_string_", "zone_value", "encoding_", 
      "nonreservedword_or_sconst", "variableresetstmt", "reset_rest", "generic_reset", 
      "setresetclause", "functionsetresetclause", "variableshowstmt", "constraintssetstmt", 
      "constraints_set_list", "constraints_set_mode", "checkpointstmt", 
      "discardstmt", "altertablestmt", "alter_table_cmds", "partition_cmd", 
      "index_partition_cmd", "alter_table_cmd", "alter_column_default", 
      "drop_behavior_", "collate_clause_", "alter_using", "replica_identity", 
      "reloptions", "reloptions_", "reloption_list", "reloption_elem", "alter_identity_column_option_list", 
      "alter_identity_column_option", "partitionboundspec", "hash_partbound_elem", 
      "hash_partbound", "altercompositetypestmt", "alter_type_cmds", "alter_type_cmd", 
      "closeportalstmt", "copystmt", "copy_from", "program_", "copy_file_name", 
      "copy_options", "copy_opt_list", "copy_opt_item", "binary_", "copy_delimiter", 
      "using_", "copy_generic_opt_list", "copy_generic_opt_elem", "copy_generic_opt_arg", 
      "copy_generic_opt_arg_list", "copy_generic_opt_arg_list_item", "createstmt", 
      "opttemp", "opttableelementlist", "opttypedtableelementlist", "tableelementlist", 
      "typedtableelementlist", "tableelement", "typedtableelement", "columnDef", 
      "columnOptions", "colquallist", "colconstraint", "colconstraintelem", 
      "generated_when", "constraintattr", "tablelikeclause", "tablelikeoptionlist", 
      "tablelikeoption", "tableconstraint", "constraintelem", "no_inherit_", 
      "column_list_", "columnlist", "columnElem", "c_include_", "key_match", 
      "exclusionconstraintlist", "exclusionconstraintelem", "exclusionwhereclause", 
      "key_actions", "key_update", "key_delete", "key_action", "optinherit", 
      "optpartitionspec", "partitionspec", "part_params", "part_elem", "table_access_method_clause", 
      "optwith", "oncommitoption", "opttablespace", "optconstablespace", 
      "existingindex", "createstatsstmt", "alterstatsstmt", "createasstmt", 
      "create_as_target", "with_data_", "creatematviewstmt", "create_mv_target", 
      "optnolog", "refreshmatviewstmt", "createseqstmt", "alterseqstmt", 
      "optseqoptlist", "optparenthesizedseqoptlist", "seqoptlist", "seqoptelem", 
      "by_", "numericonly", "numericonly_list", "createplangstmt", "trusted_", 
      "handler_name", "inline_handler_", "validator_clause", "validator_", 
      "procedural_", "createtablespacestmt", "opttablespaceowner", "droptablespacestmt", 
      "createextensionstmt", "create_extension_opt_list", "create_extension_opt_item", 
      "alterextensionstmt", "alter_extension_opt_list", "alter_extension_opt_item", 
      "alterextensioncontentsstmt", "createfdwstmt", "fdw_option", "fdw_options", 
      "fdw_options_", "alterfdwstmt", "create_generic_options", "generic_option_list", 
      "alter_generic_options", "alter_generic_option_list", "alter_generic_option_elem", 
      "generic_option_elem", "generic_option_name", "generic_option_arg", 
      "createforeignserverstmt", "type_", "foreign_server_version", "foreign_server_version_", 
      "alterforeignserverstmt", "createforeigntablestmt", "importforeignschemastmt", 
      "import_qualification_type", "import_qualification", "createusermappingstmt", 
      "auth_ident", "dropusermappingstmt", "alterusermappingstmt", "createpolicystmt", 
      "alterpolicystmt", "rowsecurityoptionalexpr", "rowsecurityoptionalwithcheck", 
      "rowsecuritydefaulttorole", "rowsecurityoptionaltorole", "rowsecuritydefaultpermissive", 
      "rowsecuritydefaultforcmd", "row_security_cmd", "createamstmt", "am_type", 
      "createtrigstmt", "triggeractiontime", "triggerevents", "triggeroneevent", 
      "triggerreferencing", "triggertransitions", "triggertransition", "transitionoldornew", 
      "transitionrowortable", "transitionrelname", "triggerforspec", "triggerforopteach", 
      "triggerfortype", "triggerwhen", "function_or_procedure", "triggerfuncargs", 
      "triggerfuncarg", "optconstrfromtable", "constraintattributespec", 
      "constraintattributeElem", "createeventtrigstmt", "event_trigger_when_list", 
      "event_trigger_when_item", "event_trigger_value_list", "altereventtrigstmt", 
      "enable_trigger", "createassertionstmt", "definestmt", "definition", 
      "def_list", "def_elem", "def_arg", "old_aggr_definition", "old_aggr_list", 
      "old_aggr_elem", "enum_val_list_", "enum_val_list", "alterenumstmt", 
      "if_not_exists_", "createopclassstmt", "opclass_item_list", "opclass_item", 
      "default_", "opfamily_", "opclass_purpose", "recheck_", "createopfamilystmt", 
      "alteropfamilystmt", "opclass_drop_list", "opclass_drop", "dropopclassstmt", 
      "dropopfamilystmt", "dropownedstmt", "reassignownedstmt", "dropstmt", 
      "object_type_any_name", "object_type_name", "drop_type_name", "object_type_name_on_any_name", 
      "any_name_list_", "any_name", "attrs", "type_name_list", "truncatestmt", 
      "restart_seqs_", "commentstmt", "comment_text", "seclabelstmt", "provider_", 
      "security_label", "fetchstmt", "fetch_args", "from_in", "from_in_", 
      "grantstmt", "revokestmt", "privileges", "privilege_list", "privilege", 
      "privilege_target", "grantee_list", "grantee", "grant_grant_option_", 
      "grantrolestmt", "revokerolestmt", "grant_admin_option_", "granted_by_", 
      "alterdefaultprivilegesstmt", "defacloptionlist", "defacloption", 
      "defaclaction", "defacl_privilege_target", "indexstmt", "unique_", 
      "nulls_distinct", "single_name_", "concurrently_", "index_name_", 
      "access_method_clause", "index_params", "index_elem_options", "index_elem", 
      "include_", "index_including_params", "collate_", "class_", "asc_desc_", 
      "nulls_order_", "createfunctionstmt", "or_replace_", "func_args", 
      "func_args_list", "function_with_argtypes_list", "function_with_argtypes", 
      "func_args_with_defaults", "func_args_with_defaults_list", "func_arg", 
      "arg_class", "param_name", "func_return", "func_type", "func_arg_with_default", 
      "aggr_arg", "aggr_args", "aggr_args_list", "aggregate_with_argtypes", 
      "aggregate_with_argtypes_list", "createfunc_opt_list", "common_func_opt_item", 
      "createfunc_opt_item", "func_as", "transform_type_list", "definition_", 
      "table_func_column", "table_func_column_list", "alterfunctionstmt", 
      "alterfunc_opt_list", "restrict_", "removefuncstmt", "removeaggrstmt", 
      "removeoperstmt", "oper_argtypes", "any_operator", "operator_with_argtypes_list", 
      "operator_with_argtypes", "dostmt", "dostmt_opt_list", "dostmt_opt_item", 
      "createcaststmt", "cast_context", "dropcaststmt", "if_exists_", "createtransformstmt", 
      "transform_element_list", "droptransformstmt", "reindexstmt", "reindex_target_relation", 
      "reindex_target_all", "reindex_option_list", "altertblspcstmt", "renamestmt", 
      "column_", "set_data_", "alterobjectdependsstmt", "no_", "alterobjectschemastmt", 
      "alteroperatorstmt", "operator_def_list", "operator_def_elem", "operator_def_arg", 
      "altertypestmt", "alterownerstmt", "createpublicationstmt", "publication_for_tables_", 
      "publication_for_tables", "alterpublicationstmt", "createsubscriptionstmt", 
      "publication_name_list", "publication_name_item", "altersubscriptionstmt", 
      "dropsubscriptionstmt", "rulestmt", "ruleactionlist", "ruleactionmulti", 
      "ruleactionstmt", "ruleactionstmtOrEmpty", "event", "instead_", "notifystmt", 
      "notify_payload", "listenstmt", "unlistenstmt", "transactionstmt", 
      "transaction_", "transaction_mode_item", "transaction_mode_list", 
      "transaction_mode_list_or_empty", "transaction_chain_", "viewstmt", 
      "check_option_", "loadstmt", "createdbstmt", "createdb_opt_list", 
      "createdb_opt_items", "createdb_opt_item", "createdb_opt_name", "equal_", 
      "alterdatabasestmt", "alterdatabasesetstmt", "dropdbstmt", "drop_option_list", 
      "drop_option", "altercollationstmt", "altersystemstmt", "createdomainstmt", 
      "alterdomainstmt", "as_", "altertsdictionarystmt", "altertsconfigurationstmt", 
      "any_with", "createconversionstmt", "clusterstmt", "cluster_index_specification", 
      "vacuumstmt", "analyzestmt", "utility_option_list", "vac_analyze_option_list", 
      "analyze_keyword", "utility_option_elem", "utility_option_name", "utility_option_arg", 
      "vac_analyze_option_elem", "vac_analyze_option_name", "vac_analyze_option_arg", 
      "analyze_", "verbose_", "full_", "freeze_", "name_list_", "vacuum_relation", 
      "vacuum_relation_list", "vacuum_relation_list_", "explainstmt", "explainablestmt", 
      "explain_option_list", "explain_option_elem", "explain_option_name", 
      "explain_option_arg", "preparestmt", "prep_type_clause", "preparablestmt", 
      "executestmt", "execute_param_clause", "deallocatestmt", "insertstmt", 
      "insert_target", "insert_rest", "override_kind", "insert_column_list", 
      "insert_column_item", "on_conflict_", "conf_expr_", "returning_clause", 
      "mergestmt", "merge_insert_clause", "merge_update_clause", "merge_delete_clause", 
      "deletestmt", "using_clause", "lockstmt", "lock_", "lock_type", "nowait_", 
      "nowait_or_skip_", "updatestmt", "set_clause_list", "set_clause", 
      "set_target", "set_target_list", "declarecursorstmt", "cursor_name", 
      "cursor_options", "hold_", "selectstmt", "select_with_parens", "select_no_parens", 
      "select_clause", "simple_select_intersect", "simple_select_pramary", 
      "with_clause", "cte_list", "common_table_expr", "materialized_", "with_clause_", 
      "into_clause", "strict_", "opttempTableName", "table_", "all_or_distinct", 
      "distinct_clause", "all_clause_", "sort_clause_", "sort_clause", "sortby_list", 
      "sortby", "select_limit", "select_limit_", "limit_clause", "offset_clause", 
      "select_limit_value", "select_offset_value", "select_fetch_first_value", 
      "i_or_f_const", "row_or_rows", "first_or_next", "group_clause", "group_by_list", 
      "group_by_item", "empty_grouping_set", "rollup_clause", "cube_clause", 
      "grouping_sets_clause", "having_clause", "for_locking_clause", "for_locking_clause_", 
      "for_locking_items", "for_locking_item", "for_locking_strength", "locked_rels_list", 
      "values_clause", "from_clause", "from_list", "table_ref", "alias_clause", 
      "func_alias_clause", "join_type", "join_qual", "relation_expr", "relation_expr_list", 
      "relation_expr_opt_alias", "tablesample_clause", "repeatable_clause_", 
      "func_table", "rowsfrom_item", "rowsfrom_list", "col_def_list_", "ordinality_", 
      "where_clause", "where_or_current_clause", "opttablefuncelementlist", 
      "tablefuncelementlist", "tablefuncelement", "xmltable", "xmltable_column_list", 
      "xmltable_column_el", "xmltable_column_option_list", "xmltable_column_option_el", 
      "xml_namespace_list", "xml_namespace_el", "typename", "opt_array_bounds", 
      "simpletypename", "consttypename", "generictype", "type_modifiers_", 
      "numeric", "float_", "bit", "constbit", "bitwithlength", "bitwithoutlength", 
      "character", "constcharacter", "character_c", "varying_", "constdatetime", 
      "constinterval", "timezone_", "interval_", "interval_second", "jsonType", 
      "escape_", "a_expr", "a_expr_qual", "a_expr_lessless", "a_expr_or", 
      "a_expr_and", "a_expr_between", "a_expr_in", "a_expr_unary_not", "a_expr_isnull", 
      "a_expr_is_not", "a_expr_compare", "a_expr_like", "a_expr_qual_op", 
      "a_expr_unary_qualop", "a_expr_add", "a_expr_mul", "a_expr_caret", 
      "a_expr_unary_sign", "a_expr_at_time_zone", "a_expr_collate", "a_expr_typecast", 
      "b_expr", "c_expr", "plsqlvariablename", "func_application", "func_expr", 
      "func_expr_windowless", "func_expr_common_subexpr", "xml_root_version", 
      "xml_root_standalone_", "xml_attributes", "xml_attribute_list", "xml_attribute_el", 
      "document_or_content", "xml_whitespace_option", "xmlexists_argument", 
      "xml_passing_mech", "within_group_clause", "filter_clause", "window_clause", 
      "window_definition_list", "window_definition", "over_clause", "window_specification", 
      "existing_window_name_", "partition_clause_", "frame_clause_", "frame_extent", 
      "frame_bound", "window_exclusion_clause_", "row", "explicit_row", 
      "implicit_row", "sub_type", "all_op", "mathop", "qual_op", "qual_all_op", 
      "subquery_Op", "expr_list", "func_arg_list", "func_arg_expr", "type_list", 
      "array_expr", "array_expr_list", "extract_list", "extract_arg", "unicode_normal_form", 
      "overlay_list", "position_list", "substr_list", "trim_list", "in_expr", 
      "case_expr", "when_clause_list", "when_clause", "case_default", "case_arg", 
      "columnref", "indirection_el", "slice_bound_", "indirection", "opt_indirection", 
      "json_passing_clause", "json_arguments", "json_argument", "json_wrapper_behavior", 
      "json_behavior", "json_behavior_type", "json_behavior_clause", "json_on_error_clause", 
      "json_value_expr", "json_format_clause", "json_quotes_clause", "json_returning_clause", 
      "json_predicate_type_constraint", "json_key_uniqueness_constraint", 
      "json_name_and_value_list", "json_name_and_value", "json_object_constructor_null_clause", 
      "json_array_constructor_null_clause", "json_value_expr_list", "json_aggregate_func", 
      "json_array_aggregate_order_by_clause", "target_list_", "target_list", 
      "target_el", "qualified_name_list", "qualified_name", "name_list", 
      "name", "attr_name", "file_name", "func_name", "aexprconst", "xconst", 
      "bconst", "fconst", "iconst", "sconst", "anysconst", "uescape_", "signediconst", 
      "roleid", "rolespec", "role_list", "colid", "type_function_name", 
      "nonreservedword", "colLabel", "bareColLabel", "unreserved_keyword", 
      "col_name_keyword", "type_func_name_keyword", "reserved_keyword", 
      "bare_label_keyword", "any_identifier", "identifier"
    },
    std::vector<std::string>{
      "", "'$'", "'('", "')'", "'['", "']'", "','", "';'", "':'", "'*'", 
      "'='", "'.'", "'+'", "'-'", "'/'", "'^'", "'<'", "'>'", "'<<'", "'>>'", 
      "':='", "'<='", "'=>'", "'>='", "'..'", "'<>'", "'::'", "'%'", "", 
      "", "'JSON'", "'JSON_ARRAY'", "'JSON_ARRAYAGG'", "'JSON_EXISTS'", 
      "'JSON_OBJECT'", "'JSON_OBJECTAGG'", "'JSON_QUERY'", "'JSON_SCALAR'", 
      "'JSON_SERIALIZE'", "'JSON_TABLE'", "'JSON_VALUE'", "'MERGE_ACTION'", 
      "'SYSTEM_USER'", "'ABSENT'", "'ASENSITIVE'", "'ATOMIC'", "'BREATH'", 
      "'COMPRESSION'", "'CONDITIONAL'", "'DEPTH'", "'EMPTY'", "'FINALIZE'", 
      "'INDENT'", "'KEEP'", "'KEYS'", "'NESTED'", "'OMIT'", "'PARAMETER'", 
      "'PATH'", "'PLAN'", "'QUOTES'", "'SCALAR'", "'SOURCE'", "'STRING'", 
      "'TARGET'", "'UNCONDITIONAL'", "'PERIOD'", "'FORMAT_LA'", "'ALL'", 
      "'ANALYSE'", "'ANALYZE'", "'AND'", "'ANY'", "'ARRAY'", "'AS'", "'ASC'", 
      "'ASYMMETRIC'", "'BOTH'", "'CASE'", "'CAST'", "'CHECK'", "'COLLATE'", 
      "'COLUMN'", "'CONSTRAINT'", "'CREATE'", "'CURRENT_CATALOG'", "'CURRENT_DATE'", 
      "'CURRENT_ROLE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'CURRENT_USER'", 
      "'DEFAULT'", "'DEFERRABLE'", "'DESC'", "'DISTINCT'", "'DO'", "'ELSE'", 
      "'EXCEPT'", "'FALSE'", "'FETCH'", "'FOR'", "'FOREIGN'", "'FROM'", 
      "'GRANT'", "'GROUP'", "'HAVING'", "'IN'", "'INITIALLY'", "'INTERSECT'", 
      "'INTO'", "'LATERAL'", "'LEADING'", "'LIMIT'", "'LOCALTIME'", "'LOCALTIMESTAMP'", 
      "'NOT'", "'NULL'", "'OFFSET'", "'ON'", "'ONLY'", "'OR'", "'ORDER'", 
      "'PLACING'", "'PRIMARY'", "'REFERENCES'", "'RETURNING'", "'SELECT'", 
      "'SESSION_USER'", "'SOME'", "'SYMMETRIC'", "'TABLE'", "'THEN'", "'TO'", 
      "'TRAILING'", "'TRUE'", "'UNION'", "'UNIQUE'", "'USER'", "'USING'", 
      "'VARIADIC'", "'WHEN'", "'WHERE'", "'WINDOW'", "'WITH'", "'AUTHORIZATION'", 
      "'BINARY'", "'COLLATION'", "'CONCURRENTLY'", "'CROSS'", "'CURRENT_SCHEMA'", 
      "'FREEZE'", "'FULL'", "'ILIKE'", "'INNER'", "'IS'", "'ISNULL'", "'JOIN'", 
      "'LEFT'", "'LIKE'", "'NATURAL'", "'NOTNULL'", "'OUTER'", "'OVER'", 
      "'OVERLAPS'", "'RIGHT'", "'SIMILAR'", "'VERBOSE'", "'ABORT'", "'ABSOLUTE'", 
      "'ACCESS'", "'ACTION'", "'ADD'", "'ADMIN'", "'AFTER'", "'AGGREGATE'", 
      "'ALSO'", "'ALTER'", "'ALWAYS'", "'ASSERTION'", "'ASSIGNMENT'", "'AT'", 
      "'ATTRIBUTE'", "'BACKWARD'", "'BEFORE'", "'BEGIN'", "'BY'", "'CACHE'", 
      "'CALLED'", "'CASCADE'", "'CASCADED'", "'CATALOG'", "'CHAIN'", "'CHARACTERISTICS'", 
      "'CHECKPOINT'", "'CLASS'", "'CLOSE'", "'CLUSTER'", "'COMMENT'", "'COMMENTS'", 
      "'COMMIT'", "'COMMITTED'", "'CONFIGURATION'", "'CONNECTION'", "'CONSTRAINTS'", 
      "'CONTENT'", "'CONTINUE'", "'CONVERSION'", "'COPY'", "'COST'", "'CSV'", 
      "'CURSOR'", "'CYCLE'", "'DATA'", "'DATABASE'", "'DAY'", "'DEALLOCATE'", 
      "'DECLARE'", "'DEFAULTS'", "'DEFERRED'", "'DEFINER'", "'DELETE'", 
      "'DELIMITER'", "'DELIMITERS'", "'DICTIONARY'", "'DISABLE'", "'DISCARD'", 
      "'DOCUMENT'", "'DOMAIN'", "'DOUBLE'", "'DROP'", "'EACH'", "'ENABLE'", 
      "'ENCODING'", "'ENCRYPTED'", "'ENUM'", "'ESCAPE'", "'EVENT'", "'EXCLUDE'", 
      "'EXCLUDING'", "'EXCLUSIVE'", "'EXECUTE'", "'EXPLAIN'", "'EXTENSION'", 
      "'EXTERNAL'", "'FAMILY'", "'FIRST'", "'FOLLOWING'", "'FORCE'", "'FORWARD'", 
      "'FUNCTION'", "'FUNCTIONS'", "'GLOBAL'", "'GRANTED'", "'HANDLER'", 
      "'HEADER'", "'HOLD'", "'HOUR'", "'IDENTITY'", "'IF'", "'IMMEDIATE'", 
      "'IMMUTABLE'", "'IMPLICIT'", "'INCLUDING'", "'INCREMENT'", "'INDEX'", 
      "'INDEXES'", "'INHERIT'", "'INHERITS'", "'INLINE'", "'INSENSITIVE'", 
      "'INSERT'", "'INSTEAD'", "'INVOKER'", "'ISOLATION'", "'KEY'", "'LABEL'", 
      "'LANGUAGE'", "'LARGE'", "'LAST'", "'LEAKPROOF'", "'LEVEL'", "'LISTEN'", 
      "'LOAD'", "'LOCAL'", "'LOCATION'", "'LOCK'", "'MAPPING'", "'MATCH'", 
      "'MATCHED'", "'MATERIALIZED'", "'MAXVALUE'", "'MERGE'", "'MINUTE'", 
      "'MINVALUE'", "'MODE'", "'MONTH'", "'MOVE'", "'NAME'", "'NAMES'", 
      "'NEXT'", "'NO'", "'NOTHING'", "'NOTIFY'", "'NOWAIT'", "'NULLS'", 
      "'OBJECT'", "'OF'", "'OFF'", "'OIDS'", "'OPERATOR'", "'OPTION'", "'OPTIONS'", 
      "'OWNED'", "'OWNER'", "'PARSER'", "'PARTIAL'", "'PARTITION'", "'PASSING'", 
      "'PASSWORD'", "'PLANS'", "'PRECEDING'", "'PREPARE'", "'PREPARED'", 
      "'PRESERVE'", "'PRIOR'", "'PRIVILEGES'", "'PROCEDURAL'", "'PROCEDURE'", 
      "'PROGRAM'", "'QUOTE'", "'RANGE'", "'READ'", "'REASSIGN'", "'RECHECK'", 
      "'RECURSIVE'", "'REF'", "'REFRESH'", "'REINDEX'", "'RELATIVE'", "'RELEASE'", 
      "'RENAME'", "'REPEATABLE'", "'REPLACE'", "'REPLICA'", "'RESET'", "'RESTART'", 
      "'RESTRICT'", "'RETURNS'", "'REVOKE'", "'ROLE'", "'ROLLBACK'", "'ROWS'", 
      "'RULE'", "'SAVEPOINT'", "'SCHEMA'", "'SCROLL'", "'SEARCH'", "'SECOND'", 
      "'SECURITY'", "'SEQUENCE'", "'SEQUENCES'", "'SERIALIZABLE'", "'SERVER'", 
      "'SESSION'", "'SET'", "'SHARE'", "'SHOW'", "'SIMPLE'", "'SNAPSHOT'", 
      "'STABLE'", "'STANDALONE'", "'START'", "'STATEMENT'", "'STATISTICS'", 
      "'STDIN'", "'STDOUT'", "'STORAGE'", "'STRICT'", "'STRIP'", "'SYSID'", 
      "'SYSTEM'", "'TABLES'", "'TABLESPACE'", "'TEMP'", "'TEMPLATE'", "'TEMPORARY'", 
      "'TEXT'", "'TRANSACTION'", "'TRIGGER'", "'TRUNCATE'", "'TRUSTED'", 
      "'TYPE'", "'TYPES'", "'UNBOUNDED'", "'UNCOMMITTED'", "'UNENCRYPTED'", 
      "'UNKNOWN'", "'UNLISTEN'", "'UNLOGGED'", "'UNTIL'", "'UPDATE'", "'VACUUM'", 
      "'VALID'", "'VALIDATE'", "'VALIDATOR'", "'VARYING'", "'VERSION'", 
      "'VIEW'", "'VOLATILE'", "'WHITESPACE'", "'WITHOUT'", "'WORK'", "'WRAPPER'", 
      "'WRITE'", "'XML'", "'YEAR'", "'YES'", "'ZONE'", "'BETWEEN'", "'BIGINT'", 
      "'BIT'", "'BOOLEAN'", "'CHAR'", "'CHARACTER'", "'COALESCE'", "'DEC'", 
      "'DECIMAL'", "'EXISTS'", "'EXTRACT'", "'FLOAT'", "'GREATEST'", "'INOUT'", 
      "'INT'", "'INTEGER'", "'INTERVAL'", "'LEAST'", "'NATIONAL'", "'NCHAR'", 
      "'NONE'", "'NULLIF'", "'NUMERIC'", "'OVERLAY'", "'POSITION'", "'PRECISION'", 
      "'REAL'", "'ROW'", "'SETOF'", "'SMALLINT'", "'SUBSTRING'", "'TIME'", 
      "'TIMESTAMP'", "'TREAT'", "'TRIM'", "'VALUES'", "'VARCHAR'", "'XMLATTRIBUTES'", 
      "'XMLCOMMENT'", "'XMLAGG'", "'XML_IS_WELL_FORMED'", "'XML_IS_WELL_FORMED_DOCUMENT'", 
      "'XML_IS_WELL_FORMED_CONTENT'", "'XPATH'", "'XPATH_EXISTS'", "'XMLCONCAT'", 
      "'XMLELEMENT'", "'XMLEXISTS'", "'XMLFOREST'", "'XMLPARSE'", "'XMLPI'", 
      "'XMLROOT'", "'XMLSERIALIZE'", "'CALL'", "'CURRENT'", "'ATTACH'", 
      "'DETACH'", "'EXPRESSION'", "'GENERATED'", "'LOGGED'", "'STORED'", 
      "'INCLUDE'", "'ROUTINE'", "'TRANSFORM'", "'IMPORT'", "'POLICY'", "'METHOD'", 
      "'REFERENCING'", "'NEW'", "'OLD'", "'VALUE'", "'SUBSCRIPTION'", "'PUBLICATION'", 
      "'OUT'", "'END'", "'ROUTINES'", "'SCHEMAS'", "'PROCEDURES'", "'INPUT'", 
      "'SUPPORT'", "'PARALLEL'", "'SQL'", "'DEPENDS'", "'OVERRIDING'", "'CONFLICT'", 
      "'SKIP'", "'LOCKED'", "'TIES'", "'ROLLUP'", "'CUBE'", "'GROUPING'", 
      "'SETS'", "'TABLESAMPLE'", "'ORDINALITY'", "'XMLTABLE'", "'COLUMNS'", 
      "'XMLNAMESPACES'", "'ROWTYPE'", "'NORMALIZED'", "'WITHIN'", "'FILTER'", 
      "'GROUPS'", "'OTHERS'", "'NFC'", "'NFD'", "'NFKC'", "'NFKD'", "'UESCAPE'", 
      "'VIEWS'", "'NORMALIZE'", "'DUMP'", "'ERROR'", "'USE_VARIABLE'", "'USE_COLUMN'", 
      "'CONSTANT'", "'PERFORM'", "'GET'", "'DIAGNOSTICS'", "'STACKED'", 
      "'ELSIF'", "'WHILE'", "'FOREACH'", "'SLICE'", "'EXIT'", "'RETURN'", 
      "'RAISE'", "'SQLSTATE'", "'DEBUG'", "'INFO'", "'NOTICE'", "'WARNING'", 
      "'EXCEPTION'", "'ASSERT'", "'LOOP'", "'OPEN'", "'FORMAT'", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "'\\'", "'''"
    },
    std::vector<std::string>{
      "", "Dollar", "OPEN_PAREN", "CLOSE_PAREN", "OPEN_BRACKET", "CLOSE_BRACKET", 
      "COMMA", "SEMI", "COLON", "STAR", "EQUAL", "DOT", "PLUS", "MINUS", 
      "SLASH", "CARET", "LT", "GT", "LESS_LESS", "GREATER_GREATER", "COLON_EQUALS", 
      "LESS_EQUALS", "EQUALS_GREATER", "GREATER_EQUALS", "DOT_DOT", "NOT_EQUALS", 
      "TYPECAST", "PERCENT", "PARAM", "Operator", "JSON", "JSON_ARRAY", 
      "JSON_ARRAYAGG", "JSON_EXISTS", "JSON_OBJECT", "JSON_OBJECTAGG", "JSON_QUERY", 
      "JSON_SCALAR", "JSON_SERIALIZE", "JSON_TABLE", "JSON_VALUE", "MERGE_ACTION", 
      "SYSTEM_USER", "ABSENT", "ASENSITIVE", "ATOMIC", "BREADTH", "COMPRESSION", 
      "CONDITIONAL", "DEPTH", "EMPTY_P", "FINALIZE", "INDENT", "KEEP", "KEYS", 
      "NESTED", "OMIT", "PARAMETER", "PATH", "PLAN", "QUOTES", "SCALAR", 
      "SOURCE", "STRING_P", "TARGET", "UNCONDITIONAL", "PERIOD", "FORMAT_LA", 
      "ALL", "ANALYSE", "ANALYZE", "AND", "ANY", "ARRAY", "AS", "ASC", "ASYMMETRIC", 
      "BOTH", "CASE", "CAST", "CHECK", "COLLATE", "COLUMN", "CONSTRAINT", 
      "CREATE", "CURRENT_CATALOG", "CURRENT_DATE", "CURRENT_ROLE", "CURRENT_TIME", 
      "CURRENT_TIMESTAMP", "CURRENT_USER", "DEFAULT", "DEFERRABLE", "DESC", 
      "DISTINCT", "DO", "ELSE", "EXCEPT", "FALSE_P", "FETCH", "FOR", "FOREIGN", 
      "FROM", "GRANT", "GROUP_P", "HAVING", "IN_P", "INITIALLY", "INTERSECT", 
      "INTO", "LATERAL_P", "LEADING", "LIMIT", "LOCALTIME", "LOCALTIMESTAMP", 
      "NOT", "NULL_P", "OFFSET", "ON", "ONLY", "OR", "ORDER", "PLACING", 
      "PRIMARY", "REFERENCES", "RETURNING", "SELECT", "SESSION_USER", "SOME", 
      "SYMMETRIC", "TABLE", "THEN", "TO", "TRAILING", "TRUE_P", "UNION", 
      "UNIQUE", "USER", "USING", "VARIADIC", "WHEN", "WHERE", "WINDOW", 
      "WITH", "AUTHORIZATION", "BINARY", "COLLATION", "CONCURRENTLY", "CROSS", 
      "CURRENT_SCHEMA", "FREEZE", "FULL", "ILIKE", "INNER_P", "IS", "ISNULL", 
      "JOIN", "LEFT", "LIKE", "NATURAL", "NOTNULL", "OUTER_P", "OVER", "OVERLAPS", 
      "RIGHT", "SIMILAR", "VERBOSE", "ABORT_P", "ABSOLUTE_P", "ACCESS", 
      "ACTION", "ADD_P", "ADMIN", "AFTER", "AGGREGATE", "ALSO", "ALTER", 
      "ALWAYS", "ASSERTION", "ASSIGNMENT", "AT", "ATTRIBUTE", "BACKWARD", 
      "BEFORE", "BEGIN_P", "BY", "CACHE", "CALLED", "CASCADE", "CASCADED", 
      "CATALOG", "CHAIN", "CHARACTERISTICS", "CHECKPOINT", "CLASS", "CLOSE", 
      "CLUSTER", "COMMENT", "COMMENTS", "COMMIT", "COMMITTED", "CONFIGURATION", 
      "CONNECTION", "CONSTRAINTS", "CONTENT_P", "CONTINUE_P", "CONVERSION_P", 
      "COPY", "COST", "CSV", "CURSOR", "CYCLE", "DATA_P", "DATABASE", "DAY_P", 
      "DEALLOCATE", "DECLARE", "DEFAULTS", "DEFERRED", "DEFINER", "DELETE_P", 
      "DELIMITER", "DELIMITERS", "DICTIONARY", "DISABLE_P", "DISCARD", "DOCUMENT_P", 
      "DOMAIN_P", "DOUBLE_P", "DROP", "EACH", "ENABLE_P", "ENCODING", "ENCRYPTED", 
      "ENUM_P", "ESCAPE", "EVENT", "EXCLUDE", "EXCLUDING", "EXCLUSIVE", 
      "EXECUTE", "EXPLAIN", "EXTENSION", "EXTERNAL", "FAMILY", "FIRST_P", 
      "FOLLOWING", "FORCE", "FORWARD", "FUNCTION", "FUNCTIONS", "GLOBAL", 
      "GRANTED", "HANDLER", "HEADER_P", "HOLD", "HOUR_P", "IDENTITY_P", 
      "IF_P", "IMMEDIATE", "IMMUTABLE", "IMPLICIT_P", "INCLUDING", "INCREMENT", 
      "INDEX", "INDEXES", "INHERIT", "INHERITS", "INLINE_P", "INSENSITIVE", 
      "INSERT", "INSTEAD", "INVOKER", "ISOLATION", "KEY", "LABEL", "LANGUAGE", 
      "LARGE_P", "LAST_P", "LEAKPROOF", "LEVEL", "LISTEN", "LOAD", "LOCAL", 
      "LOCATION", "LOCK_P", "MAPPING", "MATCH", "MATCHED", "MATERIALIZED", 
      "MAXVALUE", "MERGE", "MINUTE_P", "MINVALUE", "MODE", "MONTH_P", "MOVE", 
      "NAME_P", "NAMES", "NEXT", "NO", "NOTHING", "NOTIFY", "NOWAIT", "NULLS_P", 
      "OBJECT_P", "OF", "OFF", "OIDS", "OPERATOR", "OPTION", "OPTIONS", 
      "OWNED", "OWNER", "PARSER", "PARTIAL", "PARTITION", "PASSING", "PASSWORD", 
      "PLANS", "PRECEDING", "PREPARE", "PREPARED", "PRESERVE", "PRIOR", 
      "PRIVILEGES", "PROCEDURAL", "PROCEDURE", "PROGRAM", "QUOTE", "RANGE", 
      "READ", "REASSIGN", "RECHECK", "RECURSIVE", "REF", "REFRESH", "REINDEX", 
      "RELATIVE_P", "RELEASE", "RENAME", "REPEATABLE", "REPLACE", "REPLICA", 
      "RESET", "RESTART", "RESTRICT", "RETURNS", "REVOKE", "ROLE", "ROLLBACK", 
      "ROWS", "RULE", "SAVEPOINT", "SCHEMA", "SCROLL", "SEARCH", "SECOND_P", 
      "SECURITY", "SEQUENCE", "SEQUENCES", "SERIALIZABLE", "SERVER", "SESSION", 
      "SET", "SHARE", "SHOW", "SIMPLE", "SNAPSHOT", "STABLE", "STANDALONE_P", 
      "START", "STATEMENT", "STATISTICS", "STDIN", "STDOUT", "STORAGE", 
      "STRICT_P", "STRIP_P", "SYSID", "SYSTEM_P", "TABLES", "TABLESPACE", 
      "TEMP", "TEMPLATE", "TEMPORARY", "TEXT_P", "TRANSACTION", "TRIGGER", 
      "TRUNCATE", "TRUSTED", "TYPE_P", "TYPES_P", "UNBOUNDED", "UNCOMMITTED", 
      "UNENCRYPTED", "UNKNOWN", "UNLISTEN", "UNLOGGED", "UNTIL", "UPDATE", 
      "VACUUM", "VALID", "VALIDATE", "VALIDATOR", "VARYING", "VERSION_P", 
      "VIEW", "VOLATILE", "WHITESPACE_P", "WITHOUT", "WORK", "WRAPPER", 
      "WRITE", "XML_P", "YEAR_P", "YES_P", "ZONE", "BETWEEN", "BIGINT", 
      "BIT", "BOOLEAN_P", "CHAR_P", "CHARACTER", "COALESCE", "DEC", "DECIMAL_P", 
      "EXISTS", "EXTRACT", "FLOAT_P", "GREATEST", "INOUT", "INT_P", "INTEGER", 
      "INTERVAL", "LEAST", "NATIONAL", "NCHAR", "NONE", "NULLIF", "NUMERIC", 
      "OVERLAY", "POSITION", "PRECISION", "REAL", "ROW", "SETOF", "SMALLINT", 
      "SUBSTRING", "TIME", "TIMESTAMP", "TREAT", "TRIM", "VALUES", "VARCHAR", 
      "XMLATTRIBUTES", "XMLCOMMENT", "XMLAGG", "XML_IS_WELL_FORMED", "XML_IS_WELL_FORMED_DOCUMENT", 
      "XML_IS_WELL_FORMED_CONTENT", "XPATH", "XPATH_EXISTS", "XMLCONCAT", 
      "XMLELEMENT", "XMLEXISTS", "XMLFOREST", "XMLPARSE", "XMLPI", "XMLROOT", 
      "XMLSERIALIZE", "CALL", "CURRENT_P", "ATTACH", "DETACH", "EXPRESSION", 
      "GENERATED", "LOGGED", "STORED", "INCLUDE", "ROUTINE", "TRANSFORM", 
      "IMPORT_P", "POLICY", "METHOD", "REFERENCING", "NEW", "OLD", "VALUE_P", 
      "SUBSCRIPTION", "PUBLICATION", "OUT_P", "END_P", "ROUTINES", "SCHEMAS", 
      "PROCEDURES", "INPUT_P", "SUPPORT", "PARALLEL", "SQL_P", "DEPENDS", 
      "OVERRIDING", "CONFLICT", "SKIP_P", "LOCKED", "TIES", "ROLLUP", "CUBE", 
      "GROUPING", "SETS", "TABLESAMPLE", "ORDINALITY", "XMLTABLE", "COLUMNS", 
      "XMLNAMESPACES", "ROWTYPE", "NORMALIZED", "WITHIN", "FILTER", "GROUPS", 
      "OTHERS", "NFC", "NFD", "NFKC", "NFKD", "UESCAPE", "VIEWS", "NORMALIZE", 
      "DUMP", "ERROR", "USE_VARIABLE", "USE_COLUMN", "CONSTANT", "PERFORM", 
      "GET", "DIAGNOSTICS", "STACKED", "ELSIF", "WHILE", "FOREACH", "SLICE", 
      "EXIT", "RETURN", "RAISE", "SQLSTATE", "DEBUG", "INFO", "NOTICE", 
      "WARNING", "EXCEPTION", "ASSERT", "LOOP", "OPEN", "FORMAT", "Identifier", 
      "QuotedIdentifier", "UnterminatedQuotedIdentifier", "InvalidQuotedIdentifier", 
      "InvalidUnterminatedQuotedIdentifier", "UnicodeQuotedIdentifier", 
      "UnterminatedUnicodeQuotedIdentifier", "InvalidUnicodeQuotedIdentifier", 
      "InvalidUnterminatedUnicodeQuotedIdentifier", "StringConstant", "UnterminatedStringConstant", 
      "UnicodeEscapeStringConstant", "UnterminatedUnicodeEscapeStringConstant", 
      "BeginDollarStringConstant", "BinaryStringConstant", "UnterminatedBinaryStringConstant", 
      "InvalidBinaryStringConstant", "InvalidUnterminatedBinaryStringConstant", 
      "HexadecimalStringConstant", "UnterminatedHexadecimalStringConstant", 
      "InvalidHexadecimalStringConstant", "InvalidUnterminatedHexadecimalStringConstant", 
      "Integral", "BinaryIntegral", "OctalIntegral", "HexadecimalIntegral", 
      "NumericFail", "Numeric", "PLSQLVARIABLENAME", "PLSQLIDENTIFIER", 
      "Whitespace", "Newline", "LineComment", "BlockComment", "UnterminatedBlockComment", 
      "ErrorCharacter", "EscapeStringConstant", "UnterminatedEscapeStringConstant", 
      "InvalidEscapeStringConstant", "InvalidUnterminatedEscapeStringConstant", 
      "AfterEscapeStringConstantMode_NotContinued", "AfterEscapeStringConstantWithNewlineMode_NotContinued", 
      "DollarText", "EndDollarStringConstant", "MetaCommand", "AfterEscapeStringConstantWithNewlineMode_Continued"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,599,10520,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,2,140,
  	7,140,2,141,7,141,2,142,7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,
  	7,146,2,147,7,147,2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,
  	7,152,2,153,7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,
  	7,158,2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
  	7,164,2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,2,170,
  	7,170,2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,7,175,2,176,
  	7,176,2,177,7,177,2,178,7,178,2,179,7,179,2,180,7,180,2,181,7,181,2,182,
  	7,182,2,183,7,183,2,184,7,184,2,185,7,185,2,186,7,186,2,187,7,187,2,188,
  	7,188,2,189,7,189,2,190,7,190,2,191,7,191,2,192,7,192,2,193,7,193,2,194,
  	7,194,2,195,7,195,2,196,7,196,2,197,7,197,2,198,7,198,2,199,7,199,2,200,
  	7,200,2,201,7,201,2,202,7,202,2,203,7,203,2,204,7,204,2,205,7,205,2,206,
  	7,206,2,207,7,207,2,208,7,208,2,209,7,209,2,210,7,210,2,211,7,211,2,212,
  	7,212,2,213,7,213,2,214,7,214,2,215,7,215,2,216,7,216,2,217,7,217,2,218,
  	7,218,2,219,7,219,2,220,7,220,2,221,7,221,2,222,7,222,2,223,7,223,2,224,
  	7,224,2,225,7,225,2,226,7,226,2,227,7,227,2,228,7,228,2,229,7,229,2,230,
  	7,230,2,231,7,231,2,232,7,232,2,233,7,233,2,234,7,234,2,235,7,235,2,236,
  	7,236,2,237,7,237,2,238,7,238,2,239,7,239,2,240,7,240,2,241,7,241,2,242,
  	7,242,2,243,7,243,2,244,7,244,2,245,7,245,2,246,7,246,2,247,7,247,2,248,
  	7,248,2,249,7,249,2,250,7,250,2,251,7,251,2,252,7,252,2,253,7,253,2,254,
  	7,254,2,255,7,255,2,256,7,256,2,257,7,257,2,258,7,258,2,259,7,259,2,260,
  	7,260,2,261,7,261,2,262,7,262,2,263,7,263,2,264,7,264,2,265,7,265,2,266,
  	7,266,2,267,7,267,2,268,7,268,2,269,7,269,2,270,7,270,2,271,7,271,2,272,
  	7,272,2,273,7,273,2,274,7,274,2,275,7,275,2,276,7,276,2,277,7,277,2,278,
  	7,278,2,279,7,279,2,280,7,280,2,281,7,281,2,282,7,282,2,283,7,283,2,284,
  	7,284,2,285,7,285,2,286,7,286,2,287,7,287,2,288,7,288,2,289,7,289,2,290,
  	7,290,2,291,7,291,2,292,7,292,2,293,7,293,2,294,7,294,2,295,7,295,2,296,
  	7,296,2,297,7,297,2,298,7,298,2,299,7,299,2,300,7,300,2,301,7,301,2,302,
  	7,302,2,303,7,303,2,304,7,304,2,305,7,305,2,306,7,306,2,307,7,307,2,308,
  	7,308,2,309,7,309,2,310,7,310,2,311,7,311,2,312,7,312,2,313,7,313,2,314,
  	7,314,2,315,7,315,2,316,7,316,2,317,7,317,2,318,7,318,2,319,7,319,2,320,
  	7,320,2,321,7,321,2,322,7,322,2,323,7,323,2,324,7,324,2,325,7,325,2,326,
  	7,326,2,327,7,327,2,328,7,328,2,329,7,329,2,330,7,330,2,331,7,331,2,332,
  	7,332,2,333,7,333,2,334,7,334,2,335,7,335,2,336,7,336,2,337,7,337,2,338,
  	7,338,2,339,7,339,2,340,7,340,2,341,7,341,2,342,7,342,2,343,7,343,2,344,
  	7,344,2,345,7,345,2,346,7,346,2,347,7,347,2,348,7,348,2,349,7,349,2,350,
  	7,350,2,351,7,351,2,352,7,352,2,353,7,353,2,354,7,354,2,355,7,355,2,356,
  	7,356,2,357,7,357,2,358,7,358,2,359,7,359,2,360,7,360,2,361,7,361,2,362,
  	7,362,2,363,7,363,2,364,7,364,2,365,7,365,2,366,7,366,2,367,7,367,2,368,
  	7,368,2,369,7,369,2,370,7,370,2,371,7,371,2,372,7,372,2,373,7,373,2,374,
  	7,374,2,375,7,375,2,376,7,376,2,377,7,377,2,378,7,378,2,379,7,379,2,380,
  	7,380,2,381,7,381,2,382,7,382,2,383,7,383,2,384,7,384,2,385,7,385,2,386,
  	7,386,2,387,7,387,2,388,7,388,2,389,7,389,2,390,7,390,2,391,7,391,2,392,
  	7,392,2,393,7,393,2,394,7,394,2,395,7,395,2,396,7,396,2,397,7,397,2,398,
  	7,398,2,399,7,399,2,400,7,400,2,401,7,401,2,402,7,402,2,403,7,403,2,404,
  	7,404,2,405,7,405,2,406,7,406,2,407,7,407,2,408,7,408,2,409,7,409,2,410,
  	7,410,2,411,7,411,2,412,7,412,2,413,7,413,2,414,7,414,2,415,7,415,2,416,
  	7,416,2,417,7,417,2,418,7,418,2,419,7,419,2,420,7,420,2,421,7,421,2,422,
  	7,422,2,423,7,423,2,424,7,424,2,425,7,425,2,426,7,426,2,427,7,427,2,428,
  	7,428,2,429,7,429,2,430,7,430,2,431,7,431,2,432,7,432,2,433,7,433,2,434,
  	7,434,2,435,7,435,2,436,7,436,2,437,7,437,2,438,7,438,2,439,7,439,2,440,
  	7,440,2,441,7,441,2,442,7,442,2,443,7,443,2,444,7,444,2,445,7,445,2,446,
  	7,446,2,447,7,447,2,448,7,448,2,449,7,449,2,450,7,450,2,451,7,451,2,452,
  	7,452,2,453,7,453,2,454,7,454,2,455,7,455,2,456,7,456,2,457,7,457,2,458,
  	7,458,2,459,7,459,2,460,7,460,2,461,7,461,2,462,7,462,2,463,7,463,2,464,
  	7,464,2,465,7,465,2,466,7,466,2,467,7,467,2,468,7,468,2,469,7,469,2,470,
  	7,470,2,471,7,471,2,472,7,472,2,473,7,473,2,474,7,474,2,475,7,475,2,476,
  	7,476,2,477,7,477,2,478,7,478,2,479,7,479,2,480,7,480,2,481,7,481,2,482,
  	7,482,2,483,7,483,2,484,7,484,2,485,7,485,2,486,7,486,2,487,7,487,2,488,
  	7,488,2,489,7,489,2,490,7,490,2,491,7,491,2,492,7,492,2,493,7,493,2,494,
  	7,494,2,495,7,495,2,496,7,496,2,497,7,497,2,498,7,498,2,499,7,499,2,500,
  	7,500,2,501,7,501,2,502,7,502,2,503,7,503,2,504,7,504,2,505,7,505,2,506,
  	7,506,2,507,7,507,2,508,7,508,2,509,7,509,2,510,7,510,2,511,7,511,2,512,
  	7,512,2,513,7,513,2,514,7,514,2,515,7,515,2,516,7,516,2,517,7,517,2,518,
  	7,518,2,519,7,519,2,520,7,520,2,521,7,521,2,522,7,522,2,523,7,523,2,524,
  	7,524,2,525,7,525,2,526,7,526,2,527,7,527,2,528,7,528,2,529,7,529,2,530,
  	7,530,2,531,7,531,2,532,7,532,2,533,7,533,2,534,7,534,2,535,7,535,2,536,
  	7,536,2,537,7,537,2,538,7,538,2,539,7,539,2,540,7,540,2,541,7,541,2,542,
  	7,542,2,543,7,543,2,544,7,544,2,545,7,545,2,546,7,546,2,547,7,547,2,548,
  	7,548,2,549,7,549,2,550,7,550,2,551,7,551,2,552,7,552,2,553,7,553,2,554,
  	7,554,2,555,7,555,2,556,7,556,2,557,7,557,2,558,7,558,2,559,7,559,2,560,
  	7,560,2,561,7,561,2,562,7,562,2,563,7,563,2,564,7,564,2,565,7,565,2,566,
  	7,566,2,567,7,567,2,568,7,568,2,569,7,569,2,570,7,570,2,571,7,571,2,572,
  	7,572,2,573,7,573,2,574,7,574,2,575,7,575,2,576,7,576,2,577,7,577,2,578,
  	7,578,2,579,7,579,2,580,7,580,2,581,7,581,2,582,7,582,2,583,7,583,2,584,
  	7,584,2,585,7,585,2,586,7,586,2,587,7,587,2,588,7,588,2,589,7,589,2,590,
  	7,590,2,591,7,591,2,592,7,592,2,593,7,593,2,594,7,594,2,595,7,595,2,596,
  	7,596,2,597,7,597,2,598,7,598,2,599,7,599,2,600,7,600,2,601,7,601,2,602,
  	7,602,2,603,7,603,2,604,7,604,2,605,7,605,2,606,7,606,2,607,7,607,2,608,
  	7,608,2,609,7,609,2,610,7,610,2,611,7,611,2,612,7,612,2,613,7,613,2,614,
  	7,614,2,615,7,615,2,616,7,616,2,617,7,617,2,618,7,618,2,619,7,619,2,620,
  	7,620,2,621,7,621,2,622,7,622,2,623,7,623,2,624,7,624,2,625,7,625,2,626,
  	7,626,2,627,7,627,2,628,7,628,2,629,7,629,2,630,7,630,2,631,7,631,2,632,
  	7,632,2,633,7,633,2,634,7,634,2,635,7,635,2,636,7,636,2,637,7,637,2,638,
  	7,638,2,639,7,639,2,640,7,640,2,641,7,641,2,642,7,642,2,643,7,643,2,644,
  	7,644,2,645,7,645,2,646,7,646,2,647,7,647,2,648,7,648,2,649,7,649,2,650,
  	7,650,2,651,7,651,2,652,7,652,2,653,7,653,2,654,7,654,2,655,7,655,2,656,
  	7,656,2,657,7,657,2,658,7,658,2,659,7,659,2,660,7,660,2,661,7,661,2,662,
  	7,662,2,663,7,663,2,664,7,664,2,665,7,665,2,666,7,666,2,667,7,667,2,668,
  	7,668,2,669,7,669,2,670,7,670,2,671,7,671,2,672,7,672,2,673,7,673,2,674,
  	7,674,2,675,7,675,2,676,7,676,2,677,7,677,2,678,7,678,2,679,7,679,2,680,
  	7,680,2,681,7,681,2,682,7,682,2,683,7,683,2,684,7,684,2,685,7,685,2,686,
  	7,686,2,687,7,687,2,688,7,688,2,689,7,689,2,690,7,690,2,691,7,691,2,692,
  	7,692,2,693,7,693,2,694,7,694,2,695,7,695,2,696,7,696,2,697,7,697,2,698,
  	7,698,2,699,7,699,2,700,7,700,2,701,7,701,2,702,7,702,2,703,7,703,2,704,
  	7,704,2,705,7,705,2,706,7,706,2,707,7,707,2,708,7,708,2,709,7,709,2,710,
  	7,710,2,711,7,711,2,712,7,712,2,713,7,713,2,714,7,714,2,715,7,715,2,716,
  	7,716,2,717,7,717,2,718,7,718,2,719,7,719,1,0,1,0,1,0,1,1,1,1,1,2,3,2,
  	1447,8,2,1,2,1,2,3,2,1451,8,2,5,2,1453,8,2,10,2,12,2,1456,9,2,1,3,1,3,
  	1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,
  	3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,
  	1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,
  	3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,
  	1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,
  	3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,
  	1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,3,
  	3,1582,8,3,1,4,1,4,1,4,1,5,1,5,1,5,1,5,3,5,1591,8,5,1,5,1,5,1,6,1,6,1,
  	7,5,7,1598,8,7,10,7,12,7,1601,9,7,1,8,5,8,1604,8,8,10,8,12,8,1607,9,8,
  	1,9,1,9,1,9,3,9,1612,8,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,
  	1,9,1,9,3,9,1627,8,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,
  	3,10,1639,8,10,1,11,1,11,1,11,1,11,3,11,1645,8,11,1,11,1,11,1,12,1,12,
  	1,12,1,12,3,12,1653,8,12,1,12,1,12,1,13,1,13,1,13,1,13,1,14,1,14,1,14,
  	3,14,1664,8,14,1,14,1,14,3,14,1668,8,14,1,14,1,14,1,15,1,15,1,15,1,15,
  	3,15,1676,8,15,1,15,1,15,1,16,1,16,1,16,1,16,3,16,1684,8,16,1,16,1,16,
  	1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,18,1,18,1,19,1,19,1,19,1,19,1,19,
  	3,19,1702,8,19,1,19,3,19,1705,8,19,1,19,1,19,1,19,3,19,1710,8,19,1,19,
  	1,19,1,20,1,20,1,21,5,21,1717,8,21,10,21,12,21,1720,9,21,1,22,1,22,1,
  	22,1,22,1,22,1,22,3,22,1728,8,22,1,23,1,23,3,23,1732,8,23,1,23,1,23,1,
  	24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,3,24,1744,8,24,1,25,1,25,1,25,1,
  	25,3,25,1750,8,25,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,
  	26,1,26,1,26,1,26,3,26,1766,8,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,
  	26,1,26,1,26,1,26,3,26,1779,8,26,1,27,1,27,1,27,5,27,1784,8,27,10,27,
  	12,27,1787,9,27,1,28,1,28,1,28,5,28,1792,8,28,10,28,12,28,1795,9,28,1,
  	29,1,29,3,29,1799,8,29,1,30,1,30,1,30,1,30,1,30,3,30,1806,8,30,1,31,1,
  	31,1,31,1,31,3,31,1812,8,31,1,32,1,32,1,32,1,32,1,32,3,32,1819,8,32,1,
  	32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,3,32,1830,8,32,1,33,1,33,3,
  	33,1834,8,33,1,34,1,34,3,34,1838,8,34,1,35,1,35,1,35,1,36,1,36,1,36,1,
  	36,1,36,1,36,1,36,1,36,3,36,1851,8,36,1,37,1,37,3,37,1855,8,37,1,38,1,
  	38,1,38,3,38,1860,8,38,1,39,1,39,1,39,3,39,1865,8,39,1,40,1,40,1,40,1,
  	40,1,40,1,40,1,40,1,40,1,40,1,40,3,40,1877,8,40,1,41,1,41,1,41,1,41,1,
  	41,1,42,1,42,3,42,1886,8,42,1,43,1,43,1,44,1,44,1,45,1,45,1,45,1,46,1,
  	46,1,46,1,46,3,46,1899,8,46,1,46,1,46,1,46,3,46,1904,8,46,1,46,1,46,1,
  	46,1,46,1,46,1,46,1,46,1,46,1,46,3,46,1915,8,46,1,46,1,46,1,46,1,46,3,
  	46,1921,8,46,1,46,1,46,1,46,1,46,3,46,1927,8,46,1,46,1,46,1,46,3,46,1932,
  	8,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,3,46,1943,8,46,1,46,
  	1,46,1,46,1,46,3,46,1949,8,46,1,46,1,46,1,46,1,46,3,46,1955,8,46,1,46,
  	1,46,1,46,1,46,1,46,1,46,1,46,3,46,1964,8,46,1,46,1,46,1,46,1,46,1,46,
  	1,46,1,46,1,46,3,46,1974,8,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,
  	1,46,1,46,1,46,1,46,1,46,3,46,1989,8,46,1,46,1,46,1,46,1,46,3,46,1995,
  	8,46,1,46,1,46,1,46,1,46,1,46,3,46,2002,8,46,1,46,1,46,1,46,3,46,2007,
  	8,46,1,47,1,47,1,47,5,47,2012,8,47,10,47,12,47,2015,9,47,1,48,1,48,1,
  	48,1,48,1,48,1,48,1,48,1,48,3,48,2025,8,48,1,49,1,49,1,49,1,49,1,50,1,
  	50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,
  	50,1,50,1,50,3,50,2049,8,50,1,50,1,50,1,50,1,50,1,50,3,50,2056,8,50,1,
  	50,1,50,1,50,1,50,1,50,1,50,1,50,3,50,2065,8,50,1,50,1,50,1,50,1,50,1,
  	50,1,50,1,50,3,50,2074,8,50,1,50,1,50,1,50,1,50,1,50,1,50,3,50,2082,8,
  	50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,3,50,2092,8,50,1,50,1,50,1,
  	50,1,50,1,50,1,50,1,50,3,50,2101,8,50,1,50,1,50,1,50,1,50,1,50,1,50,1,
  	50,3,50,2110,8,50,1,50,1,50,1,50,1,50,1,50,1,50,3,50,2118,8,50,1,50,1,
  	50,1,50,1,50,1,50,1,50,3,50,2126,8,50,1,50,1,50,1,50,1,50,1,50,1,50,1,
  	50,3,50,2135,8,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,3,50,2144,8,50,1,
  	50,1,50,3,50,2148,8,50,1,50,1,50,1,50,1,50,1,50,3,50,2155,8,50,1,50,1,
  	50,1,50,1,50,1,50,1,50,3,50,2163,8,50,1,50,1,50,1,50,1,50,1,50,1,50,1,
  	50,1,50,3,50,2173,8,50,1,50,1,50,1,50,1,50,3,50,2179,8,50,1,50,1,50,3,
  	50,2183,8,50,1,50,1,50,3,50,2187,8,50,1,50,1,50,3,50,2191,8,50,1,50,1,
  	50,3,50,2195,8,50,1,50,1,50,1,50,3,50,2200,8,50,1,50,3,50,2203,8,50,1,
  	50,1,50,3,50,2207,8,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,
  	50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,3,50,2228,8,50,1,50,1,
  	50,1,50,1,50,3,50,2234,8,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,
  	50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,
  	50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,
  	50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,
  	50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,
  	50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,
  	50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,
  	50,3,50,2329,8,50,1,51,1,51,1,51,1,51,1,51,3,51,2336,8,51,1,52,1,52,1,
  	53,1,53,1,53,1,54,1,54,1,54,1,55,1,55,1,55,1,55,1,55,1,55,3,55,2352,8,
  	55,1,56,1,56,1,56,1,56,1,57,1,57,1,57,1,58,1,58,1,58,5,58,2364,8,58,10,
  	58,12,58,2367,9,58,1,59,1,59,1,59,1,59,1,59,1,59,1,59,3,59,2376,8,59,
  	3,59,2378,8,59,1,60,4,60,2381,8,60,11,60,12,60,2382,1,61,1,61,3,61,2387,
  	8,61,1,61,3,61,2390,8,61,1,61,1,61,1,61,1,61,3,61,2396,8,61,3,61,2398,
  	8,61,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,
  	1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,3,62,
  	2426,8,62,1,63,1,63,1,63,1,64,1,64,1,64,5,64,2434,8,64,10,64,12,64,2437,
  	9,64,1,65,1,65,1,65,1,65,1,65,1,66,1,66,1,66,5,66,2447,8,66,10,66,12,
  	66,2450,9,66,1,67,1,67,1,67,1,67,3,67,2456,8,67,1,67,1,67,1,67,1,67,3,
  	67,2462,8,67,1,67,1,67,3,67,2466,8,67,1,67,1,67,1,67,1,67,3,67,2472,8,
  	67,1,67,1,67,1,67,3,67,2477,8,67,1,67,3,67,2480,8,67,3,67,2482,8,67,1,
  	68,1,68,1,68,3,68,2487,8,68,1,69,1,69,3,69,2491,8,69,1,69,1,69,3,69,2495,
  	8,69,1,69,1,69,3,69,2499,8,69,1,69,1,69,3,69,2503,8,69,1,69,3,69,2506,
  	8,69,1,69,1,69,3,69,2510,8,69,1,69,1,69,1,69,1,69,1,69,1,69,3,69,2518,
  	8,69,1,69,1,69,3,69,2522,8,69,1,69,1,69,3,69,2526,8,69,1,70,1,70,1,71,
  	1,71,1,72,1,72,1,72,3,72,2535,8,72,1,73,1,73,1,73,1,73,1,73,3,73,2542,
  	8,73,1,74,5,74,2545,8,74,10,74,12,74,2548,9,74,1,75,1,75,1,75,1,75,3,
  	75,2554,8,75,1,75,1,75,1,75,3,75,2559,8,75,1,75,1,75,1,75,1,75,1,75,3,
  	75,2566,8,75,1,75,1,75,1,75,3,75,2571,8,75,1,75,1,75,1,75,1,75,1,75,1,
  	75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,3,75,2589,8,75,1,
  	76,1,76,1,77,3,77,2594,8,77,1,77,1,77,1,77,1,78,1,78,1,79,1,79,1,79,5,
  	79,2604,8,79,10,79,12,79,2607,9,79,1,80,1,80,3,80,2611,8,80,1,81,1,81,
  	1,81,1,81,1,81,1,81,1,81,3,81,2620,8,81,1,82,1,82,1,82,5,82,2625,8,82,
  	10,82,12,82,2628,9,82,1,83,1,83,1,84,1,84,3,84,2634,8,84,1,84,1,84,1,
  	84,1,84,3,84,2640,8,84,1,84,1,84,1,84,3,84,2645,8,84,1,84,1,84,3,84,2649,
  	8,84,1,84,3,84,2652,8,84,1,84,3,84,2655,8,84,1,84,3,84,2658,8,84,1,84,
  	3,84,2661,8,84,1,84,3,84,2664,8,84,1,84,1,84,1,84,3,84,2669,8,84,1,84,
  	3,84,2672,8,84,1,84,3,84,2675,8,84,1,84,3,84,2678,8,84,1,84,3,84,2681,
  	8,84,1,84,3,84,2684,8,84,1,84,1,84,1,84,1,84,3,84,2690,8,84,1,84,1,84,
  	3,84,2694,8,84,1,84,3,84,2697,8,84,1,84,3,84,2700,8,84,1,84,3,84,2703,
  	8,84,1,84,3,84,2706,8,84,3,84,2708,8,84,1,85,1,85,1,85,1,85,1,85,1,85,
  	1,85,3,85,2717,8,85,1,86,1,86,1,87,1,87,1,87,1,87,1,88,1,88,1,88,5,88,
  	2728,8,88,10,88,12,88,2731,9,88,1,89,1,89,1,89,5,89,2736,8,89,10,89,12,
  	89,2739,9,89,1,90,1,90,1,90,3,90,2744,8,90,1,91,1,91,3,91,2748,8,91,1,
  	92,1,92,1,92,3,92,2753,8,92,1,92,1,92,1,93,1,93,1,93,3,93,2760,8,93,1,
  	93,1,93,1,94,5,94,2765,8,94,10,94,12,94,2768,9,94,1,95,1,95,1,95,1,95,
  	1,95,1,95,1,95,1,95,3,95,2778,8,95,1,96,1,96,1,96,1,96,1,96,3,96,2785,
  	8,96,1,96,3,96,2788,8,96,1,96,1,96,1,96,3,96,2793,8,96,1,96,3,96,2796,
  	8,96,1,96,1,96,1,96,1,96,1,96,3,96,2803,8,96,1,96,1,96,1,96,1,96,1,96,
  	1,96,1,96,3,96,2812,8,96,1,96,1,96,1,96,1,96,1,96,3,96,2819,8,96,1,96,
  	1,96,1,96,3,96,2824,8,96,1,96,3,96,2827,8,96,1,96,3,96,2830,8,96,3,96,
  	2832,8,96,1,97,1,97,1,97,3,97,2837,8,97,1,98,1,98,1,98,1,98,1,98,3,98,
  	2844,8,98,1,99,1,99,1,99,1,99,1,100,1,100,5,100,2852,8,100,10,100,12,
  	100,2855,9,100,1,101,1,101,1,102,1,102,1,102,1,102,1,102,3,102,2864,8,
  	102,1,103,1,103,1,103,1,103,1,103,1,103,1,103,1,103,1,103,1,103,1,103,
  	3,103,2877,8,103,1,103,3,103,2880,8,103,1,103,3,103,2883,8,103,1,103,
  	1,103,1,103,1,103,1,103,3,103,2890,8,103,1,103,1,103,1,103,1,103,1,103,
  	1,103,3,103,2898,8,103,1,103,3,103,2901,8,103,1,103,3,103,2904,8,103,
  	1,103,1,103,1,103,1,103,1,103,3,103,2911,8,103,1,103,1,103,3,103,2915,
  	8,103,1,103,1,103,1,103,1,103,3,103,2921,8,103,1,103,3,103,2924,8,103,
  	1,103,3,103,2927,8,103,1,103,3,103,2930,8,103,1,103,1,103,1,103,1,103,
  	1,103,1,103,1,103,1,103,1,103,1,103,3,103,2942,8,103,1,103,3,103,2945,
  	8,103,1,103,3,103,2948,8,103,1,103,1,103,3,103,2952,8,103,1,104,1,104,
  	1,104,1,105,1,105,1,105,1,105,1,106,1,106,1,106,5,106,2964,8,106,10,106,
  	12,106,2967,9,106,1,107,1,107,1,108,1,108,1,108,1,108,1,108,1,109,1,109,
  	1,109,1,110,1,110,1,110,5,110,2982,8,110,10,110,12,110,2985,9,110,1,111,
  	1,111,1,111,1,111,1,111,1,111,1,111,1,111,3,111,2995,8,111,1,112,1,112,
  	1,112,1,112,1,112,1,113,1,113,1,113,1,113,1,113,1,113,1,113,1,113,3,113,
  	3010,8,113,1,114,1,114,1,114,1,114,1,115,1,115,1,115,1,115,1,116,1,116,
  	1,116,1,116,1,116,1,116,3,116,3026,8,116,1,117,1,117,1,117,1,117,1,117,
  	1,118,1,118,1,119,1,119,1,119,1,119,1,119,1,119,1,119,1,120,1,120,1,120,
  	5,120,3045,8,120,10,120,12,120,3048,9,120,1,121,1,121,3,121,3052,8,121,
  	1,121,3,121,3055,8,121,1,121,1,121,3,121,3059,8,121,1,121,3,121,3062,
  	8,121,1,121,1,121,1,121,1,121,3,121,3068,8,121,1,121,3,121,3071,8,121,
  	3,121,3073,8,121,1,122,1,122,1,122,1,123,1,123,1,123,1,123,3,123,3082,
  	8,123,1,124,1,124,1,124,1,124,1,124,1,124,1,124,3,124,3091,8,124,1,125,
  	1,125,1,125,1,126,1,126,1,126,1,126,1,126,1,127,1,127,1,127,1,127,1,128,
  	1,128,1,128,1,128,1,128,3,128,3110,8,128,1,128,1,128,3,128,3114,8,128,
  	1,128,1,128,1,128,1,128,1,128,1,129,1,129,1,129,1,129,3,129,3125,8,129,
  	1,129,1,129,1,129,1,129,1,129,1,130,1,130,3,130,3134,8,130,1,130,1,130,
  	1,130,1,130,3,130,3140,8,130,1,130,1,130,1,130,1,130,3,130,3146,8,130,
  	1,131,1,131,3,131,3150,8,131,1,131,3,131,3153,8,131,1,131,3,131,3156,
  	8,131,1,131,3,131,3159,8,131,1,131,3,131,3162,8,131,1,132,1,132,1,132,
  	1,132,3,132,3168,8,132,1,133,1,133,3,133,3172,8,133,1,133,1,133,1,133,
  	1,133,1,133,3,133,3179,8,133,1,133,1,133,1,133,1,133,3,133,3185,8,133,
  	1,134,1,134,3,134,3189,8,134,1,134,3,134,3192,8,134,1,134,3,134,3195,
  	8,134,1,134,3,134,3198,8,134,1,135,1,135,1,136,1,136,1,136,1,136,3,136,
  	3206,8,136,1,136,1,136,3,136,3210,8,136,1,137,1,137,3,137,3214,8,137,
  	1,137,1,137,1,137,1,137,3,137,3220,8,137,1,137,1,137,3,137,3224,8,137,
  	1,138,1,138,1,138,1,138,3,138,3230,8,138,1,138,1,138,1,138,1,139,1,139,
  	1,140,1,140,1,140,1,140,1,141,4,141,3242,8,141,11,141,12,141,3243,1,142,
  	1,142,1,142,1,142,1,142,1,142,1,142,3,142,3253,8,142,1,142,1,142,1,142,
  	1,142,1,142,1,142,1,142,1,142,1,142,1,142,1,142,1,142,1,142,1,142,1,142,
  	3,142,3270,8,142,1,142,1,142,1,142,3,142,3275,8,142,1,142,3,142,3278,
  	8,142,3,142,3280,8,142,1,143,1,143,1,144,1,144,1,144,1,144,1,144,1,144,
  	3,144,3290,8,144,1,145,1,145,1,145,5,145,3295,8,145,10,145,12,145,3298,
  	9,145,1,146,1,146,3,146,3302,8,146,1,146,3,146,3305,8,146,1,146,3,146,
  	3308,8,146,1,146,1,146,1,146,1,146,1,146,3,146,3315,8,146,1,146,3,146,
  	3318,8,146,3,146,3320,8,146,1,147,1,147,1,148,1,148,3,148,3326,8,148,
  	1,149,1,149,1,149,1,150,1,150,1,150,1,150,3,150,3335,8,150,1,151,1,151,
  	1,152,1,152,1,153,1,153,1,153,1,153,3,153,3345,8,153,1,153,1,153,1,153,
  	3,153,3350,8,153,1,154,1,154,1,154,1,155,1,155,1,155,1,155,3,155,3359,
  	8,155,1,155,1,155,1,156,1,156,1,156,1,156,1,156,3,156,3368,8,156,1,156,
  	1,156,3,156,3372,8,156,1,156,1,156,1,157,5,157,3377,8,157,10,157,12,157,
  	3380,9,157,1,158,1,158,1,158,1,158,1,158,1,158,1,158,3,158,3389,8,158,
  	1,159,1,159,1,159,1,159,1,159,1,159,1,160,5,160,3398,8,160,10,160,12,
  	160,3401,9,160,1,161,1,161,1,161,1,162,1,162,1,162,1,162,1,162,1,162,
  	1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,
  	1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,
  	1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,
  	1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,
  	1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,
  	1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,
  	1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,
  	1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,
  	1,162,1,162,3,162,3510,8,162,1,163,1,163,1,163,1,163,1,163,1,163,3,163,
  	3518,8,163,1,163,3,163,3521,8,163,1,164,1,164,1,164,1,164,1,164,1,164,
  	1,164,1,164,3,164,3531,8,164,1,165,4,165,3534,8,165,11,165,12,165,3535,
  	1,166,1,166,1,167,1,167,1,167,1,167,1,167,1,167,3,167,3546,8,167,1,167,
  	1,167,1,167,1,167,1,167,1,167,1,167,1,167,1,167,3,167,3557,8,167,1,168,
  	1,168,1,168,1,168,1,168,1,169,1,169,1,169,5,169,3567,8,169,10,169,12,
  	169,3570,9,169,1,170,1,170,1,170,1,170,1,170,1,171,1,171,1,171,5,171,
  	3580,8,171,10,171,12,171,3583,9,171,1,172,1,172,1,172,1,172,1,172,1,172,
  	1,172,3,172,3592,8,172,1,173,1,173,1,173,1,174,1,174,1,175,1,175,1,176,
  	1,176,1,176,1,176,3,176,3605,8,176,1,176,3,176,3608,8,176,1,176,1,176,
  	1,176,1,176,1,176,3,176,3615,8,176,1,176,1,176,1,176,1,176,1,176,1,176,
  	1,176,3,176,3624,8,176,1,176,3,176,3627,8,176,1,176,1,176,1,176,1,176,
  	1,176,3,176,3634,8,176,3,176,3636,8,176,1,177,1,177,1,177,1,178,1,178,
  	1,178,3,178,3644,8,178,1,179,1,179,1,180,1,180,1,180,1,180,1,180,1,180,
  	3,180,3654,8,180,3,180,3656,8,180,1,181,1,181,1,181,1,181,1,181,1,181,
  	3,181,3664,8,181,1,181,1,181,3,181,3668,8,181,1,181,1,181,1,181,3,181,
  	3673,8,181,1,181,1,181,1,181,1,181,1,181,1,181,1,181,1,181,1,181,3,181,
  	3684,8,181,1,181,1,181,3,181,3688,8,181,1,181,1,181,1,181,3,181,3693,
  	8,181,1,181,1,181,1,181,1,181,1,181,1,181,1,181,1,181,3,181,3703,8,181,
  	1,181,1,181,1,181,1,181,3,181,3709,8,181,1,181,1,181,1,181,1,181,1,181,
  	1,181,1,181,1,181,1,181,1,181,1,181,3,181,3722,8,181,1,181,1,181,1,181,
  	1,181,3,181,3728,8,181,3,181,3730,8,181,1,182,1,182,1,182,1,182,1,182,
  	3,182,3737,8,182,1,182,1,182,1,182,1,182,1,182,1,182,3,182,3745,8,182,
  	1,183,1,183,1,183,3,183,3750,8,183,1,184,1,184,1,184,1,184,1,184,1,185,
  	1,185,1,185,1,185,1,185,1,185,1,185,1,185,3,185,3765,8,185,1,185,1,185,
  	1,185,1,185,1,185,1,185,1,185,1,185,1,185,1,185,1,185,3,185,3778,8,185,
  	3,185,3780,8,185,1,186,1,186,3,186,3784,8,186,1,187,1,187,1,187,1,187,
  	1,187,1,187,1,187,1,187,1,187,1,187,1,187,1,187,1,187,1,187,1,187,1,187,
  	1,187,1,187,3,187,3804,8,187,1,188,1,188,1,188,1,188,1,188,1,188,1,188,
  	1,188,1,188,1,189,1,189,1,189,1,189,1,189,1,189,3,189,3821,8,189,1,189,
  	3,189,3824,8,189,1,189,3,189,3827,8,189,1,189,3,189,3830,8,189,1,189,
  	3,189,3833,8,189,1,190,1,190,1,190,1,190,1,190,1,190,3,190,3841,8,190,
  	1,190,3,190,3844,8,190,1,190,3,190,3847,8,190,1,191,1,191,1,191,1,191,
  	1,191,1,192,1,192,1,192,1,192,1,192,1,192,1,193,1,193,1,193,1,194,1,194,
  	1,194,1,195,1,195,1,195,1,196,1,196,1,196,1,197,1,197,1,198,1,198,1,198,
  	1,198,1,198,1,198,1,198,1,198,1,198,1,199,1,199,1,200,1,200,1,200,1,200,
  	1,200,1,200,1,200,1,200,3,200,3893,8,200,1,200,3,200,3896,8,200,1,200,
  	3,200,3899,8,200,1,200,1,200,1,200,1,200,1,200,1,200,1,200,1,200,1,200,
  	1,200,1,200,1,200,1,200,1,200,1,200,1,200,3,200,3917,8,200,1,200,1,200,
  	1,200,1,200,1,200,3,200,3924,8,200,1,200,1,200,1,200,1,200,1,200,1,200,
  	1,200,3,200,3933,8,200,1,201,1,201,1,201,1,201,3,201,3939,8,201,1,202,
  	1,202,1,202,5,202,3944,8,202,10,202,12,202,3947,9,202,1,203,1,203,1,203,
  	1,203,1,203,1,203,1,203,3,203,3956,8,203,1,204,1,204,1,204,1,205,4,205,
  	3962,8,205,11,205,12,205,3963,1,206,1,206,1,206,3,206,3969,8,206,1,206,
  	1,206,1,207,1,207,1,208,1,208,1,209,1,209,1,210,1,210,3,210,3981,8,210,
  	1,210,1,210,1,211,1,211,1,212,1,212,1,213,1,213,1,213,1,213,1,213,1,214,
  	1,214,1,215,1,215,3,215,3998,8,215,1,215,1,215,5,215,4002,8,215,10,215,
  	12,215,4005,9,215,1,216,1,216,1,216,1,216,3,216,4011,8,216,1,217,1,217,
  	1,217,1,218,5,218,4017,8,218,10,218,12,218,4020,9,218,1,219,1,219,1,219,
  	1,219,1,219,1,219,1,219,1,219,1,219,1,219,1,219,3,219,4033,8,219,1,220,
  	1,220,1,220,1,220,1,220,1,220,1,220,1,220,1,220,1,220,1,220,1,220,1,220,
  	1,220,1,220,1,220,1,220,1,220,1,220,1,220,1,220,1,220,1,220,1,220,1,220,
  	1,220,3,220,4061,8,220,1,221,1,221,1,221,5,221,4066,8,221,10,221,12,221,
  	4069,9,221,1,222,1,222,1,222,1,222,1,222,1,222,1,223,1,223,1,223,5,223,
  	4080,8,223,10,223,12,223,4083,9,223,1,224,1,224,1,224,1,224,1,224,1,224,
  	1,225,1,225,1,225,1,225,1,225,1,225,3,225,4097,8,225,1,226,1,226,1,226,
  	1,226,1,226,1,226,1,226,1,226,1,226,1,227,1,227,3,227,4110,8,227,1,227,
  	1,227,1,227,1,227,1,227,1,227,1,227,3,227,4119,8,227,1,227,1,227,1,227,
  	1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,
  	1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,3,227,4144,8,227,1,227,
  	1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,3,227,4155,8,227,1,227,
  	1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,
  	1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,
  	1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,
  	1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,
  	1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,
  	1,227,1,227,1,227,1,227,3,227,4222,8,227,1,228,1,228,1,228,1,228,1,229,
  	1,229,1,229,5,229,4231,8,229,10,229,12,229,4234,9,229,1,230,1,230,1,230,
  	3,230,4239,8,230,1,231,1,231,1,231,1,231,1,231,1,231,3,231,4247,8,231,
  	1,232,1,232,1,232,1,232,1,233,1,233,1,233,5,233,4256,8,233,10,233,12,
  	233,4259,9,233,1,234,1,234,1,234,1,234,1,235,1,235,1,236,1,236,1,236,
  	5,236,4270,8,236,10,236,12,236,4273,9,236,1,237,1,237,1,237,1,237,1,237,
  	1,237,3,237,4281,8,237,1,237,1,237,1,237,1,237,1,237,1,237,1,237,1,237,
  	3,237,4291,8,237,1,237,1,237,1,237,1,237,1,237,1,237,1,237,1,237,1,237,
  	1,237,3,237,4303,8,237,1,237,1,237,1,237,1,237,1,237,1,237,1,237,1,237,
  	1,237,1,237,1,237,1,237,1,237,3,237,4318,8,237,1,238,1,238,1,238,1,238,
  	1,239,1,239,1,239,1,239,1,239,3,239,4329,8,239,1,239,1,239,1,239,1,239,
  	1,239,1,239,3,239,4337,8,239,1,239,1,239,1,239,1,240,1,240,1,240,5,240,
  	4345,8,240,10,240,12,240,4348,9,240,1,241,1,241,1,241,1,241,3,241,4354,
  	8,241,1,241,3,241,4357,8,241,1,241,1,241,1,241,1,241,3,241,4363,8,241,
  	1,241,3,241,4366,8,241,1,241,1,241,1,241,1,241,1,241,1,241,1,241,1,241,
  	1,241,1,241,1,241,1,241,1,241,3,241,4381,8,241,1,242,1,242,1,243,1,243,
  	1,243,1,244,1,244,1,244,1,244,1,244,1,244,3,244,4394,8,244,1,245,1,245,
  	1,246,1,246,1,246,1,246,1,246,1,246,1,246,1,247,1,247,1,247,1,247,1,247,
  	1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,
  	1,247,3,247,4423,8,247,1,248,1,248,1,248,5,248,4428,8,248,10,248,12,248,
  	4431,9,248,1,249,1,249,1,249,1,249,1,249,1,249,1,249,1,249,1,249,1,249,
  	1,249,1,249,3,249,4445,8,249,1,250,1,250,1,250,1,250,1,250,1,250,1,250,
  	3,250,4454,8,250,1,250,1,250,1,250,1,250,1,250,1,250,1,250,1,250,1,250,
  	3,250,4465,8,250,3,250,4467,8,250,1,251,1,251,1,251,1,251,1,251,1,251,
  	1,251,3,251,4476,8,251,1,251,1,251,1,251,1,251,1,251,1,251,1,251,1,251,
  	1,251,3,251,4487,8,251,3,251,4489,8,251,1,252,1,252,1,252,1,252,1,252,
  	3,252,4496,8,252,1,253,1,253,1,253,1,253,1,253,1,253,1,253,1,254,1,254,
  	1,254,1,254,1,254,1,254,3,254,4511,8,254,1,254,1,254,1,254,1,254,3,254,
  	4517,8,254,1,254,1,254,1,254,1,254,1,254,1,254,3,254,4525,8,254,1,254,
  	1,254,1,254,1,254,3,254,4531,8,254,1,254,1,254,1,254,1,254,1,254,1,254,
  	3,254,4539,8,254,1,254,1,254,1,254,1,254,1,254,1,254,1,254,1,254,3,254,
  	4549,8,254,1,254,1,254,1,254,1,254,3,254,4555,8,254,1,254,1,254,1,254,
  	1,254,1,254,1,254,3,254,4563,8,254,1,254,1,254,1,254,1,254,3,254,4569,
  	8,254,1,254,1,254,1,254,1,254,1,254,1,254,3,254,4577,8,254,1,254,1,254,
  	1,254,1,254,1,254,3,254,4584,8,254,1,254,1,254,1,254,1,254,1,254,1,254,
  	1,254,3,254,4593,8,254,3,254,4595,8,254,1,255,1,255,1,255,1,255,1,255,
  	1,255,1,255,1,255,1,255,1,255,1,255,1,255,1,255,1,255,1,255,1,255,1,255,
  	1,255,1,255,1,255,1,255,1,255,1,255,3,255,4620,8,255,1,256,1,256,1,256,
  	1,256,1,256,3,256,4627,8,256,1,257,1,257,1,257,1,257,1,257,1,257,1,257,
  	1,257,1,257,3,257,4638,8,257,1,257,1,257,1,257,1,257,3,257,4644,8,257,
  	1,258,1,258,1,259,1,259,1,259,5,259,4651,8,259,10,259,12,259,4654,9,259,
  	1,260,1,260,3,260,4658,8,260,1,261,1,261,4,261,4662,8,261,11,261,12,261,
  	4663,1,262,1,262,1,262,5,262,4669,8,262,10,262,12,262,4672,9,262,1,263,
  	1,263,3,263,4676,8,263,1,263,1,263,3,263,4680,8,263,1,263,3,263,4683,
  	8,263,1,264,1,264,1,264,1,264,3,264,4689,8,264,1,265,1,265,1,265,1,265,
  	1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,
  	1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,
  	1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,
  	1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,
  	1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,
  	1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,
  	1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,
  	1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,
  	1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,
  	1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,
  	1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,
  	1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,1,265,3,265,
  	4838,8,265,1,266,1,266,3,266,4842,8,266,1,267,1,267,1,267,3,267,4847,
  	8,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,3,267,4858,
  	8,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,3,267,4869,
  	8,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,3,267,4880,
  	8,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,3,267,4891,
  	8,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,3,267,4902,
  	8,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,3,267,4913,
  	8,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,3,267,4924,
  	8,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,3,267,
  	4936,8,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,1,267,3,267,
  	4947,8,267,1,267,1,267,1,267,1,267,1,267,1,267,3,267,4955,8,267,1,268,
  	1,268,1,268,1,269,1,269,3,269,4962,8,269,1,270,1,270,1,270,1,270,3,270,
  	4968,8,270,1,271,1,271,1,271,1,271,1,271,1,271,3,271,4976,8,271,1,271,
  	1,271,1,271,3,271,4981,8,271,1,271,1,271,1,271,3,271,4986,8,271,1,271,
  	1,271,1,271,3,271,4991,8,271,1,271,1,271,1,271,1,271,3,271,4997,8,271,
  	1,271,1,271,1,271,1,271,1,271,3,271,5004,8,271,1,271,1,271,1,271,1,271,
  	3,271,5010,8,271,1,271,1,271,1,271,1,271,3,271,5016,8,271,1,271,1,271,
  	1,271,3,271,5021,8,271,1,271,1,271,1,271,1,271,3,271,5027,8,271,1,271,
  	1,271,1,271,1,271,1,271,3,271,5034,8,271,1,271,1,271,1,271,3,271,5039,
  	8,271,1,271,1,271,1,271,1,271,3,271,5045,8,271,1,271,1,271,1,271,1,271,
  	1,271,3,271,5052,8,271,1,271,3,271,5055,8,271,1,272,1,272,1,273,1,273,
  	1,274,1,274,1,274,1,274,1,274,1,274,1,274,3,274,5068,8,274,1,275,1,275,
  	1,275,1,275,1,275,1,275,1,275,3,275,5077,8,275,1,275,1,275,1,275,1,275,
  	1,275,1,275,1,275,1,275,1,275,1,275,3,275,5089,8,275,3,275,5091,8,275,
  	1,276,1,276,1,276,1,276,1,276,1,276,1,276,1,276,1,276,1,276,1,276,1,276,
  	1,276,1,276,1,276,3,276,5108,8,276,1,277,1,277,1,277,5,277,5113,8,277,
  	10,277,12,277,5116,9,277,1,278,1,278,3,278,5120,8,278,1,278,1,278,3,278,
  	5124,8,278,1,278,1,278,3,278,5128,8,278,1,278,1,278,3,278,5132,8,278,
  	3,278,5134,8,278,1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,
  	1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,
  	1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,
  	1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,
  	1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,1,279,
  	1,279,3,279,5194,8,279,1,280,1,280,1,280,5,280,5199,8,280,10,280,12,280,
  	5202,9,280,1,281,1,281,1,281,3,281,5207,8,281,1,282,1,282,1,282,1,282,
  	1,283,1,283,1,283,1,283,1,283,3,283,5218,8,283,1,283,3,283,5221,8,283,
  	1,284,1,284,1,284,1,284,1,284,3,284,5228,8,284,1,284,3,284,5231,8,284,
  	1,284,1,284,1,284,1,284,1,284,1,284,1,284,1,284,3,284,5241,8,284,1,284,
  	3,284,5244,8,284,3,284,5246,8,284,1,285,1,285,1,285,1,285,1,286,1,286,
  	1,286,1,286,1,287,1,287,1,287,1,287,1,287,1,287,1,288,5,288,5263,8,288,
  	10,288,12,288,5266,9,288,1,289,1,289,1,289,1,289,1,289,1,289,1,289,1,
  	289,1,289,3,289,5277,8,289,1,290,1,290,1,290,1,290,1,290,1,290,1,290,
  	3,290,5286,8,290,1,290,1,290,1,290,1,290,1,290,1,290,1,290,3,290,5295,
  	8,290,1,290,1,290,1,290,1,290,1,290,1,290,1,290,1,290,1,290,1,290,3,290,
  	5307,8,290,3,290,5309,8,290,1,291,1,291,1,292,1,292,3,292,5315,8,292,
  	1,292,1,292,3,292,5319,8,292,1,292,3,292,5322,8,292,1,292,3,292,5325,
  	8,292,1,292,1,292,1,292,3,292,5330,8,292,1,292,1,292,1,292,1,292,3,292,
  	5336,8,292,1,292,3,292,5339,8,292,1,292,3,292,5342,8,292,1,292,3,292,
  	5345,8,292,1,292,3,292,5348,8,292,1,292,1,292,3,292,5352,8,292,1,292,
  	1,292,3,292,5356,8,292,1,292,3,292,5359,8,292,1,292,1,292,1,292,1,292,
  	3,292,5365,8,292,1,292,1,292,1,292,1,292,3,292,5371,8,292,1,292,3,292,
  	5374,8,292,1,292,3,292,5377,8,292,1,292,3,292,5380,8,292,1,292,3,292,
  	5383,8,292,3,292,5385,8,292,1,293,1,293,1,294,1,294,3,294,5391,8,294,
  	1,294,1,294,1,295,1,295,1,296,1,296,1,297,1,297,1,298,1,298,1,298,1,299,
  	1,299,1,299,5,299,5407,8,299,10,299,12,299,5410,9,299,1,300,3,300,5413,
  	8,300,1,300,3,300,5416,8,300,1,300,3,300,5419,8,300,1,300,3,300,5422,
  	8,300,1,300,3,300,5425,8,300,1,300,1,300,1,300,3,300,5430,8,300,1,300,
  	3,300,5433,8,300,3,300,5435,8,300,1,301,1,301,1,301,1,301,1,301,1,301,
  	1,301,1,301,1,301,1,301,1,301,3,301,5448,8,301,1,302,1,302,1,302,1,302,
  	1,302,1,303,1,303,1,303,5,303,5458,8,303,10,303,12,303,5461,9,303,1,304,
  	1,304,1,304,1,305,1,305,1,306,1,306,1,307,1,307,1,307,1,307,3,307,5474,
  	8,307,1,308,1,308,3,308,5478,8,308,1,308,1,308,1,308,1,308,1,308,1,308,
  	1,308,1,308,1,308,1,308,3,308,5490,8,308,3,308,5492,8,308,1,308,1,308,
  	1,309,1,309,1,309,1,310,1,310,3,310,5501,8,310,1,310,1,310,1,311,1,311,
  	1,311,5,311,5508,8,311,10,311,12,311,5511,9,311,1,312,1,312,1,312,5,312,
  	5516,8,312,10,312,12,312,5519,9,312,1,313,1,313,1,313,1,313,1,313,1,313,
  	3,313,5527,8,313,3,313,5529,8,313,1,314,1,314,3,314,5533,8,314,1,314,
  	1,314,1,315,1,315,1,315,5,315,5540,8,315,10,315,12,315,5543,9,315,1,316,
  	1,316,3,316,5547,8,316,1,316,1,316,1,316,1,316,3,316,5553,8,316,1,316,
  	1,316,1,316,3,316,5558,8,316,1,317,1,317,3,317,5562,8,317,1,317,1,317,
  	1,317,3,317,5567,8,317,1,318,1,318,1,319,1,319,1,320,1,320,3,320,5575,
  	8,320,1,320,1,320,1,320,1,320,1,320,3,320,5582,8,320,1,321,1,321,1,321,
  	3,321,5587,8,321,1,322,1,322,1,323,1,323,1,323,1,323,1,323,1,323,1,323,
  	1,323,1,323,1,323,1,323,3,323,5602,8,323,1,323,1,323,1,324,1,324,1,324,
  	5,324,5609,8,324,10,324,12,324,5612,9,324,1,325,1,325,1,325,1,326,1,326,
  	1,326,5,326,5620,8,326,10,326,12,326,5623,9,326,1,327,4,327,5626,8,327,
  	11,327,12,327,5627,1,327,1,327,1,328,1,328,1,328,1,328,1,328,1,328,1,
  	328,1,328,1,328,1,328,1,328,1,328,1,328,1,328,1,328,1,328,1,328,1,328,
  	1,328,1,328,1,328,1,328,1,328,1,328,1,328,1,328,1,328,1,328,1,328,1,328,
  	1,328,1,328,1,328,1,328,1,328,3,328,5667,8,328,1,329,1,329,1,329,1,329,
  	1,329,1,329,1,329,1,329,3,329,5677,8,329,1,330,1,330,1,330,1,330,1,330,
  	3,330,5684,8,330,1,331,1,331,1,331,1,331,1,331,1,331,1,331,5,331,5693,
  	8,331,10,331,12,331,5696,9,331,1,332,1,332,1,332,1,333,1,333,1,333,1,
  	334,1,334,1,334,5,334,5707,8,334,10,334,12,334,5710,9,334,1,335,1,335,
  	1,335,1,335,1,335,3,335,5717,8,335,1,336,4,336,5720,8,336,11,336,12,336,
  	5721,1,337,1,337,1,338,1,338,1,338,1,338,3,338,5730,8,338,1,338,1,338,
  	1,338,1,338,1,338,1,338,3,338,5738,8,338,1,338,1,338,1,338,1,338,3,338,
  	5744,8,338,1,338,1,338,1,338,1,338,1,338,1,338,3,338,5752,8,338,1,338,
  	1,338,1,338,1,338,3,338,5758,8,338,1,338,1,338,1,338,1,338,1,338,1,338,
  	3,338,5766,8,338,3,338,5768,8,338,1,339,1,339,1,339,1,339,3,339,5774,
  	8,339,1,339,1,339,1,339,1,339,1,339,1,339,3,339,5782,8,339,3,339,5784,
  	8,339,1,340,1,340,1,340,1,340,3,340,5790,8,340,1,340,1,340,1,340,1,340,
  	1,340,1,340,3,340,5798,8,340,3,340,5800,8,340,1,341,1,341,1,341,1,341,
  	1,341,1,341,1,341,1,341,1,341,1,341,1,341,1,341,1,341,1,341,1,341,1,341,
  	1,341,1,341,1,341,1,341,1,341,1,341,3,341,5824,8,341,1,342,1,342,1,342,
  	5,342,5829,8,342,10,342,12,342,5832,9,342,1,342,1,342,1,343,1,343,1,343,
  	5,343,5839,8,343,10,343,12,343,5842,9,343,1,344,1,344,1,344,1,345,1,345,
  	1,345,1,346,4,346,5851,8,346,11,346,12,346,5852,1,347,1,347,1,347,3,347,
  	5858,8,347,1,348,1,348,1,348,1,348,1,348,1,348,1,348,1,348,1,348,1,348,
  	1,348,3,348,5871,8,348,1,348,1,348,1,348,1,348,1,348,1,348,1,348,1,348,
  	1,348,1,348,3,348,5883,8,348,1,348,1,348,1,348,1,348,1,348,1,348,1,348,
  	1,348,1,348,1,348,3,348,5895,8,348,3,348,5897,8,348,1,349,1,349,1,349,
  	1,349,3,349,5903,8,349,1,350,1,350,1,350,3,350,5908,8,350,1,350,1,350,
  	1,350,1,350,1,350,1,350,3,350,5916,8,350,1,351,1,351,1,351,1,352,1,352,
  	3,352,5923,8,352,1,352,1,352,1,352,1,352,1,352,1,352,1,352,1,352,1,352,
  	1,353,1,353,1,353,1,353,1,353,1,353,1,353,1,353,1,353,1,353,1,353,1,353,
  	1,353,1,353,1,353,1,353,1,353,1,353,1,353,1,353,1,353,1,353,1,353,1,353,
  	1,353,1,353,1,353,1,353,1,353,1,353,1,353,1,353,1,353,1,353,3,353,5968,
  	8,353,1,354,1,354,1,354,3,354,5973,8,354,1,354,1,354,1,354,1,354,1,354,
  	3,354,5980,8,354,1,355,1,355,3,355,5984,8,355,1,355,1,355,3,355,5988,
  	8,355,1,355,1,355,1,355,1,355,3,355,5994,8,355,1,355,1,355,3,355,5998,
  	8,355,1,355,1,355,1,355,3,355,6003,8,355,1,355,1,355,3,355,6007,8,355,
  	1,355,3,355,6010,8,355,3,355,6012,8,355,1,356,1,356,1,357,1,357,1,358,
  	1,358,1,358,1,358,1,359,1,359,1,359,1,359,1,359,1,359,1,359,1,359,1,359,
  	1,359,1,359,1,359,3,359,6034,8,359,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,3,360,6105,8,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,3,360,6300,8,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,3,360,6313,8,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,3,360,6324,8,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,3,360,
  	6337,8,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	3,360,6349,8,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,3,360,6363,8,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	3,360,6395,8,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,3,360,6409,8,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,
  	1,360,1,360,1,360,1,360,1,360,1,360,1,360,1,360,3,360,6521,8,360,3,360,
  	6523,8,360,1,361,1,361,1,362,1,362,1,362,1,363,1,363,1,363,1,363,3,363,
  	6534,8,363,1,363,1,363,1,363,1,363,1,363,1,363,1,363,1,363,1,363,3,363,
  	6545,8,363,1,363,1,363,1,363,1,363,1,363,1,363,1,363,1,363,1,363,3,363,
  	6556,8,363,1,363,1,363,1,363,1,363,1,363,1,363,1,363,1,363,1,363,1,363,
  	1,363,3,363,6569,8,363,1,363,1,363,1,363,1,363,1,363,1,363,1,363,1,363,
  	1,363,1,363,3,363,6581,8,363,1,363,1,363,1,363,1,363,1,363,1,363,1,363,
  	1,363,1,363,3,363,6592,8,363,1,363,1,363,1,363,1,363,1,363,3,363,6599,
  	8,363,1,364,1,364,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,
  	1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,
  	1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,
  	1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,
  	1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,
  	1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,
  	1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,
  	1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,
  	1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,
  	1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,
  	1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,
  	1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,
  	1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,
  	1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,
  	1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,
  	1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,
  	1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,
  	1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,1,365,
  	1,365,1,365,1,365,1,365,3,365,6820,8,365,1,366,1,366,1,366,1,366,1,366,
  	1,366,1,366,1,366,1,367,1,367,1,367,5,367,6833,8,367,10,367,12,367,6836,
  	9,367,1,368,1,368,1,368,1,368,1,368,1,368,1,368,1,368,3,368,6846,8,368,
  	1,369,1,369,1,369,1,369,1,369,3,369,6853,8,369,1,370,1,370,1,370,1,370,
  	1,370,1,370,1,370,1,370,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,
  	1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,
  	1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,
  	1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,
  	3,371,6907,8,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,
  	1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,
  	1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,
  	1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,
  	1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,
  	1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,
  	1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,
  	1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,
  	1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,
  	1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,
  	1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,
  	1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,1,371,3,371,7048,
  	8,371,1,372,1,372,1,372,1,372,3,372,7054,8,372,1,372,3,372,7057,8,372,
  	1,373,1,373,1,374,1,374,1,374,1,374,1,374,1,374,3,374,7067,8,374,1,375,
  	1,375,1,375,1,375,1,375,1,375,1,375,1,375,1,375,1,375,1,375,1,375,1,375,
  	1,375,1,375,1,375,1,375,1,375,1,375,1,375,1,375,1,375,1,375,1,375,1,375,
  	1,375,1,375,3,375,7096,8,375,1,376,1,376,1,376,1,376,1,376,1,376,1,376,
  	1,376,3,376,7106,8,376,1,377,1,377,1,377,5,377,7111,8,377,10,377,12,377,
  	7114,9,377,1,378,1,378,1,379,1,379,1,379,1,379,1,379,1,379,1,379,1,379,
  	1,379,1,379,1,379,1,379,1,379,1,379,1,379,1,379,1,379,1,379,3,379,7136,
  	8,379,1,379,1,379,1,379,1,379,1,379,1,379,1,379,3,379,7145,8,379,1,379,
  	1,379,1,379,1,379,1,379,1,379,1,379,1,379,1,379,1,379,3,379,7157,8,379,
  	1,380,1,380,1,380,1,380,3,380,7163,8,380,1,380,1,380,1,380,1,380,1,380,
  	1,380,3,380,7171,8,380,3,380,7173,8,380,1,381,1,381,3,381,7177,8,381,
  	1,381,1,381,1,381,1,381,1,381,1,381,1,381,1,381,3,381,7187,8,381,1,381,
  	1,381,3,381,7191,8,381,1,381,1,381,1,382,1,382,1,382,1,382,1,382,1,382,
  	3,382,7201,8,382,1,383,3,383,7204,8,383,1,383,1,383,3,383,7208,8,383,
  	5,383,7210,8,383,10,383,12,383,7213,9,383,1,384,1,384,1,384,1,384,1,384,
  	3,384,7220,8,384,1,385,1,385,1,386,1,386,1,387,1,387,1,388,1,388,1,388,
  	3,388,7231,8,388,1,389,1,389,1,389,1,390,1,390,1,390,1,391,1,391,1,391,
  	1,391,3,391,7243,8,391,1,392,1,392,3,392,7247,8,392,1,392,3,392,7250,
  	8,392,1,392,1,392,3,392,7254,8,392,1,392,3,392,7257,8,392,1,392,1,392,
  	1,392,3,392,7262,8,392,1,392,1,392,3,392,7266,8,392,1,392,3,392,7269,
  	8,392,1,392,1,392,3,392,7273,8,392,1,392,3,392,7276,8,392,1,392,1,392,
  	3,392,7280,8,392,1,392,3,392,7283,8,392,1,392,1,392,1,392,1,392,1,392,
  	1,392,1,392,1,392,1,392,3,392,7294,8,392,1,392,1,392,1,392,1,392,1,392,
  	3,392,7301,8,392,1,392,1,392,1,392,1,392,1,392,1,392,1,392,1,392,1,392,
  	1,392,1,392,3,392,7314,8,392,1,393,1,393,1,394,1,394,1,394,1,394,1,394,
  	1,394,1,394,1,394,1,394,1,394,3,394,7328,8,394,1,395,1,395,3,395,7332,
  	8,395,1,395,5,395,7335,8,395,10,395,12,395,7338,9,395,1,396,1,396,1,397,
  	1,397,3,397,7344,8,397,1,397,1,397,1,398,1,398,1,398,3,398,7351,8,398,
  	1,398,3,398,7354,8,398,1,398,1,398,1,398,3,398,7359,8,398,1,398,3,398,
  	7362,8,398,1,398,1,398,1,398,1,398,1,398,1,398,1,398,3,398,7371,8,398,
  	3,398,7373,8,398,1,398,1,398,1,398,3,398,7378,8,398,1,399,1,399,3,399,
  	7382,8,399,1,399,1,399,1,399,1,400,1,400,1,400,1,401,1,401,1,401,1,401,
  	3,401,7394,8,401,1,401,3,401,7397,8,401,1,402,1,402,1,403,4,403,7402,
  	8,403,11,403,12,403,7403,1,404,1,404,3,404,7408,8,404,1,404,1,404,1,404,
  	3,404,7413,8,404,1,405,1,405,1,405,1,405,1,405,1,405,1,405,1,405,3,405,
  	7423,8,405,1,406,1,406,1,407,1,407,1,407,1,407,1,407,3,407,7432,8,407,
  	1,407,3,407,7435,8,407,1,407,1,407,1,407,3,407,7440,8,407,1,408,1,408,
  	1,408,1,408,1,408,1,409,1,409,1,409,1,409,3,409,7451,8,409,1,409,1,409,
  	3,409,7455,8,409,1,409,1,409,1,409,1,409,3,409,7461,8,409,1,410,1,410,
  	1,410,5,410,7466,8,410,10,410,12,410,7469,9,410,1,411,1,411,1,412,1,412,
  	1,412,1,412,1,412,1,412,1,413,1,413,1,413,1,413,1,413,1,414,1,414,1,414,
  	1,414,3,414,7488,8,414,1,414,1,414,1,414,1,415,1,415,1,415,1,415,1,415,
  	1,415,1,415,1,415,1,415,1,415,1,415,1,415,1,415,1,415,1,415,1,415,3,415,
  	7509,8,415,1,415,1,415,3,415,7513,8,415,1,415,1,415,1,415,3,415,7518,
  	8,415,1,416,1,416,1,417,1,417,1,417,1,417,1,417,1,417,1,417,1,418,1,418,
  	1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,
  	1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,
  	1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,
  	1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,
  	1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,
  	1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,1,418,3,418,7601,
  	8,418,1,419,1,419,1,420,1,420,3,420,7607,8,420,1,420,1,420,1,420,1,420,
  	1,420,1,420,1,420,1,420,1,420,1,421,1,421,3,421,7620,8,421,1,421,1,421,
  	3,421,7624,8,421,1,421,1,421,3,421,7628,8,421,1,421,1,421,3,421,7632,
  	8,421,1,421,1,421,1,421,1,421,3,421,7638,8,421,1,422,1,422,1,422,1,423,
  	1,423,3,423,7645,8,423,1,423,3,423,7648,8,423,1,423,3,423,7651,8,423,
  	1,423,3,423,7654,8,423,1,423,3,423,7657,8,423,1,423,1,423,1,423,1,423,
  	1,423,3,423,7664,8,423,3,423,7666,8,423,1,424,1,424,3,424,7670,8,424,
  	1,424,3,424,7673,8,424,1,424,1,424,1,424,1,424,1,424,3,424,7680,8,424,
  	3,424,7682,8,424,1,425,1,425,1,425,5,425,7687,8,425,10,425,12,425,7690,
  	9,425,1,426,1,426,1,426,5,426,7695,8,426,10,426,12,426,7698,9,426,1,427,
  	1,427,1,428,1,428,3,428,7704,8,428,1,429,1,429,1,429,3,429,7709,8,429,
  	1,430,1,430,3,430,7713,8,430,1,431,1,431,3,431,7717,8,431,1,432,1,432,
  	3,432,7721,8,432,1,433,1,433,3,433,7725,8,433,1,434,1,434,1,435,1,435,
  	1,436,1,436,1,437,1,437,1,438,1,438,1,438,1,438,1,439,1,439,3,439,7741,
  	8,439,1,440,1,440,1,440,5,440,7746,8,440,10,440,12,440,7749,9,440,1,441,
  	1,441,1,442,1,442,1,442,1,442,1,442,3,442,7758,8,442,1,442,1,442,1,442,
  	1,442,1,442,1,442,1,442,1,442,1,442,1,442,1,442,3,442,7771,8,442,1,443,
  	1,443,1,443,1,443,1,443,1,443,1,443,1,443,1,443,3,443,7782,8,443,1,444,
  	1,444,1,444,5,444,7787,8,444,10,444,12,444,7790,9,444,1,445,1,445,3,445,
  	7794,8,445,1,446,1,446,3,446,7798,8,446,1,447,1,447,3,447,7802,8,447,
  	1,448,1,448,1,448,3,448,7807,8,448,1,448,1,448,1,448,1,449,1,449,1,449,
  	1,449,1,450,1,450,1,450,1,450,3,450,7820,8,450,1,451,1,451,1,451,3,451,
  	7825,8,451,1,451,1,451,3,451,7829,8,451,1,451,1,451,1,451,1,451,1,451,
  	1,451,3,451,7837,8,451,1,451,3,451,7840,8,451,1,451,1,451,3,451,7844,
  	8,451,1,451,1,451,1,451,1,451,1,451,1,451,1,451,1,451,1,451,3,451,7855,
  	8,451,1,451,3,451,7858,8,451,3,451,7860,8,451,1,452,1,452,1,452,1,452,
  	1,453,1,453,1,453,1,453,1,453,1,453,1,453,1,453,1,453,1,453,3,453,7876,
  	8,453,1,454,3,454,7879,8,454,1,454,1,454,1,454,1,454,1,454,3,454,7886,
  	8,454,1,454,3,454,7889,8,454,1,455,1,455,1,455,3,455,7894,8,455,1,456,
  	1,456,1,456,1,456,1,456,1,456,1,456,1,456,1,456,1,456,1,456,1,456,1,456,
  	3,456,7909,8,456,1,456,1,456,1,456,1,456,3,456,7915,8,456,1,457,1,457,
  	1,458,1,458,1,458,5,458,7922,8,458,10,458,12,458,7925,9,458,1,459,1,459,
  	1,459,1,460,1,460,1,460,3,460,7933,8,460,1,460,1,460,1,460,1,460,1,460,
  	3,460,7940,8,460,1,460,3,460,7943,8,460,1,461,1,461,1,461,1,461,3,461,
  	7949,8,461,1,461,1,461,1,461,3,461,7954,8,461,1,462,1,462,1,462,1,463,
  	1,463,3,463,7961,8,463,1,463,1,463,3,463,7965,8,463,1,463,1,463,1,463,
  	3,463,7970,8,463,1,463,3,463,7973,8,463,1,463,1,463,1,463,1,463,3,463,
  	7979,8,463,1,463,1,463,3,463,7983,8,463,3,463,7985,8,463,1,463,3,463,
  	7988,8,463,1,464,1,464,1,464,1,464,1,464,3,464,7995,8,464,1,464,3,464,
  	7998,8,464,1,464,1,464,1,464,1,464,1,464,3,464,8005,8,464,1,464,1,464,
  	1,465,1,465,1,465,1,465,3,465,8013,8,465,1,465,3,465,8016,8,465,1,465,
  	1,465,1,465,1,465,1,466,1,466,1,466,3,466,8025,8,466,1,466,1,466,1,467,
  	3,467,8030,8,467,1,467,1,467,1,467,1,467,3,467,8036,8,467,1,467,3,467,
  	8039,8,467,1,467,3,467,8042,8,467,1,468,1,468,1,468,1,469,1,469,3,469,
  	8049,8,469,1,469,1,469,3,469,8053,8,469,1,469,3,469,8056,8,469,1,470,
  	1,470,1,470,1,470,1,471,1,471,1,471,1,471,1,471,1,471,1,471,1,471,1,471,
  	3,471,8071,8,471,1,471,3,471,8074,8,471,1,472,1,472,1,473,1,473,1,473,
  	3,473,8081,8,473,1,474,3,474,8084,8,474,1,474,1,474,1,474,1,474,1,474,
  	3,474,8091,8,474,1,474,3,474,8094,8,474,1,474,3,474,8097,8,474,1,475,
  	1,475,1,475,5,475,8102,8,475,10,475,12,475,8105,9,475,1,476,1,476,1,476,
  	1,476,1,476,1,476,1,476,1,476,1,476,1,476,3,476,8117,8,476,1,477,1,477,
  	1,477,1,478,1,478,1,478,5,478,8125,8,478,10,478,12,478,8128,9,478,1,479,
  	1,479,1,479,1,479,1,479,3,479,8135,8,479,1,479,1,479,1,479,1,480,1,480,
  	1,481,1,481,1,481,1,481,1,481,5,481,8147,8,481,10,481,12,481,8150,9,481,
  	1,482,1,482,1,482,1,482,3,482,8156,8,482,1,483,1,483,3,483,8160,8,483,
  	1,484,1,484,1,484,1,484,1,484,1,484,1,484,1,484,3,484,8170,8,484,1,485,
  	1,485,3,485,8174,8,485,1,485,1,485,3,485,8178,8,485,1,485,1,485,3,485,
  	8182,8,485,3,485,8184,8,485,1,485,1,485,1,485,3,485,8189,8,485,1,485,
  	1,485,3,485,8193,8,485,1,485,1,485,3,485,8197,8,485,3,485,8199,8,485,
  	3,485,8201,8,485,1,486,1,486,1,486,3,486,8206,8,486,1,486,5,486,8209,
  	8,486,10,486,12,486,8212,9,486,1,487,1,487,1,487,3,487,8217,8,487,1,487,
  	5,487,8220,8,487,10,487,12,487,8223,9,487,1,488,1,488,3,488,8227,8,488,
  	1,488,3,488,8230,8,488,1,488,3,488,8233,8,488,1,488,3,488,8236,8,488,
  	1,488,3,488,8239,8,488,1,488,3,488,8242,8,488,1,488,3,488,8245,8,488,
  	1,488,3,488,8248,8,488,1,488,1,488,1,488,3,488,8253,8,488,1,488,3,488,
  	8256,8,488,1,488,3,488,8259,8,488,1,488,3,488,8262,8,488,1,488,3,488,
  	8265,8,488,1,488,3,488,8268,8,488,3,488,8270,8,488,1,488,1,488,1,488,
  	1,488,3,488,8276,8,488,1,489,1,489,3,489,8280,8,489,1,489,1,489,1,490,
  	1,490,1,490,5,490,8287,8,490,10,490,12,490,8290,9,490,1,491,1,491,3,491,
  	8294,8,491,1,491,1,491,3,491,8298,8,491,1,491,1,491,1,491,1,491,1,492,
  	1,492,1,492,3,492,8307,8,492,1,493,1,493,1,494,1,494,1,494,1,495,1,495,
  	1,496,3,496,8317,8,496,1,496,1,496,3,496,8321,8,496,1,496,1,496,1,496,
  	3,496,8326,8,496,1,496,1,496,1,496,1,496,3,496,8332,8,496,1,497,1,497,
  	1,498,1,498,1,499,1,499,1,499,1,499,1,499,1,499,3,499,8344,8,499,1,500,
  	1,500,1,501,1,501,1,502,1,502,1,502,1,502,1,503,1,503,1,503,5,503,8357,
  	8,503,10,503,12,503,8360,9,503,1,504,1,504,1,504,1,504,3,504,8366,8,504,
  	3,504,8368,8,504,1,504,3,504,8371,8,504,1,505,1,505,3,505,8375,8,505,
  	1,505,1,505,3,505,8379,8,505,3,505,8381,8,505,1,506,1,506,1,507,1,507,
  	1,507,1,507,3,507,8389,8,507,1,507,1,507,1,507,1,507,1,507,1,507,1,507,
  	3,507,8398,8,507,1,507,1,507,1,507,1,507,3,507,8404,8,507,3,507,8406,
  	8,507,3,507,8408,8,507,1,508,1,508,1,508,1,508,1,508,3,508,8415,8,508,
  	1,509,1,509,3,509,8419,8,509,1,510,1,510,1,511,1,511,1,511,1,511,1,511,
  	3,511,8428,8,511,1,512,1,512,3,512,8432,8,512,1,513,1,513,1,514,1,514,
  	1,515,1,515,1,515,1,515,1,516,1,516,1,516,5,516,8445,8,516,10,516,12,
  	516,8448,9,516,1,517,1,517,1,517,1,517,1,517,3,517,8455,8,517,1,518,1,
  	518,1,518,1,519,1,519,1,519,1,519,1,519,1,520,1,520,1,520,1,520,1,520,
  	1,521,1,521,1,521,1,521,1,521,1,521,1,522,1,522,1,522,1,523,1,523,1,523,
  	1,523,3,523,8483,8,523,1,524,1,524,1,525,4,525,8488,8,525,11,525,12,525,
  	8489,1,526,1,526,3,526,8494,8,526,1,526,3,526,8497,8,526,1,527,1,527,
  	1,527,3,527,8502,8,527,1,527,1,527,3,527,8506,8,527,1,527,3,527,8509,
  	8,527,1,528,1,528,1,528,1,529,1,529,1,529,1,529,1,529,1,529,1,529,1,529,
  	1,529,5,529,8523,8,529,10,529,12,529,8526,9,529,1,530,1,530,1,530,1,531,
  	1,531,1,531,5,531,8534,8,531,10,531,12,531,8537,9,531,1,532,1,532,3,532,
  	8541,8,532,1,532,3,532,8544,8,532,1,532,1,532,3,532,8548,8,532,1,532,
  	1,532,3,532,8552,8,532,1,532,1,532,3,532,8556,8,532,1,532,1,532,1,532,
  	3,532,8561,8,532,1,532,1,532,3,532,8565,8,532,1,532,1,532,3,532,8569,
  	8,532,3,532,8571,8,532,1,532,1,532,1,532,1,532,1,532,1,532,1,532,3,532,
  	8580,8,532,1,532,1,532,1,532,3,532,8585,8,532,1,532,1,532,1,532,1,532,
  	3,532,8591,8,532,1,532,1,532,3,532,8595,8,532,3,532,8597,8,532,1,532,
  	1,532,1,532,1,532,1,532,3,532,8604,8,532,1,532,1,532,1,532,3,532,8609,
  	8,532,1,532,1,532,1,532,1,532,5,532,8615,8,532,10,532,12,532,8618,9,532,
  	1,533,3,533,8621,8,533,1,533,1,533,1,533,1,533,1,533,3,533,8628,8,533,
  	1,534,1,534,1,534,3,534,8633,8,534,1,534,3,534,8636,8,534,1,534,1,534,
  	1,534,1,534,3,534,8642,8,534,1,535,1,535,3,535,8646,8,535,1,536,1,536,
  	1,536,1,536,1,536,1,536,1,536,3,536,8655,8,536,1,537,1,537,3,537,8659,
  	8,537,1,537,1,537,1,537,1,537,1,537,1,537,3,537,8667,8,537,3,537,8669,
  	8,537,1,538,1,538,1,538,5,538,8674,8,538,10,538,12,538,8677,9,538,1,539,
  	1,539,3,539,8681,8,539,1,539,3,539,8684,8,539,1,540,1,540,1,540,1,540,
  	1,540,1,540,3,540,8692,8,540,1,541,1,541,1,541,1,541,1,541,1,542,1,542,
  	3,542,8701,8,542,1,542,1,542,1,542,1,542,1,542,1,542,3,542,8709,8,542,
  	3,542,8711,8,542,1,543,1,543,3,543,8715,8,543,1,544,1,544,1,544,5,544,
  	8720,8,544,10,544,12,544,8723,9,544,1,545,1,545,1,545,1,545,1,545,1,546,
  	1,546,1,546,1,547,1,547,1,547,1,548,1,548,1,548,1,548,1,548,3,548,8741,
  	8,548,1,549,1,549,1,550,1,550,1,550,5,550,8748,8,550,10,550,12,550,8751,
  	9,550,1,551,1,551,1,551,3,551,8756,8,551,1,552,1,552,1,552,1,552,1,552,
  	1,552,1,552,1,552,1,552,1,552,1,552,1,552,1,552,1,552,1,552,1,552,1,552,
  	3,552,8775,8,552,1,552,1,552,1,553,1,553,1,553,5,553,8782,8,553,10,553,
  	12,553,8785,9,553,1,554,1,554,1,554,3,554,8790,8,554,1,554,1,554,3,554,
  	8794,8,554,1,555,4,555,8797,8,555,11,555,12,555,8798,1,556,1,556,1,556,
  	1,556,1,556,1,556,1,556,1,556,3,556,8809,8,556,1,557,1,557,1,557,5,557,
  	8814,8,557,10,557,12,557,8817,9,557,1,558,1,558,1,558,1,558,1,558,1,558,
  	3,558,8825,8,558,1,559,3,559,8828,8,559,1,559,1,559,1,559,1,559,1,559,
  	1,559,1,559,3,559,8837,8,559,3,559,8839,8,559,1,560,1,560,3,560,8843,
  	8,560,1,560,5,560,8846,8,560,10,560,12,560,8849,9,560,1,561,1,561,1,561,
  	1,561,1,561,1,561,1,561,3,561,8858,8,561,1,561,1,561,1,561,1,561,3,561,
  	8864,8,561,1,561,3,561,8867,8,561,1,562,1,562,1,562,1,562,1,562,3,562,
  	8874,8,562,1,563,1,563,3,563,8878,8,563,1,563,3,563,8881,8,563,1,564,
  	1,564,1,564,1,564,1,565,1,565,1,565,1,565,1,565,1,565,1,565,3,565,8894,
  	8,565,1,565,1,565,1,565,1,565,3,565,8900,8,565,1,565,1,565,3,565,8904,
  	8,565,1,565,1,565,3,565,8908,8,565,1,565,3,565,8911,8,565,1,566,1,566,
  	1,566,1,566,1,567,1,567,3,567,8919,8,567,1,568,1,568,3,568,8923,8,568,
  	1,569,1,569,3,569,8927,8,569,1,569,1,569,1,569,1,569,1,570,1,570,3,570,
  	8935,8,570,1,571,1,571,1,571,1,571,1,571,3,571,8942,8,571,1,572,1,572,
  	1,572,1,572,1,572,3,572,8949,8,572,1,573,1,573,3,573,8953,8,573,1,573,
  	1,573,1,573,1,573,3,573,8959,8,573,3,573,8961,8,573,1,574,1,574,1,575,
  	1,575,1,575,1,575,1,575,3,575,8970,8,575,1,575,3,575,8973,8,575,1,576,
  	1,576,1,577,1,577,1,577,1,577,1,577,1,577,3,577,8983,8,577,1,578,1,578,
  	1,578,1,578,1,578,1,578,1,578,1,578,1,578,1,578,1,578,1,578,1,578,1,578,
  	3,578,8999,8,578,1,578,1,578,1,578,1,578,3,578,9005,8,578,1,578,1,578,
  	1,578,3,578,9010,8,578,1,579,1,579,1,579,1,579,1,579,3,579,9017,8,579,
  	1,580,1,580,1,581,1,581,1,581,1,582,1,582,1,583,1,583,1,583,1,583,3,583,
  	9030,8,583,1,584,1,584,1,584,5,584,9035,8,584,10,584,12,584,9038,9,584,
  	1,585,1,585,1,585,5,585,9043,8,585,10,585,12,585,9046,9,585,1,586,1,586,
  	1,586,5,586,9051,8,586,10,586,12,586,9054,9,586,1,587,1,587,3,587,9058,
  	8,587,1,587,1,587,3,587,9062,8,587,1,587,1,587,1,587,1,587,3,587,9068,
  	8,587,1,588,1,588,3,588,9072,8,588,1,588,1,588,3,588,9076,8,588,1,589,
  	3,589,9079,8,589,1,589,1,589,1,590,1,590,3,590,9085,8,590,1,591,1,591,
  	1,591,3,591,9090,8,591,1,591,1,591,1,591,1,591,1,591,1,591,1,591,1,591,
  	1,591,1,591,1,591,1,591,1,591,1,591,3,591,9106,8,591,1,591,3,591,9109,
  	8,591,3,591,9111,8,591,1,592,1,592,1,592,1,592,1,592,1,592,1,592,1,592,
  	1,592,1,592,3,592,9123,8,592,3,592,9125,8,592,1,593,1,593,3,593,9129,
  	8,593,1,593,1,593,1,593,1,593,3,593,9135,8,593,1,593,1,593,3,593,9139,
  	8,593,3,593,9141,8,593,1,594,1,594,1,594,1,594,5,594,9147,8,594,10,594,
  	12,594,9150,9,594,1,595,3,595,9153,8,595,1,595,1,595,1,596,1,596,1,596,
  	5,596,9160,8,596,10,596,12,596,9163,9,596,1,597,1,597,1,597,5,597,9168,
  	8,597,10,597,12,597,9171,9,597,1,598,1,598,1,598,3,598,9176,8,598,1,599,
  	3,599,9179,8,599,1,599,1,599,1,600,1,600,1,600,1,600,1,600,3,600,9188,
  	8,600,1,601,1,601,1,601,3,601,9193,8,601,1,602,1,602,1,602,5,602,9198,
  	8,602,10,602,12,602,9201,9,602,1,603,1,603,1,603,1,603,1,603,1,603,1,
  	603,3,603,9210,8,603,1,603,1,603,1,603,1,603,1,603,1,603,1,603,1,603,
  	1,603,1,603,1,603,1,603,1,603,1,603,1,603,1,603,1,603,1,603,1,603,1,603,
  	1,603,1,603,1,603,1,603,3,603,9236,8,603,1,603,1,603,1,603,1,603,1,603,
  	1,603,1,603,1,603,1,603,3,603,9247,8,603,5,603,9249,8,603,10,603,12,603,
  	9252,9,603,1,604,1,604,1,604,1,604,1,604,3,604,9259,8,604,1,604,1,604,
  	1,604,1,604,1,604,1,604,1,604,1,604,1,604,1,604,1,604,1,604,1,604,1,604,
  	1,604,1,604,1,604,1,604,1,604,1,604,3,604,9281,8,604,1,604,1,604,1,604,
  	1,604,1,604,1,604,1,604,3,604,9290,8,604,1,605,1,605,1,606,1,606,1,606,
  	1,606,1,606,1,606,3,606,9300,8,606,1,606,3,606,9303,8,606,1,606,1,606,
  	1,606,3,606,9308,8,606,1,606,1,606,1,606,3,606,9313,8,606,1,606,1,606,
  	3,606,9317,8,606,1,606,1,606,1,607,1,607,3,607,9323,8,607,1,607,3,607,
  	9326,8,607,1,607,3,607,9329,8,607,1,607,3,607,9332,8,607,1,608,1,608,
  	3,608,9336,8,608,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,
  	1,609,1,609,1,609,3,609,9350,8,609,1,609,1,609,1,609,1,609,1,609,3,609,
  	9357,8,609,1,609,1,609,1,609,1,609,1,609,3,609,9364,8,609,1,609,1,609,
  	1,609,1,609,1,609,3,609,9371,8,609,1,609,1,609,1,609,1,609,1,609,1,609,
  	1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,3,609,
  	9390,8,609,1,609,1,609,1,609,1,609,1,609,1,609,3,609,9398,8,609,1,609,
  	1,609,1,609,1,609,1,609,1,609,3,609,9406,8,609,3,609,9408,8,609,1,609,
  	1,609,1,609,1,609,3,609,9414,8,609,1,609,1,609,1,609,1,609,1,609,3,609,
  	9421,8,609,3,609,9423,8,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,
  	1,609,1,609,1,609,1,609,3,609,9436,8,609,1,609,1,609,1,609,1,609,1,609,
  	1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,
  	1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,
  	1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,3,609,9475,8,609,3,609,
  	9477,8,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,
  	1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,3,609,9497,8,609,1,609,
  	1,609,1,609,1,609,1,609,1,609,1,609,1,609,3,609,9507,8,609,1,609,1,609,
  	1,609,1,609,1,609,1,609,1,609,1,609,1,609,3,609,9518,8,609,1,609,1,609,
  	1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,
  	1,609,3,609,9535,8,609,1,609,3,609,9538,8,609,1,609,3,609,9541,8,609,
  	1,609,3,609,9544,8,609,3,609,9546,8,609,1,609,1,609,1,609,1,609,1,609,
  	3,609,9553,8,609,1,609,3,609,9556,8,609,1,609,1,609,3,609,9560,8,609,
  	1,609,3,609,9563,8,609,1,609,3,609,9566,8,609,3,609,9568,8,609,1,609,
  	1,609,1,609,1,609,1,609,3,609,9575,8,609,1,609,1,609,1,609,1,609,1,609,
  	1,609,1,609,1,609,1,609,1,609,1,609,3,609,9588,8,609,1,609,1,609,1,609,
  	1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,3,609,9601,8,609,1,609,
  	3,609,9604,8,609,1,609,1,609,3,609,9608,8,609,1,609,3,609,9611,8,609,
  	1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,3,609,9621,8,609,1,609,
  	3,609,9624,8,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,1,609,3,609,
  	9634,8,609,1,609,3,609,9637,8,609,1,609,3,609,9640,8,609,1,609,1,609,
  	3,609,9644,8,609,1,610,1,610,1,610,1,610,1,610,3,610,9651,8,610,1,611,
  	1,611,1,611,1,611,1,611,1,611,1,611,1,611,1,611,1,611,3,611,9663,8,611,
  	1,612,1,612,1,612,1,612,1,612,1,613,1,613,1,613,5,613,9673,8,613,10,613,
  	12,613,9676,9,613,1,614,1,614,1,614,3,614,9681,8,614,1,615,1,615,1,616,
  	1,616,1,616,1,616,3,616,9689,8,616,1,617,1,617,1,617,1,617,1,617,1,617,
  	1,617,1,617,1,617,1,617,1,617,1,617,1,617,1,617,1,617,3,617,9706,8,617,
  	1,618,1,618,1,618,1,619,1,619,1,619,1,619,1,619,1,619,1,620,1,620,1,620,
  	1,620,1,620,1,620,1,621,1,621,1,621,1,622,1,622,1,622,5,622,9729,8,622,
  	10,622,12,622,9732,9,622,1,623,1,623,1,623,1,623,1,624,1,624,1,624,3,
  	624,9741,8,624,1,625,1,625,3,625,9745,8,625,1,625,3,625,9748,8,625,1,
  	625,3,625,9751,8,625,1,625,3,625,9754,8,625,1,625,1,625,1,626,1,626,1,
  	627,1,627,1,627,1,627,1,628,1,628,1,628,3,628,9767,8,628,1,628,1,628,
  	1,628,3,628,9772,8,628,1,628,1,628,1,628,3,628,9777,8,628,3,628,9779,
  	8,628,1,629,1,629,1,629,1,629,1,629,1,629,3,629,9787,8,629,1,630,1,630,
  	1,630,1,630,1,630,1,630,1,630,3,630,9796,8,630,1,631,1,631,1,631,1,631,
  	1,631,1,631,1,631,3,631,9805,8,631,1,632,1,632,1,632,3,632,9810,8,632,
  	1,632,1,632,1,632,1,632,1,632,1,632,1,632,3,632,9819,8,632,1,633,1,633,
  	1,633,3,633,9824,8,633,1,633,1,633,1,634,1,634,1,634,1,634,1,634,1,634,
  	1,635,1,635,1,636,1,636,3,636,9838,8,636,1,637,1,637,1,638,1,638,1,638,
  	1,638,1,638,1,638,3,638,9848,8,638,1,639,1,639,1,639,1,639,1,639,1,639,
  	3,639,9856,8,639,1,640,1,640,1,640,1,640,1,640,1,640,1,640,1,640,1,640,
  	1,640,1,640,1,640,3,640,9870,8,640,1,641,1,641,1,641,5,641,9875,8,641,
  	10,641,12,641,9878,9,641,1,642,1,642,1,642,5,642,9883,8,642,10,642,12,
  	642,9886,9,642,1,643,1,643,1,643,1,643,1,643,3,643,9893,8,643,1,644,1,
  	644,1,644,5,644,9898,8,644,10,644,12,644,9901,9,644,1,645,1,645,1,645,
  	3,645,9906,8,645,1,645,1,645,1,646,1,646,1,646,5,646,9913,8,646,10,646,
  	12,646,9916,9,646,1,647,1,647,1,647,1,647,1,648,1,648,1,648,1,648,1,648,
  	1,648,1,648,1,648,3,648,9930,8,648,1,649,1,649,1,650,1,650,1,650,1,650,
  	1,650,1,650,1,650,3,650,9941,8,650,1,651,1,651,1,651,1,651,1,652,1,652,
  	1,652,1,652,1,652,1,652,1,652,1,652,1,652,1,652,1,652,1,652,1,652,1,652,
  	1,652,1,652,1,652,1,652,1,652,1,652,1,652,1,652,1,652,1,652,1,652,1,652,
  	3,652,9973,8,652,1,653,1,653,1,653,1,653,1,653,1,653,1,653,3,653,9982,
  	8,653,1,654,1,654,1,654,1,654,1,654,3,654,9989,8,654,1,655,1,655,3,655,
  	9993,8,655,1,655,1,655,3,655,9997,8,655,1,655,1,655,1,656,4,656,10002,
  	8,656,11,656,12,656,10003,1,657,1,657,1,657,1,657,1,657,1,658,1,658,1,
  	658,1,659,1,659,1,660,1,660,3,660,10018,8,660,1,661,1,661,1,661,3,661,
  	10023,8,661,1,661,1,661,1,661,3,661,10028,8,661,1,661,1,661,3,661,10032,
  	8,661,3,661,10034,8,661,1,661,3,661,10037,8,661,1,662,1,662,1,663,4,663,
  	10042,8,663,11,663,12,663,10043,1,664,5,664,10047,8,664,10,664,12,664,
  	10050,9,664,1,665,1,665,1,665,1,666,1,666,1,666,1,666,1,666,1,666,5,666,
  	10061,8,666,10,666,12,666,10064,9,666,1,667,1,667,1,667,1,667,1,668,1,
  	668,1,668,1,668,1,668,1,668,1,668,1,668,1,668,1,668,1,668,1,668,1,668,
  	1,668,1,668,1,668,1,668,1,668,1,668,1,668,1,668,1,668,1,668,1,668,1,668,
  	3,668,10095,8,668,1,669,1,669,1,669,3,669,10100,8,669,1,670,1,670,1,670,
  	1,670,1,670,1,670,1,670,1,670,1,670,1,670,3,670,10112,8,670,1,671,1,671,
  	1,671,1,671,1,671,1,671,1,671,1,671,1,671,1,671,1,671,1,671,1,671,1,671,
  	1,671,3,671,10129,8,671,1,672,1,672,1,672,1,672,1,673,1,673,3,673,10137,
  	8,673,1,674,1,674,1,674,1,674,1,674,1,674,3,674,10145,8,674,1,675,1,675,
  	1,675,1,675,1,675,1,675,1,675,1,675,1,675,1,675,1,675,1,675,1,675,1,675,
  	3,675,10161,8,675,1,676,1,676,1,676,3,676,10166,8,676,1,677,1,677,1,677,
  	1,677,1,677,1,677,1,677,1,677,1,677,3,677,10177,8,677,1,678,1,678,1,678,
  	1,678,1,678,1,678,1,678,1,678,1,678,1,678,3,678,10189,8,678,1,679,1,679,
  	1,679,1,679,1,679,1,679,5,679,10197,8,679,10,679,12,679,10200,9,679,1,
  	680,1,680,1,680,1,680,1,680,1,680,1,680,1,680,3,680,10210,8,680,1,681,
  	1,681,1,681,1,681,1,681,1,681,3,681,10218,8,681,1,682,1,682,1,682,1,682,
  	1,682,1,682,3,682,10226,8,682,1,683,1,683,1,683,1,683,1,683,1,683,5,683,
  	10234,8,683,10,683,12,683,10237,9,683,1,684,1,684,1,684,1,684,3,684,10243,
  	8,684,1,684,3,684,10246,8,684,1,684,1,684,1,684,1,684,1,684,1,684,1,684,
  	3,684,10255,8,684,1,684,3,684,10258,8,684,1,684,1,684,1,684,3,684,10263,
  	8,684,1,685,1,685,1,685,1,685,1,686,1,686,1,687,1,687,1,687,5,687,10274,
  	8,687,10,687,12,687,10277,9,687,1,688,1,688,1,688,1,688,1,688,3,688,10284,
  	8,688,1,688,3,688,10287,8,688,1,689,1,689,1,689,5,689,10292,8,689,10,
  	689,12,689,10295,9,689,1,690,1,690,3,690,10299,8,690,1,691,1,691,1,691,
  	5,691,10304,8,691,10,691,12,691,10307,9,691,1,692,1,692,1,693,1,693,1,
  	694,1,694,1,695,1,695,1,695,1,695,3,695,10319,8,695,1,696,1,696,1,696,
  	1,696,1,696,1,696,1,696,1,696,1,696,1,696,3,696,10331,8,696,1,696,1,696,
  	1,696,3,696,10336,8,696,1,696,1,696,1,696,1,696,1,696,1,696,3,696,10344,
  	8,696,1,696,1,696,1,696,1,696,1,696,3,696,10351,8,696,1,696,1,696,1,696,
  	3,696,10356,8,696,1,697,1,697,1,698,1,698,1,699,1,699,1,700,1,700,1,701,
  	1,701,3,701,10368,8,701,1,702,1,702,1,702,1,702,5,702,10374,8,702,10,
  	702,12,702,10377,9,702,1,702,1,702,3,702,10381,8,702,1,703,1,703,1,703,
  	1,704,1,704,1,704,1,704,1,704,3,704,10391,8,704,1,705,1,705,1,706,1,706,
  	1,706,3,706,10398,8,706,1,707,1,707,1,707,5,707,10403,8,707,10,707,12,
  	707,10406,9,707,1,708,1,708,1,708,3,708,10411,8,708,1,709,1,709,1,709,
  	3,709,10416,8,709,1,710,1,710,1,710,1,710,3,710,10422,8,710,1,711,1,711,
  	1,711,1,711,1,711,1,711,3,711,10430,8,711,1,712,1,712,3,712,10434,8,712,
  	1,713,1,713,1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,
  	1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,
  	1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,
  	1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,
  	1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,1,714,
  	1,714,1,714,1,714,1,714,1,714,3,714,10501,8,714,1,715,1,715,1,716,1,716,
  	1,717,1,717,1,718,1,718,1,719,1,719,3,719,10513,8,719,1,719,1,719,1,719,
  	3,719,10518,8,719,1,719,0,4,1206,1332,1358,1366,720,0,2,4,6,8,10,12,14,
  	16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,
  	62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,
  	106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,
  	142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,
  	178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,
  	214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,
  	250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,
  	286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,
  	322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,
  	358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,
  	394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,
  	430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,
  	466,468,470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,
  	502,504,506,508,510,512,514,516,518,520,522,524,526,528,530,532,534,536,
  	538,540,542,544,546,548,550,552,554,556,558,560,562,564,566,568,570,572,
  	574,576,578,580,582,584,586,588,590,592,594,596,598,600,602,604,606,608,
  	610,612,614,616,618,620,622,624,626,628,630,632,634,636,638,640,642,644,
  	646,648,650,652,654,656,658,660,662,664,666,668,670,672,674,676,678,680,
  	682,684,686,688,690,692,694,696,698,700,702,704,706,708,710,712,714,716,
  	718,720,722,724,726,728,730,732,734,736,738,740,742,744,746,748,750,752,
  	754,756,758,760,762,764,766,768,770,772,774,776,778,780,782,784,786,788,
  	790,792,794,796,798,800,802,804,806,808,810,812,814,816,818,820,822,824,
  	826,828,830,832,834,836,838,840,842,844,846,848,850,852,854,856,858,860,
  	862,864,866,868,870,872,874,876,878,880,882,884,886,888,890,892,894,896,
  	898,900,902,904,906,908,910,912,914,916,918,920,922,924,926,928,930,932,
  	934,936,938,940,942,944,946,948,950,952,954,956,958,960,962,964,966,968,
  	970,972,974,976,978,980,982,984,986,988,990,992,994,996,998,1000,1002,
  	1004,1006,1008,1010,1012,1014,1016,1018,1020,1022,1024,1026,1028,1030,
  	1032,1034,1036,1038,1040,1042,1044,1046,1048,1050,1052,1054,1056,1058,
  	1060,1062,1064,1066,1068,1070,1072,1074,1076,1078,1080,1082,1084,1086,
  	1088,1090,1092,1094,1096,1098,1100,1102,1104,1106,1108,1110,1112,1114,
  	1116,1118,1120,1122,1124,1126,1128,1130,1132,1134,1136,1138,1140,1142,
  	1144,1146,1148,1150,1152,1154,1156,1158,1160,1162,1164,1166,1168,1170,
  	1172,1174,1176,1178,1180,1182,1184,1186,1188,1190,1192,1194,1196,1198,
  	1200,1202,1204,1206,1208,1210,1212,1214,1216,1218,1220,1222,1224,1226,
  	1228,1230,1232,1234,1236,1238,1240,1242,1244,1246,1248,1250,1252,1254,
  	1256,1258,1260,1262,1264,1266,1268,1270,1272,1274,1276,1278,1280,1282,
  	1284,1286,1288,1290,1292,1294,1296,1298,1300,1302,1304,1306,1308,1310,
  	1312,1314,1316,1318,1320,1322,1324,1326,1328,1330,1332,1334,1336,1338,
  	1340,1342,1344,1346,1348,1350,1352,1354,1356,1358,1360,1362,1364,1366,
  	1368,1370,1372,1374,1376,1378,1380,1382,1384,1386,1388,1390,1392,1394,
  	1396,1398,1400,1402,1404,1406,1408,1410,1412,1414,1416,1418,1420,1422,
  	1424,1426,1428,1430,1432,1434,1436,1438,0,66,2,0,233,233,395,395,2,0,
  	104,104,349,349,2,0,137,137,349,349,3,0,104,104,137,137,349,349,2,0,171,
  	171,229,229,2,0,283,283,363,363,2,0,10,10,132,132,2,0,200,200,394,394,
  	2,0,218,218,259,259,5,0,68,68,319,319,360,360,383,383,385,385,2,0,188,
  	188,346,346,2,0,102,102,132,132,2,0,383,383,385,385,2,0,238,238,262,262,
  	9,0,68,68,198,198,203,203,217,217,257,257,265,265,373,373,376,376,476,
  	476,3,0,151,151,315,315,367,367,2,0,91,91,116,116,3,0,211,211,290,290,
  	293,293,5,0,68,68,126,126,220,220,270,270,400,400,2,0,130,130,264,264,
  	1,0,486,487,2,0,130,130,445,445,2,0,372,372,445,445,2,0,249,249,327,327,
  	3,0,352,352,388,388,483,483,2,0,102,102,106,106,5,0,250,250,360,360,381,
  	381,392,392,493,494,2,0,75,75,93,93,2,0,10,10,91,91,3,0,249,249,327,327,
  	480,480,2,0,213,213,380,380,4,0,126,126,220,220,270,270,400,400,2,0,175,
  	175,271,271,2,0,387,387,411,411,2,0,189,189,283,283,2,0,344,344,364,364,
  	1,0,69,70,2,0,137,137,380,380,2,0,239,239,365,365,2,0,97,97,135,135,2,
  	0,251,251,283,283,2,0,68,68,94,94,2,0,351,351,445,445,2,0,245,245,299,
  	299,4,0,151,151,153,153,157,157,164,164,2,0,422,423,437,437,1,0,422,423,
  	1,0,449,450,1,0,18,19,2,0,155,155,160,160,5,0,10,10,16,17,21,21,23,23,
  	25,25,1,0,12,13,3,0,9,9,14,14,27,27,3,0,77,77,111,111,133,133,2,0,204,
  	204,226,226,2,0,335,335,488,488,2,0,246,246,320,320,3,0,68,68,72,72,128,
  	128,6,0,9,10,12,17,21,21,23,23,25,25,27,27,2,0,20,20,22,22,1,0,521,524,
  	1,0,576,579,13,0,43,66,162,162,167,332,334,417,471,490,493,507,509,509,
  	511,511,513,513,516,526,529,529,542,542,553,553,3,0,144,161,163,166,510,
  	510,3,0,42,42,68,143,492,492,35,0,30,66,68,72,75,83,85,96,98,98,101,101,
  	106,107,110,111,113,116,119,120,122,124,126,131,133,134,136,140,144,154,
  	156,159,161,161,164,213,215,255,257,291,293,294,296,332,334,356,358,404,
  	406,409,411,414,416,421,424,442,444,455,463,514,516,516,519,527,529,529,
  	542,542,553,553,11724,0,1440,1,0,0,0,2,1443,1,0,0,0,4,1446,1,0,0,0,6,
  	1581,1,0,0,0,8,1583,1,0,0,0,10,1586,1,0,0,0,12,1594,1,0,0,0,14,1599,1,
  	0,0,0,16,1605,1,0,0,0,18,1626,1,0,0,0,20,1638,1,0,0,0,22,1640,1,0,0,0,
  	24,1648,1,0,0,0,26,1656,1,0,0,0,28,1660,1,0,0,0,30,1671,1,0,0,0,32,1679,
  	1,0,0,0,34,1687,1,0,0,0,36,1694,1,0,0,0,38,1696,1,0,0,0,40,1713,1,0,0,
  	0,42,1718,1,0,0,0,44,1727,1,0,0,0,46,1729,1,0,0,0,48,1743,1,0,0,0,50,
  	1745,1,0,0,0,52,1778,1,0,0,0,54,1780,1,0,0,0,56,1788,1,0,0,0,58,1798,
  	1,0,0,0,60,1805,1,0,0,0,62,1811,1,0,0,0,64,1829,1,0,0,0,66,1833,1,0,0,
  	0,68,1837,1,0,0,0,70,1839,1,0,0,0,72,1850,1,0,0,0,74,1854,1,0,0,0,76,
  	1859,1,0,0,0,78,1864,1,0,0,0,80,1866,1,0,0,0,82,1878,1,0,0,0,84,1885,
  	1,0,0,0,86,1887,1,0,0,0,88,1889,1,0,0,0,90,1891,1,0,0,0,92,2006,1,0,0,
  	0,94,2008,1,0,0,0,96,2024,1,0,0,0,98,2026,1,0,0,0,100,2328,1,0,0,0,102,
  	2335,1,0,0,0,104,2337,1,0,0,0,106,2339,1,0,0,0,108,2342,1,0,0,0,110,2351,
  	1,0,0,0,112,2353,1,0,0,0,114,2357,1,0,0,0,116,2360,1,0,0,0,118,2368,1,
  	0,0,0,120,2380,1,0,0,0,122,2397,1,0,0,0,124,2425,1,0,0,0,126,2427,1,0,
  	0,0,128,2430,1,0,0,0,130,2438,1,0,0,0,132,2443,1,0,0,0,134,2481,1,0,0,
  	0,136,2483,1,0,0,0,138,2525,1,0,0,0,140,2527,1,0,0,0,142,2529,1,0,0,0,
  	144,2534,1,0,0,0,146,2541,1,0,0,0,148,2546,1,0,0,0,150,2588,1,0,0,0,152,
  	2590,1,0,0,0,154,2593,1,0,0,0,156,2598,1,0,0,0,158,2600,1,0,0,0,160,2608,
  	1,0,0,0,162,2619,1,0,0,0,164,2621,1,0,0,0,166,2629,1,0,0,0,168,2631,1,
  	0,0,0,170,2716,1,0,0,0,172,2718,1,0,0,0,174,2720,1,0,0,0,176,2724,1,0,
  	0,0,178,2732,1,0,0,0,180,2743,1,0,0,0,182,2747,1,0,0,0,184,2749,1,0,0,
  	0,186,2756,1,0,0,0,188,2766,1,0,0,0,190,2777,1,0,0,0,192,2831,1,0,0,0,
  	194,2836,1,0,0,0,196,2843,1,0,0,0,198,2845,1,0,0,0,200,2853,1,0,0,0,202,
  	2856,1,0,0,0,204,2863,1,0,0,0,206,2951,1,0,0,0,208,2953,1,0,0,0,210,2956,
  	1,0,0,0,212,2960,1,0,0,0,214,2968,1,0,0,0,216,2970,1,0,0,0,218,2975,1,
  	0,0,0,220,2978,1,0,0,0,222,2986,1,0,0,0,224,2996,1,0,0,0,226,3009,1,0,
  	0,0,228,3011,1,0,0,0,230,3015,1,0,0,0,232,3025,1,0,0,0,234,3027,1,0,0,
  	0,236,3032,1,0,0,0,238,3034,1,0,0,0,240,3041,1,0,0,0,242,3072,1,0,0,0,
  	244,3074,1,0,0,0,246,3081,1,0,0,0,248,3083,1,0,0,0,250,3092,1,0,0,0,252,
  	3095,1,0,0,0,254,3100,1,0,0,0,256,3104,1,0,0,0,258,3120,1,0,0,0,260,3131,
  	1,0,0,0,262,3147,1,0,0,0,264,3163,1,0,0,0,266,3169,1,0,0,0,268,3186,1,
  	0,0,0,270,3199,1,0,0,0,272,3201,1,0,0,0,274,3211,1,0,0,0,276,3225,1,0,
  	0,0,278,3234,1,0,0,0,280,3236,1,0,0,0,282,3241,1,0,0,0,284,3279,1,0,0,
  	0,286,3281,1,0,0,0,288,3289,1,0,0,0,290,3291,1,0,0,0,292,3299,1,0,0,0,
  	294,3321,1,0,0,0,296,3323,1,0,0,0,298,3327,1,0,0,0,300,3334,1,0,0,0,302,
  	3336,1,0,0,0,304,3338,1,0,0,0,306,3340,1,0,0,0,308,3351,1,0,0,0,310,3354,
  	1,0,0,0,312,3362,1,0,0,0,314,3378,1,0,0,0,316,3388,1,0,0,0,318,3390,1,
  	0,0,0,320,3399,1,0,0,0,322,3402,1,0,0,0,324,3509,1,0,0,0,326,3511,1,0,
  	0,0,328,3530,1,0,0,0,330,3533,1,0,0,0,332,3537,1,0,0,0,334,3556,1,0,0,
  	0,336,3558,1,0,0,0,338,3563,1,0,0,0,340,3571,1,0,0,0,342,3576,1,0,0,0,
  	344,3591,1,0,0,0,346,3593,1,0,0,0,348,3596,1,0,0,0,350,3598,1,0,0,0,352,
  	3635,1,0,0,0,354,3637,1,0,0,0,356,3640,1,0,0,0,358,3645,1,0,0,0,360,3647,
  	1,0,0,0,362,3729,1,0,0,0,364,3731,1,0,0,0,366,3749,1,0,0,0,368,3751,1,
  	0,0,0,370,3779,1,0,0,0,372,3783,1,0,0,0,374,3803,1,0,0,0,376,3805,1,0,
  	0,0,378,3814,1,0,0,0,380,3834,1,0,0,0,382,3848,1,0,0,0,384,3853,1,0,0,
  	0,386,3859,1,0,0,0,388,3862,1,0,0,0,390,3865,1,0,0,0,392,3868,1,0,0,0,
  	394,3871,1,0,0,0,396,3873,1,0,0,0,398,3882,1,0,0,0,400,3932,1,0,0,0,402,
  	3938,1,0,0,0,404,3940,1,0,0,0,406,3955,1,0,0,0,408,3957,1,0,0,0,410,3961,
  	1,0,0,0,412,3965,1,0,0,0,414,3972,1,0,0,0,416,3974,1,0,0,0,418,3976,1,
  	0,0,0,420,3978,1,0,0,0,422,3984,1,0,0,0,424,3986,1,0,0,0,426,3988,1,0,
  	0,0,428,3993,1,0,0,0,430,3997,1,0,0,0,432,4010,1,0,0,0,434,4012,1,0,0,
  	0,436,4018,1,0,0,0,438,4032,1,0,0,0,440,4060,1,0,0,0,442,4062,1,0,0,0,
  	444,4070,1,0,0,0,446,4076,1,0,0,0,448,4084,1,0,0,0,450,4096,1,0,0,0,452,
  	4098,1,0,0,0,454,4221,1,0,0,0,456,4223,1,0,0,0,458,4227,1,0,0,0,460,4235,
  	1,0,0,0,462,4246,1,0,0,0,464,4248,1,0,0,0,466,4252,1,0,0,0,468,4260,1,
  	0,0,0,470,4264,1,0,0,0,472,4266,1,0,0,0,474,4317,1,0,0,0,476,4319,1,0,
  	0,0,478,4323,1,0,0,0,480,4341,1,0,0,0,482,4380,1,0,0,0,484,4382,1,0,0,
  	0,486,4384,1,0,0,0,488,4393,1,0,0,0,490,4395,1,0,0,0,492,4397,1,0,0,0,
  	494,4422,1,0,0,0,496,4424,1,0,0,0,498,4444,1,0,0,0,500,4466,1,0,0,0,502,
  	4488,1,0,0,0,504,4490,1,0,0,0,506,4497,1,0,0,0,508,4594,1,0,0,0,510,4619,
  	1,0,0,0,512,4626,1,0,0,0,514,4643,1,0,0,0,516,4645,1,0,0,0,518,4647,1,
  	0,0,0,520,4655,1,0,0,0,522,4661,1,0,0,0,524,4665,1,0,0,0,526,4673,1,0,
  	0,0,528,4688,1,0,0,0,530,4837,1,0,0,0,532,4841,1,0,0,0,534,4954,1,0,0,
  	0,536,4956,1,0,0,0,538,4961,1,0,0,0,540,4967,1,0,0,0,542,5054,1,0,0,0,
  	544,5056,1,0,0,0,546,5058,1,0,0,0,548,5060,1,0,0,0,550,5090,1,0,0,0,552,
  	5107,1,0,0,0,554,5109,1,0,0,0,556,5133,1,0,0,0,558,5193,1,0,0,0,560,5195,
  	1,0,0,0,562,5206,1,0,0,0,564,5208,1,0,0,0,566,5212,1,0,0,0,568,5245,1,
  	0,0,0,570,5247,1,0,0,0,572,5251,1,0,0,0,574,5255,1,0,0,0,576,5264,1,0,
  	0,0,578,5276,1,0,0,0,580,5308,1,0,0,0,582,5310,1,0,0,0,584,5384,1,0,0,
  	0,586,5386,1,0,0,0,588,5388,1,0,0,0,590,5394,1,0,0,0,592,5396,1,0,0,0,
  	594,5398,1,0,0,0,596,5400,1,0,0,0,598,5403,1,0,0,0,600,5434,1,0,0,0,602,
  	5447,1,0,0,0,604,5449,1,0,0,0,606,5454,1,0,0,0,608,5462,1,0,0,0,610,5465,
  	1,0,0,0,612,5467,1,0,0,0,614,5473,1,0,0,0,616,5475,1,0,0,0,618,5495,1,
  	0,0,0,620,5498,1,0,0,0,622,5504,1,0,0,0,624,5512,1,0,0,0,626,5528,1,0,
  	0,0,628,5530,1,0,0,0,630,5536,1,0,0,0,632,5557,1,0,0,0,634,5566,1,0,0,
  	0,636,5568,1,0,0,0,638,5570,1,0,0,0,640,5581,1,0,0,0,642,5583,1,0,0,0,
  	644,5588,1,0,0,0,646,5590,1,0,0,0,648,5605,1,0,0,0,650,5613,1,0,0,0,652,
  	5616,1,0,0,0,654,5625,1,0,0,0,656,5666,1,0,0,0,658,5676,1,0,0,0,660,5683,
  	1,0,0,0,662,5685,1,0,0,0,664,5697,1,0,0,0,666,5700,1,0,0,0,668,5703,1,
  	0,0,0,670,5711,1,0,0,0,672,5719,1,0,0,0,674,5723,1,0,0,0,676,5767,1,0,
  	0,0,678,5783,1,0,0,0,680,5799,1,0,0,0,682,5823,1,0,0,0,684,5830,1,0,0,
  	0,686,5835,1,0,0,0,688,5843,1,0,0,0,690,5846,1,0,0,0,692,5850,1,0,0,0,
  	694,5857,1,0,0,0,696,5896,1,0,0,0,698,5902,1,0,0,0,700,5904,1,0,0,0,702,
  	5917,1,0,0,0,704,5920,1,0,0,0,706,5967,1,0,0,0,708,5969,1,0,0,0,710,6011,
  	1,0,0,0,712,6013,1,0,0,0,714,6015,1,0,0,0,716,6017,1,0,0,0,718,6033,1,
  	0,0,0,720,6522,1,0,0,0,722,6524,1,0,0,0,724,6526,1,0,0,0,726,6598,1,0,
  	0,0,728,6600,1,0,0,0,730,6819,1,0,0,0,732,6821,1,0,0,0,734,6829,1,0,0,
  	0,736,6845,1,0,0,0,738,6852,1,0,0,0,740,6854,1,0,0,0,742,7047,1,0,0,0,
  	744,7049,1,0,0,0,746,7058,1,0,0,0,748,7066,1,0,0,0,750,7095,1,0,0,0,752,
  	7097,1,0,0,0,754,7107,1,0,0,0,756,7115,1,0,0,0,758,7156,1,0,0,0,760,7172,
  	1,0,0,0,762,7174,1,0,0,0,764,7200,1,0,0,0,766,7203,1,0,0,0,768,7219,1,
  	0,0,0,770,7221,1,0,0,0,772,7223,1,0,0,0,774,7225,1,0,0,0,776,7227,1,0,
  	0,0,778,7232,1,0,0,0,780,7235,1,0,0,0,782,7242,1,0,0,0,784,7313,1,0,0,
  	0,786,7315,1,0,0,0,788,7327,1,0,0,0,790,7329,1,0,0,0,792,7339,1,0,0,0,
  	794,7341,1,0,0,0,796,7347,1,0,0,0,798,7379,1,0,0,0,800,7386,1,0,0,0,802,
  	7389,1,0,0,0,804,7398,1,0,0,0,806,7401,1,0,0,0,808,7405,1,0,0,0,810,7422,
  	1,0,0,0,812,7424,1,0,0,0,814,7426,1,0,0,0,816,7441,1,0,0,0,818,7446,1,
  	0,0,0,820,7462,1,0,0,0,822,7470,1,0,0,0,824,7472,1,0,0,0,826,7478,1,0,
  	0,0,828,7483,1,0,0,0,830,7492,1,0,0,0,832,7519,1,0,0,0,834,7521,1,0,0,
  	0,836,7600,1,0,0,0,838,7602,1,0,0,0,840,7604,1,0,0,0,842,7637,1,0,0,0,
  	844,7639,1,0,0,0,846,7665,1,0,0,0,848,7681,1,0,0,0,850,7683,1,0,0,0,852,
  	7691,1,0,0,0,854,7699,1,0,0,0,856,7701,1,0,0,0,858,7708,1,0,0,0,860,7712,
  	1,0,0,0,862,7714,1,0,0,0,864,7720,1,0,0,0,866,7724,1,0,0,0,868,7726,1,
  	0,0,0,870,7728,1,0,0,0,872,7730,1,0,0,0,874,7732,1,0,0,0,876,7734,1,0,
  	0,0,878,7738,1,0,0,0,880,7742,1,0,0,0,882,7750,1,0,0,0,884,7770,1,0,0,
  	0,886,7781,1,0,0,0,888,7783,1,0,0,0,890,7791,1,0,0,0,892,7797,1,0,0,0,
  	894,7801,1,0,0,0,896,7803,1,0,0,0,898,7811,1,0,0,0,900,7819,1,0,0,0,902,
  	7859,1,0,0,0,904,7861,1,0,0,0,906,7875,1,0,0,0,908,7878,1,0,0,0,910,7890,
  	1,0,0,0,912,7914,1,0,0,0,914,7916,1,0,0,0,916,7918,1,0,0,0,918,7926,1,
  	0,0,0,920,7929,1,0,0,0,922,7953,1,0,0,0,924,7955,1,0,0,0,926,7958,1,0,
  	0,0,928,7989,1,0,0,0,930,8008,1,0,0,0,932,8021,1,0,0,0,934,8029,1,0,0,
  	0,936,8043,1,0,0,0,938,8046,1,0,0,0,940,8057,1,0,0,0,942,8073,1,0,0,0,
  	944,8075,1,0,0,0,946,8080,1,0,0,0,948,8083,1,0,0,0,950,8098,1,0,0,0,952,
  	8116,1,0,0,0,954,8118,1,0,0,0,956,8121,1,0,0,0,958,8129,1,0,0,0,960,8139,
  	1,0,0,0,962,8148,1,0,0,0,964,8155,1,0,0,0,966,8159,1,0,0,0,968,8169,1,
  	0,0,0,970,8200,1,0,0,0,972,8202,1,0,0,0,974,8213,1,0,0,0,976,8275,1,0,
  	0,0,978,8277,1,0,0,0,980,8283,1,0,0,0,982,8291,1,0,0,0,984,8306,1,0,0,
  	0,986,8308,1,0,0,0,988,8310,1,0,0,0,990,8313,1,0,0,0,992,8331,1,0,0,0,
  	994,8333,1,0,0,0,996,8335,1,0,0,0,998,8337,1,0,0,0,1000,8345,1,0,0,0,
  	1002,8347,1,0,0,0,1004,8349,1,0,0,0,1006,8353,1,0,0,0,1008,8361,1,0,0,
  	0,1010,8380,1,0,0,0,1012,8382,1,0,0,0,1014,8407,1,0,0,0,1016,8409,1,0,
  	0,0,1018,8418,1,0,0,0,1020,8420,1,0,0,0,1022,8427,1,0,0,0,1024,8431,1,
  	0,0,0,1026,8433,1,0,0,0,1028,8435,1,0,0,0,1030,8437,1,0,0,0,1032,8441,
  	1,0,0,0,1034,8454,1,0,0,0,1036,8456,1,0,0,0,1038,8459,1,0,0,0,1040,8464,
  	1,0,0,0,1042,8469,1,0,0,0,1044,8475,1,0,0,0,1046,8482,1,0,0,0,1048,8484,
  	1,0,0,0,1050,8487,1,0,0,0,1052,8491,1,0,0,0,1054,8498,1,0,0,0,1056,8510,
  	1,0,0,0,1058,8513,1,0,0,0,1060,8527,1,0,0,0,1062,8530,1,0,0,0,1064,8596,
  	1,0,0,0,1066,8620,1,0,0,0,1068,8641,1,0,0,0,1070,8643,1,0,0,0,1072,8654,
  	1,0,0,0,1074,8668,1,0,0,0,1076,8670,1,0,0,0,1078,8678,1,0,0,0,1080,8685,
  	1,0,0,0,1082,8693,1,0,0,0,1084,8710,1,0,0,0,1086,8712,1,0,0,0,1088,8716,
  	1,0,0,0,1090,8724,1,0,0,0,1092,8729,1,0,0,0,1094,8732,1,0,0,0,1096,8735,
  	1,0,0,0,1098,8742,1,0,0,0,1100,8744,1,0,0,0,1102,8752,1,0,0,0,1104,8757,
  	1,0,0,0,1106,8778,1,0,0,0,1108,8786,1,0,0,0,1110,8796,1,0,0,0,1112,8808,
  	1,0,0,0,1114,8810,1,0,0,0,1116,8824,1,0,0,0,1118,8827,1,0,0,0,1120,8847,
  	1,0,0,0,1122,8866,1,0,0,0,1124,8873,1,0,0,0,1126,8875,1,0,0,0,1128,8882,
  	1,0,0,0,1130,8910,1,0,0,0,1132,8912,1,0,0,0,1134,8918,1,0,0,0,1136,8922,
  	1,0,0,0,1138,8924,1,0,0,0,1140,8932,1,0,0,0,1142,8936,1,0,0,0,1144,8943,
  	1,0,0,0,1146,8960,1,0,0,0,1148,8962,1,0,0,0,1150,8964,1,0,0,0,1152,8974,
  	1,0,0,0,1154,8982,1,0,0,0,1156,9009,1,0,0,0,1158,9011,1,0,0,0,1160,9018,
  	1,0,0,0,1162,9020,1,0,0,0,1164,9023,1,0,0,0,1166,9025,1,0,0,0,1168,9031,
  	1,0,0,0,1170,9039,1,0,0,0,1172,9047,1,0,0,0,1174,9055,1,0,0,0,1176,9069,
  	1,0,0,0,1178,9078,1,0,0,0,1180,9082,1,0,0,0,1182,9086,1,0,0,0,1184,9112,
  	1,0,0,0,1186,9126,1,0,0,0,1188,9142,1,0,0,0,1190,9152,1,0,0,0,1192,9156,
  	1,0,0,0,1194,9164,1,0,0,0,1196,9172,1,0,0,0,1198,9178,1,0,0,0,1200,9182,
  	1,0,0,0,1202,9189,1,0,0,0,1204,9194,1,0,0,0,1206,9209,1,0,0,0,1208,9289,
  	1,0,0,0,1210,9291,1,0,0,0,1212,9293,1,0,0,0,1214,9331,1,0,0,0,1216,9335,
  	1,0,0,0,1218,9643,1,0,0,0,1220,9650,1,0,0,0,1222,9662,1,0,0,0,1224,9664,
  	1,0,0,0,1226,9669,1,0,0,0,1228,9677,1,0,0,0,1230,9682,1,0,0,0,1232,9688,
  	1,0,0,0,1234,9705,1,0,0,0,1236,9707,1,0,0,0,1238,9710,1,0,0,0,1240,9716,
  	1,0,0,0,1242,9722,1,0,0,0,1244,9725,1,0,0,0,1246,9733,1,0,0,0,1248,9737,
  	1,0,0,0,1250,9742,1,0,0,0,1252,9757,1,0,0,0,1254,9759,1,0,0,0,1256,9778,
  	1,0,0,0,1258,9786,1,0,0,0,1260,9795,1,0,0,0,1262,9797,1,0,0,0,1264,9818,
  	1,0,0,0,1266,9820,1,0,0,0,1268,9827,1,0,0,0,1270,9833,1,0,0,0,1272,9837,
  	1,0,0,0,1274,9839,1,0,0,0,1276,9847,1,0,0,0,1278,9855,1,0,0,0,1280,9869,
  	1,0,0,0,1282,9871,1,0,0,0,1284,9879,1,0,0,0,1286,9892,1,0,0,0,1288,9894,
  	1,0,0,0,1290,9902,1,0,0,0,1292,9909,1,0,0,0,1294,9917,1,0,0,0,1296,9929,
  	1,0,0,0,1298,9931,1,0,0,0,1300,9933,1,0,0,0,1302,9942,1,0,0,0,1304,9972,
  	1,0,0,0,1306,9981,1,0,0,0,1308,9988,1,0,0,0,1310,9990,1,0,0,0,1312,10001,
  	1,0,0,0,1314,10005,1,0,0,0,1316,10010,1,0,0,0,1318,10013,1,0,0,0,1320,
  	10015,1,0,0,0,1322,10036,1,0,0,0,1324,10038,1,0,0,0,1326,10041,1,0,0,
  	0,1328,10048,1,0,0,0,1330,10051,1,0,0,0,1332,10054,1,0,0,0,1334,10065,
  	1,0,0,0,1336,10094,1,0,0,0,1338,10099,1,0,0,0,1340,10111,1,0,0,0,1342,
  	10128,1,0,0,0,1344,10130,1,0,0,0,1346,10134,1,0,0,0,1348,10144,1,0,0,
  	0,1350,10160,1,0,0,0,1352,10162,1,0,0,0,1354,10176,1,0,0,0,1356,10188,
  	1,0,0,0,1358,10190,1,0,0,0,1360,10209,1,0,0,0,1362,10217,1,0,0,0,1364,
  	10225,1,0,0,0,1366,10227,1,0,0,0,1368,10262,1,0,0,0,1370,10264,1,0,0,
  	0,1372,10268,1,0,0,0,1374,10270,1,0,0,0,1376,10286,1,0,0,0,1378,10288,
  	1,0,0,0,1380,10296,1,0,0,0,1382,10300,1,0,0,0,1384,10308,1,0,0,0,1386,
  	10310,1,0,0,0,1388,10312,1,0,0,0,1390,10318,1,0,0,0,1392,10355,1,0,0,
  	0,1394,10357,1,0,0,0,1396,10359,1,0,0,0,1398,10361,1,0,0,0,1400,10363,
  	1,0,0,0,1402,10365,1,0,0,0,1404,10380,1,0,0,0,1406,10382,1,0,0,0,1408,
  	10390,1,0,0,0,1410,10392,1,0,0,0,1412,10397,1,0,0,0,1414,10399,1,0,0,
  	0,1416,10410,1,0,0,0,1418,10415,1,0,0,0,1420,10421,1,0,0,0,1422,10429,
  	1,0,0,0,1424,10433,1,0,0,0,1426,10435,1,0,0,0,1428,10500,1,0,0,0,1430,
  	10502,1,0,0,0,1432,10504,1,0,0,0,1434,10506,1,0,0,0,1436,10508,1,0,0,
  	0,1438,10517,1,0,0,0,1440,1441,3,2,1,0,1441,1442,5,0,0,1,1442,1,1,0,0,
  	0,1443,1444,3,4,2,0,1444,3,1,0,0,0,1445,1447,3,6,3,0,1446,1445,1,0,0,
  	0,1446,1447,1,0,0,0,1447,1454,1,0,0,0,1448,1450,5,7,0,0,1449,1451,3,6,
  	3,0,1450,1449,1,0,0,0,1450,1451,1,0,0,0,1451,1453,1,0,0,0,1452,1448,1,
  	0,0,0,1453,1456,1,0,0,0,1454,1452,1,0,0,0,1454,1455,1,0,0,0,1455,5,1,
  	0,0,0,1456,1454,1,0,0,0,1457,1582,3,448,224,0,1458,1582,3,824,412,0,1459,
  	1582,3,814,407,0,1460,1582,3,816,408,0,1461,1582,3,574,287,0,1462,1582,
  	3,830,415,0,1463,1582,3,474,237,0,1464,1582,3,318,159,0,1465,1582,3,324,
  	162,0,1466,1582,3,334,167,0,1467,1582,3,360,180,0,1468,1582,3,670,335,
  	0,1469,1582,3,34,17,0,1470,1582,3,726,363,0,1471,1582,3,730,365,0,1472,
  	1582,3,742,371,0,1473,1582,3,732,366,0,1474,1582,3,740,370,0,1475,1582,
  	3,380,190,0,1476,1582,3,276,138,0,1477,1582,3,826,413,0,1478,1582,3,92,
  	46,0,1479,1582,3,718,359,0,1480,1582,3,130,65,0,1481,1582,3,750,375,0,
  	1482,1582,3,28,14,0,1483,1582,3,24,12,0,1484,1582,3,758,379,0,1485,1582,
  	3,258,129,0,1486,1582,3,836,418,0,1487,1582,3,834,417,0,1488,1582,3,376,
  	188,0,1489,1582,3,848,424,0,1490,1582,3,8,4,0,1491,1582,3,88,44,0,1492,
  	1582,3,136,68,0,1493,1582,3,842,421,0,1494,1582,3,530,265,0,1495,1582,
  	3,82,41,0,1496,1582,3,138,69,0,1497,1582,3,396,198,0,1498,1582,3,260,
  	130,0,1499,1582,3,452,226,0,1500,1582,3,696,348,0,1501,1582,3,840,420,
  	0,1502,1582,3,828,414,0,1503,1582,3,312,156,0,1504,1582,3,326,163,0,1505,
  	1582,3,352,176,0,1506,1582,3,362,181,0,1507,1582,3,616,308,0,1508,1582,
  	3,32,16,0,1509,1582,3,266,133,0,1510,1582,3,478,239,0,1511,1582,3,492,
  	246,0,1512,1582,3,744,372,0,1513,1582,3,494,247,0,1514,1582,3,378,189,
  	0,1515,1582,3,292,146,0,1516,1582,3,38,19,0,1517,1582,3,274,137,0,1518,
  	1582,3,168,84,0,1519,1582,3,752,376,0,1520,1582,3,256,128,0,1521,1582,
  	3,306,153,0,1522,1582,3,704,352,0,1523,1582,3,400,200,0,1524,1582,3,440,
  	220,0,1525,1582,3,10,5,0,1526,1582,3,22,11,0,1527,1582,3,370,185,0,1528,
  	1582,3,802,401,0,1529,1582,3,906,453,0,1530,1582,3,958,479,0,1531,1582,
  	3,454,227,0,1532,1582,3,934,467,0,1533,1582,3,90,45,0,1534,1582,3,690,
  	345,0,1535,1582,3,700,350,0,1536,1582,3,500,250,0,1537,1582,3,502,251,
  	0,1538,1582,3,504,252,0,1539,1582,3,508,254,0,1540,1582,3,760,380,0,1541,
  	1582,3,310,155,0,1542,1582,3,708,354,0,1543,1582,3,30,15,0,1544,1582,
  	3,374,187,0,1545,1582,3,818,409,0,1546,1582,3,902,451,0,1547,1582,3,884,
  	442,0,1548,1582,3,540,270,0,1549,1582,3,548,274,0,1550,1582,3,566,283,
  	0,1551,1582,3,364,182,0,1552,1582,3,584,292,0,1553,1582,3,908,454,0,1554,
  	1582,3,926,463,0,1555,1582,3,780,390,0,1556,1582,3,272,136,0,1557,1582,
  	3,800,400,0,1558,1582,3,938,469,0,1559,1582,3,776,388,0,1560,1582,3,896,
  	448,0,1561,1582,3,506,253,0,1562,1582,3,710,355,0,1563,1582,3,678,339,
  	0,1564,1582,3,676,338,0,1565,1582,3,680,340,0,1566,1582,3,720,360,0,1567,
  	1582,3,550,275,0,1568,1582,3,568,284,0,1569,1582,3,762,381,0,1570,1582,
  	3,534,267,0,1571,1582,3,966,483,0,1572,1582,3,784,392,0,1573,1582,3,526,
  	263,0,1574,1582,3,782,391,0,1575,1582,3,948,474,0,1576,1582,3,846,423,
  	0,1577,1582,3,70,35,0,1578,1582,3,46,23,0,1579,1582,3,80,40,0,1580,1582,
  	3,796,398,0,1581,1457,1,0,0,0,1581,1458,1,0,0,0,1581,1459,1,0,0,0,1581,
  	1460,1,0,0,0,1581,1461,1,0,0,0,1581,1462,1,0,0,0,1581,1463,1,0,0,0,1581,
  	1464,1,0,0,0,1581,1465,1,0,0,0,1581,1466,1,0,0,0,1581,1467,1,0,0,0,1581,
  	1468,1,0,0,0,1581,1469,1,0,0,0,1581,1470,1,0,0,0,1581,1471,1,0,0,0,1581,
  	1472,1,0,0,0,1581,1473,1,0,0,0,1581,1474,1,0,0,0,1581,1475,1,0,0,0,1581,
  	1476,1,0,0,0,1581,1477,1,0,0,0,1581,1478,1,0,0,0,1581,1479,1,0,0,0,1581,
  	1480,1,0,0,0,1581,1481,1,0,0,0,1581,1482,1,0,0,0,1581,1483,1,0,0,0,1581,
  	1484,1,0,0,0,1581,1485,1,0,0,0,1581,1486,1,0,0,0,1581,1487,1,0,0,0,1581,
  	1488,1,0,0,0,1581,1489,1,0,0,0,1581,1490,1,0,0,0,1581,1491,1,0,0,0,1581,
  	1492,1,0,0,0,1581,1493,1,0,0,0,1581,1494,1,0,0,0,1581,1495,1,0,0,0,1581,
  	1496,1,0,0,0,1581,1497,1,0,0,0,1581,1498,1,0,0,0,1581,1499,1,0,0,0,1581,
  	1500,1,0,0,0,1581,1501,1,0,0,0,1581,1502,1,0,0,0,1581,1503,1,0,0,0,1581,
  	1504,1,0,0,0,1581,1505,1,0,0,0,1581,1506,1,0,0,0,1581,1507,1,0,0,0,1581,
  	1508,1,0,0,0,1581,1509,1,0,0,0,1581,1510,1,0,0,0,1581,1511,1,0,0,0,1581,
  	1512,1,0,0,0,1581,1513,1,0,0,0,1581,1514,1,0,0,0,1581,1515,1,0,0,0,1581,
  	1516,1,0,0,0,1581,1517,1,0,0,0,1581,1518,1,0,0,0,1581,1519,1,0,0,0,1581,
  	1520,1,0,0,0,1581,1521,1,0,0,0,1581,1522,1,0,0,0,1581,1523,1,0,0,0,1581,
  	1524,1,0,0,0,1581,1525,1,0,0,0,1581,1526,1,0,0,0,1581,1527,1,0,0,0,1581,
  	1528,1,0,0,0,1581,1529,1,0,0,0,1581,1530,1,0,0,0,1581,1531,1,0,0,0,1581,
  	1532,1,0,0,0,1581,1533,1,0,0,0,1581,1534,1,0,0,0,1581,1535,1,0,0,0,1581,
  	1536,1,0,0,0,1581,1537,1,0,0,0,1581,1538,1,0,0,0,1581,1539,1,0,0,0,1581,
  	1540,1,0,0,0,1581,1541,1,0,0,0,1581,1542,1,0,0,0,1581,1543,1,0,0,0,1581,
  	1544,1,0,0,0,1581,1545,1,0,0,0,1581,1546,1,0,0,0,1581,1547,1,0,0,0,1581,
  	1548,1,0,0,0,1581,1549,1,0,0,0,1581,1550,1,0,0,0,1581,1551,1,0,0,0,1581,
  	1552,1,0,0,0,1581,1553,1,0,0,0,1581,1554,1,0,0,0,1581,1555,1,0,0,0,1581,
  	1556,1,0,0,0,1581,1557,1,0,0,0,1581,1558,1,0,0,0,1581,1559,1,0,0,0,1581,
  	1560,1,0,0,0,1581,1561,1,0,0,0,1581,1562,1,0,0,0,1581,1563,1,0,0,0,1581,
  	1564,1,0,0,0,1581,1565,1,0,0,0,1581,1566,1,0,0,0,1581,1567,1,0,0,0,1581,
  	1568,1,0,0,0,1581,1569,1,0,0,0,1581,1570,1,0,0,0,1581,1571,1,0,0,0,1581,
  	1572,1,0,0,0,1581,1573,1,0,0,0,1581,1574,1,0,0,0,1581,1575,1,0,0,0,1581,
  	1576,1,0,0,0,1581,1577,1,0,0,0,1581,1578,1,0,0,0,1581,1579,1,0,0,0,1581,
  	1580,1,0,0,0,1582,7,1,0,0,0,1583,1584,5,471,0,0,1584,1585,3,1212,606,
  	0,1585,9,1,0,0,0,1586,1587,5,84,0,0,1587,1588,5,349,0,0,1588,1590,3,1410,
  	705,0,1589,1591,3,12,6,0,1590,1589,1,0,0,0,1590,1591,1,0,0,0,1591,1592,
  	1,0,0,0,1592,1593,3,14,7,0,1593,11,1,0,0,0,1594,1595,5,143,0,0,1595,13,
  	1,0,0,0,1596,1598,3,20,10,0,1597,1596,1,0,0,0,1598,1601,1,0,0,0,1599,
  	1597,1,0,0,0,1599,1600,1,0,0,0,1600,15,1,0,0,0,1601,1599,1,0,0,0,1602,
  	1604,3,18,9,0,1603,1602,1,0,0,0,1604,1607,1,0,0,0,1605,1603,1,0,0,0,1605,
  	1606,1,0,0,0,1606,17,1,0,0,0,1607,1605,1,0,0,0,1608,1611,5,318,0,0,1609,
  	1612,3,1402,701,0,1610,1612,5,116,0,0,1611,1609,1,0,0,0,1611,1610,1,0,
  	0,0,1612,1627,1,0,0,0,1613,1614,7,0,0,0,1614,1615,5,318,0,0,1615,1627,
  	3,1402,701,0,1616,1627,5,266,0,0,1617,1618,5,202,0,0,1618,1619,5,112,
  	0,0,1619,1627,3,1408,704,0,1620,1621,5,402,0,0,1621,1622,5,399,0,0,1622,
  	1627,3,1402,701,0,1623,1624,5,137,0,0,1624,1627,3,1414,707,0,1625,1627,
  	3,1438,719,0,1626,1608,1,0,0,0,1626,1613,1,0,0,0,1626,1616,1,0,0,0,1626,
  	1617,1,0,0,0,1626,1620,1,0,0,0,1626,1623,1,0,0,0,1626,1625,1,0,0,0,1627,
  	19,1,0,0,0,1628,1639,3,18,9,0,1629,1630,5,379,0,0,1630,1639,3,1400,700,
  	0,1631,1632,5,172,0,0,1632,1639,3,1414,707,0,1633,1634,5,349,0,0,1634,
  	1639,3,1414,707,0,1635,1636,5,106,0,0,1636,1637,7,1,0,0,1637,1639,3,1414,
  	707,0,1638,1628,1,0,0,0,1638,1629,1,0,0,0,1638,1631,1,0,0,0,1638,1633,
  	1,0,0,0,1638,1635,1,0,0,0,1639,21,1,0,0,0,1640,1641,5,84,0,0,1641,1642,
  	5,137,0,0,1642,1644,3,1410,705,0,1643,1645,3,12,6,0,1644,1643,1,0,0,0,
  	1644,1645,1,0,0,0,1645,1646,1,0,0,0,1646,1647,3,14,7,0,1647,23,1,0,0,
  	0,1648,1649,5,176,0,0,1649,1650,7,2,0,0,1650,1652,3,1412,706,0,1651,1653,
  	3,12,6,0,1652,1651,1,0,0,0,1652,1653,1,0,0,0,1653,1654,1,0,0,0,1654,1655,
  	3,16,8,0,1655,25,1,0,0,0,1656,1657,5,106,0,0,1657,1658,5,213,0,0,1658,
  	1659,3,1384,692,0,1659,27,1,0,0,0,1660,1661,5,176,0,0,1661,1663,7,2,0,
  	0,1662,1664,5,68,0,0,1663,1662,1,0,0,0,1663,1664,1,0,0,0,1664,1665,1,
  	0,0,0,1665,1667,3,1412,706,0,1666,1668,3,26,13,0,1667,1666,1,0,0,0,1667,
  	1668,1,0,0,0,1668,1669,1,0,0,0,1669,1670,3,76,38,0,1670,29,1,0,0,0,1671,
  	1672,5,229,0,0,1672,1675,7,3,0,0,1673,1674,5,258,0,0,1674,1676,5,427,
  	0,0,1675,1673,1,0,0,0,1675,1676,1,0,0,0,1676,1677,1,0,0,0,1677,1678,3,
  	1414,707,0,1678,31,1,0,0,0,1679,1680,5,84,0,0,1680,1681,5,104,0,0,1681,
  	1683,3,1410,705,0,1682,1684,3,12,6,0,1683,1682,1,0,0,0,1683,1684,1,0,
  	0,0,1684,1685,1,0,0,0,1685,1686,3,14,7,0,1686,33,1,0,0,0,1687,1688,5,
  	176,0,0,1688,1689,5,104,0,0,1689,1690,3,1412,706,0,1690,1691,3,36,18,
  	0,1691,1692,5,137,0,0,1692,1693,3,1414,707,0,1693,35,1,0,0,0,1694,1695,
  	7,4,0,0,1695,37,1,0,0,0,1696,1697,5,84,0,0,1697,1701,5,354,0,0,1698,1699,
  	5,258,0,0,1699,1700,5,115,0,0,1700,1702,5,427,0,0,1701,1698,1,0,0,0,1701,
  	1702,1,0,0,0,1702,1709,1,0,0,0,1703,1705,3,40,20,0,1704,1703,1,0,0,0,
  	1704,1705,1,0,0,0,1705,1706,1,0,0,0,1706,1707,5,144,0,0,1707,1710,3,1412,
  	706,0,1708,1710,3,1416,708,0,1709,1704,1,0,0,0,1709,1708,1,0,0,0,1710,
  	1711,1,0,0,0,1711,1712,3,42,21,0,1712,39,1,0,0,0,1713,1714,3,1416,708,
  	0,1714,41,1,0,0,0,1715,1717,3,44,22,0,1716,1715,1,0,0,0,1717,1720,1,0,
  	0,0,1718,1716,1,0,0,0,1718,1719,1,0,0,0,1719,43,1,0,0,0,1720,1718,1,0,
  	0,0,1721,1728,3,168,84,0,1722,1728,3,584,292,0,1723,1728,3,274,137,0,
  	1724,1728,3,400,200,0,1725,1728,3,548,274,0,1726,1728,3,796,398,0,1727,
  	1721,1,0,0,0,1727,1722,1,0,0,0,1727,1723,1,0,0,0,1727,1724,1,0,0,0,1727,
  	1725,1,0,0,0,1727,1726,1,0,0,0,1728,45,1,0,0,0,1729,1731,5,364,0,0,1730,
  	1732,7,5,0,0,1731,1730,1,0,0,0,1731,1732,1,0,0,0,1732,1733,1,0,0,0,1733,
  	1734,3,48,24,0,1734,47,1,0,0,0,1735,1736,5,387,0,0,1736,1744,3,790,395,
  	0,1737,1738,5,363,0,0,1738,1739,5,192,0,0,1739,1740,5,74,0,0,1740,1741,
  	5,387,0,0,1741,1744,3,790,395,0,1742,1744,3,52,26,0,1743,1735,1,0,0,0,
  	1743,1737,1,0,0,0,1743,1742,1,0,0,0,1744,49,1,0,0,0,1745,1746,3,54,27,
  	0,1746,1749,7,6,0,0,1747,1750,3,56,28,0,1748,1750,5,91,0,0,1749,1747,
  	1,0,0,0,1749,1748,1,0,0,0,1750,51,1,0,0,0,1751,1779,3,50,25,0,1752,1753,
  	3,54,27,0,1753,1754,5,102,0,0,1754,1755,5,472,0,0,1755,1779,1,0,0,0,1756,
  	1757,5,449,0,0,1757,1758,5,417,0,0,1758,1779,3,64,32,0,1759,1760,5,190,
  	0,0,1760,1779,3,1402,701,0,1761,1762,5,354,0,0,1762,1779,3,1402,701,0,
  	1763,1765,5,298,0,0,1764,1766,3,66,33,0,1765,1764,1,0,0,0,1765,1766,1,
  	0,0,0,1766,1779,1,0,0,0,1767,1768,5,349,0,0,1768,1779,3,68,34,0,1769,
  	1770,5,363,0,0,1770,1771,5,144,0,0,1771,1779,3,68,34,0,1772,1773,5,414,
  	0,0,1773,1774,5,310,0,0,1774,1779,3,1230,615,0,1775,1776,5,387,0,0,1776,
  	1777,5,368,0,0,1777,1779,3,1402,701,0,1778,1751,1,0,0,0,1778,1752,1,0,
  	0,0,1778,1756,1,0,0,0,1778,1759,1,0,0,0,1778,1761,1,0,0,0,1778,1763,1,
  	0,0,0,1778,1767,1,0,0,0,1778,1769,1,0,0,0,1778,1772,1,0,0,0,1778,1775,
  	1,0,0,0,1779,53,1,0,0,0,1780,1785,3,1416,708,0,1781,1782,5,11,0,0,1782,
  	1784,3,1416,708,0,1783,1781,1,0,0,0,1784,1787,1,0,0,0,1785,1783,1,0,0,
  	0,1785,1786,1,0,0,0,1786,55,1,0,0,0,1787,1785,1,0,0,0,1788,1793,3,58,
  	29,0,1789,1790,5,6,0,0,1790,1792,3,58,29,0,1791,1789,1,0,0,0,1792,1795,
  	1,0,0,0,1793,1791,1,0,0,0,1793,1794,1,0,0,0,1794,57,1,0,0,0,1795,1793,
  	1,0,0,0,1796,1799,3,62,31,0,1797,1799,3,288,144,0,1798,1796,1,0,0,0,1798,
  	1797,1,0,0,0,1799,59,1,0,0,0,1800,1801,5,331,0,0,1801,1806,7,7,0,0,1802,
  	1803,5,341,0,0,1803,1806,5,331,0,0,1804,1806,5,361,0,0,1805,1800,1,0,
  	0,0,1805,1802,1,0,0,0,1805,1804,1,0,0,0,1806,61,1,0,0,0,1807,1812,5,134,
  	0,0,1808,1812,5,98,0,0,1809,1812,5,118,0,0,1810,1812,3,68,34,0,1811,1807,
  	1,0,0,0,1811,1808,1,0,0,0,1811,1809,1,0,0,0,1811,1810,1,0,0,0,1812,63,
  	1,0,0,0,1813,1830,3,1402,701,0,1814,1830,3,1438,719,0,1815,1816,3,1152,
  	576,0,1816,1818,3,1402,701,0,1817,1819,3,1156,578,0,1818,1817,1,0,0,0,
  	1818,1819,1,0,0,0,1819,1830,1,0,0,0,1820,1821,3,1152,576,0,1821,1822,
  	5,2,0,0,1822,1823,3,1400,700,0,1823,1824,5,3,0,0,1824,1825,3,1402,701,
  	0,1825,1830,1,0,0,0,1826,1830,3,288,144,0,1827,1830,5,91,0,0,1828,1830,
  	5,283,0,0,1829,1813,1,0,0,0,1829,1814,1,0,0,0,1829,1815,1,0,0,0,1829,
  	1820,1,0,0,0,1829,1826,1,0,0,0,1829,1827,1,0,0,0,1829,1828,1,0,0,0,1830,
  	65,1,0,0,0,1831,1834,3,1402,701,0,1832,1834,5,91,0,0,1833,1831,1,0,0,
  	0,1833,1832,1,0,0,0,1834,67,1,0,0,0,1835,1838,3,1420,710,0,1836,1838,
  	3,1402,701,0,1837,1835,1,0,0,0,1837,1836,1,0,0,0,1838,69,1,0,0,0,1839,
  	1840,5,344,0,0,1840,1841,3,72,36,0,1841,71,1,0,0,0,1842,1851,3,74,37,
  	0,1843,1844,5,449,0,0,1844,1851,5,417,0,0,1845,1846,5,387,0,0,1846,1847,
  	5,273,0,0,1847,1851,5,280,0,0,1848,1849,5,363,0,0,1849,1851,5,144,0,0,
  	1850,1842,1,0,0,0,1850,1843,1,0,0,0,1850,1845,1,0,0,0,1850,1848,1,0,0,
  	0,1851,73,1,0,0,0,1852,1855,3,54,27,0,1853,1855,5,68,0,0,1854,1852,1,
  	0,0,0,1854,1853,1,0,0,0,1855,75,1,0,0,0,1856,1857,5,364,0,0,1857,1860,
  	3,48,24,0,1858,1860,3,70,35,0,1859,1856,1,0,0,0,1859,1858,1,0,0,0,1860,
  	77,1,0,0,0,1861,1862,5,364,0,0,1862,1865,3,52,26,0,1863,1865,3,70,35,
  	0,1864,1861,1,0,0,0,1864,1863,1,0,0,0,1865,79,1,0,0,0,1866,1876,5,366,
  	0,0,1867,1877,3,54,27,0,1868,1869,5,449,0,0,1869,1877,5,417,0,0,1870,
  	1871,5,387,0,0,1871,1872,5,273,0,0,1872,1877,5,280,0,0,1873,1874,5,363,
  	0,0,1874,1877,5,144,0,0,1875,1877,5,68,0,0,1876,1867,1,0,0,0,1876,1868,
  	1,0,0,0,1876,1870,1,0,0,0,1876,1873,1,0,0,0,1876,1875,1,0,0,0,1877,81,
  	1,0,0,0,1878,1879,5,364,0,0,1879,1880,5,203,0,0,1880,1881,3,84,42,0,1881,
  	1882,3,86,43,0,1882,83,1,0,0,0,1883,1886,5,68,0,0,1884,1886,3,1378,689,
  	0,1885,1883,1,0,0,0,1885,1884,1,0,0,0,1886,85,1,0,0,0,1887,1888,7,8,0,
  	0,1888,87,1,0,0,0,1889,1890,5,193,0,0,1890,89,1,0,0,0,1891,1892,5,225,
  	0,0,1892,1893,7,9,0,0,1893,91,1,0,0,0,1894,1895,5,176,0,0,1895,1898,5,
  	130,0,0,1896,1897,5,258,0,0,1897,1899,5,427,0,0,1898,1896,1,0,0,0,1898,
  	1899,1,0,0,0,1899,1900,1,0,0,0,1900,1903,3,1074,537,0,1901,1904,3,94,
  	47,0,1902,1904,3,96,48,0,1903,1901,1,0,0,0,1903,1902,1,0,0,0,1904,2007,
  	1,0,0,0,1905,1906,5,176,0,0,1906,1907,5,130,0,0,1907,1908,5,68,0,0,1908,
  	1909,5,106,0,0,1909,1910,5,382,0,0,1910,1914,3,1384,692,0,1911,1912,5,
  	312,0,0,1912,1913,5,185,0,0,1913,1915,3,1414,707,0,1914,1911,1,0,0,0,
  	1914,1915,1,0,0,0,1915,1916,1,0,0,0,1916,1917,5,364,0,0,1917,1918,5,382,
  	0,0,1918,1920,3,1384,692,0,1919,1921,3,944,472,0,1920,1919,1,0,0,0,1920,
  	1921,1,0,0,0,1921,2007,1,0,0,0,1922,1923,5,176,0,0,1923,1926,5,264,0,
  	0,1924,1925,5,258,0,0,1925,1927,5,427,0,0,1926,1924,1,0,0,0,1926,1927,
  	1,0,0,0,1927,1928,1,0,0,0,1928,1931,3,1380,690,0,1929,1932,3,94,47,0,
  	1930,1932,3,98,49,0,1931,1929,1,0,0,0,1931,1930,1,0,0,0,1932,2007,1,0,
  	0,0,1933,1934,5,176,0,0,1934,1935,5,264,0,0,1935,1936,5,68,0,0,1936,1937,
  	5,106,0,0,1937,1938,5,382,0,0,1938,1942,3,1384,692,0,1939,1940,5,312,
  	0,0,1940,1941,5,185,0,0,1941,1943,3,1414,707,0,1942,1939,1,0,0,0,1942,
  	1943,1,0,0,0,1943,1944,1,0,0,0,1944,1945,5,364,0,0,1945,1946,5,382,0,
  	0,1946,1948,3,1384,692,0,1947,1949,3,944,472,0,1948,1947,1,0,0,0,1948,
  	1949,1,0,0,0,1949,2007,1,0,0,0,1950,1951,5,176,0,0,1951,1954,5,359,0,
  	0,1952,1953,5,258,0,0,1953,1955,5,427,0,0,1954,1952,1,0,0,0,1954,1955,
  	1,0,0,0,1955,1956,1,0,0,0,1956,1957,3,1380,690,0,1957,1958,3,94,47,0,
  	1958,2007,1,0,0,0,1959,1960,5,176,0,0,1960,1963,5,407,0,0,1961,1962,5,
  	258,0,0,1962,1964,5,427,0,0,1963,1961,1,0,0,0,1963,1964,1,0,0,0,1964,
  	1965,1,0,0,0,1965,1966,3,1380,690,0,1966,1967,3,94,47,0,1967,2007,1,0,
  	0,0,1968,1969,5,176,0,0,1969,1970,5,289,0,0,1970,1973,5,407,0,0,1971,
  	1972,5,258,0,0,1972,1974,5,427,0,0,1973,1971,1,0,0,0,1973,1974,1,0,0,
  	0,1974,1975,1,0,0,0,1975,1976,3,1380,690,0,1976,1977,3,94,47,0,1977,2007,
  	1,0,0,0,1978,1979,5,176,0,0,1979,1980,5,289,0,0,1980,1981,5,407,0,0,1981,
  	1982,5,68,0,0,1982,1983,5,106,0,0,1983,1984,5,382,0,0,1984,1988,3,1384,
  	692,0,1985,1986,5,312,0,0,1986,1987,5,185,0,0,1987,1989,3,1414,707,0,
  	1988,1985,1,0,0,0,1988,1989,1,0,0,0,1989,1990,1,0,0,0,1990,1991,5,364,
  	0,0,1991,1992,5,382,0,0,1992,1994,3,1384,692,0,1993,1995,3,944,472,0,
  	1994,1993,1,0,0,0,1994,1995,1,0,0,0,1995,2007,1,0,0,0,1996,1997,5,176,
  	0,0,1997,1998,5,101,0,0,1998,2001,5,130,0,0,1999,2000,5,258,0,0,2000,
  	2002,5,427,0,0,2001,1999,1,0,0,0,2001,2002,1,0,0,0,2002,2003,1,0,0,0,
  	2003,2004,3,1074,537,0,2004,2005,3,94,47,0,2005,2007,1,0,0,0,2006,1894,
  	1,0,0,0,2006,1905,1,0,0,0,2006,1922,1,0,0,0,2006,1933,1,0,0,0,2006,1950,
  	1,0,0,0,2006,1959,1,0,0,0,2006,1968,1,0,0,0,2006,1978,1,0,0,0,2006,1996,
  	1,0,0,0,2007,93,1,0,0,0,2008,2013,3,100,50,0,2009,2010,5,6,0,0,2010,2012,
  	3,100,50,0,2011,2009,1,0,0,0,2012,2015,1,0,0,0,2013,2011,1,0,0,0,2013,
  	2014,1,0,0,0,2014,95,1,0,0,0,2015,2013,1,0,0,0,2016,2017,5,473,0,0,2017,
  	2018,5,316,0,0,2018,2019,3,1380,690,0,2019,2020,3,124,62,0,2020,2025,
  	1,0,0,0,2021,2022,5,474,0,0,2022,2023,5,316,0,0,2023,2025,3,1380,690,
  	0,2024,2016,1,0,0,0,2024,2021,1,0,0,0,2025,97,1,0,0,0,2026,2027,5,473,
  	0,0,2027,2028,5,316,0,0,2028,2029,3,1380,690,0,2029,99,1,0,0,0,2030,2031,
  	5,171,0,0,2031,2329,3,184,92,0,2032,2033,5,171,0,0,2033,2034,5,258,0,
  	0,2034,2035,5,115,0,0,2035,2036,5,427,0,0,2036,2329,3,184,92,0,2037,2038,
  	5,171,0,0,2038,2039,5,82,0,0,2039,2329,3,184,92,0,2040,2041,5,171,0,0,
  	2041,2042,5,82,0,0,2042,2043,5,258,0,0,2043,2044,5,115,0,0,2044,2045,
  	5,427,0,0,2045,2329,3,184,92,0,2046,2048,5,176,0,0,2047,2049,3,722,361,
  	0,2048,2047,1,0,0,0,2048,2049,1,0,0,0,2049,2050,1,0,0,0,2050,2051,3,1416,
  	708,0,2051,2052,3,102,51,0,2052,2329,1,0,0,0,2053,2055,5,176,0,0,2054,
  	2056,3,722,361,0,2055,2054,1,0,0,0,2055,2056,1,0,0,0,2056,2057,1,0,0,
  	0,2057,2058,3,1416,708,0,2058,2059,5,229,0,0,2059,2060,5,115,0,0,2060,
  	2061,5,116,0,0,2061,2329,1,0,0,0,2062,2064,5,176,0,0,2063,2065,3,722,
  	361,0,2064,2063,1,0,0,0,2064,2065,1,0,0,0,2065,2066,1,0,0,0,2066,2067,
  	3,1416,708,0,2067,2068,5,364,0,0,2068,2069,5,115,0,0,2069,2070,5,116,
  	0,0,2070,2329,1,0,0,0,2071,2073,5,176,0,0,2072,2074,3,722,361,0,2073,
  	2072,1,0,0,0,2073,2074,1,0,0,0,2074,2075,1,0,0,0,2075,2076,3,1416,708,
  	0,2076,2077,5,229,0,0,2077,2078,5,475,0,0,2078,2329,1,0,0,0,2079,2081,
  	5,176,0,0,2080,2082,3,722,361,0,2081,2080,1,0,0,0,2081,2082,1,0,0,0,2082,
  	2083,1,0,0,0,2083,2084,3,1416,708,0,2084,2085,5,229,0,0,2085,2086,5,475,
  	0,0,2086,2087,5,258,0,0,2087,2088,5,427,0,0,2088,2329,1,0,0,0,2089,2091,
  	5,176,0,0,2090,2092,3,722,361,0,2091,2090,1,0,0,0,2091,2092,1,0,0,0,2092,
  	2093,1,0,0,0,2093,2094,3,1416,708,0,2094,2095,5,364,0,0,2095,2096,5,373,
  	0,0,2096,2097,3,1408,704,0,2097,2329,1,0,0,0,2098,2100,5,176,0,0,2099,
  	2101,3,722,361,0,2100,2099,1,0,0,0,2100,2101,1,0,0,0,2101,2102,1,0,0,
  	0,2102,2103,3,1400,700,0,2103,2104,5,364,0,0,2104,2105,5,373,0,0,2105,
  	2106,3,1408,704,0,2106,2329,1,0,0,0,2107,2109,5,176,0,0,2108,2110,3,722,
  	361,0,2109,2108,1,0,0,0,2109,2110,1,0,0,0,2110,2111,1,0,0,0,2111,2112,
  	3,1416,708,0,2112,2113,5,364,0,0,2113,2114,3,112,56,0,2114,2329,1,0,0,
  	0,2115,2117,5,176,0,0,2116,2118,3,722,361,0,2117,2116,1,0,0,0,2117,2118,
  	1,0,0,0,2118,2119,1,0,0,0,2119,2120,3,1416,708,0,2120,2121,5,344,0,0,
  	2121,2122,3,112,56,0,2122,2329,1,0,0,0,2123,2125,5,176,0,0,2124,2126,
  	3,722,361,0,2125,2124,1,0,0,0,2125,2126,1,0,0,0,2126,2127,1,0,0,0,2127,
  	2128,3,1416,708,0,2128,2129,5,364,0,0,2129,2130,5,376,0,0,2130,2131,3,
  	1416,708,0,2131,2329,1,0,0,0,2132,2134,5,176,0,0,2133,2135,3,722,361,
  	0,2134,2133,1,0,0,0,2134,2135,1,0,0,0,2135,2136,1,0,0,0,2136,2137,3,1416,
  	708,0,2137,2138,5,171,0,0,2138,2139,5,476,0,0,2139,2140,3,194,97,0,2140,
  	2141,5,74,0,0,2141,2143,5,257,0,0,2142,2144,3,280,140,0,2143,2142,1,0,
  	0,0,2143,2144,1,0,0,0,2144,2329,1,0,0,0,2145,2147,5,176,0,0,2146,2148,
  	3,722,361,0,2147,2146,1,0,0,0,2147,2148,1,0,0,0,2148,2149,1,0,0,0,2149,
  	2150,3,1416,708,0,2150,2151,3,120,60,0,2151,2329,1,0,0,0,2152,2154,5,
  	176,0,0,2153,2155,3,722,361,0,2154,2153,1,0,0,0,2154,2155,1,0,0,0,2155,
  	2156,1,0,0,0,2156,2157,3,1416,708,0,2157,2158,5,229,0,0,2158,2159,5,257,
  	0,0,2159,2329,1,0,0,0,2160,2162,5,176,0,0,2161,2163,3,722,361,0,2162,
  	2161,1,0,0,0,2162,2163,1,0,0,0,2163,2164,1,0,0,0,2164,2165,3,1416,708,
  	0,2165,2166,5,229,0,0,2166,2167,5,257,0,0,2167,2168,5,258,0,0,2168,2169,
  	5,427,0,0,2169,2329,1,0,0,0,2170,2172,5,229,0,0,2171,2173,3,722,361,0,
  	2172,2171,1,0,0,0,2172,2173,1,0,0,0,2173,2174,1,0,0,0,2174,2175,5,258,
  	0,0,2175,2176,5,427,0,0,2176,2178,3,1416,708,0,2177,2179,3,104,52,0,2178,
  	2177,1,0,0,0,2178,2179,1,0,0,0,2179,2329,1,0,0,0,2180,2182,5,229,0,0,
  	2181,2183,3,722,361,0,2182,2181,1,0,0,0,2182,2183,1,0,0,0,2183,2184,1,
  	0,0,0,2184,2186,3,1416,708,0,2185,2187,3,104,52,0,2186,2185,1,0,0,0,2186,
  	2187,1,0,0,0,2187,2329,1,0,0,0,2188,2190,5,176,0,0,2189,2191,3,722,361,
  	0,2190,2189,1,0,0,0,2190,2191,1,0,0,0,2191,2192,1,0,0,0,2192,2194,3,1416,
  	708,0,2193,2195,3,724,362,0,2194,2193,1,0,0,0,2194,2195,1,0,0,0,2195,
  	2196,1,0,0,0,2196,2197,5,391,0,0,2197,2199,3,1118,559,0,2198,2200,3,106,
  	53,0,2199,2198,1,0,0,0,2199,2200,1,0,0,0,2200,2202,1,0,0,0,2201,2203,
  	3,108,54,0,2202,2201,1,0,0,0,2202,2203,1,0,0,0,2203,2329,1,0,0,0,2204,
  	2206,5,176,0,0,2205,2207,3,722,361,0,2206,2205,1,0,0,0,2206,2207,1,0,
  	0,0,2207,2208,1,0,0,0,2208,2209,3,1416,708,0,2209,2210,3,340,170,0,2210,
  	2329,1,0,0,0,2211,2212,5,171,0,0,2212,2329,3,204,102,0,2213,2214,5,176,
  	0,0,2214,2215,5,83,0,0,2215,2216,3,1384,692,0,2216,2217,3,436,218,0,2217,
  	2329,1,0,0,0,2218,2219,5,403,0,0,2219,2220,5,83,0,0,2220,2329,3,1384,
  	692,0,2221,2222,5,229,0,0,2222,2223,5,83,0,0,2223,2224,5,258,0,0,2224,
  	2225,5,427,0,0,2225,2227,3,1384,692,0,2226,2228,3,104,52,0,2227,2226,
  	1,0,0,0,2227,2228,1,0,0,0,2228,2329,1,0,0,0,2229,2230,5,229,0,0,2230,
  	2231,5,83,0,0,2231,2233,3,1384,692,0,2232,2234,3,104,52,0,2233,2232,1,
  	0,0,0,2233,2234,1,0,0,0,2234,2329,1,0,0,0,2235,2236,5,364,0,0,2236,2237,
  	5,410,0,0,2237,2329,5,308,0,0,2238,2239,5,196,0,0,2239,2240,5,118,0,0,
  	2240,2329,3,1384,692,0,2241,2242,5,364,0,0,2242,2243,5,410,0,0,2243,2329,
  	5,196,0,0,2244,2245,5,364,0,0,2245,2329,5,477,0,0,2246,2247,5,364,0,0,
  	2247,2329,5,398,0,0,2248,2249,5,231,0,0,2249,2250,5,388,0,0,2250,2329,
  	3,1384,692,0,2251,2252,5,231,0,0,2252,2253,5,177,0,0,2253,2254,5,388,
  	0,0,2254,2329,3,1384,692,0,2255,2256,5,231,0,0,2256,2257,5,343,0,0,2257,
  	2258,5,388,0,0,2258,2329,3,1384,692,0,2259,2260,5,231,0,0,2260,2261,5,
  	388,0,0,2261,2329,5,68,0,0,2262,2263,5,231,0,0,2263,2264,5,388,0,0,2264,
  	2329,5,137,0,0,2265,2266,5,224,0,0,2266,2267,5,388,0,0,2267,2329,3,1384,
  	692,0,2268,2269,5,224,0,0,2269,2270,5,388,0,0,2270,2329,5,68,0,0,2271,
  	2272,5,224,0,0,2272,2273,5,388,0,0,2273,2329,5,137,0,0,2274,2275,5,231,
  	0,0,2275,2276,5,352,0,0,2276,2329,3,1384,692,0,2277,2278,5,231,0,0,2278,
  	2279,5,177,0,0,2279,2280,5,352,0,0,2280,2329,3,1384,692,0,2281,2282,5,
  	231,0,0,2282,2283,5,343,0,0,2283,2284,5,352,0,0,2284,2329,3,1384,692,
  	0,2285,2286,5,224,0,0,2286,2287,5,352,0,0,2287,2329,3,1384,692,0,2288,
  	2289,5,266,0,0,2289,2329,3,1380,690,0,2290,2291,5,300,0,0,2291,2292,5,
  	266,0,0,2292,2329,3,1380,690,0,2293,2294,5,306,0,0,2294,2329,3,520,260,
  	0,2295,2296,5,115,0,0,2296,2329,5,306,0,0,2297,2298,5,313,0,0,2298,2299,
  	5,132,0,0,2299,2329,3,1412,706,0,2300,2301,5,364,0,0,2301,2302,5,382,
  	0,0,2302,2329,3,1384,692,0,2303,2304,5,364,0,0,2304,2329,3,112,56,0,2305,
  	2306,5,344,0,0,2306,2329,3,112,56,0,2307,2308,5,343,0,0,2308,2309,5,257,
  	0,0,2309,2329,3,110,55,0,2310,2311,5,231,0,0,2311,2312,5,445,0,0,2312,
  	2313,5,280,0,0,2313,2329,5,358,0,0,2314,2315,5,224,0,0,2315,2316,5,445,
  	0,0,2316,2317,5,280,0,0,2317,2329,5,358,0,0,2318,2319,5,247,0,0,2319,
  	2320,5,445,0,0,2320,2321,5,280,0,0,2321,2329,5,358,0,0,2322,2323,5,300,
  	0,0,2323,2324,5,247,0,0,2324,2325,5,445,0,0,2325,2326,5,280,0,0,2326,
  	2329,5,358,0,0,2327,2329,3,340,170,0,2328,2030,1,0,0,0,2328,2032,1,0,
  	0,0,2328,2037,1,0,0,0,2328,2040,1,0,0,0,2328,2046,1,0,0,0,2328,2053,1,
  	0,0,0,2328,2062,1,0,0,0,2328,2071,1,0,0,0,2328,2079,1,0,0,0,2328,2089,
  	1,0,0,0,2328,2098,1,0,0,0,2328,2107,1,0,0,0,2328,2115,1,0,0,0,2328,2123,
  	1,0,0,0,2328,2132,1,0,0,0,2328,2145,1,0,0,0,2328,2152,1,0,0,0,2328,2160,
  	1,0,0,0,2328,2170,1,0,0,0,2328,2180,1,0,0,0,2328,2188,1,0,0,0,2328,2204,
  	1,0,0,0,2328,2211,1,0,0,0,2328,2213,1,0,0,0,2328,2218,1,0,0,0,2328,2221,
  	1,0,0,0,2328,2229,1,0,0,0,2328,2235,1,0,0,0,2328,2238,1,0,0,0,2328,2241,
  	1,0,0,0,2328,2244,1,0,0,0,2328,2246,1,0,0,0,2328,2248,1,0,0,0,2328,2251,
  	1,0,0,0,2328,2255,1,0,0,0,2328,2259,1,0,0,0,2328,2262,1,0,0,0,2328,2265,
  	1,0,0,0,2328,2268,1,0,0,0,2328,2271,1,0,0,0,2328,2274,1,0,0,0,2328,2277,
  	1,0,0,0,2328,2281,1,0,0,0,2328,2285,1,0,0,0,2328,2288,1,0,0,0,2328,2290,
  	1,0,0,0,2328,2293,1,0,0,0,2328,2295,1,0,0,0,2328,2297,1,0,0,0,2328,2300,
  	1,0,0,0,2328,2303,1,0,0,0,2328,2305,1,0,0,0,2328,2307,1,0,0,0,2328,2310,
  	1,0,0,0,2328,2314,1,0,0,0,2328,2318,1,0,0,0,2328,2322,1,0,0,0,2328,2327,
  	1,0,0,0,2329,101,1,0,0,0,2330,2331,5,364,0,0,2331,2332,5,91,0,0,2332,
  	2336,3,1164,582,0,2333,2334,5,229,0,0,2334,2336,5,91,0,0,2335,2330,1,
  	0,0,0,2335,2333,1,0,0,0,2336,103,1,0,0,0,2337,2338,7,10,0,0,2338,105,
  	1,0,0,0,2339,2340,5,81,0,0,2340,2341,3,520,260,0,2341,107,1,0,0,0,2342,
  	2343,5,138,0,0,2343,2344,3,1164,582,0,2344,109,1,0,0,0,2345,2352,5,301,
  	0,0,2346,2352,5,151,0,0,2347,2352,5,91,0,0,2348,2349,5,138,0,0,2349,2350,
  	5,264,0,0,2350,2352,3,1384,692,0,2351,2345,1,0,0,0,2351,2346,1,0,0,0,
  	2351,2347,1,0,0,0,2351,2348,1,0,0,0,2352,111,1,0,0,0,2353,2354,5,2,0,
  	0,2354,2355,3,116,58,0,2355,2356,5,3,0,0,2356,113,1,0,0,0,2357,2358,5,
  	143,0,0,2358,2359,3,112,56,0,2359,115,1,0,0,0,2360,2365,3,118,59,0,2361,
  	2362,5,6,0,0,2362,2364,3,118,59,0,2363,2361,1,0,0,0,2364,2367,1,0,0,0,
  	2365,2363,1,0,0,0,2365,2366,1,0,0,0,2366,117,1,0,0,0,2367,2365,1,0,0,
  	0,2368,2377,3,1422,711,0,2369,2370,5,10,0,0,2370,2378,3,462,231,0,2371,
  	2372,5,11,0,0,2372,2375,3,1422,711,0,2373,2374,5,10,0,0,2374,2376,3,462,
  	231,0,2375,2373,1,0,0,0,2375,2376,1,0,0,0,2376,2378,1,0,0,0,2377,2369,
  	1,0,0,0,2377,2371,1,0,0,0,2377,2378,1,0,0,0,2378,119,1,0,0,0,2379,2381,
  	3,122,61,0,2380,2379,1,0,0,0,2381,2382,1,0,0,0,2382,2380,1,0,0,0,2382,
  	2383,1,0,0,0,2383,121,1,0,0,0,2384,2389,5,345,0,0,2385,2387,3,12,6,0,
  	2386,2385,1,0,0,0,2386,2387,1,0,0,0,2387,2388,1,0,0,0,2388,2390,3,288,
  	144,0,2389,2386,1,0,0,0,2389,2390,1,0,0,0,2390,2398,1,0,0,0,2391,2395,
  	5,364,0,0,2392,2396,3,284,142,0,2393,2394,5,476,0,0,2394,2396,3,194,97,
  	0,2395,2392,1,0,0,0,2395,2393,1,0,0,0,2396,2398,1,0,0,0,2397,2384,1,0,
  	0,0,2397,2391,1,0,0,0,2398,123,1,0,0,0,2399,2400,5,100,0,0,2400,2401,
  	5,453,0,0,2401,2402,5,143,0,0,2402,2403,5,2,0,0,2403,2404,3,128,64,0,
  	2404,2405,5,3,0,0,2405,2426,1,0,0,0,2406,2407,5,100,0,0,2407,2408,5,453,
  	0,0,2408,2409,5,106,0,0,2409,2410,5,2,0,0,2410,2411,3,1282,641,0,2411,
  	2412,5,3,0,0,2412,2426,1,0,0,0,2413,2414,5,100,0,0,2414,2415,5,453,0,
  	0,2415,2416,5,102,0,0,2416,2417,5,2,0,0,2417,2418,3,1282,641,0,2418,2419,
  	5,3,0,0,2419,2420,5,132,0,0,2420,2421,5,2,0,0,2421,2422,3,1282,641,0,
  	2422,2423,5,3,0,0,2423,2426,1,0,0,0,2424,2426,5,91,0,0,2425,2399,1,0,
  	0,0,2425,2406,1,0,0,0,2425,2413,1,0,0,0,2425,2424,1,0,0,0,2426,125,1,
  	0,0,0,2427,2428,3,1420,710,0,2428,2429,3,1400,700,0,2429,127,1,0,0,0,
  	2430,2435,3,126,63,0,2431,2432,5,6,0,0,2432,2434,3,126,63,0,2433,2431,
  	1,0,0,0,2434,2437,1,0,0,0,2435,2433,1,0,0,0,2435,2436,1,0,0,0,2436,129,
  	1,0,0,0,2437,2435,1,0,0,0,2438,2439,5,176,0,0,2439,2440,5,391,0,0,2440,
  	2441,3,520,260,0,2441,2442,3,132,66,0,2442,131,1,0,0,0,2443,2448,3,134,
  	67,0,2444,2445,5,6,0,0,2445,2447,3,134,67,0,2446,2444,1,0,0,0,2447,2450,
  	1,0,0,0,2448,2446,1,0,0,0,2448,2449,1,0,0,0,2449,133,1,0,0,0,2450,2448,
  	1,0,0,0,2451,2452,5,171,0,0,2452,2453,5,181,0,0,2453,2455,3,1102,551,
  	0,2454,2456,3,104,52,0,2455,2454,1,0,0,0,2455,2456,1,0,0,0,2456,2482,
  	1,0,0,0,2457,2458,5,229,0,0,2458,2461,5,181,0,0,2459,2460,5,258,0,0,2460,
  	2462,5,427,0,0,2461,2459,1,0,0,0,2461,2462,1,0,0,0,2462,2463,1,0,0,0,
  	2463,2465,3,1416,708,0,2464,2466,3,104,52,0,2465,2464,1,0,0,0,2465,2466,
  	1,0,0,0,2466,2482,1,0,0,0,2467,2468,5,176,0,0,2468,2469,5,181,0,0,2469,
  	2471,3,1416,708,0,2470,2472,3,724,362,0,2471,2470,1,0,0,0,2471,2472,1,
  	0,0,0,2472,2473,1,0,0,0,2473,2474,5,391,0,0,2474,2476,3,1118,559,0,2475,
  	2477,3,106,53,0,2476,2475,1,0,0,0,2476,2477,1,0,0,0,2477,2479,1,0,0,0,
  	2478,2480,3,104,52,0,2479,2478,1,0,0,0,2479,2480,1,0,0,0,2480,2482,1,
  	0,0,0,2481,2451,1,0,0,0,2481,2457,1,0,0,0,2481,2467,1,0,0,0,2482,135,
  	1,0,0,0,2483,2486,5,195,0,0,2484,2487,3,960,480,0,2485,2487,5,68,0,0,
  	2486,2484,1,0,0,0,2486,2485,1,0,0,0,2487,137,1,0,0,0,2488,2490,5,207,
  	0,0,2489,2491,3,152,76,0,2490,2489,1,0,0,0,2490,2491,1,0,0,0,2491,2492,
  	1,0,0,0,2492,2494,3,1380,690,0,2493,2495,3,210,105,0,2494,2493,1,0,0,
  	0,2494,2495,1,0,0,0,2495,2496,1,0,0,0,2496,2498,3,140,70,0,2497,2499,
  	3,142,71,0,2498,2497,1,0,0,0,2498,2499,1,0,0,0,2499,2500,1,0,0,0,2500,
  	2502,3,144,72,0,2501,2503,3,154,77,0,2502,2501,1,0,0,0,2502,2503,1,0,
  	0,0,2503,2505,1,0,0,0,2504,2506,3,12,6,0,2505,2504,1,0,0,0,2505,2506,
  	1,0,0,0,2506,2507,1,0,0,0,2507,2509,3,146,73,0,2508,2510,3,1094,547,0,
  	2509,2508,1,0,0,0,2509,2510,1,0,0,0,2510,2526,1,0,0,0,2511,2512,5,207,
  	0,0,2512,2513,5,2,0,0,2513,2514,3,900,450,0,2514,2515,5,3,0,0,2515,2517,
  	5,132,0,0,2516,2518,3,142,71,0,2517,2516,1,0,0,0,2517,2518,1,0,0,0,2518,
  	2519,1,0,0,0,2519,2521,3,144,72,0,2520,2522,3,12,6,0,2521,2520,1,0,0,
  	0,2521,2522,1,0,0,0,2522,2523,1,0,0,0,2523,2524,3,146,73,0,2524,2526,
  	1,0,0,0,2525,2488,1,0,0,0,2525,2511,1,0,0,0,2526,139,1,0,0,0,2527,2528,
  	7,11,0,0,2528,141,1,0,0,0,2529,2530,5,328,0,0,2530,143,1,0,0,0,2531,2535,
  	3,1402,701,0,2532,2535,5,374,0,0,2533,2535,5,375,0,0,2534,2531,1,0,0,
  	0,2534,2532,1,0,0,0,2534,2533,1,0,0,0,2535,145,1,0,0,0,2536,2542,3,148,
  	74,0,2537,2538,5,2,0,0,2538,2539,3,158,79,0,2539,2540,5,3,0,0,2540,2542,
  	1,0,0,0,2541,2536,1,0,0,0,2541,2537,1,0,0,0,2542,147,1,0,0,0,2543,2545,
  	3,150,75,0,2544,2543,1,0,0,0,2545,2548,1,0,0,0,2546,2544,1,0,0,0,2546,
  	2547,1,0,0,0,2547,149,1,0,0,0,2548,2546,1,0,0,0,2549,2589,5,145,0,0,2550,
  	2589,5,150,0,0,2551,2553,5,221,0,0,2552,2554,3,832,416,0,2553,2552,1,
  	0,0,0,2553,2554,1,0,0,0,2554,2555,1,0,0,0,2555,2589,3,1402,701,0,2556,
  	2558,5,116,0,0,2557,2559,3,832,416,0,2558,2557,1,0,0,0,2558,2559,1,0,
  	0,0,2559,2560,1,0,0,0,2560,2589,3,1402,701,0,2561,2589,5,209,0,0,2562,
  	2589,5,254,0,0,2563,2565,5,329,0,0,2564,2566,3,832,416,0,2565,2564,1,
  	0,0,0,2565,2566,1,0,0,0,2566,2567,1,0,0,0,2567,2589,3,1402,701,0,2568,
  	2570,5,235,0,0,2569,2571,3,832,416,0,2570,2569,1,0,0,0,2570,2571,1,0,
  	0,0,2571,2572,1,0,0,0,2572,2589,3,1402,701,0,2573,2574,5,247,0,0,2574,
  	2575,5,329,0,0,2575,2589,3,212,106,0,2576,2577,5,247,0,0,2577,2578,5,
  	329,0,0,2578,2589,5,9,0,0,2579,2580,5,247,0,0,2580,2581,5,115,0,0,2581,
  	2582,5,116,0,0,2582,2589,3,212,106,0,2583,2584,5,247,0,0,2584,2585,5,
  	116,0,0,2585,2589,3,212,106,0,2586,2587,5,232,0,0,2587,2589,3,1402,701,
  	0,2588,2549,1,0,0,0,2588,2550,1,0,0,0,2588,2551,1,0,0,0,2588,2556,1,0,
  	0,0,2588,2561,1,0,0,0,2588,2562,1,0,0,0,2588,2563,1,0,0,0,2588,2568,1,
  	0,0,0,2588,2573,1,0,0,0,2588,2576,1,0,0,0,2588,2579,1,0,0,0,2588,2583,
  	1,0,0,0,2588,2586,1,0,0,0,2589,151,1,0,0,0,2590,2591,5,145,0,0,2591,153,
  	1,0,0,0,2592,2594,3,156,78,0,2593,2592,1,0,0,0,2593,2594,1,0,0,0,2594,
  	2595,1,0,0,0,2595,2596,5,222,0,0,2596,2597,3,1402,701,0,2597,155,1,0,
  	0,0,2598,2599,5,138,0,0,2599,157,1,0,0,0,2600,2605,3,160,80,0,2601,2602,
  	5,6,0,0,2602,2604,3,160,80,0,2603,2601,1,0,0,0,2604,2607,1,0,0,0,2605,
  	2603,1,0,0,0,2605,2606,1,0,0,0,2606,159,1,0,0,0,2607,2605,1,0,0,0,2608,
  	2610,3,1422,711,0,2609,2611,3,162,81,0,2610,2609,1,0,0,0,2610,2611,1,
  	0,0,0,2611,161,1,0,0,0,2612,2620,3,62,31,0,2613,2620,3,288,144,0,2614,
  	2620,5,9,0,0,2615,2616,5,2,0,0,2616,2617,3,164,82,0,2617,2618,5,3,0,0,
  	2618,2620,1,0,0,0,2619,2612,1,0,0,0,2619,2613,1,0,0,0,2619,2614,1,0,0,
  	0,2619,2615,1,0,0,0,2620,163,1,0,0,0,2621,2626,3,166,83,0,2622,2623,5,
  	6,0,0,2623,2625,3,166,83,0,2624,2622,1,0,0,0,2625,2628,1,0,0,0,2626,2624,
  	1,0,0,0,2626,2627,1,0,0,0,2627,165,1,0,0,0,2628,2626,1,0,0,0,2629,2630,
  	3,62,31,0,2630,167,1,0,0,0,2631,2633,5,84,0,0,2632,2634,3,170,85,0,2633,
  	2632,1,0,0,0,2633,2634,1,0,0,0,2634,2635,1,0,0,0,2635,2639,5,130,0,0,
  	2636,2637,5,258,0,0,2637,2638,5,115,0,0,2638,2640,5,427,0,0,2639,2636,
  	1,0,0,0,2639,2640,1,0,0,0,2640,2641,1,0,0,0,2641,2707,3,1380,690,0,2642,
  	2644,5,2,0,0,2643,2645,3,172,86,0,2644,2643,1,0,0,0,2644,2645,1,0,0,0,
  	2645,2646,1,0,0,0,2646,2648,5,3,0,0,2647,2649,3,234,117,0,2648,2647,1,
  	0,0,0,2648,2649,1,0,0,0,2649,2651,1,0,0,0,2650,2652,3,236,118,0,2651,
  	2650,1,0,0,0,2651,2652,1,0,0,0,2652,2654,1,0,0,0,2653,2655,3,244,122,
  	0,2654,2653,1,0,0,0,2654,2655,1,0,0,0,2655,2657,1,0,0,0,2656,2658,3,246,
  	123,0,2657,2656,1,0,0,0,2657,2658,1,0,0,0,2658,2660,1,0,0,0,2659,2661,
  	3,248,124,0,2660,2659,1,0,0,0,2660,2661,1,0,0,0,2661,2663,1,0,0,0,2662,
  	2664,3,250,125,0,2663,2662,1,0,0,0,2663,2664,1,0,0,0,2664,2708,1,0,0,
  	0,2665,2666,5,306,0,0,2666,2668,3,520,260,0,2667,2669,3,174,87,0,2668,
  	2667,1,0,0,0,2668,2669,1,0,0,0,2669,2671,1,0,0,0,2670,2672,3,236,118,
  	0,2671,2670,1,0,0,0,2671,2672,1,0,0,0,2672,2674,1,0,0,0,2673,2675,3,244,
  	122,0,2674,2673,1,0,0,0,2674,2675,1,0,0,0,2675,2677,1,0,0,0,2676,2678,
  	3,246,123,0,2677,2676,1,0,0,0,2677,2678,1,0,0,0,2678,2680,1,0,0,0,2679,
  	2681,3,248,124,0,2680,2679,1,0,0,0,2680,2681,1,0,0,0,2681,2683,1,0,0,
  	0,2682,2684,3,250,125,0,2683,2682,1,0,0,0,2683,2684,1,0,0,0,2684,2708,
  	1,0,0,0,2685,2686,5,316,0,0,2686,2687,5,306,0,0,2687,2689,3,1380,690,
  	0,2688,2690,3,174,87,0,2689,2688,1,0,0,0,2689,2690,1,0,0,0,2690,2691,
  	1,0,0,0,2691,2693,3,124,62,0,2692,2694,3,236,118,0,2693,2692,1,0,0,0,
  	2693,2694,1,0,0,0,2694,2696,1,0,0,0,2695,2697,3,244,122,0,2696,2695,1,
  	0,0,0,2696,2697,1,0,0,0,2697,2699,1,0,0,0,2698,2700,3,246,123,0,2699,
  	2698,1,0,0,0,2699,2700,1,0,0,0,2700,2702,1,0,0,0,2701,2703,3,248,124,
  	0,2702,2701,1,0,0,0,2702,2703,1,0,0,0,2703,2705,1,0,0,0,2704,2706,3,250,
  	125,0,2705,2704,1,0,0,0,2705,2706,1,0,0,0,2706,2708,1,0,0,0,2707,2642,
  	1,0,0,0,2707,2665,1,0,0,0,2707,2685,1,0,0,0,2708,169,1,0,0,0,2709,2717,
  	5,385,0,0,2710,2717,5,383,0,0,2711,2712,5,283,0,0,2712,2717,7,12,0,0,
  	2713,2714,5,251,0,0,2714,2717,7,12,0,0,2715,2717,5,398,0,0,2716,2709,
  	1,0,0,0,2716,2710,1,0,0,0,2716,2711,1,0,0,0,2716,2713,1,0,0,0,2716,2715,
  	1,0,0,0,2717,171,1,0,0,0,2718,2719,3,176,88,0,2719,173,1,0,0,0,2720,2721,
  	5,2,0,0,2721,2722,3,178,89,0,2722,2723,5,3,0,0,2723,175,1,0,0,0,2724,
  	2729,3,180,90,0,2725,2726,5,6,0,0,2726,2728,3,180,90,0,2727,2725,1,0,
  	0,0,2728,2731,1,0,0,0,2729,2727,1,0,0,0,2729,2730,1,0,0,0,2730,177,1,
  	0,0,0,2731,2729,1,0,0,0,2732,2737,3,182,91,0,2733,2734,5,6,0,0,2734,2736,
  	3,182,91,0,2735,2733,1,0,0,0,2736,2739,1,0,0,0,2737,2735,1,0,0,0,2737,
  	2738,1,0,0,0,2738,179,1,0,0,0,2739,2737,1,0,0,0,2740,2744,3,204,102,0,
  	2741,2744,3,198,99,0,2742,2744,3,184,92,0,2743,2740,1,0,0,0,2743,2741,
  	1,0,0,0,2743,2742,1,0,0,0,2744,181,1,0,0,0,2745,2748,3,186,93,0,2746,
  	2748,3,204,102,0,2747,2745,1,0,0,0,2747,2746,1,0,0,0,2748,183,1,0,0,0,
  	2749,2750,3,1416,708,0,2750,2752,3,1118,559,0,2751,2753,3,336,168,0,2752,
  	2751,1,0,0,0,2752,2753,1,0,0,0,2753,2754,1,0,0,0,2754,2755,3,188,94,0,
  	2755,185,1,0,0,0,2756,2759,3,1416,708,0,2757,2758,5,143,0,0,2758,2760,
  	5,311,0,0,2759,2757,1,0,0,0,2759,2760,1,0,0,0,2760,2761,1,0,0,0,2761,
  	2762,3,188,94,0,2762,187,1,0,0,0,2763,2765,3,190,95,0,2764,2763,1,0,0,
  	0,2765,2768,1,0,0,0,2766,2764,1,0,0,0,2766,2767,1,0,0,0,2767,189,1,0,
  	0,0,2768,2766,1,0,0,0,2769,2770,5,83,0,0,2770,2771,3,1384,692,0,2771,
  	2772,3,192,96,0,2772,2778,1,0,0,0,2773,2778,3,192,96,0,2774,2778,3,196,
  	98,0,2775,2776,5,81,0,0,2776,2778,3,520,260,0,2777,2769,1,0,0,0,2777,
  	2773,1,0,0,0,2777,2774,1,0,0,0,2777,2775,1,0,0,0,2778,191,1,0,0,0,2779,
  	2780,5,115,0,0,2780,2832,5,116,0,0,2781,2832,5,116,0,0,2782,2784,5,136,
  	0,0,2783,2785,3,664,332,0,2784,2783,1,0,0,0,2784,2785,1,0,0,0,2785,2787,
  	1,0,0,0,2786,2788,3,252,126,0,2787,2786,1,0,0,0,2787,2788,1,0,0,0,2788,
  	2832,1,0,0,0,2789,2790,5,123,0,0,2790,2792,5,274,0,0,2791,2793,3,664,
  	332,0,2792,2791,1,0,0,0,2792,2793,1,0,0,0,2793,2795,1,0,0,0,2794,2796,
  	3,252,126,0,2795,2794,1,0,0,0,2795,2796,1,0,0,0,2796,2832,1,0,0,0,2797,
  	2798,5,80,0,0,2798,2799,5,2,0,0,2799,2800,3,1164,582,0,2800,2802,5,3,
  	0,0,2801,2803,3,208,104,0,2802,2801,1,0,0,0,2802,2803,1,0,0,0,2803,2832,
  	1,0,0,0,2804,2805,5,91,0,0,2805,2832,3,1206,603,0,2806,2807,5,476,0,0,
  	2807,2808,3,194,97,0,2808,2818,5,74,0,0,2809,2811,5,257,0,0,2810,2812,
  	3,280,140,0,2811,2810,1,0,0,0,2811,2812,1,0,0,0,2812,2819,1,0,0,0,2813,
  	2814,5,2,0,0,2814,2815,3,1164,582,0,2815,2816,5,3,0,0,2816,2817,5,478,
  	0,0,2817,2819,1,0,0,0,2818,2809,1,0,0,0,2818,2813,1,0,0,0,2819,2832,1,
  	0,0,0,2820,2821,5,124,0,0,2821,2823,3,1380,690,0,2822,2824,3,210,105,
  	0,2823,2822,1,0,0,0,2823,2824,1,0,0,0,2824,2826,1,0,0,0,2825,2827,3,218,
  	109,0,2826,2825,1,0,0,0,2826,2827,1,0,0,0,2827,2829,1,0,0,0,2828,2830,
  	3,226,113,0,2829,2828,1,0,0,0,2829,2830,1,0,0,0,2830,2832,1,0,0,0,2831,
  	2779,1,0,0,0,2831,2781,1,0,0,0,2831,2782,1,0,0,0,2831,2789,1,0,0,0,2831,
  	2797,1,0,0,0,2831,2804,1,0,0,0,2831,2806,1,0,0,0,2831,2820,1,0,0,0,2832,
  	193,1,0,0,0,2833,2837,5,177,0,0,2834,2835,5,185,0,0,2835,2837,5,91,0,
  	0,2836,2833,1,0,0,0,2836,2834,1,0,0,0,2837,195,1,0,0,0,2838,2844,5,92,
  	0,0,2839,2840,5,115,0,0,2840,2844,5,92,0,0,2841,2842,5,107,0,0,2842,2844,
  	7,8,0,0,2843,2838,1,0,0,0,2843,2839,1,0,0,0,2843,2841,1,0,0,0,2844,197,
  	1,0,0,0,2845,2846,5,158,0,0,2846,2847,3,1380,690,0,2847,2848,3,200,100,
  	0,2848,199,1,0,0,0,2849,2850,7,13,0,0,2850,2852,3,202,101,0,2851,2849,
  	1,0,0,0,2852,2855,1,0,0,0,2853,2851,1,0,0,0,2853,2854,1,0,0,0,2854,201,
  	1,0,0,0,2855,2853,1,0,0,0,2856,2857,7,14,0,0,2857,203,1,0,0,0,2858,2859,
  	5,83,0,0,2859,2860,3,1384,692,0,2860,2861,3,206,103,0,2861,2864,1,0,0,
  	0,2862,2864,3,206,103,0,2863,2858,1,0,0,0,2863,2862,1,0,0,0,2864,205,
  	1,0,0,0,2865,2866,5,80,0,0,2866,2867,5,2,0,0,2867,2868,3,1164,582,0,2868,
  	2869,5,3,0,0,2869,2870,3,436,218,0,2870,2952,1,0,0,0,2871,2889,5,136,
  	0,0,2872,2873,5,2,0,0,2873,2874,3,212,106,0,2874,2876,5,3,0,0,2875,2877,
  	3,216,108,0,2876,2875,1,0,0,0,2876,2877,1,0,0,0,2877,2879,1,0,0,0,2878,
  	2880,3,664,332,0,2879,2878,1,0,0,0,2879,2880,1,0,0,0,2880,2882,1,0,0,
  	0,2881,2883,3,252,126,0,2882,2881,1,0,0,0,2882,2883,1,0,0,0,2883,2884,
  	1,0,0,0,2884,2885,3,436,218,0,2885,2890,1,0,0,0,2886,2887,3,254,127,0,
  	2887,2888,3,436,218,0,2888,2890,1,0,0,0,2889,2872,1,0,0,0,2889,2886,1,
  	0,0,0,2890,2952,1,0,0,0,2891,2892,5,123,0,0,2892,2910,5,274,0,0,2893,
  	2894,5,2,0,0,2894,2895,3,212,106,0,2895,2897,5,3,0,0,2896,2898,3,216,
  	108,0,2897,2896,1,0,0,0,2897,2898,1,0,0,0,2898,2900,1,0,0,0,2899,2901,
  	3,664,332,0,2900,2899,1,0,0,0,2900,2901,1,0,0,0,2901,2903,1,0,0,0,2902,
  	2904,3,252,126,0,2903,2902,1,0,0,0,2903,2904,1,0,0,0,2904,2905,1,0,0,
  	0,2905,2906,3,436,218,0,2906,2911,1,0,0,0,2907,2908,3,254,127,0,2908,
  	2909,3,436,218,0,2909,2911,1,0,0,0,2910,2893,1,0,0,0,2910,2907,1,0,0,
  	0,2911,2952,1,0,0,0,2912,2914,5,237,0,0,2913,2915,3,596,298,0,2914,2913,
  	1,0,0,0,2914,2915,1,0,0,0,2915,2916,1,0,0,0,2916,2917,5,2,0,0,2917,2918,
  	3,220,110,0,2918,2920,5,3,0,0,2919,2921,3,216,108,0,2920,2919,1,0,0,0,
  	2920,2921,1,0,0,0,2921,2923,1,0,0,0,2922,2924,3,664,332,0,2923,2922,1,
  	0,0,0,2923,2924,1,0,0,0,2924,2926,1,0,0,0,2925,2927,3,252,126,0,2926,
  	2925,1,0,0,0,2926,2927,1,0,0,0,2927,2929,1,0,0,0,2928,2930,3,224,112,
  	0,2929,2928,1,0,0,0,2929,2930,1,0,0,0,2930,2931,1,0,0,0,2931,2932,3,436,
  	218,0,2932,2952,1,0,0,0,2933,2934,5,101,0,0,2934,2935,5,274,0,0,2935,
  	2936,5,2,0,0,2936,2937,3,212,106,0,2937,2938,5,3,0,0,2938,2939,5,124,
  	0,0,2939,2941,3,1380,690,0,2940,2942,3,210,105,0,2941,2940,1,0,0,0,2941,
  	2942,1,0,0,0,2942,2944,1,0,0,0,2943,2945,3,218,109,0,2944,2943,1,0,0,
  	0,2944,2945,1,0,0,0,2945,2947,1,0,0,0,2946,2948,3,226,113,0,2947,2946,
  	1,0,0,0,2947,2948,1,0,0,0,2948,2949,1,0,0,0,2949,2950,3,436,218,0,2950,
  	2952,1,0,0,0,2951,2865,1,0,0,0,2951,2871,1,0,0,0,2951,2891,1,0,0,0,2951,
  	2912,1,0,0,0,2951,2933,1,0,0,0,2952,207,1,0,0,0,2953,2954,5,300,0,0,2954,
  	2955,5,266,0,0,2955,209,1,0,0,0,2956,2957,5,2,0,0,2957,2958,3,212,106,
  	0,2958,2959,5,3,0,0,2959,211,1,0,0,0,2960,2965,3,214,107,0,2961,2962,
  	5,6,0,0,2962,2964,3,214,107,0,2963,2961,1,0,0,0,2964,2967,1,0,0,0,2965,
  	2963,1,0,0,0,2965,2966,1,0,0,0,2966,213,1,0,0,0,2967,2965,1,0,0,0,2968,
  	2969,3,1416,708,0,2969,215,1,0,0,0,2970,2971,5,479,0,0,2971,2972,5,2,
  	0,0,2972,2973,3,212,106,0,2973,2974,5,3,0,0,2974,217,1,0,0,0,2975,2976,
  	5,287,0,0,2976,2977,7,15,0,0,2977,219,1,0,0,0,2978,2983,3,222,111,0,2979,
  	2980,5,6,0,0,2980,2982,3,222,111,0,2981,2979,1,0,0,0,2982,2985,1,0,0,
  	0,2983,2981,1,0,0,0,2983,2984,1,0,0,0,2984,221,1,0,0,0,2985,2983,1,0,
  	0,0,2986,2987,3,602,301,0,2987,2994,5,143,0,0,2988,2995,3,684,342,0,2989,
  	2990,5,309,0,0,2990,2991,5,2,0,0,2991,2992,3,684,342,0,2992,2993,5,3,
  	0,0,2993,2995,1,0,0,0,2994,2988,1,0,0,0,2994,2989,1,0,0,0,2995,223,1,
  	0,0,0,2996,2997,5,141,0,0,2997,2998,5,2,0,0,2998,2999,3,1164,582,0,2999,
  	3000,5,3,0,0,3000,225,1,0,0,0,3001,3010,3,228,114,0,3002,3010,3,230,115,
  	0,3003,3004,3,228,114,0,3004,3005,3,230,115,0,3005,3010,1,0,0,0,3006,
  	3007,3,230,115,0,3007,3008,3,228,114,0,3008,3010,1,0,0,0,3009,3001,1,
  	0,0,0,3009,3002,1,0,0,0,3009,3003,1,0,0,0,3009,3006,1,0,0,0,3010,227,
  	1,0,0,0,3011,3012,5,118,0,0,3012,3013,5,400,0,0,3013,3014,3,232,116,0,
  	3014,229,1,0,0,0,3015,3016,5,118,0,0,3016,3017,5,220,0,0,3017,3018,3,
  	232,116,0,3018,231,1,0,0,0,3019,3020,5,300,0,0,3020,3026,5,170,0,0,3021,
  	3026,5,346,0,0,3022,3026,5,188,0,0,3023,3024,5,364,0,0,3024,3026,7,16,
  	0,0,3025,3019,1,0,0,0,3025,3021,1,0,0,0,3025,3022,1,0,0,0,3025,3023,1,
  	0,0,0,3026,233,1,0,0,0,3027,3028,5,267,0,0,3028,3029,5,2,0,0,3029,3030,
  	3,1378,689,0,3030,3031,5,3,0,0,3031,235,1,0,0,0,3032,3033,3,238,119,0,
  	3033,237,1,0,0,0,3034,3035,5,316,0,0,3035,3036,5,185,0,0,3036,3037,3,
  	1416,708,0,3037,3038,5,2,0,0,3038,3039,3,240,120,0,3039,3040,5,3,0,0,
  	3040,239,1,0,0,0,3041,3046,3,242,121,0,3042,3043,5,6,0,0,3043,3045,3,
  	242,121,0,3044,3042,1,0,0,0,3045,3048,1,0,0,0,3046,3044,1,0,0,0,3046,
  	3047,1,0,0,0,3047,241,1,0,0,0,3048,3046,1,0,0,0,3049,3051,3,1416,708,
  	0,3050,3052,3,608,304,0,3051,3050,1,0,0,0,3051,3052,1,0,0,0,3052,3054,
  	1,0,0,0,3053,3055,3,610,305,0,3054,3053,1,0,0,0,3054,3055,1,0,0,0,3055,
  	3073,1,0,0,0,3056,3058,3,1216,608,0,3057,3059,3,608,304,0,3058,3057,1,
  	0,0,0,3058,3059,1,0,0,0,3059,3061,1,0,0,0,3060,3062,3,610,305,0,3061,
  	3060,1,0,0,0,3061,3062,1,0,0,0,3062,3073,1,0,0,0,3063,3064,5,2,0,0,3064,
  	3065,3,1164,582,0,3065,3067,5,3,0,0,3066,3068,3,608,304,0,3067,3066,1,
  	0,0,0,3067,3068,1,0,0,0,3068,3070,1,0,0,0,3069,3071,3,610,305,0,3070,
  	3069,1,0,0,0,3070,3071,1,0,0,0,3071,3073,1,0,0,0,3072,3049,1,0,0,0,3072,
  	3056,1,0,0,0,3072,3063,1,0,0,0,3073,243,1,0,0,0,3074,3075,5,138,0,0,3075,
  	3076,3,1384,692,0,3076,245,1,0,0,0,3077,3078,5,143,0,0,3078,3082,3,112,
  	56,0,3079,3080,5,410,0,0,3080,3082,5,308,0,0,3081,3077,1,0,0,0,3081,3079,
  	1,0,0,0,3082,247,1,0,0,0,3083,3084,5,118,0,0,3084,3090,5,199,0,0,3085,
  	3091,5,229,0,0,3086,3087,5,220,0,0,3087,3091,5,351,0,0,3088,3089,5,323,
  	0,0,3089,3091,5,351,0,0,3090,3085,1,0,0,0,3090,3086,1,0,0,0,3090,3088,
  	1,0,0,0,3091,249,1,0,0,0,3092,3093,5,382,0,0,3093,3094,3,1384,692,0,3094,
  	251,1,0,0,0,3095,3096,5,138,0,0,3096,3097,5,264,0,0,3097,3098,5,382,0,
  	0,3098,3099,3,1384,692,0,3099,253,1,0,0,0,3100,3101,5,138,0,0,3101,3102,
  	5,264,0,0,3102,3103,3,1384,692,0,3103,255,1,0,0,0,3104,3105,5,84,0,0,
  	3105,3109,5,373,0,0,3106,3107,5,258,0,0,3107,3108,5,115,0,0,3108,3110,
  	5,427,0,0,3109,3106,1,0,0,0,3109,3110,1,0,0,0,3110,3111,1,0,0,0,3111,
  	3113,3,520,260,0,3112,3114,3,876,438,0,3113,3112,1,0,0,0,3113,3114,1,
  	0,0,0,3114,3115,1,0,0,0,3115,3116,5,118,0,0,3116,3117,3,1282,641,0,3117,
  	3118,5,102,0,0,3118,3119,3,1062,531,0,3119,257,1,0,0,0,3120,3121,5,176,
  	0,0,3121,3124,5,373,0,0,3122,3123,5,258,0,0,3123,3125,5,427,0,0,3124,
  	3122,1,0,0,0,3124,3125,1,0,0,0,3125,3126,1,0,0,0,3126,3127,3,520,260,
  	0,3127,3128,5,364,0,0,3128,3129,5,373,0,0,3129,3130,3,1408,704,0,3130,
  	259,1,0,0,0,3131,3133,5,84,0,0,3132,3134,3,170,85,0,3133,3132,1,0,0,0,
  	3133,3134,1,0,0,0,3134,3135,1,0,0,0,3135,3139,5,130,0,0,3136,3137,5,258,
  	0,0,3137,3138,5,115,0,0,3138,3140,5,427,0,0,3139,3136,1,0,0,0,3139,3140,
  	1,0,0,0,3140,3141,1,0,0,0,3141,3142,3,262,131,0,3142,3143,5,74,0,0,3143,
  	3145,3,966,483,0,3144,3146,3,264,132,0,3145,3144,1,0,0,0,3145,3146,1,
  	0,0,0,3146,261,1,0,0,0,3147,3149,3,1380,690,0,3148,3150,3,210,105,0,3149,
  	3148,1,0,0,0,3149,3150,1,0,0,0,3150,3152,1,0,0,0,3151,3153,3,244,122,
  	0,3152,3151,1,0,0,0,3152,3153,1,0,0,0,3153,3155,1,0,0,0,3154,3156,3,246,
  	123,0,3155,3154,1,0,0,0,3155,3156,1,0,0,0,3156,3158,1,0,0,0,3157,3159,
  	3,248,124,0,3158,3157,1,0,0,0,3158,3159,1,0,0,0,3159,3161,1,0,0,0,3160,
  	3162,3,250,125,0,3161,3160,1,0,0,0,3161,3162,1,0,0,0,3162,263,1,0,0,0,
  	3163,3167,5,143,0,0,3164,3168,5,212,0,0,3165,3166,5,300,0,0,3166,3168,
  	5,212,0,0,3167,3164,1,0,0,0,3167,3165,1,0,0,0,3168,265,1,0,0,0,3169,3171,
  	5,84,0,0,3170,3172,3,270,135,0,3171,3170,1,0,0,0,3171,3172,1,0,0,0,3172,
  	3173,1,0,0,0,3173,3174,5,289,0,0,3174,3178,5,407,0,0,3175,3176,5,258,
  	0,0,3176,3177,5,115,0,0,3177,3179,5,427,0,0,3178,3175,1,0,0,0,3178,3179,
  	1,0,0,0,3179,3180,1,0,0,0,3180,3181,3,268,134,0,3181,3182,5,74,0,0,3182,
  	3184,3,966,483,0,3183,3185,3,264,132,0,3184,3183,1,0,0,0,3184,3185,1,
  	0,0,0,3185,267,1,0,0,0,3186,3188,3,1380,690,0,3187,3189,3,210,105,0,3188,
  	3187,1,0,0,0,3188,3189,1,0,0,0,3189,3191,1,0,0,0,3190,3192,3,244,122,
  	0,3191,3190,1,0,0,0,3191,3192,1,0,0,0,3192,3194,1,0,0,0,3193,3195,3,114,
  	57,0,3194,3193,1,0,0,0,3194,3195,1,0,0,0,3195,3197,1,0,0,0,3196,3198,
  	3,250,125,0,3197,3196,1,0,0,0,3197,3198,1,0,0,0,3198,269,1,0,0,0,3199,
  	3200,5,398,0,0,3200,271,1,0,0,0,3201,3202,5,336,0,0,3202,3203,5,289,0,
  	0,3203,3205,5,407,0,0,3204,3206,3,592,296,0,3205,3204,1,0,0,0,3205,3206,
  	1,0,0,0,3206,3207,1,0,0,0,3207,3209,3,1380,690,0,3208,3210,3,264,132,
  	0,3209,3208,1,0,0,0,3209,3210,1,0,0,0,3210,273,1,0,0,0,3211,3213,5,84,
  	0,0,3212,3214,3,170,85,0,3213,3212,1,0,0,0,3213,3214,1,0,0,0,3214,3215,
  	1,0,0,0,3215,3219,5,359,0,0,3216,3217,5,258,0,0,3217,3218,5,115,0,0,3218,
  	3220,5,427,0,0,3219,3216,1,0,0,0,3219,3220,1,0,0,0,3220,3221,1,0,0,0,
  	3221,3223,3,1380,690,0,3222,3224,3,278,139,0,3223,3222,1,0,0,0,3223,3224,
  	1,0,0,0,3224,275,1,0,0,0,3225,3226,5,176,0,0,3226,3229,5,359,0,0,3227,
  	3228,5,258,0,0,3228,3230,5,427,0,0,3229,3227,1,0,0,0,3229,3230,1,0,0,
  	0,3230,3231,1,0,0,0,3231,3232,3,1380,690,0,3232,3233,3,282,141,0,3233,
  	277,1,0,0,0,3234,3235,3,282,141,0,3235,279,1,0,0,0,3236,3237,5,2,0,0,
  	3237,3238,3,282,141,0,3238,3239,5,3,0,0,3239,281,1,0,0,0,3240,3242,3,
  	284,142,0,3241,3240,1,0,0,0,3242,3243,1,0,0,0,3243,3241,1,0,0,0,3243,
  	3244,1,0,0,0,3244,283,1,0,0,0,3245,3246,5,74,0,0,3246,3280,3,1122,561,
  	0,3247,3248,5,186,0,0,3248,3280,3,288,144,0,3249,3280,5,211,0,0,3250,
  	3252,5,263,0,0,3251,3253,3,286,143,0,3252,3251,1,0,0,0,3252,3253,1,0,
  	0,0,3253,3254,1,0,0,0,3254,3280,3,288,144,0,3255,3256,5,290,0,0,3256,
  	3280,3,288,144,0,3257,3258,5,293,0,0,3258,3280,3,288,144,0,3259,3260,
  	5,300,0,0,3260,3280,7,17,0,0,3261,3262,5,312,0,0,3262,3263,5,185,0,0,
  	3263,3280,3,520,260,0,3264,3265,5,359,0,0,3265,3266,5,297,0,0,3266,3280,
  	3,520,260,0,3267,3269,5,371,0,0,3268,3270,3,12,6,0,3269,3268,1,0,0,0,
  	3269,3270,1,0,0,0,3270,3271,1,0,0,0,3271,3280,3,288,144,0,3272,3274,5,
  	345,0,0,3273,3275,3,12,6,0,3274,3273,1,0,0,0,3274,3275,1,0,0,0,3275,3277,
  	1,0,0,0,3276,3278,3,288,144,0,3277,3276,1,0,0,0,3277,3278,1,0,0,0,3278,
  	3280,1,0,0,0,3279,3245,1,0,0,0,3279,3247,1,0,0,0,3279,3249,1,0,0,0,3279,
  	3250,1,0,0,0,3279,3255,1,0,0,0,3279,3257,1,0,0,0,3279,3259,1,0,0,0,3279,
  	3261,1,0,0,0,3279,3264,1,0,0,0,3279,3267,1,0,0,0,3279,3272,1,0,0,0,3280,
  	285,1,0,0,0,3281,3282,5,185,0,0,3282,287,1,0,0,0,3283,3290,3,1398,699,
  	0,3284,3285,5,12,0,0,3285,3290,3,1398,699,0,3286,3287,5,13,0,0,3287,3290,
  	3,1398,699,0,3288,3290,3,1408,704,0,3289,3283,1,0,0,0,3289,3284,1,0,0,
  	0,3289,3286,1,0,0,0,3289,3288,1,0,0,0,3290,289,1,0,0,0,3291,3296,3,288,
  	144,0,3292,3293,5,6,0,0,3293,3295,3,288,144,0,3294,3292,1,0,0,0,3295,
  	3298,1,0,0,0,3296,3294,1,0,0,0,3296,3297,1,0,0,0,3297,291,1,0,0,0,3298,
  	3296,1,0,0,0,3299,3301,5,84,0,0,3300,3302,3,618,309,0,3301,3300,1,0,0,
  	0,3301,3302,1,0,0,0,3302,3304,1,0,0,0,3303,3305,3,294,147,0,3304,3303,
  	1,0,0,0,3304,3305,1,0,0,0,3305,3307,1,0,0,0,3306,3308,3,304,152,0,3307,
  	3306,1,0,0,0,3307,3308,1,0,0,0,3308,3309,1,0,0,0,3309,3310,5,276,0,0,
  	3310,3319,3,1384,692,0,3311,3312,5,253,0,0,3312,3314,3,296,148,0,3313,
  	3315,3,298,149,0,3314,3313,1,0,0,0,3314,3315,1,0,0,0,3315,3317,1,0,0,
  	0,3316,3318,3,302,151,0,3317,3316,1,0,0,0,3317,3318,1,0,0,0,3318,3320,
  	1,0,0,0,3319,3311,1,0,0,0,3319,3320,1,0,0,0,3320,293,1,0,0,0,3321,3322,
  	5,390,0,0,3322,295,1,0,0,0,3323,3325,3,1384,692,0,3324,3326,3,522,261,
  	0,3325,3324,1,0,0,0,3325,3326,1,0,0,0,3326,297,1,0,0,0,3327,3328,5,268,
  	0,0,3328,3329,3,296,148,0,3329,299,1,0,0,0,3330,3331,5,404,0,0,3331,3335,
  	3,296,148,0,3332,3333,5,300,0,0,3333,3335,5,404,0,0,3334,3330,1,0,0,0,
  	3334,3332,1,0,0,0,3335,301,1,0,0,0,3336,3337,3,300,150,0,3337,303,1,0,
  	0,0,3338,3339,5,326,0,0,3339,305,1,0,0,0,3340,3341,5,84,0,0,3341,3342,
  	5,382,0,0,3342,3344,3,1384,692,0,3343,3345,3,308,154,0,3344,3343,1,0,
  	0,0,3344,3345,1,0,0,0,3345,3346,1,0,0,0,3346,3347,5,284,0,0,3347,3349,
  	3,1402,701,0,3348,3350,3,114,57,0,3349,3348,1,0,0,0,3349,3350,1,0,0,0,
  	3350,307,1,0,0,0,3351,3352,5,313,0,0,3352,3353,3,1412,706,0,3353,309,
  	1,0,0,0,3354,3355,5,229,0,0,3355,3358,5,382,0,0,3356,3357,5,258,0,0,3357,
  	3359,5,427,0,0,3358,3356,1,0,0,0,3358,3359,1,0,0,0,3359,3360,1,0,0,0,
  	3360,3361,3,1384,692,0,3361,311,1,0,0,0,3362,3363,5,84,0,0,3363,3367,
  	5,242,0,0,3364,3365,5,258,0,0,3365,3366,5,115,0,0,3366,3368,5,427,0,0,
  	3367,3364,1,0,0,0,3367,3368,1,0,0,0,3368,3369,1,0,0,0,3369,3371,3,1384,
  	692,0,3370,3372,3,12,6,0,3371,3370,1,0,0,0,3371,3372,1,0,0,0,3372,3373,
  	1,0,0,0,3373,3374,3,314,157,0,3374,313,1,0,0,0,3375,3377,3,316,158,0,
  	3376,3375,1,0,0,0,3377,3380,1,0,0,0,3378,3376,1,0,0,0,3378,3379,1,0,0,
  	0,3379,315,1,0,0,0,3380,3378,1,0,0,0,3381,3382,5,354,0,0,3382,3389,3,
  	1384,692,0,3383,3384,5,406,0,0,3384,3389,3,68,34,0,3385,3386,5,102,0,
  	0,3386,3389,3,68,34,0,3387,3389,5,188,0,0,3388,3381,1,0,0,0,3388,3383,
  	1,0,0,0,3388,3385,1,0,0,0,3388,3387,1,0,0,0,3389,317,1,0,0,0,3390,3391,
  	5,176,0,0,3391,3392,5,242,0,0,3392,3393,3,1384,692,0,3393,3394,5,400,
  	0,0,3394,3395,3,320,160,0,3395,319,1,0,0,0,3396,3398,3,322,161,0,3397,
  	3396,1,0,0,0,3398,3401,1,0,0,0,3399,3397,1,0,0,0,3399,3400,1,0,0,0,3400,
  	321,1,0,0,0,3401,3399,1,0,0,0,3402,3403,5,132,0,0,3403,3404,3,68,34,0,
  	3404,323,1,0,0,0,3405,3406,5,176,0,0,3406,3407,5,242,0,0,3407,3408,3,
  	1384,692,0,3408,3409,3,36,18,0,3409,3410,3,512,256,0,3410,3411,3,1384,
  	692,0,3411,3510,1,0,0,0,3412,3413,5,176,0,0,3413,3414,5,242,0,0,3414,
  	3415,3,1384,692,0,3415,3416,3,36,18,0,3416,3417,3,510,255,0,3417,3418,
  	3,520,260,0,3418,3510,1,0,0,0,3419,3420,5,176,0,0,3420,3421,5,242,0,0,
  	3421,3422,3,1384,692,0,3422,3423,3,36,18,0,3423,3424,5,174,0,0,3424,3425,
  	3,650,325,0,3425,3510,1,0,0,0,3426,3427,5,176,0,0,3427,3428,5,242,0,0,
  	3428,3429,3,1384,692,0,3429,3430,3,36,18,0,3430,3431,5,79,0,0,3431,3432,
  	5,2,0,0,3432,3433,3,1118,559,0,3433,3434,5,74,0,0,3434,3435,3,1118,559,
  	0,3435,3436,5,3,0,0,3436,3510,1,0,0,0,3437,3438,5,176,0,0,3438,3439,5,
  	242,0,0,3439,3440,3,1384,692,0,3440,3441,3,36,18,0,3441,3442,5,227,0,
  	0,3442,3443,3,1118,559,0,3443,3510,1,0,0,0,3444,3445,5,176,0,0,3445,3446,
  	5,242,0,0,3446,3447,3,1384,692,0,3447,3448,3,36,18,0,3448,3449,5,249,
  	0,0,3449,3450,3,626,313,0,3450,3510,1,0,0,0,3451,3452,5,176,0,0,3452,
  	3453,5,242,0,0,3453,3454,3,1384,692,0,3454,3455,3,36,18,0,3455,3456,5,
  	309,0,0,3456,3457,3,688,344,0,3457,3510,1,0,0,0,3458,3459,5,176,0,0,3459,
  	3460,5,242,0,0,3460,3461,3,1384,692,0,3461,3462,3,36,18,0,3462,3463,5,
  	309,0,0,3463,3464,5,194,0,0,3464,3465,3,520,260,0,3465,3466,5,138,0,0,
  	3466,3467,3,1384,692,0,3467,3510,1,0,0,0,3468,3469,5,176,0,0,3469,3470,
  	5,242,0,0,3470,3471,3,1384,692,0,3471,3472,3,36,18,0,3472,3473,5,309,
  	0,0,3473,3474,5,244,0,0,3474,3475,3,520,260,0,3475,3476,5,138,0,0,3476,
  	3477,3,1384,692,0,3477,3510,1,0,0,0,3478,3479,5,176,0,0,3479,3480,5,242,
  	0,0,3480,3481,3,1384,692,0,3481,3482,3,36,18,0,3482,3483,5,327,0,0,3483,
  	3484,3,626,313,0,3484,3510,1,0,0,0,3485,3486,5,176,0,0,3486,3487,5,242,
  	0,0,3487,3488,3,1384,692,0,3488,3489,3,36,18,0,3489,3490,5,480,0,0,3490,
  	3491,3,626,313,0,3491,3510,1,0,0,0,3492,3493,5,176,0,0,3493,3494,5,242,
  	0,0,3494,3495,3,1384,692,0,3495,3496,3,36,18,0,3496,3497,5,481,0,0,3497,
  	3498,5,100,0,0,3498,3499,3,1118,559,0,3499,3500,5,276,0,0,3500,3501,3,
  	1384,692,0,3501,3510,1,0,0,0,3502,3503,5,176,0,0,3503,3504,5,242,0,0,
  	3504,3505,3,1384,692,0,3505,3506,3,36,18,0,3506,3507,5,391,0,0,3507,3508,
  	3,1118,559,0,3508,3510,1,0,0,0,3509,3405,1,0,0,0,3509,3412,1,0,0,0,3509,
  	3419,1,0,0,0,3509,3426,1,0,0,0,3509,3437,1,0,0,0,3509,3444,1,0,0,0,3509,
  	3451,1,0,0,0,3509,3458,1,0,0,0,3509,3468,1,0,0,0,3509,3478,1,0,0,0,3509,
  	3485,1,0,0,0,3509,3492,1,0,0,0,3509,3502,1,0,0,0,3510,325,1,0,0,0,3511,
  	3512,5,84,0,0,3512,3513,5,101,0,0,3513,3514,5,212,0,0,3514,3515,5,412,
  	0,0,3515,3517,3,1384,692,0,3516,3518,3,332,166,0,3517,3516,1,0,0,0,3517,
  	3518,1,0,0,0,3518,3520,1,0,0,0,3519,3521,3,336,168,0,3520,3519,1,0,0,
  	0,3520,3521,1,0,0,0,3521,327,1,0,0,0,3522,3523,5,253,0,0,3523,3531,3,
  	296,148,0,3524,3525,5,300,0,0,3525,3531,5,253,0,0,3526,3527,5,404,0,0,
  	3527,3531,3,296,148,0,3528,3529,5,300,0,0,3529,3531,5,404,0,0,3530,3522,
  	1,0,0,0,3530,3524,1,0,0,0,3530,3526,1,0,0,0,3530,3528,1,0,0,0,3531,329,
  	1,0,0,0,3532,3534,3,328,164,0,3533,3532,1,0,0,0,3534,3535,1,0,0,0,3535,
  	3533,1,0,0,0,3535,3536,1,0,0,0,3536,331,1,0,0,0,3537,3538,3,330,165,0,
  	3538,333,1,0,0,0,3539,3540,5,176,0,0,3540,3541,5,101,0,0,3541,3542,5,
  	212,0,0,3542,3543,5,412,0,0,3543,3545,3,1384,692,0,3544,3546,3,332,166,
  	0,3545,3544,1,0,0,0,3545,3546,1,0,0,0,3546,3547,1,0,0,0,3547,3548,3,340,
  	170,0,3548,3557,1,0,0,0,3549,3550,5,176,0,0,3550,3551,5,101,0,0,3551,
  	3552,5,212,0,0,3552,3553,5,412,0,0,3553,3554,3,1384,692,0,3554,3555,3,
  	330,165,0,3555,3557,1,0,0,0,3556,3539,1,0,0,0,3556,3549,1,0,0,0,3557,
  	335,1,0,0,0,3558,3559,5,311,0,0,3559,3560,5,2,0,0,3560,3561,3,338,169,
  	0,3561,3562,5,3,0,0,3562,337,1,0,0,0,3563,3568,3,346,173,0,3564,3565,
  	5,6,0,0,3565,3567,3,346,173,0,3566,3564,1,0,0,0,3567,3570,1,0,0,0,3568,
  	3566,1,0,0,0,3568,3569,1,0,0,0,3569,339,1,0,0,0,3570,3568,1,0,0,0,3571,
  	3572,5,311,0,0,3572,3573,5,2,0,0,3573,3574,3,342,171,0,3574,3575,5,3,
  	0,0,3575,341,1,0,0,0,3576,3581,3,344,172,0,3577,3578,5,6,0,0,3578,3580,
  	3,344,172,0,3579,3577,1,0,0,0,3580,3583,1,0,0,0,3581,3579,1,0,0,0,3581,
  	3582,1,0,0,0,3582,343,1,0,0,0,3583,3581,1,0,0,0,3584,3592,3,346,173,0,
  	3585,3586,5,364,0,0,3586,3592,3,346,173,0,3587,3588,5,171,0,0,3588,3592,
  	3,346,173,0,3589,3590,5,229,0,0,3590,3592,3,348,174,0,3591,3584,1,0,0,
  	0,3591,3585,1,0,0,0,3591,3587,1,0,0,0,3591,3589,1,0,0,0,3592,345,1,0,
  	0,0,3593,3594,3,348,174,0,3594,3595,3,350,175,0,3595,347,1,0,0,0,3596,
  	3597,3,1422,711,0,3597,349,1,0,0,0,3598,3599,3,1402,701,0,3599,351,1,
  	0,0,0,3600,3601,5,84,0,0,3601,3602,5,362,0,0,3602,3604,3,1384,692,0,3603,
  	3605,3,354,177,0,3604,3603,1,0,0,0,3604,3605,1,0,0,0,3605,3607,1,0,0,
  	0,3606,3608,3,358,179,0,3607,3606,1,0,0,0,3607,3608,1,0,0,0,3608,3609,
  	1,0,0,0,3609,3610,5,101,0,0,3610,3611,5,212,0,0,3611,3612,5,412,0,0,3612,
  	3614,3,1384,692,0,3613,3615,3,336,168,0,3614,3613,1,0,0,0,3614,3615,1,
  	0,0,0,3615,3636,1,0,0,0,3616,3617,5,84,0,0,3617,3618,5,362,0,0,3618,3619,
  	5,258,0,0,3619,3620,5,115,0,0,3620,3621,5,427,0,0,3621,3623,3,1384,692,
  	0,3622,3624,3,354,177,0,3623,3622,1,0,0,0,3623,3624,1,0,0,0,3624,3626,
  	1,0,0,0,3625,3627,3,358,179,0,3626,3625,1,0,0,0,3626,3627,1,0,0,0,3627,
  	3628,1,0,0,0,3628,3629,5,101,0,0,3629,3630,5,212,0,0,3630,3631,5,412,
  	0,0,3631,3633,3,1384,692,0,3632,3634,3,336,168,0,3633,3632,1,0,0,0,3633,
  	3634,1,0,0,0,3634,3636,1,0,0,0,3635,3600,1,0,0,0,3635,3616,1,0,0,0,3636,
  	353,1,0,0,0,3637,3638,5,391,0,0,3638,3639,3,1402,701,0,3639,355,1,0,0,
  	0,3640,3643,5,406,0,0,3641,3644,3,1402,701,0,3642,3644,5,116,0,0,3643,
  	3641,1,0,0,0,3643,3642,1,0,0,0,3644,357,1,0,0,0,3645,3646,3,356,178,0,
  	3646,359,1,0,0,0,3647,3648,5,176,0,0,3648,3649,5,362,0,0,3649,3655,3,
  	1384,692,0,3650,3656,3,340,170,0,3651,3653,3,356,178,0,3652,3654,3,340,
  	170,0,3653,3652,1,0,0,0,3653,3654,1,0,0,0,3654,3656,1,0,0,0,3655,3650,
  	1,0,0,0,3655,3651,1,0,0,0,3656,361,1,0,0,0,3657,3658,5,84,0,0,3658,3659,
  	5,101,0,0,3659,3660,5,130,0,0,3660,3661,3,1380,690,0,3661,3663,5,2,0,
  	0,3662,3664,3,172,86,0,3663,3662,1,0,0,0,3663,3664,1,0,0,0,3664,3665,
  	1,0,0,0,3665,3667,5,3,0,0,3666,3668,3,234,117,0,3667,3666,1,0,0,0,3667,
  	3668,1,0,0,0,3668,3669,1,0,0,0,3669,3670,5,362,0,0,3670,3672,3,1384,692,
  	0,3671,3673,3,336,168,0,3672,3671,1,0,0,0,3672,3673,1,0,0,0,3673,3730,
  	1,0,0,0,3674,3675,5,84,0,0,3675,3676,5,101,0,0,3676,3677,5,130,0,0,3677,
  	3678,5,258,0,0,3678,3679,5,115,0,0,3679,3680,5,427,0,0,3680,3681,3,1380,
  	690,0,3681,3683,5,2,0,0,3682,3684,3,172,86,0,3683,3682,1,0,0,0,3683,3684,
  	1,0,0,0,3684,3685,1,0,0,0,3685,3687,5,3,0,0,3686,3688,3,234,117,0,3687,
  	3686,1,0,0,0,3687,3688,1,0,0,0,3688,3689,1,0,0,0,3689,3690,5,362,0,0,
  	3690,3692,3,1384,692,0,3691,3693,3,336,168,0,3692,3691,1,0,0,0,3692,3693,
  	1,0,0,0,3693,3730,1,0,0,0,3694,3695,5,84,0,0,3695,3696,5,101,0,0,3696,
  	3697,5,130,0,0,3697,3698,3,1380,690,0,3698,3699,5,316,0,0,3699,3700,5,
  	306,0,0,3700,3702,3,1380,690,0,3701,3703,3,174,87,0,3702,3701,1,0,0,0,
  	3702,3703,1,0,0,0,3703,3704,1,0,0,0,3704,3705,3,124,62,0,3705,3706,5,
  	362,0,0,3706,3708,3,1384,692,0,3707,3709,3,336,168,0,3708,3707,1,0,0,
  	0,3708,3709,1,0,0,0,3709,3730,1,0,0,0,3710,3711,5,84,0,0,3711,3712,5,
  	101,0,0,3712,3713,5,130,0,0,3713,3714,5,258,0,0,3714,3715,5,115,0,0,3715,
  	3716,5,427,0,0,3716,3717,3,1380,690,0,3717,3718,5,316,0,0,3718,3719,5,
  	306,0,0,3719,3721,3,1380,690,0,3720,3722,3,174,87,0,3721,3720,1,0,0,0,
  	3721,3722,1,0,0,0,3722,3723,1,0,0,0,3723,3724,3,124,62,0,3724,3725,5,
  	362,0,0,3725,3727,3,1384,692,0,3726,3728,3,336,168,0,3727,3726,1,0,0,
  	0,3727,3728,1,0,0,0,3728,3730,1,0,0,0,3729,3657,1,0,0,0,3729,3674,1,0,
  	0,0,3729,3694,1,0,0,0,3729,3710,1,0,0,0,3730,363,1,0,0,0,3731,3732,5,
  	482,0,0,3732,3733,5,101,0,0,3733,3734,5,354,0,0,3734,3736,3,1384,692,
  	0,3735,3737,3,368,184,0,3736,3735,1,0,0,0,3736,3737,1,0,0,0,3737,3738,
  	1,0,0,0,3738,3739,5,102,0,0,3739,3740,5,362,0,0,3740,3741,3,1384,692,
  	0,3741,3742,5,109,0,0,3742,3744,3,1384,692,0,3743,3745,3,336,168,0,3744,
  	3743,1,0,0,0,3744,3745,1,0,0,0,3745,365,1,0,0,0,3746,3747,5,112,0,0,3747,
  	3750,5,132,0,0,3748,3750,5,97,0,0,3749,3746,1,0,0,0,3749,3748,1,0,0,0,
  	3750,367,1,0,0,0,3751,3752,3,366,183,0,3752,3753,5,2,0,0,3753,3754,3,
  	1076,538,0,3754,3755,5,3,0,0,3755,369,1,0,0,0,3756,3757,5,84,0,0,3757,
  	3758,5,137,0,0,3758,3759,5,286,0,0,3759,3760,5,100,0,0,3760,3761,3,372,
  	186,0,3761,3762,5,362,0,0,3762,3764,3,1384,692,0,3763,3765,3,336,168,
  	0,3764,3763,1,0,0,0,3764,3765,1,0,0,0,3765,3780,1,0,0,0,3766,3767,5,84,
  	0,0,3767,3768,5,137,0,0,3768,3769,5,286,0,0,3769,3770,5,258,0,0,3770,
  	3771,5,115,0,0,3771,3772,5,427,0,0,3772,3773,5,100,0,0,3773,3774,3,372,
  	186,0,3774,3775,5,362,0,0,3775,3777,3,1384,692,0,3776,3778,3,336,168,
  	0,3777,3776,1,0,0,0,3777,3778,1,0,0,0,3778,3780,1,0,0,0,3779,3756,1,0,
  	0,0,3779,3766,1,0,0,0,3780,371,1,0,0,0,3781,3784,3,1412,706,0,3782,3784,
  	5,137,0,0,3783,3781,1,0,0,0,3783,3782,1,0,0,0,3784,373,1,0,0,0,3785,3786,
  	5,229,0,0,3786,3787,5,137,0,0,3787,3788,5,286,0,0,3788,3789,5,100,0,0,
  	3789,3790,3,372,186,0,3790,3791,5,362,0,0,3791,3792,3,1384,692,0,3792,
  	3804,1,0,0,0,3793,3794,5,229,0,0,3794,3795,5,137,0,0,3795,3796,5,286,
  	0,0,3796,3797,5,258,0,0,3797,3798,5,427,0,0,3798,3799,5,100,0,0,3799,
  	3800,3,372,186,0,3800,3801,5,362,0,0,3801,3802,3,1384,692,0,3802,3804,
  	1,0,0,0,3803,3785,1,0,0,0,3803,3793,1,0,0,0,3804,375,1,0,0,0,3805,3806,
  	5,176,0,0,3806,3807,5,137,0,0,3807,3808,5,286,0,0,3808,3809,5,100,0,0,
  	3809,3810,3,372,186,0,3810,3811,5,362,0,0,3811,3812,3,1384,692,0,3812,
  	3813,3,340,170,0,3813,377,1,0,0,0,3814,3815,5,84,0,0,3815,3816,5,483,
  	0,0,3816,3817,3,1384,692,0,3817,3818,5,118,0,0,3818,3820,3,1380,690,0,
  	3819,3821,3,390,195,0,3820,3819,1,0,0,0,3820,3821,1,0,0,0,3821,3823,1,
  	0,0,0,3822,3824,3,392,196,0,3823,3822,1,0,0,0,3823,3824,1,0,0,0,3824,
  	3826,1,0,0,0,3825,3827,3,386,193,0,3826,3825,1,0,0,0,3826,3827,1,0,0,
  	0,3827,3829,1,0,0,0,3828,3830,3,382,191,0,3829,3828,1,0,0,0,3829,3830,
  	1,0,0,0,3830,3832,1,0,0,0,3831,3833,3,384,192,0,3832,3831,1,0,0,0,3832,
  	3833,1,0,0,0,3833,379,1,0,0,0,3834,3835,5,176,0,0,3835,3836,5,483,0,0,
  	3836,3837,3,1384,692,0,3837,3838,5,118,0,0,3838,3840,3,1380,690,0,3839,
  	3841,3,388,194,0,3840,3839,1,0,0,0,3840,3841,1,0,0,0,3841,3843,1,0,0,
  	0,3842,3844,3,382,191,0,3843,3842,1,0,0,0,3843,3844,1,0,0,0,3844,3846,
  	1,0,0,0,3845,3847,3,384,192,0,3846,3845,1,0,0,0,3846,3847,1,0,0,0,3847,
  	381,1,0,0,0,3848,3849,5,138,0,0,3849,3850,5,2,0,0,3850,3851,3,1164,582,
  	0,3851,3852,5,3,0,0,3852,383,1,0,0,0,3853,3854,5,143,0,0,3854,3855,5,
  	80,0,0,3855,3856,5,2,0,0,3856,3857,3,1164,582,0,3857,3858,5,3,0,0,3858,
  	385,1,0,0,0,3859,3860,5,132,0,0,3860,3861,3,1414,707,0,3861,387,1,0,0,
  	0,3862,3863,5,132,0,0,3863,3864,3,1414,707,0,3864,389,1,0,0,0,3865,3866,
  	5,74,0,0,3866,3867,3,1438,719,0,3867,391,1,0,0,0,3868,3869,5,100,0,0,
  	3869,3870,3,394,197,0,3870,393,1,0,0,0,3871,3872,7,18,0,0,3872,395,1,
  	0,0,0,3873,3874,5,84,0,0,3874,3875,5,169,0,0,3875,3876,5,484,0,0,3876,
  	3877,3,1384,692,0,3877,3878,5,391,0,0,3878,3879,3,398,199,0,3879,3880,
  	5,253,0,0,3880,3881,3,296,148,0,3881,397,1,0,0,0,3882,3883,7,19,0,0,3883,
  	399,1,0,0,0,3884,3885,5,84,0,0,3885,3886,5,388,0,0,3886,3887,3,1384,692,
  	0,3887,3888,3,402,201,0,3888,3889,3,404,202,0,3889,3890,5,118,0,0,3890,
  	3892,3,1380,690,0,3891,3893,3,408,204,0,3892,3891,1,0,0,0,3892,3893,1,
  	0,0,0,3893,3895,1,0,0,0,3894,3896,3,420,210,0,3895,3894,1,0,0,0,3895,
  	3896,1,0,0,0,3896,3898,1,0,0,0,3897,3899,3,426,213,0,3898,3897,1,0,0,
  	0,3898,3899,1,0,0,0,3899,3900,1,0,0,0,3900,3901,5,240,0,0,3901,3902,3,
  	428,214,0,3902,3903,3,1390,695,0,3903,3904,5,2,0,0,3904,3905,3,430,215,
  	0,3905,3906,5,3,0,0,3906,3933,1,0,0,0,3907,3908,5,84,0,0,3908,3909,5,
  	83,0,0,3909,3910,5,388,0,0,3910,3911,3,1384,692,0,3911,3912,5,173,0,0,
  	3912,3913,3,404,202,0,3913,3914,5,118,0,0,3914,3916,3,1380,690,0,3915,
  	3917,3,434,217,0,3916,3915,1,0,0,0,3916,3917,1,0,0,0,3917,3918,1,0,0,
  	0,3918,3919,3,436,218,0,3919,3920,5,100,0,0,3920,3921,5,230,0,0,3921,
  	3923,5,445,0,0,3922,3924,3,426,213,0,3923,3922,1,0,0,0,3923,3924,1,0,
  	0,0,3924,3925,1,0,0,0,3925,3926,5,240,0,0,3926,3927,3,428,214,0,3927,
  	3928,3,1390,695,0,3928,3929,5,2,0,0,3929,3930,3,430,215,0,3930,3931,5,
  	3,0,0,3931,3933,1,0,0,0,3932,3884,1,0,0,0,3932,3907,1,0,0,0,3933,401,
  	1,0,0,0,3934,3939,5,183,0,0,3935,3939,5,173,0,0,3936,3937,5,271,0,0,3937,
  	3939,5,306,0,0,3938,3934,1,0,0,0,3938,3935,1,0,0,0,3938,3936,1,0,0,0,
  	3939,403,1,0,0,0,3940,3945,3,406,203,0,3941,3942,5,120,0,0,3942,3944,
  	3,406,203,0,3943,3941,1,0,0,0,3944,3947,1,0,0,0,3945,3943,1,0,0,0,3945,
  	3946,1,0,0,0,3946,405,1,0,0,0,3947,3945,1,0,0,0,3948,3956,5,270,0,0,3949,
  	3956,5,220,0,0,3950,3956,5,400,0,0,3951,3952,5,400,0,0,3952,3953,5,306,
  	0,0,3953,3956,3,212,106,0,3954,3956,5,389,0,0,3955,3948,1,0,0,0,3955,
  	3949,1,0,0,0,3955,3950,1,0,0,0,3955,3951,1,0,0,0,3955,3954,1,0,0,0,3956,
  	407,1,0,0,0,3957,3958,5,485,0,0,3958,3959,3,410,205,0,3959,409,1,0,0,
  	0,3960,3962,3,412,206,0,3961,3960,1,0,0,0,3962,3963,1,0,0,0,3963,3961,
  	1,0,0,0,3963,3964,1,0,0,0,3964,411,1,0,0,0,3965,3966,3,414,207,0,3966,
  	3968,3,416,208,0,3967,3969,3,832,416,0,3968,3967,1,0,0,0,3968,3969,1,
  	0,0,0,3969,3970,1,0,0,0,3970,3971,3,418,209,0,3971,413,1,0,0,0,3972,3973,
  	7,20,0,0,3973,415,1,0,0,0,3974,3975,7,21,0,0,3975,417,1,0,0,0,3976,3977,
  	3,1416,708,0,3977,419,1,0,0,0,3978,3980,5,100,0,0,3979,3981,3,422,211,
  	0,3980,3979,1,0,0,0,3980,3981,1,0,0,0,3981,3982,1,0,0,0,3982,3983,3,424,
  	212,0,3983,421,1,0,0,0,3984,3985,5,230,0,0,3985,423,1,0,0,0,3986,3987,
  	7,22,0,0,3987,425,1,0,0,0,3988,3989,5,140,0,0,3989,3990,5,2,0,0,3990,
  	3991,3,1164,582,0,3991,3992,5,3,0,0,3992,427,1,0,0,0,3993,3994,7,23,0,
  	0,3994,429,1,0,0,0,3995,3998,3,432,216,0,3996,3998,1,0,0,0,3997,3995,
  	1,0,0,0,3997,3996,1,0,0,0,3998,4003,1,0,0,0,3999,4000,5,6,0,0,4000,4002,
  	3,432,216,0,4001,3999,1,0,0,0,4002,4005,1,0,0,0,4003,4001,1,0,0,0,4003,
  	4004,1,0,0,0,4004,431,1,0,0,0,4005,4003,1,0,0,0,4006,4011,3,1400,700,
  	0,4007,4011,3,1398,699,0,4008,4011,3,1402,701,0,4009,4011,3,1422,711,
  	0,4010,4006,1,0,0,0,4010,4007,1,0,0,0,4010,4008,1,0,0,0,4010,4009,1,0,
  	0,0,4011,433,1,0,0,0,4012,4013,5,102,0,0,4013,4014,3,1380,690,0,4014,
  	435,1,0,0,0,4015,4017,3,438,219,0,4016,4015,1,0,0,0,4017,4020,1,0,0,0,
  	4018,4016,1,0,0,0,4018,4019,1,0,0,0,4019,437,1,0,0,0,4020,4018,1,0,0,
  	0,4021,4022,5,115,0,0,4022,4033,5,92,0,0,4023,4033,5,92,0,0,4024,4025,
  	5,107,0,0,4025,4033,5,259,0,0,4026,4027,5,107,0,0,4027,4033,5,218,0,0,
  	4028,4029,5,115,0,0,4029,4033,5,402,0,0,4030,4031,5,300,0,0,4031,4033,
  	5,266,0,0,4032,4021,1,0,0,0,4032,4023,1,0,0,0,4032,4024,1,0,0,0,4032,
  	4026,1,0,0,0,4032,4028,1,0,0,0,4032,4030,1,0,0,0,4033,439,1,0,0,0,4034,
  	4035,5,84,0,0,4035,4036,5,236,0,0,4036,4037,5,388,0,0,4037,4038,3,1384,
  	692,0,4038,4039,5,118,0,0,4039,4040,3,1422,711,0,4040,4041,5,240,0,0,
  	4041,4042,3,428,214,0,4042,4043,3,1390,695,0,4043,4044,5,2,0,0,4044,4045,
  	5,3,0,0,4045,4061,1,0,0,0,4046,4047,5,84,0,0,4047,4048,5,236,0,0,4048,
  	4049,5,388,0,0,4049,4050,3,1384,692,0,4050,4051,5,118,0,0,4051,4052,3,
  	1422,711,0,4052,4053,5,140,0,0,4053,4054,3,442,221,0,4054,4055,5,240,
  	0,0,4055,4056,3,428,214,0,4056,4057,3,1390,695,0,4057,4058,5,2,0,0,4058,
  	4059,5,3,0,0,4059,4061,1,0,0,0,4060,4034,1,0,0,0,4060,4046,1,0,0,0,4061,
  	441,1,0,0,0,4062,4067,3,444,222,0,4063,4064,5,71,0,0,4064,4066,3,444,
  	222,0,4065,4063,1,0,0,0,4066,4069,1,0,0,0,4067,4065,1,0,0,0,4067,4068,
  	1,0,0,0,4068,443,1,0,0,0,4069,4067,1,0,0,0,4070,4071,3,1416,708,0,4071,
  	4072,5,106,0,0,4072,4073,5,2,0,0,4073,4074,3,446,223,0,4074,4075,5,3,
  	0,0,4075,445,1,0,0,0,4076,4081,3,1402,701,0,4077,4078,5,6,0,0,4078,4080,
  	3,1402,701,0,4079,4077,1,0,0,0,4080,4083,1,0,0,0,4081,4079,1,0,0,0,4081,
  	4082,1,0,0,0,4082,447,1,0,0,0,4083,4081,1,0,0,0,4084,4085,5,176,0,0,4085,
  	4086,5,236,0,0,4086,4087,5,388,0,0,4087,4088,3,1384,692,0,4088,4089,3,
  	450,225,0,4089,449,1,0,0,0,4090,4097,5,231,0,0,4091,4092,5,231,0,0,4092,
  	4097,5,343,0,0,4093,4094,5,231,0,0,4094,4097,5,177,0,0,4095,4097,5,224,
  	0,0,4096,4090,1,0,0,0,4096,4091,1,0,0,0,4096,4093,1,0,0,0,4096,4095,1,
  	0,0,0,4097,451,1,0,0,0,4098,4099,5,84,0,0,4099,4100,5,178,0,0,4100,4101,
  	3,520,260,0,4101,4102,5,80,0,0,4102,4103,5,2,0,0,4103,4104,3,1164,582,
  	0,4104,4105,5,3,0,0,4105,4106,3,436,218,0,4106,453,1,0,0,0,4107,4109,
  	5,84,0,0,4108,4110,3,618,309,0,4109,4108,1,0,0,0,4109,4110,1,0,0,0,4110,
  	4111,1,0,0,0,4111,4112,5,174,0,0,4112,4113,3,1390,695,0,4113,4114,3,646,
  	323,0,4114,4115,3,456,228,0,4115,4222,1,0,0,0,4116,4118,5,84,0,0,4117,
  	4119,3,618,309,0,4118,4117,1,0,0,0,4118,4119,1,0,0,0,4119,4120,1,0,0,
  	0,4120,4121,5,174,0,0,4121,4122,3,1390,695,0,4122,4123,3,464,232,0,4123,
  	4222,1,0,0,0,4124,4125,5,84,0,0,4125,4126,5,309,0,0,4126,4127,3,684,342,
  	0,4127,4128,3,456,228,0,4128,4222,1,0,0,0,4129,4130,5,84,0,0,4130,4131,
  	5,391,0,0,4131,4132,3,520,260,0,4132,4133,3,456,228,0,4133,4222,1,0,0,
  	0,4134,4135,5,84,0,0,4135,4136,5,391,0,0,4136,4222,3,520,260,0,4137,4138,
  	5,84,0,0,4138,4139,5,391,0,0,4139,4140,3,520,260,0,4140,4141,5,74,0,0,
  	4141,4143,5,2,0,0,4142,4144,3,1098,549,0,4143,4142,1,0,0,0,4143,4144,
  	1,0,0,0,4144,4145,1,0,0,0,4145,4146,5,3,0,0,4146,4222,1,0,0,0,4147,4148,
  	5,84,0,0,4148,4149,5,391,0,0,4149,4150,3,520,260,0,4150,4151,5,74,0,0,
  	4151,4152,5,234,0,0,4152,4154,5,2,0,0,4153,4155,3,470,235,0,4154,4153,
  	1,0,0,0,4154,4155,1,0,0,0,4155,4156,1,0,0,0,4156,4157,5,3,0,0,4157,4222,
  	1,0,0,0,4158,4159,5,84,0,0,4159,4160,5,391,0,0,4160,4161,3,520,260,0,
  	4161,4162,5,74,0,0,4162,4163,5,330,0,0,4163,4164,3,456,228,0,4164,4222,
  	1,0,0,0,4165,4166,5,84,0,0,4166,4167,5,386,0,0,4167,4168,5,356,0,0,4168,
  	4169,5,314,0,0,4169,4170,3,520,260,0,4170,4171,3,456,228,0,4171,4222,
  	1,0,0,0,4172,4173,5,84,0,0,4173,4174,5,386,0,0,4174,4175,5,356,0,0,4175,
  	4176,5,223,0,0,4176,4177,3,520,260,0,4177,4178,3,456,228,0,4178,4222,
  	1,0,0,0,4179,4180,5,84,0,0,4180,4181,5,386,0,0,4181,4182,5,356,0,0,4182,
  	4183,5,384,0,0,4183,4184,3,520,260,0,4184,4185,3,456,228,0,4185,4222,
  	1,0,0,0,4186,4187,5,84,0,0,4187,4188,5,386,0,0,4188,4189,5,356,0,0,4189,
  	4190,5,201,0,0,4190,4191,3,520,260,0,4191,4192,3,456,228,0,4192,4222,
  	1,0,0,0,4193,4194,5,84,0,0,4194,4195,5,146,0,0,4195,4196,3,520,260,0,
  	4196,4197,3,456,228,0,4197,4222,1,0,0,0,4198,4199,5,84,0,0,4199,4200,
  	5,146,0,0,4200,4201,5,258,0,0,4201,4202,5,115,0,0,4202,4203,5,427,0,0,
  	4203,4204,3,520,260,0,4204,4205,3,456,228,0,4205,4222,1,0,0,0,4206,4207,
  	5,84,0,0,4207,4208,5,146,0,0,4208,4209,3,520,260,0,4209,4210,5,102,0,
  	0,4210,4211,3,520,260,0,4211,4222,1,0,0,0,4212,4213,5,84,0,0,4213,4214,
  	5,146,0,0,4214,4215,5,258,0,0,4215,4216,5,115,0,0,4216,4217,5,427,0,0,
  	4217,4218,3,520,260,0,4218,4219,5,102,0,0,4219,4220,3,520,260,0,4220,
  	4222,1,0,0,0,4221,4107,1,0,0,0,4221,4116,1,0,0,0,4221,4124,1,0,0,0,4221,
  	4129,1,0,0,0,4221,4134,1,0,0,0,4221,4137,1,0,0,0,4221,4147,1,0,0,0,4221,
  	4158,1,0,0,0,4221,4165,1,0,0,0,4221,4172,1,0,0,0,4221,4179,1,0,0,0,4221,
  	4186,1,0,0,0,4221,4193,1,0,0,0,4221,4198,1,0,0,0,4221,4206,1,0,0,0,4221,
  	4212,1,0,0,0,4222,455,1,0,0,0,4223,4224,5,2,0,0,4224,4225,3,458,229,0,
  	4225,4226,5,3,0,0,4226,457,1,0,0,0,4227,4232,3,460,230,0,4228,4229,5,
  	6,0,0,4229,4231,3,460,230,0,4230,4228,1,0,0,0,4231,4234,1,0,0,0,4232,
  	4230,1,0,0,0,4232,4233,1,0,0,0,4233,459,1,0,0,0,4234,4232,1,0,0,0,4235,
  	4238,3,1422,711,0,4236,4237,5,10,0,0,4237,4239,3,462,231,0,4238,4236,
  	1,0,0,0,4238,4239,1,0,0,0,4239,461,1,0,0,0,4240,4247,3,640,320,0,4241,
  	4247,3,1432,716,0,4242,4247,3,1278,639,0,4243,4247,3,288,144,0,4244,4247,
  	3,1402,701,0,4245,4247,5,438,0,0,4246,4240,1,0,0,0,4246,4241,1,0,0,0,
  	4246,4242,1,0,0,0,4246,4243,1,0,0,0,4246,4244,1,0,0,0,4246,4245,1,0,0,
  	0,4247,463,1,0,0,0,4248,4249,5,2,0,0,4249,4250,3,466,233,0,4250,4251,
  	5,3,0,0,4251,465,1,0,0,0,4252,4257,3,468,234,0,4253,4254,5,6,0,0,4254,
  	4256,3,468,234,0,4255,4253,1,0,0,0,4256,4259,1,0,0,0,4257,4255,1,0,0,
  	0,4257,4258,1,0,0,0,4258,467,1,0,0,0,4259,4257,1,0,0,0,4260,4261,3,1438,
  	719,0,4261,4262,5,10,0,0,4262,4263,3,462,231,0,4263,469,1,0,0,0,4264,
  	4265,3,472,236,0,4265,471,1,0,0,0,4266,4271,3,1402,701,0,4267,4268,5,
  	6,0,0,4268,4270,3,1402,701,0,4269,4267,1,0,0,0,4270,4273,1,0,0,0,4271,
  	4269,1,0,0,0,4271,4272,1,0,0,0,4272,473,1,0,0,0,4273,4271,1,0,0,0,4274,
  	4275,5,176,0,0,4275,4276,5,391,0,0,4276,4277,3,520,260,0,4277,4278,5,
  	171,0,0,4278,4280,5,488,0,0,4279,4281,3,476,238,0,4280,4279,1,0,0,0,4280,
  	4281,1,0,0,0,4281,4282,1,0,0,0,4282,4283,3,1402,701,0,4283,4318,1,0,0,
  	0,4284,4285,5,176,0,0,4285,4286,5,391,0,0,4286,4287,3,520,260,0,4287,
  	4288,5,171,0,0,4288,4290,5,488,0,0,4289,4291,3,476,238,0,4290,4289,1,
  	0,0,0,4290,4291,1,0,0,0,4291,4292,1,0,0,0,4292,4293,3,1402,701,0,4293,
  	4294,5,183,0,0,4294,4295,3,1402,701,0,4295,4318,1,0,0,0,4296,4297,5,176,
  	0,0,4297,4298,5,391,0,0,4298,4299,3,520,260,0,4299,4300,5,171,0,0,4300,
  	4302,5,488,0,0,4301,4303,3,476,238,0,4302,4301,1,0,0,0,4302,4303,1,0,
  	0,0,4303,4304,1,0,0,0,4304,4305,3,1402,701,0,4305,4306,5,173,0,0,4306,
  	4307,3,1402,701,0,4307,4318,1,0,0,0,4308,4309,5,176,0,0,4309,4310,5,391,
  	0,0,4310,4311,3,520,260,0,4311,4312,5,340,0,0,4312,4313,5,488,0,0,4313,
  	4314,3,1402,701,0,4314,4315,5,132,0,0,4315,4316,3,1402,701,0,4316,4318,
  	1,0,0,0,4317,4274,1,0,0,0,4317,4284,1,0,0,0,4317,4296,1,0,0,0,4317,4308,
  	1,0,0,0,4318,475,1,0,0,0,4319,4320,5,258,0,0,4320,4321,5,115,0,0,4321,
  	4322,5,427,0,0,4322,477,1,0,0,0,4323,4324,5,84,0,0,4324,4325,5,309,0,
  	0,4325,4326,5,194,0,0,4326,4328,3,520,260,0,4327,4329,3,484,242,0,4328,
  	4327,1,0,0,0,4328,4329,1,0,0,0,4329,4330,1,0,0,0,4330,4331,5,100,0,0,
  	4331,4332,5,391,0,0,4332,4333,3,1118,559,0,4333,4334,5,138,0,0,4334,4336,
  	3,1384,692,0,4335,4337,3,486,243,0,4336,4335,1,0,0,0,4336,4337,1,0,0,
  	0,4337,4338,1,0,0,0,4338,4339,5,74,0,0,4339,4340,3,480,240,0,4340,479,
  	1,0,0,0,4341,4346,3,482,241,0,4342,4343,5,6,0,0,4343,4345,3,482,241,0,
  	4344,4342,1,0,0,0,4345,4348,1,0,0,0,4346,4344,1,0,0,0,4346,4347,1,0,0,
  	0,4347,481,1,0,0,0,4348,4346,1,0,0,0,4349,4350,5,309,0,0,4350,4351,3,
  	1400,700,0,4351,4353,3,684,342,0,4352,4354,3,488,244,0,4353,4352,1,0,
  	0,0,4353,4354,1,0,0,0,4354,4356,1,0,0,0,4355,4357,3,490,245,0,4356,4355,
  	1,0,0,0,4356,4357,1,0,0,0,4357,4381,1,0,0,0,4358,4359,5,309,0,0,4359,
  	4360,3,1400,700,0,4360,4362,3,688,344,0,4361,4363,3,488,244,0,4362,4361,
  	1,0,0,0,4362,4363,1,0,0,0,4363,4365,1,0,0,0,4364,4366,3,490,245,0,4365,
  	4364,1,0,0,0,4365,4366,1,0,0,0,4366,4381,1,0,0,0,4367,4368,5,249,0,0,
  	4368,4369,3,1400,700,0,4369,4370,3,626,313,0,4370,4381,1,0,0,0,4371,4372,
  	5,249,0,0,4372,4373,3,1400,700,0,4373,4374,5,2,0,0,4374,4375,3,1288,644,
  	0,4375,4376,5,3,0,0,4376,4377,3,626,313,0,4377,4381,1,0,0,0,4378,4379,
  	5,376,0,0,4379,4381,3,1118,559,0,4380,4349,1,0,0,0,4380,4358,1,0,0,0,
  	4380,4367,1,0,0,0,4380,4371,1,0,0,0,4380,4378,1,0,0,0,4381,483,1,0,0,
  	0,4382,4383,5,91,0,0,4383,485,1,0,0,0,4384,4385,5,244,0,0,4385,4386,3,
  	520,260,0,4386,487,1,0,0,0,4387,4388,5,100,0,0,4388,4394,5,356,0,0,4389,
  	4390,5,100,0,0,4390,4391,5,121,0,0,4391,4392,5,185,0,0,4392,4394,3,520,
  	260,0,4393,4387,1,0,0,0,4393,4389,1,0,0,0,4394,489,1,0,0,0,4395,4396,
  	5,333,0,0,4396,491,1,0,0,0,4397,4398,5,84,0,0,4398,4399,5,309,0,0,4399,
  	4400,5,244,0,0,4400,4401,3,520,260,0,4401,4402,5,138,0,0,4402,4403,3,
  	1384,692,0,4403,493,1,0,0,0,4404,4405,5,176,0,0,4405,4406,5,309,0,0,4406,
  	4407,5,244,0,0,4407,4408,3,520,260,0,4408,4409,5,138,0,0,4409,4410,3,
  	1384,692,0,4410,4411,5,171,0,0,4411,4412,3,480,240,0,4412,4423,1,0,0,
  	0,4413,4414,5,176,0,0,4414,4415,5,309,0,0,4415,4416,5,244,0,0,4416,4417,
  	3,520,260,0,4417,4418,5,138,0,0,4418,4419,3,1384,692,0,4419,4420,5,229,
  	0,0,4420,4421,3,496,248,0,4421,4423,1,0,0,0,4422,4404,1,0,0,0,4422,4413,
  	1,0,0,0,4423,495,1,0,0,0,4424,4429,3,498,249,0,4425,4426,5,6,0,0,4426,
  	4428,3,498,249,0,4427,4425,1,0,0,0,4428,4431,1,0,0,0,4429,4427,1,0,0,
  	0,4429,4430,1,0,0,0,4430,497,1,0,0,0,4431,4429,1,0,0,0,4432,4433,5,309,
  	0,0,4433,4434,3,1400,700,0,4434,4435,5,2,0,0,4435,4436,3,1288,644,0,4436,
  	4437,5,3,0,0,4437,4445,1,0,0,0,4438,4439,5,249,0,0,4439,4440,3,1400,700,
  	0,4440,4441,5,2,0,0,4441,4442,3,1288,644,0,4442,4443,5,3,0,0,4443,4445,
  	1,0,0,0,4444,4432,1,0,0,0,4444,4438,1,0,0,0,4445,499,1,0,0,0,4446,4447,
  	5,229,0,0,4447,4448,5,309,0,0,4448,4449,5,194,0,0,4449,4450,3,520,260,
  	0,4450,4451,5,138,0,0,4451,4453,3,1384,692,0,4452,4454,3,104,52,0,4453,
  	4452,1,0,0,0,4453,4454,1,0,0,0,4454,4467,1,0,0,0,4455,4456,5,229,0,0,
  	4456,4457,5,309,0,0,4457,4458,5,194,0,0,4458,4459,5,258,0,0,4459,4460,
  	5,427,0,0,4460,4461,3,520,260,0,4461,4462,5,138,0,0,4462,4464,3,1384,
  	692,0,4463,4465,3,104,52,0,4464,4463,1,0,0,0,4464,4465,1,0,0,0,4465,4467,
  	1,0,0,0,4466,4446,1,0,0,0,4466,4455,1,0,0,0,4467,501,1,0,0,0,4468,4469,
  	5,229,0,0,4469,4470,5,309,0,0,4470,4471,5,244,0,0,4471,4472,3,520,260,
  	0,4472,4473,5,138,0,0,4473,4475,3,1384,692,0,4474,4476,3,104,52,0,4475,
  	4474,1,0,0,0,4475,4476,1,0,0,0,4476,4489,1,0,0,0,4477,4478,5,229,0,0,
  	4478,4479,5,309,0,0,4479,4480,5,244,0,0,4480,4481,5,258,0,0,4481,4482,
  	5,427,0,0,4482,4483,3,520,260,0,4483,4484,5,138,0,0,4484,4486,3,1384,
  	692,0,4485,4487,3,104,52,0,4486,4485,1,0,0,0,4486,4487,1,0,0,0,4487,4489,
  	1,0,0,0,4488,4468,1,0,0,0,4488,4477,1,0,0,0,4489,503,1,0,0,0,4490,4491,
  	5,229,0,0,4491,4492,5,312,0,0,4492,4493,5,185,0,0,4493,4495,3,1414,707,
  	0,4494,4496,3,104,52,0,4495,4494,1,0,0,0,4495,4496,1,0,0,0,4496,505,1,
  	0,0,0,4497,4498,5,332,0,0,4498,4499,5,312,0,0,4499,4500,5,185,0,0,4500,
  	4501,3,1414,707,0,4501,4502,5,132,0,0,4502,4503,3,1412,706,0,4503,507,
  	1,0,0,0,4504,4505,5,229,0,0,4505,4506,3,510,255,0,4506,4507,5,258,0,0,
  	4507,4508,5,427,0,0,4508,4510,3,518,259,0,4509,4511,3,104,52,0,4510,4509,
  	1,0,0,0,4510,4511,1,0,0,0,4511,4595,1,0,0,0,4512,4513,5,229,0,0,4513,
  	4514,3,510,255,0,4514,4516,3,518,259,0,4515,4517,3,104,52,0,4516,4515,
  	1,0,0,0,4516,4517,1,0,0,0,4517,4595,1,0,0,0,4518,4519,5,229,0,0,4519,
  	4520,3,514,257,0,4520,4521,5,258,0,0,4521,4522,5,427,0,0,4522,4524,3,
  	1382,691,0,4523,4525,3,104,52,0,4524,4523,1,0,0,0,4524,4525,1,0,0,0,4525,
  	4595,1,0,0,0,4526,4527,5,229,0,0,4527,4528,3,514,257,0,4528,4530,3,1382,
  	691,0,4529,4531,3,104,52,0,4530,4529,1,0,0,0,4530,4531,1,0,0,0,4531,4595,
  	1,0,0,0,4532,4533,5,229,0,0,4533,4534,3,516,258,0,4534,4535,3,1384,692,
  	0,4535,4536,5,118,0,0,4536,4538,3,520,260,0,4537,4539,3,104,52,0,4538,
  	4537,1,0,0,0,4538,4539,1,0,0,0,4539,4595,1,0,0,0,4540,4541,5,229,0,0,
  	4541,4542,3,516,258,0,4542,4543,5,258,0,0,4543,4544,5,427,0,0,4544,4545,
  	3,1384,692,0,4545,4546,5,118,0,0,4546,4548,3,520,260,0,4547,4549,3,104,
  	52,0,4548,4547,1,0,0,0,4548,4549,1,0,0,0,4549,4595,1,0,0,0,4550,4551,
  	5,229,0,0,4551,4552,5,391,0,0,4552,4554,3,524,262,0,4553,4555,3,104,52,
  	0,4554,4553,1,0,0,0,4554,4555,1,0,0,0,4555,4595,1,0,0,0,4556,4557,5,229,
  	0,0,4557,4558,5,391,0,0,4558,4559,5,258,0,0,4559,4560,5,427,0,0,4560,
  	4562,3,524,262,0,4561,4563,3,104,52,0,4562,4561,1,0,0,0,4562,4563,1,0,
  	0,0,4563,4595,1,0,0,0,4564,4565,5,229,0,0,4565,4566,5,227,0,0,4566,4568,
  	3,524,262,0,4567,4569,3,104,52,0,4568,4567,1,0,0,0,4568,4569,1,0,0,0,
  	4569,4595,1,0,0,0,4570,4571,5,229,0,0,4571,4572,5,227,0,0,4572,4573,5,
  	258,0,0,4573,4574,5,427,0,0,4574,4576,3,524,262,0,4575,4577,3,104,52,
  	0,4576,4575,1,0,0,0,4576,4577,1,0,0,0,4577,4595,1,0,0,0,4578,4579,5,229,
  	0,0,4579,4580,5,264,0,0,4580,4581,5,147,0,0,4581,4583,3,518,259,0,4582,
  	4584,3,104,52,0,4583,4582,1,0,0,0,4583,4584,1,0,0,0,4584,4595,1,0,0,0,
  	4585,4586,5,229,0,0,4586,4587,5,264,0,0,4587,4588,5,147,0,0,4588,4589,
  	5,258,0,0,4589,4590,5,427,0,0,4590,4592,3,518,259,0,4591,4593,3,104,52,
  	0,4592,4591,1,0,0,0,4592,4593,1,0,0,0,4593,4595,1,0,0,0,4594,4504,1,0,
  	0,0,4594,4512,1,0,0,0,4594,4518,1,0,0,0,4594,4526,1,0,0,0,4594,4532,1,
  	0,0,0,4594,4540,1,0,0,0,4594,4550,1,0,0,0,4594,4556,1,0,0,0,4594,4564,
  	1,0,0,0,4594,4570,1,0,0,0,4594,4578,1,0,0,0,4594,4585,1,0,0,0,4595,509,
  	1,0,0,0,4596,4620,5,130,0,0,4597,4620,5,359,0,0,4598,4620,5,407,0,0,4599,
  	4600,5,289,0,0,4600,4620,5,407,0,0,4601,4620,5,264,0,0,4602,4603,5,101,
  	0,0,4603,4620,5,130,0,0,4604,4620,5,146,0,0,4605,4620,5,206,0,0,4606,
  	4620,5,373,0,0,4607,4608,5,386,0,0,4608,4609,5,356,0,0,4609,4620,5,314,
  	0,0,4610,4611,5,386,0,0,4611,4612,5,356,0,0,4612,4620,5,223,0,0,4613,
  	4614,5,386,0,0,4614,4615,5,356,0,0,4615,4620,5,384,0,0,4616,4617,5,386,
  	0,0,4617,4618,5,356,0,0,4618,4620,5,201,0,0,4619,4596,1,0,0,0,4619,4597,
  	1,0,0,0,4619,4598,1,0,0,0,4619,4599,1,0,0,0,4619,4601,1,0,0,0,4619,4602,
  	1,0,0,0,4619,4604,1,0,0,0,4619,4605,1,0,0,0,4619,4606,1,0,0,0,4619,4607,
  	1,0,0,0,4619,4610,1,0,0,0,4619,4613,1,0,0,0,4619,4616,1,0,0,0,4620,511,
  	1,0,0,0,4621,4627,3,514,257,0,4622,4627,5,213,0,0,4623,4627,5,349,0,0,
  	4624,4627,5,489,0,0,4625,4627,5,382,0,0,4626,4621,1,0,0,0,4626,4622,1,
  	0,0,0,4626,4623,1,0,0,0,4626,4624,1,0,0,0,4626,4625,1,0,0,0,4627,513,
  	1,0,0,0,4628,4629,5,169,0,0,4629,4644,5,484,0,0,4630,4631,5,236,0,0,4631,
  	4644,5,388,0,0,4632,4644,5,242,0,0,4633,4634,5,101,0,0,4634,4635,5,212,
  	0,0,4635,4644,5,412,0,0,4636,4638,3,304,152,0,4637,4636,1,0,0,0,4637,
  	4638,1,0,0,0,4638,4639,1,0,0,0,4639,4644,5,276,0,0,4640,4644,5,490,0,
  	0,4641,4644,5,354,0,0,4642,4644,5,362,0,0,4643,4628,1,0,0,0,4643,4630,
  	1,0,0,0,4643,4632,1,0,0,0,4643,4633,1,0,0,0,4643,4637,1,0,0,0,4643,4640,
  	1,0,0,0,4643,4641,1,0,0,0,4643,4642,1,0,0,0,4644,515,1,0,0,0,4645,4646,
  	7,24,0,0,4646,517,1,0,0,0,4647,4652,3,520,260,0,4648,4649,5,6,0,0,4649,
  	4651,3,520,260,0,4650,4648,1,0,0,0,4651,4654,1,0,0,0,4652,4650,1,0,0,
  	0,4652,4653,1,0,0,0,4653,519,1,0,0,0,4654,4652,1,0,0,0,4655,4657,3,1416,
  	708,0,4656,4658,3,522,261,0,4657,4656,1,0,0,0,4657,4658,1,0,0,0,4658,
  	521,1,0,0,0,4659,4660,5,11,0,0,4660,4662,3,1386,693,0,4661,4659,1,0,0,
  	0,4662,4663,1,0,0,0,4663,4661,1,0,0,0,4663,4664,1,0,0,0,4664,523,1,0,
  	0,0,4665,4670,3,1118,559,0,4666,4667,5,6,0,0,4667,4669,3,1118,559,0,4668,
  	4666,1,0,0,0,4669,4672,1,0,0,0,4670,4668,1,0,0,0,4670,4671,1,0,0,0,4671,
  	525,1,0,0,0,4672,4670,1,0,0,0,4673,4675,5,389,0,0,4674,4676,3,994,497,
  	0,4675,4674,1,0,0,0,4675,4676,1,0,0,0,4676,4677,1,0,0,0,4677,4679,3,1076,
  	538,0,4678,4680,3,528,264,0,4679,4678,1,0,0,0,4679,4680,1,0,0,0,4680,
  	4682,1,0,0,0,4681,4683,3,104,52,0,4682,4681,1,0,0,0,4682,4683,1,0,0,0,
  	4683,527,1,0,0,0,4684,4685,5,205,0,0,4685,4689,5,257,0,0,4686,4687,5,
  	345,0,0,4687,4689,5,257,0,0,4688,4684,1,0,0,0,4688,4686,1,0,0,0,4689,
  	529,1,0,0,0,4690,4691,5,197,0,0,4691,4692,5,118,0,0,4692,4693,3,510,255,
  	0,4693,4694,3,520,260,0,4694,4695,5,154,0,0,4695,4696,3,532,266,0,4696,
  	4838,1,0,0,0,4697,4698,5,197,0,0,4698,4699,5,118,0,0,4699,4700,5,82,0,
  	0,4700,4701,3,520,260,0,4701,4702,5,154,0,0,4702,4703,3,532,266,0,4703,
  	4838,1,0,0,0,4704,4705,5,197,0,0,4705,4706,5,118,0,0,4706,4707,3,512,
  	256,0,4707,4708,3,1384,692,0,4708,4709,5,154,0,0,4709,4710,3,532,266,
  	0,4710,4838,1,0,0,0,4711,4712,5,197,0,0,4712,4713,5,118,0,0,4713,4714,
  	5,391,0,0,4714,4715,3,1118,559,0,4715,4716,5,154,0,0,4716,4717,3,532,
  	266,0,4717,4838,1,0,0,0,4718,4719,5,197,0,0,4719,4720,5,118,0,0,4720,
  	4721,5,227,0,0,4721,4722,3,1118,559,0,4722,4723,5,154,0,0,4723,4724,3,
  	532,266,0,4724,4838,1,0,0,0,4725,4726,5,197,0,0,4726,4727,5,118,0,0,4727,
  	4728,5,174,0,0,4728,4729,3,650,325,0,4729,4730,5,154,0,0,4730,4731,3,
  	532,266,0,4731,4838,1,0,0,0,4732,4733,5,197,0,0,4733,4734,5,118,0,0,4734,
  	4735,5,249,0,0,4735,4736,3,626,313,0,4736,4737,5,154,0,0,4737,4738,3,
  	532,266,0,4738,4838,1,0,0,0,4739,4740,5,197,0,0,4740,4741,5,118,0,0,4741,
  	4742,5,309,0,0,4742,4743,3,688,344,0,4743,4744,5,154,0,0,4744,4745,3,
  	532,266,0,4745,4838,1,0,0,0,4746,4747,5,197,0,0,4747,4748,5,118,0,0,4748,
  	4749,5,83,0,0,4749,4750,3,1384,692,0,4750,4751,5,118,0,0,4751,4752,3,
  	520,260,0,4752,4753,5,154,0,0,4753,4754,3,532,266,0,4754,4838,1,0,0,0,
  	4755,4756,5,197,0,0,4756,4757,5,118,0,0,4757,4758,5,83,0,0,4758,4759,
  	3,1384,692,0,4759,4760,5,118,0,0,4760,4761,5,227,0,0,4761,4762,3,520,
  	260,0,4762,4763,5,154,0,0,4763,4764,3,532,266,0,4764,4838,1,0,0,0,4765,
  	4766,5,197,0,0,4766,4767,5,118,0,0,4767,4768,3,516,258,0,4768,4769,3,
  	1384,692,0,4769,4770,5,118,0,0,4770,4771,3,520,260,0,4771,4772,5,154,
  	0,0,4772,4773,3,532,266,0,4773,4838,1,0,0,0,4774,4775,5,197,0,0,4775,
  	4776,5,118,0,0,4776,4777,5,327,0,0,4777,4778,3,626,313,0,4778,4779,5,
  	154,0,0,4779,4780,3,532,266,0,4780,4838,1,0,0,0,4781,4782,5,197,0,0,4782,
  	4783,5,118,0,0,4783,4784,5,480,0,0,4784,4785,3,626,313,0,4785,4786,5,
  	154,0,0,4786,4787,3,532,266,0,4787,4838,1,0,0,0,4788,4789,5,197,0,0,4789,
  	4790,5,118,0,0,4790,4791,5,481,0,0,4791,4792,5,100,0,0,4792,4793,3,1118,
  	559,0,4793,4794,5,276,0,0,4794,4795,3,1384,692,0,4795,4796,5,154,0,0,
  	4796,4797,3,532,266,0,4797,4838,1,0,0,0,4798,4799,5,197,0,0,4799,4800,
  	5,118,0,0,4800,4801,5,309,0,0,4801,4802,5,194,0,0,4802,4803,3,520,260,
  	0,4803,4804,5,138,0,0,4804,4805,3,1384,692,0,4805,4806,5,154,0,0,4806,
  	4807,3,532,266,0,4807,4838,1,0,0,0,4808,4809,5,197,0,0,4809,4810,5,118,
  	0,0,4810,4811,5,309,0,0,4811,4812,5,244,0,0,4812,4813,3,520,260,0,4813,
  	4814,5,138,0,0,4814,4815,3,1384,692,0,4815,4816,5,154,0,0,4816,4817,3,
  	532,266,0,4817,4838,1,0,0,0,4818,4819,5,197,0,0,4819,4820,5,118,0,0,4820,
  	4821,5,277,0,0,4821,4822,5,305,0,0,4822,4823,3,288,144,0,4823,4824,5,
  	154,0,0,4824,4825,3,532,266,0,4825,4838,1,0,0,0,4826,4827,5,197,0,0,4827,
  	4828,5,118,0,0,4828,4829,5,79,0,0,4829,4830,5,2,0,0,4830,4831,3,1118,
  	559,0,4831,4832,5,74,0,0,4832,4833,3,1118,559,0,4833,4834,5,3,0,0,4834,
  	4835,5,154,0,0,4835,4836,3,532,266,0,4836,4838,1,0,0,0,4837,4690,1,0,
  	0,0,4837,4697,1,0,0,0,4837,4704,1,0,0,0,4837,4711,1,0,0,0,4837,4718,1,
  	0,0,0,4837,4725,1,0,0,0,4837,4732,1,0,0,0,4837,4739,1,0,0,0,4837,4746,
  	1,0,0,0,4837,4755,1,0,0,0,4837,4765,1,0,0,0,4837,4774,1,0,0,0,4837,4781,
  	1,0,0,0,4837,4788,1,0,0,0,4837,4798,1,0,0,0,4837,4808,1,0,0,0,4837,4818,
  	1,0,0,0,4837,4826,1,0,0,0,4838,531,1,0,0,0,4839,4842,3,1402,701,0,4840,
  	4842,5,116,0,0,4841,4839,1,0,0,0,4841,4840,1,0,0,0,4842,533,1,0,0,0,4843,
  	4844,5,358,0,0,4844,4846,5,275,0,0,4845,4847,3,536,268,0,4846,4845,1,
  	0,0,0,4846,4847,1,0,0,0,4847,4848,1,0,0,0,4848,4849,5,118,0,0,4849,4850,
  	3,510,255,0,4850,4851,3,520,260,0,4851,4852,5,154,0,0,4852,4853,3,538,
  	269,0,4853,4955,1,0,0,0,4854,4855,5,358,0,0,4855,4857,5,275,0,0,4856,
  	4858,3,536,268,0,4857,4856,1,0,0,0,4857,4858,1,0,0,0,4858,4859,1,0,0,
  	0,4859,4860,5,118,0,0,4860,4861,5,82,0,0,4861,4862,3,520,260,0,4862,4863,
  	5,154,0,0,4863,4864,3,538,269,0,4864,4955,1,0,0,0,4865,4866,5,358,0,0,
  	4866,4868,5,275,0,0,4867,4869,3,536,268,0,4868,4867,1,0,0,0,4868,4869,
  	1,0,0,0,4869,4870,1,0,0,0,4870,4871,5,118,0,0,4871,4872,3,512,256,0,4872,
  	4873,3,1384,692,0,4873,4874,5,154,0,0,4874,4875,3,538,269,0,4875,4955,
  	1,0,0,0,4876,4877,5,358,0,0,4877,4879,5,275,0,0,4878,4880,3,536,268,0,
  	4879,4878,1,0,0,0,4879,4880,1,0,0,0,4880,4881,1,0,0,0,4881,4882,5,118,
  	0,0,4882,4883,5,391,0,0,4883,4884,3,1118,559,0,4884,4885,5,154,0,0,4885,
  	4886,3,538,269,0,4886,4955,1,0,0,0,4887,4888,5,358,0,0,4888,4890,5,275,
  	0,0,4889,4891,3,536,268,0,4890,4889,1,0,0,0,4890,4891,1,0,0,0,4891,4892,
  	1,0,0,0,4892,4893,5,118,0,0,4893,4894,5,227,0,0,4894,4895,3,1118,559,
  	0,4895,4896,5,154,0,0,4896,4897,3,538,269,0,4897,4955,1,0,0,0,4898,4899,
  	5,358,0,0,4899,4901,5,275,0,0,4900,4902,3,536,268,0,4901,4900,1,0,0,0,
  	4901,4902,1,0,0,0,4902,4903,1,0,0,0,4903,4904,5,118,0,0,4904,4905,5,174,
  	0,0,4905,4906,3,650,325,0,4906,4907,5,154,0,0,4907,4908,3,538,269,0,4908,
  	4955,1,0,0,0,4909,4910,5,358,0,0,4910,4912,5,275,0,0,4911,4913,3,536,
  	268,0,4912,4911,1,0,0,0,4912,4913,1,0,0,0,4913,4914,1,0,0,0,4914,4915,
  	5,118,0,0,4915,4916,5,249,0,0,4916,4917,3,626,313,0,4917,4918,5,154,0,
  	0,4918,4919,3,538,269,0,4919,4955,1,0,0,0,4920,4921,5,358,0,0,4921,4923,
  	5,275,0,0,4922,4924,3,536,268,0,4923,4922,1,0,0,0,4923,4924,1,0,0,0,4924,
  	4925,1,0,0,0,4925,4926,5,118,0,0,4926,4927,5,277,0,0,4927,4928,5,305,
  	0,0,4928,4929,3,288,144,0,4929,4930,5,154,0,0,4930,4931,3,538,269,0,4931,
  	4955,1,0,0,0,4932,4933,5,358,0,0,4933,4935,5,275,0,0,4934,4936,3,536,
  	268,0,4935,4934,1,0,0,0,4935,4936,1,0,0,0,4936,4937,1,0,0,0,4937,4938,
  	5,118,0,0,4938,4939,5,327,0,0,4939,4940,3,626,313,0,4940,4941,5,154,0,
  	0,4941,4942,3,538,269,0,4942,4955,1,0,0,0,4943,4944,5,358,0,0,4944,4946,
  	5,275,0,0,4945,4947,3,536,268,0,4946,4945,1,0,0,0,4946,4947,1,0,0,0,4947,
  	4948,1,0,0,0,4948,4949,5,118,0,0,4949,4950,5,480,0,0,4950,4951,3,626,
  	313,0,4951,4952,5,154,0,0,4952,4953,3,538,269,0,4953,4955,1,0,0,0,4954,
  	4843,1,0,0,0,4954,4854,1,0,0,0,4954,4865,1,0,0,0,4954,4876,1,0,0,0,4954,
  	4887,1,0,0,0,4954,4898,1,0,0,0,4954,4909,1,0,0,0,4954,4920,1,0,0,0,4954,
  	4932,1,0,0,0,4954,4943,1,0,0,0,4955,535,1,0,0,0,4956,4957,5,100,0,0,4957,
  	4958,3,68,34,0,4958,537,1,0,0,0,4959,4962,3,1402,701,0,4960,4962,5,116,
  	0,0,4961,4959,1,0,0,0,4961,4960,1,0,0,0,4962,539,1,0,0,0,4963,4964,5,
  	99,0,0,4964,4968,3,542,271,0,4965,4966,5,296,0,0,4966,4968,3,542,271,
  	0,4967,4963,1,0,0,0,4967,4965,1,0,0,0,4968,541,1,0,0,0,4969,5055,3,960,
  	480,0,4970,4971,3,544,272,0,4971,4972,3,960,480,0,4972,5055,1,0,0,0,4973,
  	4975,5,299,0,0,4974,4976,3,546,273,0,4975,4974,1,0,0,0,4975,4976,1,0,
  	0,0,4976,4977,1,0,0,0,4977,5055,3,960,480,0,4978,4980,5,324,0,0,4979,
  	4981,3,546,273,0,4980,4979,1,0,0,0,4980,4981,1,0,0,0,4981,4982,1,0,0,
  	0,4982,5055,3,960,480,0,4983,4985,5,245,0,0,4984,4986,3,546,273,0,4985,
  	4984,1,0,0,0,4985,4986,1,0,0,0,4986,4987,1,0,0,0,4987,5055,3,960,480,
  	0,4988,4990,5,278,0,0,4989,4991,3,546,273,0,4990,4989,1,0,0,0,4990,4991,
  	1,0,0,0,4991,4992,1,0,0,0,4992,5055,3,960,480,0,4993,4994,5,168,0,0,4994,
  	4996,3,1408,704,0,4995,4997,3,546,273,0,4996,4995,1,0,0,0,4996,4997,1,
  	0,0,0,4997,4998,1,0,0,0,4998,4999,3,960,480,0,4999,5055,1,0,0,0,5000,
  	5001,5,338,0,0,5001,5003,3,1408,704,0,5002,5004,3,546,273,0,5003,5002,
  	1,0,0,0,5003,5004,1,0,0,0,5004,5005,1,0,0,0,5005,5006,3,960,480,0,5006,
  	5055,1,0,0,0,5007,5009,3,1408,704,0,5008,5010,3,546,273,0,5009,5008,1,
  	0,0,0,5009,5010,1,0,0,0,5010,5011,1,0,0,0,5011,5012,3,960,480,0,5012,
  	5055,1,0,0,0,5013,5015,5,68,0,0,5014,5016,3,546,273,0,5015,5014,1,0,0,
  	0,5015,5016,1,0,0,0,5016,5017,1,0,0,0,5017,5055,3,960,480,0,5018,5020,
  	5,248,0,0,5019,5021,3,546,273,0,5020,5019,1,0,0,0,5020,5021,1,0,0,0,5021,
  	5022,1,0,0,0,5022,5055,3,960,480,0,5023,5024,5,248,0,0,5024,5026,3,1408,
  	704,0,5025,5027,3,546,273,0,5026,5025,1,0,0,0,5026,5027,1,0,0,0,5027,
  	5028,1,0,0,0,5028,5029,3,960,480,0,5029,5055,1,0,0,0,5030,5031,5,248,
  	0,0,5031,5033,5,68,0,0,5032,5034,3,546,273,0,5033,5032,1,0,0,0,5033,5034,
  	1,0,0,0,5034,5035,1,0,0,0,5035,5055,3,960,480,0,5036,5038,5,182,0,0,5037,
  	5039,3,546,273,0,5038,5037,1,0,0,0,5038,5039,1,0,0,0,5039,5040,1,0,0,
  	0,5040,5055,3,960,480,0,5041,5042,5,182,0,0,5042,5044,3,1408,704,0,5043,
  	5045,3,546,273,0,5044,5043,1,0,0,0,5044,5045,1,0,0,0,5045,5046,1,0,0,
  	0,5046,5047,3,960,480,0,5047,5055,1,0,0,0,5048,5049,5,182,0,0,5049,5051,
  	5,68,0,0,5050,5052,3,546,273,0,5051,5050,1,0,0,0,5051,5052,1,0,0,0,5052,
  	5053,1,0,0,0,5053,5055,3,960,480,0,5054,4969,1,0,0,0,5054,4970,1,0,0,
  	0,5054,4973,1,0,0,0,5054,4978,1,0,0,0,5054,4983,1,0,0,0,5054,4988,1,0,
  	0,0,5054,4993,1,0,0,0,5054,5000,1,0,0,0,5054,5007,1,0,0,0,5054,5013,1,
  	0,0,0,5054,5018,1,0,0,0,5054,5023,1,0,0,0,5054,5030,1,0,0,0,5054,5036,
  	1,0,0,0,5054,5041,1,0,0,0,5054,5048,1,0,0,0,5055,543,1,0,0,0,5056,5057,
  	7,25,0,0,5057,545,1,0,0,0,5058,5059,3,544,272,0,5059,547,1,0,0,0,5060,
  	5061,5,103,0,0,5061,5062,3,552,276,0,5062,5063,5,118,0,0,5063,5064,3,
  	558,279,0,5064,5065,5,132,0,0,5065,5067,3,560,280,0,5066,5068,3,564,282,
  	0,5067,5066,1,0,0,0,5067,5068,1,0,0,0,5068,549,1,0,0,0,5069,5070,5,348,
  	0,0,5070,5071,3,552,276,0,5071,5072,5,118,0,0,5072,5073,3,558,279,0,5073,
  	5074,5,102,0,0,5074,5076,3,560,280,0,5075,5077,3,104,52,0,5076,5075,1,
  	0,0,0,5076,5077,1,0,0,0,5077,5091,1,0,0,0,5078,5079,5,348,0,0,5079,5080,
  	5,103,0,0,5080,5081,5,310,0,0,5081,5082,5,100,0,0,5082,5083,3,552,276,
  	0,5083,5084,5,118,0,0,5084,5085,3,558,279,0,5085,5086,5,102,0,0,5086,
  	5088,3,560,280,0,5087,5089,3,104,52,0,5088,5087,1,0,0,0,5088,5089,1,0,
  	0,0,5089,5091,1,0,0,0,5090,5069,1,0,0,0,5090,5078,1,0,0,0,5091,551,1,
  	0,0,0,5092,5108,3,554,277,0,5093,5108,5,68,0,0,5094,5095,5,68,0,0,5095,
  	5108,5,325,0,0,5096,5097,5,68,0,0,5097,5098,5,2,0,0,5098,5099,3,212,106,
  	0,5099,5100,5,3,0,0,5100,5108,1,0,0,0,5101,5102,5,68,0,0,5102,5103,5,
  	325,0,0,5103,5104,5,2,0,0,5104,5105,3,212,106,0,5105,5106,5,3,0,0,5106,
  	5108,1,0,0,0,5107,5092,1,0,0,0,5107,5093,1,0,0,0,5107,5094,1,0,0,0,5107,
  	5096,1,0,0,0,5107,5101,1,0,0,0,5108,553,1,0,0,0,5109,5114,3,556,278,0,
  	5110,5111,5,6,0,0,5111,5113,3,556,278,0,5112,5110,1,0,0,0,5113,5116,1,
  	0,0,0,5114,5112,1,0,0,0,5114,5115,1,0,0,0,5115,555,1,0,0,0,5116,5114,
  	1,0,0,0,5117,5119,5,126,0,0,5118,5120,3,210,105,0,5119,5118,1,0,0,0,5119,
  	5120,1,0,0,0,5120,5134,1,0,0,0,5121,5123,5,124,0,0,5122,5124,3,210,105,
  	0,5123,5122,1,0,0,0,5123,5124,1,0,0,0,5124,5134,1,0,0,0,5125,5127,5,84,
  	0,0,5126,5128,3,210,105,0,5127,5126,1,0,0,0,5127,5128,1,0,0,0,5128,5134,
  	1,0,0,0,5129,5131,3,1416,708,0,5130,5132,3,210,105,0,5131,5130,1,0,0,
  	0,5131,5132,1,0,0,0,5132,5134,1,0,0,0,5133,5117,1,0,0,0,5133,5121,1,0,
  	0,0,5133,5125,1,0,0,0,5133,5129,1,0,0,0,5134,557,1,0,0,0,5135,5194,3,
  	1378,689,0,5136,5137,5,130,0,0,5137,5194,3,1378,689,0,5138,5139,5,359,
  	0,0,5139,5194,3,1378,689,0,5140,5141,5,101,0,0,5141,5142,5,212,0,0,5142,
  	5143,5,412,0,0,5143,5194,3,1382,691,0,5144,5145,5,101,0,0,5145,5146,5,
  	362,0,0,5146,5194,3,1382,691,0,5147,5148,5,249,0,0,5148,5194,3,624,312,
  	0,5149,5150,5,327,0,0,5150,5194,3,624,312,0,5151,5152,5,480,0,0,5152,
  	5194,3,624,312,0,5153,5154,5,213,0,0,5154,5194,3,1382,691,0,5155,5156,
  	5,227,0,0,5156,5194,3,518,259,0,5157,5158,5,276,0,0,5158,5194,3,1382,
  	691,0,5159,5160,5,277,0,0,5160,5161,5,305,0,0,5161,5194,3,290,145,0,5162,
  	5163,5,354,0,0,5163,5194,3,1382,691,0,5164,5165,5,382,0,0,5165,5194,3,
  	1382,691,0,5166,5167,5,391,0,0,5167,5194,3,518,259,0,5168,5169,5,68,0,
  	0,5169,5170,5,381,0,0,5170,5171,5,106,0,0,5171,5172,5,354,0,0,5172,5194,
  	3,1382,691,0,5173,5174,5,68,0,0,5174,5175,5,360,0,0,5175,5176,5,106,0,
  	0,5176,5177,5,354,0,0,5177,5194,3,1382,691,0,5178,5179,5,68,0,0,5179,
  	5180,5,250,0,0,5180,5181,5,106,0,0,5181,5182,5,354,0,0,5182,5194,3,1382,
  	691,0,5183,5184,5,68,0,0,5184,5185,5,495,0,0,5185,5186,5,106,0,0,5186,
  	5187,5,354,0,0,5187,5194,3,1382,691,0,5188,5189,5,68,0,0,5189,5190,5,
  	493,0,0,5190,5191,5,106,0,0,5191,5192,5,354,0,0,5192,5194,3,1382,691,
  	0,5193,5135,1,0,0,0,5193,5136,1,0,0,0,5193,5138,1,0,0,0,5193,5140,1,0,
  	0,0,5193,5144,1,0,0,0,5193,5147,1,0,0,0,5193,5149,1,0,0,0,5193,5151,1,
  	0,0,0,5193,5153,1,0,0,0,5193,5155,1,0,0,0,5193,5157,1,0,0,0,5193,5159,
  	1,0,0,0,5193,5162,1,0,0,0,5193,5164,1,0,0,0,5193,5166,1,0,0,0,5193,5168,
  	1,0,0,0,5193,5173,1,0,0,0,5193,5178,1,0,0,0,5193,5183,1,0,0,0,5193,5188,
  	1,0,0,0,5194,559,1,0,0,0,5195,5200,3,562,281,0,5196,5197,5,6,0,0,5197,
  	5199,3,562,281,0,5198,5196,1,0,0,0,5199,5202,1,0,0,0,5200,5198,1,0,0,
  	0,5200,5201,1,0,0,0,5201,561,1,0,0,0,5202,5200,1,0,0,0,5203,5207,3,1412,
  	706,0,5204,5205,5,104,0,0,5205,5207,3,1412,706,0,5206,5203,1,0,0,0,5206,
  	5204,1,0,0,0,5207,563,1,0,0,0,5208,5209,5,143,0,0,5209,5210,5,103,0,0,
  	5210,5211,5,310,0,0,5211,565,1,0,0,0,5212,5213,5,103,0,0,5213,5214,3,
  	554,277,0,5214,5215,5,132,0,0,5215,5217,3,1414,707,0,5216,5218,3,570,
  	285,0,5217,5216,1,0,0,0,5217,5218,1,0,0,0,5218,5220,1,0,0,0,5219,5221,
  	3,572,286,0,5220,5219,1,0,0,0,5220,5221,1,0,0,0,5221,567,1,0,0,0,5222,
  	5223,5,348,0,0,5223,5224,3,554,277,0,5224,5225,5,102,0,0,5225,5227,3,
  	1414,707,0,5226,5228,3,572,286,0,5227,5226,1,0,0,0,5227,5228,1,0,0,0,
  	5228,5230,1,0,0,0,5229,5231,3,104,52,0,5230,5229,1,0,0,0,5230,5231,1,
  	0,0,0,5231,5246,1,0,0,0,5232,5233,5,348,0,0,5233,5234,5,172,0,0,5234,
  	5235,5,310,0,0,5235,5236,5,100,0,0,5236,5237,3,554,277,0,5237,5238,5,
  	102,0,0,5238,5240,3,1414,707,0,5239,5241,3,572,286,0,5240,5239,1,0,0,
  	0,5240,5241,1,0,0,0,5241,5243,1,0,0,0,5242,5244,3,104,52,0,5243,5242,
  	1,0,0,0,5243,5244,1,0,0,0,5244,5246,1,0,0,0,5245,5222,1,0,0,0,5245,5232,
  	1,0,0,0,5246,569,1,0,0,0,5247,5248,5,143,0,0,5248,5249,5,172,0,0,5249,
  	5250,5,310,0,0,5250,571,1,0,0,0,5251,5252,5,252,0,0,5252,5253,5,185,0,
  	0,5253,5254,3,1412,706,0,5254,573,1,0,0,0,5255,5256,5,176,0,0,5256,5257,
  	5,91,0,0,5257,5258,5,325,0,0,5258,5259,3,576,288,0,5259,5260,3,580,290,
  	0,5260,575,1,0,0,0,5261,5263,3,578,289,0,5262,5261,1,0,0,0,5263,5266,
  	1,0,0,0,5264,5262,1,0,0,0,5264,5265,1,0,0,0,5265,577,1,0,0,0,5266,5264,
  	1,0,0,0,5267,5268,5,106,0,0,5268,5269,5,354,0,0,5269,5277,3,1382,691,
  	0,5270,5271,5,100,0,0,5271,5272,5,349,0,0,5272,5277,3,1414,707,0,5273,
  	5274,5,100,0,0,5274,5275,5,137,0,0,5275,5277,3,1414,707,0,5276,5267,1,
  	0,0,0,5276,5270,1,0,0,0,5276,5273,1,0,0,0,5277,579,1,0,0,0,5278,5279,
  	5,103,0,0,5279,5280,3,552,276,0,5280,5281,5,118,0,0,5281,5282,3,582,291,
  	0,5282,5283,5,132,0,0,5283,5285,3,560,280,0,5284,5286,3,564,282,0,5285,
  	5284,1,0,0,0,5285,5286,1,0,0,0,5286,5309,1,0,0,0,5287,5288,5,348,0,0,
  	5288,5289,3,552,276,0,5289,5290,5,118,0,0,5290,5291,3,582,291,0,5291,
  	5292,5,102,0,0,5292,5294,3,560,280,0,5293,5295,3,104,52,0,5294,5293,1,
  	0,0,0,5294,5295,1,0,0,0,5295,5309,1,0,0,0,5296,5297,5,348,0,0,5297,5298,
  	5,103,0,0,5298,5299,5,310,0,0,5299,5300,5,100,0,0,5300,5301,3,552,276,
  	0,5301,5302,5,118,0,0,5302,5303,3,582,291,0,5303,5304,5,102,0,0,5304,
  	5306,3,560,280,0,5305,5307,3,104,52,0,5306,5305,1,0,0,0,5306,5307,1,0,
  	0,0,5307,5309,1,0,0,0,5308,5278,1,0,0,0,5308,5287,1,0,0,0,5308,5296,1,
  	0,0,0,5309,581,1,0,0,0,5310,5311,7,26,0,0,5311,583,1,0,0,0,5312,5314,
  	5,84,0,0,5313,5315,3,586,293,0,5314,5313,1,0,0,0,5314,5315,1,0,0,0,5315,
  	5316,1,0,0,0,5316,5318,5,264,0,0,5317,5319,3,592,296,0,5318,5317,1,0,
  	0,0,5318,5319,1,0,0,0,5319,5324,1,0,0,0,5320,5322,3,476,238,0,5321,5320,
  	1,0,0,0,5321,5322,1,0,0,0,5322,5323,1,0,0,0,5323,5325,3,594,297,0,5324,
  	5321,1,0,0,0,5324,5325,1,0,0,0,5325,5326,1,0,0,0,5326,5327,5,118,0,0,
  	5327,5329,3,1074,537,0,5328,5330,3,596,298,0,5329,5328,1,0,0,0,5329,5330,
  	1,0,0,0,5330,5331,1,0,0,0,5331,5332,5,2,0,0,5332,5333,3,598,299,0,5333,
  	5335,5,3,0,0,5334,5336,3,604,302,0,5335,5334,1,0,0,0,5335,5336,1,0,0,
  	0,5336,5338,1,0,0,0,5337,5339,3,588,294,0,5338,5337,1,0,0,0,5338,5339,
  	1,0,0,0,5339,5341,1,0,0,0,5340,5342,3,114,57,0,5341,5340,1,0,0,0,5341,
  	5342,1,0,0,0,5342,5344,1,0,0,0,5343,5345,3,250,125,0,5344,5343,1,0,0,
  	0,5344,5345,1,0,0,0,5345,5347,1,0,0,0,5346,5348,3,1094,547,0,5347,5346,
  	1,0,0,0,5347,5348,1,0,0,0,5348,5385,1,0,0,0,5349,5351,5,84,0,0,5350,5352,
  	3,586,293,0,5351,5350,1,0,0,0,5351,5352,1,0,0,0,5352,5353,1,0,0,0,5353,
  	5355,5,264,0,0,5354,5356,3,592,296,0,5355,5354,1,0,0,0,5355,5356,1,0,
  	0,0,5356,5358,1,0,0,0,5357,5359,3,476,238,0,5358,5357,1,0,0,0,5358,5359,
  	1,0,0,0,5359,5360,1,0,0,0,5360,5361,3,1384,692,0,5361,5362,5,118,0,0,
  	5362,5364,3,1074,537,0,5363,5365,3,596,298,0,5364,5363,1,0,0,0,5364,5365,
  	1,0,0,0,5365,5366,1,0,0,0,5366,5367,5,2,0,0,5367,5368,3,598,299,0,5368,
  	5370,5,3,0,0,5369,5371,3,604,302,0,5370,5369,1,0,0,0,5370,5371,1,0,0,
  	0,5371,5373,1,0,0,0,5372,5374,3,588,294,0,5373,5372,1,0,0,0,5373,5374,
  	1,0,0,0,5374,5376,1,0,0,0,5375,5377,3,114,57,0,5376,5375,1,0,0,0,5376,
  	5377,1,0,0,0,5377,5379,1,0,0,0,5378,5380,3,250,125,0,5379,5378,1,0,0,
  	0,5379,5380,1,0,0,0,5380,5382,1,0,0,0,5381,5383,3,1094,547,0,5382,5381,
  	1,0,0,0,5382,5383,1,0,0,0,5383,5385,1,0,0,0,5384,5312,1,0,0,0,5384,5349,
  	1,0,0,0,5385,585,1,0,0,0,5386,5387,5,136,0,0,5387,587,1,0,0,0,5388,5390,
  	5,304,0,0,5389,5391,5,115,0,0,5390,5389,1,0,0,0,5390,5391,1,0,0,0,5391,
  	5392,1,0,0,0,5392,5393,5,94,0,0,5393,589,1,0,0,0,5394,5395,3,1416,708,
  	0,5395,591,1,0,0,0,5396,5397,5,147,0,0,5397,593,1,0,0,0,5398,5399,3,1384,
  	692,0,5399,595,1,0,0,0,5400,5401,5,138,0,0,5401,5402,3,1384,692,0,5402,
  	597,1,0,0,0,5403,5408,3,602,301,0,5404,5405,5,6,0,0,5405,5407,3,602,301,
  	0,5406,5404,1,0,0,0,5407,5410,1,0,0,0,5408,5406,1,0,0,0,5408,5409,1,0,
  	0,0,5409,599,1,0,0,0,5410,5408,1,0,0,0,5411,5413,3,608,304,0,5412,5411,
  	1,0,0,0,5412,5413,1,0,0,0,5413,5415,1,0,0,0,5414,5416,3,610,305,0,5415,
  	5414,1,0,0,0,5415,5416,1,0,0,0,5416,5418,1,0,0,0,5417,5419,3,612,306,
  	0,5418,5417,1,0,0,0,5418,5419,1,0,0,0,5419,5421,1,0,0,0,5420,5422,3,614,
  	307,0,5421,5420,1,0,0,0,5421,5422,1,0,0,0,5422,5435,1,0,0,0,5423,5425,
  	3,608,304,0,5424,5423,1,0,0,0,5424,5425,1,0,0,0,5425,5426,1,0,0,0,5426,
  	5427,3,520,260,0,5427,5429,3,112,56,0,5428,5430,3,612,306,0,5429,5428,
  	1,0,0,0,5429,5430,1,0,0,0,5430,5432,1,0,0,0,5431,5433,3,614,307,0,5432,
  	5431,1,0,0,0,5432,5433,1,0,0,0,5433,5435,1,0,0,0,5434,5412,1,0,0,0,5434,
  	5424,1,0,0,0,5435,601,1,0,0,0,5436,5437,3,1416,708,0,5437,5438,3,600,
  	300,0,5438,5448,1,0,0,0,5439,5440,3,1216,608,0,5440,5441,3,600,300,0,
  	5441,5448,1,0,0,0,5442,5443,5,2,0,0,5443,5444,3,1164,582,0,5444,5445,
  	5,3,0,0,5445,5446,3,600,300,0,5446,5448,1,0,0,0,5447,5436,1,0,0,0,5447,
  	5439,1,0,0,0,5447,5442,1,0,0,0,5448,603,1,0,0,0,5449,5450,5,479,0,0,5450,
  	5451,5,2,0,0,5451,5452,3,606,303,0,5452,5453,5,3,0,0,5453,605,1,0,0,0,
  	5454,5459,3,602,301,0,5455,5456,5,6,0,0,5456,5458,3,602,301,0,5457,5455,
  	1,0,0,0,5458,5461,1,0,0,0,5459,5457,1,0,0,0,5459,5460,1,0,0,0,5460,607,
  	1,0,0,0,5461,5459,1,0,0,0,5462,5463,5,81,0,0,5463,5464,3,520,260,0,5464,
  	609,1,0,0,0,5465,5466,3,520,260,0,5466,611,1,0,0,0,5467,5468,7,27,0,0,
  	5468,613,1,0,0,0,5469,5470,5,304,0,0,5470,5474,5,245,0,0,5471,5472,5,
  	304,0,0,5472,5474,5,278,0,0,5473,5469,1,0,0,0,5473,5471,1,0,0,0,5474,
  	615,1,0,0,0,5475,5477,5,84,0,0,5476,5478,3,618,309,0,5477,5476,1,0,0,
  	0,5477,5478,1,0,0,0,5478,5479,1,0,0,0,5479,5480,7,23,0,0,5480,5481,3,
  	1390,695,0,5481,5491,3,628,314,0,5482,5489,5,347,0,0,5483,5490,3,638,
  	319,0,5484,5485,5,130,0,0,5485,5486,5,2,0,0,5486,5487,3,668,334,0,5487,
  	5488,5,3,0,0,5488,5490,1,0,0,0,5489,5483,1,0,0,0,5489,5484,1,0,0,0,5490,
  	5492,1,0,0,0,5491,5482,1,0,0,0,5491,5492,1,0,0,0,5492,5493,1,0,0,0,5493,
  	5494,3,654,327,0,5494,617,1,0,0,0,5495,5496,5,120,0,0,5496,5497,5,342,
  	0,0,5497,619,1,0,0,0,5498,5500,5,2,0,0,5499,5501,3,622,311,0,5500,5499,
  	1,0,0,0,5500,5501,1,0,0,0,5501,5502,1,0,0,0,5502,5503,5,3,0,0,5503,621,
  	1,0,0,0,5504,5509,3,632,316,0,5505,5506,5,6,0,0,5506,5508,3,632,316,0,
  	5507,5505,1,0,0,0,5508,5511,1,0,0,0,5509,5507,1,0,0,0,5509,5510,1,0,0,
  	0,5510,623,1,0,0,0,5511,5509,1,0,0,0,5512,5517,3,626,313,0,5513,5514,
  	5,6,0,0,5514,5516,3,626,313,0,5515,5513,1,0,0,0,5516,5519,1,0,0,0,5517,
  	5515,1,0,0,0,5517,5518,1,0,0,0,5518,625,1,0,0,0,5519,5517,1,0,0,0,5520,
  	5521,3,1390,695,0,5521,5522,3,620,310,0,5522,5529,1,0,0,0,5523,5529,3,
  	1430,715,0,5524,5526,3,1416,708,0,5525,5527,3,1326,663,0,5526,5525,1,
  	0,0,0,5526,5527,1,0,0,0,5527,5529,1,0,0,0,5528,5520,1,0,0,0,5528,5523,
  	1,0,0,0,5528,5524,1,0,0,0,5529,627,1,0,0,0,5530,5532,5,2,0,0,5531,5533,
  	3,630,315,0,5532,5531,1,0,0,0,5532,5533,1,0,0,0,5533,5534,1,0,0,0,5534,
  	5535,5,3,0,0,5535,629,1,0,0,0,5536,5541,3,642,321,0,5537,5538,5,6,0,0,
  	5538,5540,3,642,321,0,5539,5537,1,0,0,0,5540,5543,1,0,0,0,5541,5539,1,
  	0,0,0,5541,5542,1,0,0,0,5542,631,1,0,0,0,5543,5541,1,0,0,0,5544,5546,
  	3,634,317,0,5545,5547,3,636,318,0,5546,5545,1,0,0,0,5546,5547,1,0,0,0,
  	5547,5548,1,0,0,0,5548,5549,3,640,320,0,5549,5558,1,0,0,0,5550,5552,3,
  	636,318,0,5551,5553,3,634,317,0,5552,5551,1,0,0,0,5552,5553,1,0,0,0,5553,
  	5554,1,0,0,0,5554,5555,3,640,320,0,5555,5558,1,0,0,0,5556,5558,3,640,
  	320,0,5557,5544,1,0,0,0,5557,5550,1,0,0,0,5557,5556,1,0,0,0,5558,633,
  	1,0,0,0,5559,5561,5,106,0,0,5560,5562,5,491,0,0,5561,5560,1,0,0,0,5561,
  	5562,1,0,0,0,5562,5567,1,0,0,0,5563,5567,5,491,0,0,5564,5567,5,431,0,
  	0,5565,5567,5,139,0,0,5566,5559,1,0,0,0,5566,5563,1,0,0,0,5566,5564,1,
  	0,0,0,5566,5565,1,0,0,0,5567,635,1,0,0,0,5568,5569,3,1418,709,0,5569,
  	637,1,0,0,0,5570,5571,3,640,320,0,5571,639,1,0,0,0,5572,5582,3,1118,559,
  	0,5573,5575,5,446,0,0,5574,5573,1,0,0,0,5574,5575,1,0,0,0,5575,5576,1,
  	0,0,0,5576,5577,3,1418,709,0,5577,5578,3,522,261,0,5578,5579,5,27,0,0,
  	5579,5580,5,391,0,0,5580,5582,1,0,0,0,5581,5572,1,0,0,0,5581,5574,1,0,
  	0,0,5582,641,1,0,0,0,5583,5586,3,632,316,0,5584,5585,7,28,0,0,5585,5587,
  	3,1164,582,0,5586,5584,1,0,0,0,5586,5587,1,0,0,0,5587,643,1,0,0,0,5588,
  	5589,3,632,316,0,5589,645,1,0,0,0,5590,5601,5,2,0,0,5591,5602,5,9,0,0,
  	5592,5602,3,648,324,0,5593,5594,5,121,0,0,5594,5595,5,185,0,0,5595,5602,
  	3,648,324,0,5596,5597,3,648,324,0,5597,5598,5,121,0,0,5598,5599,5,185,
  	0,0,5599,5600,3,648,324,0,5600,5602,1,0,0,0,5601,5591,1,0,0,0,5601,5592,
  	1,0,0,0,5601,5593,1,0,0,0,5601,5596,1,0,0,0,5602,5603,1,0,0,0,5603,5604,
  	5,3,0,0,5604,647,1,0,0,0,5605,5610,3,644,322,0,5606,5607,5,6,0,0,5607,
  	5609,3,644,322,0,5608,5606,1,0,0,0,5609,5612,1,0,0,0,5610,5608,1,0,0,
  	0,5610,5611,1,0,0,0,5611,649,1,0,0,0,5612,5610,1,0,0,0,5613,5614,3,1390,
  	695,0,5614,5615,3,646,323,0,5615,651,1,0,0,0,5616,5621,3,650,325,0,5617,
  	5618,5,6,0,0,5618,5620,3,650,325,0,5619,5617,1,0,0,0,5620,5623,1,0,0,
  	0,5621,5619,1,0,0,0,5621,5622,1,0,0,0,5622,653,1,0,0,0,5623,5621,1,0,
  	0,0,5624,5626,3,658,329,0,5625,5624,1,0,0,0,5626,5627,1,0,0,0,5627,5625,
  	1,0,0,0,5627,5628,1,0,0,0,5628,5629,1,0,0,0,5629,5630,6,327,-1,0,5630,
  	655,1,0,0,0,5631,5632,5,187,0,0,5632,5633,5,118,0,0,5633,5634,5,116,0,
  	0,5634,5667,5,496,0,0,5635,5636,5,347,0,0,5636,5637,5,116,0,0,5637,5638,
  	5,118,0,0,5638,5639,5,116,0,0,5639,5667,5,496,0,0,5640,5667,5,377,0,0,
  	5641,5667,5,260,0,0,5642,5667,5,369,0,0,5643,5667,5,408,0,0,5644,5645,
  	5,243,0,0,5645,5646,5,358,0,0,5646,5667,5,219,0,0,5647,5648,5,243,0,0,
  	5648,5649,5,358,0,0,5649,5667,5,272,0,0,5650,5651,5,358,0,0,5651,5667,
  	5,219,0,0,5652,5653,5,358,0,0,5653,5667,5,272,0,0,5654,5667,5,279,0,0,
  	5655,5656,5,115,0,0,5656,5667,5,279,0,0,5657,5658,5,208,0,0,5658,5667,
  	3,288,144,0,5659,5660,5,351,0,0,5660,5667,3,288,144,0,5661,5662,5,497,
  	0,0,5662,5667,3,520,260,0,5663,5667,3,78,39,0,5664,5665,5,498,0,0,5665,
  	5667,3,1416,708,0,5666,5631,1,0,0,0,5666,5635,1,0,0,0,5666,5640,1,0,0,
  	0,5666,5641,1,0,0,0,5666,5642,1,0,0,0,5666,5643,1,0,0,0,5666,5644,1,0,
  	0,0,5666,5647,1,0,0,0,5666,5650,1,0,0,0,5666,5652,1,0,0,0,5666,5654,1,
  	0,0,0,5666,5655,1,0,0,0,5666,5657,1,0,0,0,5666,5659,1,0,0,0,5666,5661,
  	1,0,0,0,5666,5663,1,0,0,0,5666,5664,1,0,0,0,5667,657,1,0,0,0,5668,5669,
  	5,74,0,0,5669,5677,3,660,330,0,5670,5671,5,276,0,0,5671,5677,3,68,34,
  	0,5672,5673,5,481,0,0,5673,5677,3,662,331,0,5674,5677,5,142,0,0,5675,
  	5677,3,656,328,0,5676,5668,1,0,0,0,5676,5670,1,0,0,0,5676,5672,1,0,0,
  	0,5676,5674,1,0,0,0,5676,5675,1,0,0,0,5677,659,1,0,0,0,5678,5684,3,1402,
  	701,0,5679,5680,3,1402,701,0,5680,5681,5,6,0,0,5681,5682,3,1402,701,0,
  	5682,5684,1,0,0,0,5683,5678,1,0,0,0,5683,5679,1,0,0,0,5684,661,1,0,0,
  	0,5685,5686,5,100,0,0,5686,5687,5,391,0,0,5687,5694,3,1118,559,0,5688,
  	5689,5,6,0,0,5689,5690,5,100,0,0,5690,5691,5,391,0,0,5691,5693,3,1118,
  	559,0,5692,5688,1,0,0,0,5693,5696,1,0,0,0,5694,5692,1,0,0,0,5694,5695,
  	1,0,0,0,5695,663,1,0,0,0,5696,5694,1,0,0,0,5697,5698,5,143,0,0,5698,5699,
  	3,456,228,0,5699,665,1,0,0,0,5700,5701,3,636,318,0,5701,5702,3,640,320,
  	0,5702,667,1,0,0,0,5703,5708,3,666,333,0,5704,5705,5,6,0,0,5705,5707,
  	3,666,333,0,5706,5704,1,0,0,0,5707,5710,1,0,0,0,5708,5706,1,0,0,0,5708,
  	5709,1,0,0,0,5709,669,1,0,0,0,5710,5708,1,0,0,0,5711,5712,5,176,0,0,5712,
  	5713,7,29,0,0,5713,5714,3,626,313,0,5714,5716,3,672,336,0,5715,5717,3,
  	674,337,0,5716,5715,1,0,0,0,5716,5717,1,0,0,0,5717,671,1,0,0,0,5718,5720,
  	3,656,328,0,5719,5718,1,0,0,0,5720,5721,1,0,0,0,5721,5719,1,0,0,0,5721,
  	5722,1,0,0,0,5722,673,1,0,0,0,5723,5724,5,346,0,0,5724,675,1,0,0,0,5725,
  	5726,5,229,0,0,5726,5727,5,249,0,0,5727,5729,3,624,312,0,5728,5730,3,
  	104,52,0,5729,5728,1,0,0,0,5729,5730,1,0,0,0,5730,5768,1,0,0,0,5731,5732,
  	5,229,0,0,5732,5733,5,249,0,0,5733,5734,5,258,0,0,5734,5735,5,427,0,0,
  	5735,5737,3,624,312,0,5736,5738,3,104,52,0,5737,5736,1,0,0,0,5737,5738,
  	1,0,0,0,5738,5768,1,0,0,0,5739,5740,5,229,0,0,5740,5741,5,327,0,0,5741,
  	5743,3,624,312,0,5742,5744,3,104,52,0,5743,5742,1,0,0,0,5743,5744,1,0,
  	0,0,5744,5768,1,0,0,0,5745,5746,5,229,0,0,5746,5747,5,327,0,0,5747,5748,
  	5,258,0,0,5748,5749,5,427,0,0,5749,5751,3,624,312,0,5750,5752,3,104,52,
  	0,5751,5750,1,0,0,0,5751,5752,1,0,0,0,5752,5768,1,0,0,0,5753,5754,5,229,
  	0,0,5754,5755,5,480,0,0,5755,5757,3,624,312,0,5756,5758,3,104,52,0,5757,
  	5756,1,0,0,0,5757,5758,1,0,0,0,5758,5768,1,0,0,0,5759,5760,5,229,0,0,
  	5760,5761,5,480,0,0,5761,5762,5,258,0,0,5762,5763,5,427,0,0,5763,5765,
  	3,624,312,0,5764,5766,3,104,52,0,5765,5764,1,0,0,0,5765,5766,1,0,0,0,
  	5766,5768,1,0,0,0,5767,5725,1,0,0,0,5767,5731,1,0,0,0,5767,5739,1,0,0,
  	0,5767,5745,1,0,0,0,5767,5753,1,0,0,0,5767,5759,1,0,0,0,5768,677,1,0,
  	0,0,5769,5770,5,229,0,0,5770,5771,5,174,0,0,5771,5773,3,652,326,0,5772,
  	5774,3,104,52,0,5773,5772,1,0,0,0,5773,5774,1,0,0,0,5774,5784,1,0,0,0,
  	5775,5776,5,229,0,0,5776,5777,5,174,0,0,5777,5778,5,258,0,0,5778,5779,
  	5,427,0,0,5779,5781,3,652,326,0,5780,5782,3,104,52,0,5781,5780,1,0,0,
  	0,5781,5782,1,0,0,0,5782,5784,1,0,0,0,5783,5769,1,0,0,0,5783,5775,1,0,
  	0,0,5784,679,1,0,0,0,5785,5786,5,229,0,0,5786,5787,5,309,0,0,5787,5789,
  	3,686,343,0,5788,5790,3,104,52,0,5789,5788,1,0,0,0,5789,5790,1,0,0,0,
  	5790,5800,1,0,0,0,5791,5792,5,229,0,0,5792,5793,5,309,0,0,5793,5794,5,
  	258,0,0,5794,5795,5,427,0,0,5795,5797,3,686,343,0,5796,5798,3,104,52,
  	0,5797,5796,1,0,0,0,5797,5798,1,0,0,0,5798,5800,1,0,0,0,5799,5785,1,0,
  	0,0,5799,5791,1,0,0,0,5800,681,1,0,0,0,5801,5802,5,2,0,0,5802,5803,3,
  	1118,559,0,5803,5804,5,3,0,0,5804,5824,1,0,0,0,5805,5806,5,2,0,0,5806,
  	5807,3,1118,559,0,5807,5808,5,6,0,0,5808,5809,3,1118,559,0,5809,5810,
  	5,3,0,0,5810,5824,1,0,0,0,5811,5812,5,2,0,0,5812,5813,5,438,0,0,5813,
  	5814,5,6,0,0,5814,5815,3,1118,559,0,5815,5816,5,3,0,0,5816,5824,1,0,0,
  	0,5817,5818,5,2,0,0,5818,5819,3,1118,559,0,5819,5820,5,6,0,0,5820,5821,
  	5,438,0,0,5821,5822,5,3,0,0,5822,5824,1,0,0,0,5823,5801,1,0,0,0,5823,
  	5805,1,0,0,0,5823,5811,1,0,0,0,5823,5817,1,0,0,0,5824,683,1,0,0,0,5825,
  	5826,3,1416,708,0,5826,5827,5,11,0,0,5827,5829,1,0,0,0,5828,5825,1,0,
  	0,0,5829,5832,1,0,0,0,5830,5828,1,0,0,0,5830,5831,1,0,0,0,5831,5833,1,
  	0,0,0,5832,5830,1,0,0,0,5833,5834,3,1272,636,0,5834,685,1,0,0,0,5835,
  	5840,3,688,344,0,5836,5837,5,6,0,0,5837,5839,3,688,344,0,5838,5836,1,
  	0,0,0,5839,5842,1,0,0,0,5840,5838,1,0,0,0,5840,5841,1,0,0,0,5841,687,
  	1,0,0,0,5842,5840,1,0,0,0,5843,5844,3,684,342,0,5844,5845,3,682,341,0,
  	5845,689,1,0,0,0,5846,5847,5,95,0,0,5847,5848,3,692,346,0,5848,691,1,
  	0,0,0,5849,5851,3,694,347,0,5850,5849,1,0,0,0,5851,5852,1,0,0,0,5852,
  	5850,1,0,0,0,5852,5853,1,0,0,0,5853,693,1,0,0,0,5854,5858,3,1402,701,
  	0,5855,5856,5,276,0,0,5856,5858,3,68,34,0,5857,5854,1,0,0,0,5857,5855,
  	1,0,0,0,5858,695,1,0,0,0,5859,5860,5,84,0,0,5860,5861,5,79,0,0,5861,5862,
  	5,2,0,0,5862,5863,3,1118,559,0,5863,5864,5,74,0,0,5864,5865,3,1118,559,
  	0,5865,5866,5,3,0,0,5866,5867,5,143,0,0,5867,5868,5,249,0,0,5868,5870,
  	3,626,313,0,5869,5871,3,698,349,0,5870,5869,1,0,0,0,5870,5871,1,0,0,0,
  	5871,5897,1,0,0,0,5872,5873,5,84,0,0,5873,5874,5,79,0,0,5874,5875,5,2,
  	0,0,5875,5876,3,1118,559,0,5876,5877,5,74,0,0,5877,5878,3,1118,559,0,
  	5878,5879,5,3,0,0,5879,5880,5,410,0,0,5880,5882,5,249,0,0,5881,5883,3,
  	698,349,0,5882,5881,1,0,0,0,5882,5883,1,0,0,0,5883,5897,1,0,0,0,5884,
  	5885,5,84,0,0,5885,5886,5,79,0,0,5886,5887,5,2,0,0,5887,5888,3,1118,559,
  	0,5888,5889,5,74,0,0,5889,5890,3,1118,559,0,5890,5891,5,3,0,0,5891,5892,
  	5,143,0,0,5892,5894,5,431,0,0,5893,5895,3,698,349,0,5894,5893,1,0,0,0,
  	5894,5895,1,0,0,0,5895,5897,1,0,0,0,5896,5859,1,0,0,0,5896,5872,1,0,0,
  	0,5896,5884,1,0,0,0,5897,697,1,0,0,0,5898,5899,5,74,0,0,5899,5903,5,261,
  	0,0,5900,5901,5,74,0,0,5901,5903,5,179,0,0,5902,5898,1,0,0,0,5902,5900,
  	1,0,0,0,5903,699,1,0,0,0,5904,5905,5,229,0,0,5905,5907,5,79,0,0,5906,
  	5908,3,702,351,0,5907,5906,1,0,0,0,5907,5908,1,0,0,0,5908,5909,1,0,0,
  	0,5909,5910,5,2,0,0,5910,5911,3,1118,559,0,5911,5912,5,74,0,0,5912,5913,
  	3,1118,559,0,5913,5915,5,3,0,0,5914,5916,3,104,52,0,5915,5914,1,0,0,0,
  	5915,5916,1,0,0,0,5916,701,1,0,0,0,5917,5918,5,258,0,0,5918,5919,5,427,
  	0,0,5919,703,1,0,0,0,5920,5922,5,84,0,0,5921,5923,3,618,309,0,5922,5921,
  	1,0,0,0,5922,5923,1,0,0,0,5923,5924,1,0,0,0,5924,5925,5,481,0,0,5925,
  	5926,5,100,0,0,5926,5927,3,1118,559,0,5927,5928,5,276,0,0,5928,5929,3,
  	1384,692,0,5929,5930,5,2,0,0,5930,5931,3,706,353,0,5931,5932,5,3,0,0,
  	5932,705,1,0,0,0,5933,5934,5,102,0,0,5934,5935,5,499,0,0,5935,5936,5,
  	143,0,0,5936,5937,5,249,0,0,5937,5938,3,626,313,0,5938,5939,5,6,0,0,5939,
  	5940,5,132,0,0,5940,5941,5,499,0,0,5941,5942,5,143,0,0,5942,5943,5,249,
  	0,0,5943,5944,3,626,313,0,5944,5968,1,0,0,0,5945,5946,5,132,0,0,5946,
  	5947,5,499,0,0,5947,5948,5,143,0,0,5948,5949,5,249,0,0,5949,5950,3,626,
  	313,0,5950,5951,5,6,0,0,5951,5952,5,102,0,0,5952,5953,5,499,0,0,5953,
  	5954,5,143,0,0,5954,5955,5,249,0,0,5955,5956,3,626,313,0,5956,5968,1,
  	0,0,0,5957,5958,5,102,0,0,5958,5959,5,499,0,0,5959,5960,5,143,0,0,5960,
  	5961,5,249,0,0,5961,5968,3,626,313,0,5962,5963,5,132,0,0,5963,5964,5,
  	499,0,0,5964,5965,5,143,0,0,5965,5966,5,249,0,0,5966,5968,3,626,313,0,
  	5967,5933,1,0,0,0,5967,5945,1,0,0,0,5967,5957,1,0,0,0,5967,5962,1,0,0,
  	0,5968,707,1,0,0,0,5969,5970,5,229,0,0,5970,5972,5,481,0,0,5971,5973,
  	3,702,351,0,5972,5971,1,0,0,0,5972,5973,1,0,0,0,5973,5974,1,0,0,0,5974,
  	5975,5,100,0,0,5975,5976,3,1118,559,0,5976,5977,5,276,0,0,5977,5979,3,
  	1384,692,0,5978,5980,3,104,52,0,5979,5978,1,0,0,0,5979,5980,1,0,0,0,5980,
  	709,1,0,0,0,5981,5983,5,337,0,0,5982,5984,3,716,358,0,5983,5982,1,0,0,
  	0,5983,5984,1,0,0,0,5984,5985,1,0,0,0,5985,5987,3,712,356,0,5986,5988,
  	3,592,296,0,5987,5986,1,0,0,0,5987,5988,1,0,0,0,5988,5989,1,0,0,0,5989,
  	5990,3,1380,690,0,5990,6012,1,0,0,0,5991,5993,5,337,0,0,5992,5994,3,716,
  	358,0,5993,5992,1,0,0,0,5993,5994,1,0,0,0,5994,5995,1,0,0,0,5995,5997,
  	5,354,0,0,5996,5998,3,592,296,0,5997,5996,1,0,0,0,5997,5998,1,0,0,0,5998,
  	5999,1,0,0,0,5999,6012,3,1384,692,0,6000,6002,5,337,0,0,6001,6003,3,716,
  	358,0,6002,6001,1,0,0,0,6002,6003,1,0,0,0,6003,6004,1,0,0,0,6004,6006,
  	3,714,357,0,6005,6007,3,592,296,0,6006,6005,1,0,0,0,6006,6007,1,0,0,0,
  	6007,6009,1,0,0,0,6008,6010,3,590,295,0,6009,6008,1,0,0,0,6009,6010,1,
  	0,0,0,6010,6012,1,0,0,0,6011,5981,1,0,0,0,6011,5991,1,0,0,0,6011,6000,
  	1,0,0,0,6012,711,1,0,0,0,6013,6014,7,19,0,0,6014,713,1,0,0,0,6015,6016,
  	7,30,0,0,6016,715,1,0,0,0,6017,6018,5,2,0,0,6018,6019,3,850,425,0,6019,
  	6020,5,3,0,0,6020,717,1,0,0,0,6021,6022,5,176,0,0,6022,6023,5,382,0,0,
  	6023,6024,3,1384,692,0,6024,6025,5,364,0,0,6025,6026,3,112,56,0,6026,
  	6034,1,0,0,0,6027,6028,5,176,0,0,6028,6029,5,382,0,0,6029,6030,3,1384,
  	692,0,6030,6031,5,344,0,0,6031,6032,3,112,56,0,6032,6034,1,0,0,0,6033,
  	6021,1,0,0,0,6033,6027,1,0,0,0,6034,719,1,0,0,0,6035,6036,5,176,0,0,6036,
  	6037,5,174,0,0,6037,6038,3,650,325,0,6038,6039,5,340,0,0,6039,6040,5,
  	132,0,0,6040,6041,3,1384,692,0,6041,6523,1,0,0,0,6042,6043,5,176,0,0,
  	6043,6044,5,146,0,0,6044,6045,3,520,260,0,6045,6046,5,340,0,0,6046,6047,
  	5,132,0,0,6047,6048,3,1384,692,0,6048,6523,1,0,0,0,6049,6050,5,176,0,
  	0,6050,6051,5,206,0,0,6051,6052,3,520,260,0,6052,6053,5,340,0,0,6053,
  	6054,5,132,0,0,6054,6055,3,1384,692,0,6055,6523,1,0,0,0,6056,6057,5,176,
  	0,0,6057,6058,5,213,0,0,6058,6059,3,1384,692,0,6059,6060,5,340,0,0,6060,
  	6061,5,132,0,0,6061,6062,3,1384,692,0,6062,6523,1,0,0,0,6063,6064,5,176,
  	0,0,6064,6065,5,227,0,0,6065,6066,3,520,260,0,6066,6067,5,340,0,0,6067,
  	6068,5,132,0,0,6068,6069,3,1384,692,0,6069,6523,1,0,0,0,6070,6071,5,176,
  	0,0,6071,6072,5,227,0,0,6072,6073,3,520,260,0,6073,6074,5,340,0,0,6074,
  	6075,5,83,0,0,6075,6076,3,1384,692,0,6076,6077,5,132,0,0,6077,6078,3,
  	1384,692,0,6078,6523,1,0,0,0,6079,6080,5,176,0,0,6080,6081,5,101,0,0,
  	6081,6082,5,212,0,0,6082,6083,5,412,0,0,6083,6084,3,1384,692,0,6084,6085,
  	5,340,0,0,6085,6086,5,132,0,0,6086,6087,3,1384,692,0,6087,6523,1,0,0,
  	0,6088,6089,5,176,0,0,6089,6090,5,249,0,0,6090,6091,3,626,313,0,6091,
  	6092,5,340,0,0,6092,6093,5,132,0,0,6093,6094,3,1384,692,0,6094,6523,1,
  	0,0,0,6095,6096,5,176,0,0,6096,6097,5,104,0,0,6097,6098,3,1410,705,0,
  	6098,6099,5,340,0,0,6099,6100,5,132,0,0,6100,6101,3,1410,705,0,6101,6523,
  	1,0,0,0,6102,6104,5,176,0,0,6103,6105,3,304,152,0,6104,6103,1,0,0,0,6104,
  	6105,1,0,0,0,6105,6106,1,0,0,0,6106,6107,5,276,0,0,6107,6108,3,1384,692,
  	0,6108,6109,5,340,0,0,6109,6110,5,132,0,0,6110,6111,3,1384,692,0,6111,
  	6523,1,0,0,0,6112,6113,5,176,0,0,6113,6114,5,309,0,0,6114,6115,5,194,
  	0,0,6115,6116,3,520,260,0,6116,6117,5,138,0,0,6117,6118,3,1384,692,0,
  	6118,6119,5,340,0,0,6119,6120,5,132,0,0,6120,6121,3,1384,692,0,6121,6523,
  	1,0,0,0,6122,6123,5,176,0,0,6123,6124,5,309,0,0,6124,6125,5,244,0,0,6125,
  	6126,3,520,260,0,6126,6127,5,138,0,0,6127,6128,3,1384,692,0,6128,6129,
  	5,340,0,0,6129,6130,5,132,0,0,6130,6131,3,1384,692,0,6131,6523,1,0,0,
  	0,6132,6133,5,176,0,0,6133,6134,5,483,0,0,6134,6135,3,1384,692,0,6135,
  	6136,5,118,0,0,6136,6137,3,1380,690,0,6137,6138,5,340,0,0,6138,6139,5,
  	132,0,0,6139,6140,3,1384,692,0,6140,6523,1,0,0,0,6141,6142,5,176,0,0,
  	6142,6143,5,483,0,0,6143,6144,5,258,0,0,6144,6145,5,427,0,0,6145,6146,
  	3,1384,692,0,6146,6147,5,118,0,0,6147,6148,3,1380,690,0,6148,6149,5,340,
  	0,0,6149,6150,5,132,0,0,6150,6151,3,1384,692,0,6151,6523,1,0,0,0,6152,
  	6153,5,176,0,0,6153,6154,5,327,0,0,6154,6155,3,626,313,0,6155,6156,5,
  	340,0,0,6156,6157,5,132,0,0,6157,6158,3,1384,692,0,6158,6523,1,0,0,0,
  	6159,6160,5,176,0,0,6160,6161,5,490,0,0,6161,6162,3,1384,692,0,6162,6163,
  	5,340,0,0,6163,6164,5,132,0,0,6164,6165,3,1384,692,0,6165,6523,1,0,0,
  	0,6166,6167,5,176,0,0,6167,6168,5,480,0,0,6168,6169,3,626,313,0,6169,
  	6170,5,340,0,0,6170,6171,5,132,0,0,6171,6172,3,1384,692,0,6172,6523,1,
  	0,0,0,6173,6174,5,176,0,0,6174,6175,5,354,0,0,6175,6176,3,1384,692,0,
  	6176,6177,5,340,0,0,6177,6178,5,132,0,0,6178,6179,3,1384,692,0,6179,6523,
  	1,0,0,0,6180,6181,5,176,0,0,6181,6182,5,362,0,0,6182,6183,3,1384,692,
  	0,6183,6184,5,340,0,0,6184,6185,5,132,0,0,6185,6186,3,1384,692,0,6186,
  	6523,1,0,0,0,6187,6188,5,176,0,0,6188,6189,5,489,0,0,6189,6190,3,1384,
  	692,0,6190,6191,5,340,0,0,6191,6192,5,132,0,0,6192,6193,3,1384,692,0,
  	6193,6523,1,0,0,0,6194,6195,5,176,0,0,6195,6196,5,130,0,0,6196,6197,3,
  	1074,537,0,6197,6198,5,340,0,0,6198,6199,5,132,0,0,6199,6200,3,1384,692,
  	0,6200,6523,1,0,0,0,6201,6202,5,176,0,0,6202,6203,5,130,0,0,6203,6204,
  	5,258,0,0,6204,6205,5,427,0,0,6205,6206,3,1074,537,0,6206,6207,5,340,
  	0,0,6207,6208,5,132,0,0,6208,6209,3,1384,692,0,6209,6523,1,0,0,0,6210,
  	6211,5,176,0,0,6211,6212,5,359,0,0,6212,6213,3,1380,690,0,6213,6214,5,
  	340,0,0,6214,6215,5,132,0,0,6215,6216,3,1384,692,0,6216,6523,1,0,0,0,
  	6217,6218,5,176,0,0,6218,6219,5,359,0,0,6219,6220,5,258,0,0,6220,6221,
  	5,427,0,0,6221,6222,3,1380,690,0,6222,6223,5,340,0,0,6223,6224,5,132,
  	0,0,6224,6225,3,1384,692,0,6225,6523,1,0,0,0,6226,6227,5,176,0,0,6227,
  	6228,5,407,0,0,6228,6229,3,1380,690,0,6229,6230,5,340,0,0,6230,6231,5,
  	132,0,0,6231,6232,3,1384,692,0,6232,6523,1,0,0,0,6233,6234,5,176,0,0,
  	6234,6235,5,407,0,0,6235,6236,5,258,0,0,6236,6237,5,427,0,0,6237,6238,
  	3,1380,690,0,6238,6239,5,340,0,0,6239,6240,5,132,0,0,6240,6241,3,1384,
  	692,0,6241,6523,1,0,0,0,6242,6243,5,176,0,0,6243,6244,5,289,0,0,6244,
  	6245,5,407,0,0,6245,6246,3,1380,690,0,6246,6247,5,340,0,0,6247,6248,5,
  	132,0,0,6248,6249,3,1384,692,0,6249,6523,1,0,0,0,6250,6251,5,176,0,0,
  	6251,6252,5,289,0,0,6252,6253,5,407,0,0,6253,6254,5,258,0,0,6254,6255,
  	5,427,0,0,6255,6256,3,1380,690,0,6256,6257,5,340,0,0,6257,6258,5,132,
  	0,0,6258,6259,3,1384,692,0,6259,6523,1,0,0,0,6260,6261,5,176,0,0,6261,
  	6262,5,264,0,0,6262,6263,3,1380,690,0,6263,6264,5,340,0,0,6264,6265,5,
  	132,0,0,6265,6266,3,1384,692,0,6266,6523,1,0,0,0,6267,6268,5,176,0,0,
  	6268,6269,5,264,0,0,6269,6270,5,258,0,0,6270,6271,5,427,0,0,6271,6272,
  	3,1380,690,0,6272,6273,5,340,0,0,6273,6274,5,132,0,0,6274,6275,3,1384,
  	692,0,6275,6523,1,0,0,0,6276,6277,5,176,0,0,6277,6278,5,101,0,0,6278,
  	6279,5,130,0,0,6279,6280,3,1074,537,0,6280,6281,5,340,0,0,6281,6282,5,
  	132,0,0,6282,6283,3,1384,692,0,6283,6523,1,0,0,0,6284,6285,5,176,0,0,
  	6285,6286,5,101,0,0,6286,6287,5,130,0,0,6287,6288,5,258,0,0,6288,6289,
  	5,427,0,0,6289,6290,3,1074,537,0,6290,6291,5,340,0,0,6291,6292,5,132,
  	0,0,6292,6293,3,1384,692,0,6293,6523,1,0,0,0,6294,6295,5,176,0,0,6295,
  	6296,5,130,0,0,6296,6297,3,1074,537,0,6297,6299,5,340,0,0,6298,6300,3,
  	722,361,0,6299,6298,1,0,0,0,6299,6300,1,0,0,0,6300,6301,1,0,0,0,6301,
  	6302,3,1384,692,0,6302,6303,5,132,0,0,6303,6304,3,1384,692,0,6304,6523,
  	1,0,0,0,6305,6306,5,176,0,0,6306,6307,5,130,0,0,6307,6308,5,258,0,0,6308,
  	6309,5,427,0,0,6309,6310,3,1074,537,0,6310,6312,5,340,0,0,6311,6313,3,
  	722,361,0,6312,6311,1,0,0,0,6312,6313,1,0,0,0,6313,6314,1,0,0,0,6314,
  	6315,3,1384,692,0,6315,6316,5,132,0,0,6316,6317,3,1384,692,0,6317,6523,
  	1,0,0,0,6318,6319,5,176,0,0,6319,6320,5,407,0,0,6320,6321,3,1380,690,
  	0,6321,6323,5,340,0,0,6322,6324,3,722,361,0,6323,6322,1,0,0,0,6323,6324,
  	1,0,0,0,6324,6325,1,0,0,0,6325,6326,3,1384,692,0,6326,6327,5,132,0,0,
  	6327,6328,3,1384,692,0,6328,6523,1,0,0,0,6329,6330,5,176,0,0,6330,6331,
  	5,407,0,0,6331,6332,5,258,0,0,6332,6333,5,427,0,0,6333,6334,3,1380,690,
  	0,6334,6336,5,340,0,0,6335,6337,3,722,361,0,6336,6335,1,0,0,0,6336,6337,
  	1,0,0,0,6337,6338,1,0,0,0,6338,6339,3,1384,692,0,6339,6340,5,132,0,0,
  	6340,6341,3,1384,692,0,6341,6523,1,0,0,0,6342,6343,5,176,0,0,6343,6344,
  	5,289,0,0,6344,6345,5,407,0,0,6345,6346,3,1380,690,0,6346,6348,5,340,
  	0,0,6347,6349,3,722,361,0,6348,6347,1,0,0,0,6348,6349,1,0,0,0,6349,6350,
  	1,0,0,0,6350,6351,3,1384,692,0,6351,6352,5,132,0,0,6352,6353,3,1384,692,
  	0,6353,6523,1,0,0,0,6354,6355,5,176,0,0,6355,6356,5,289,0,0,6356,6357,
  	5,407,0,0,6357,6358,5,258,0,0,6358,6359,5,427,0,0,6359,6360,3,1380,690,
  	0,6360,6362,5,340,0,0,6361,6363,3,722,361,0,6362,6361,1,0,0,0,6362,6363,
  	1,0,0,0,6363,6364,1,0,0,0,6364,6365,3,1384,692,0,6365,6366,5,132,0,0,
  	6366,6367,3,1384,692,0,6367,6523,1,0,0,0,6368,6369,5,176,0,0,6369,6370,
  	5,130,0,0,6370,6371,3,1074,537,0,6371,6372,5,340,0,0,6372,6373,5,83,0,
  	0,6373,6374,3,1384,692,0,6374,6375,5,132,0,0,6375,6376,3,1384,692,0,6376,
  	6523,1,0,0,0,6377,6378,5,176,0,0,6378,6379,5,130,0,0,6379,6380,5,258,
  	0,0,6380,6381,5,427,0,0,6381,6382,3,1074,537,0,6382,6383,5,340,0,0,6383,
  	6384,5,83,0,0,6384,6385,3,1384,692,0,6385,6386,5,132,0,0,6386,6387,3,
  	1384,692,0,6387,6523,1,0,0,0,6388,6389,5,176,0,0,6389,6390,5,101,0,0,
  	6390,6391,5,130,0,0,6391,6392,3,1074,537,0,6392,6394,5,340,0,0,6393,6395,
  	3,722,361,0,6394,6393,1,0,0,0,6394,6395,1,0,0,0,6395,6396,1,0,0,0,6396,
  	6397,3,1384,692,0,6397,6398,5,132,0,0,6398,6399,3,1384,692,0,6399,6523,
  	1,0,0,0,6400,6401,5,176,0,0,6401,6402,5,101,0,0,6402,6403,5,130,0,0,6403,
  	6404,5,258,0,0,6404,6405,5,427,0,0,6405,6406,3,1074,537,0,6406,6408,5,
  	340,0,0,6407,6409,3,722,361,0,6408,6407,1,0,0,0,6408,6409,1,0,0,0,6409,
  	6410,1,0,0,0,6410,6411,3,1384,692,0,6411,6412,5,132,0,0,6412,6413,3,1384,
  	692,0,6413,6523,1,0,0,0,6414,6415,5,176,0,0,6415,6416,5,352,0,0,6416,
  	6417,3,1384,692,0,6417,6418,5,118,0,0,6418,6419,3,1380,690,0,6419,6420,
  	5,340,0,0,6420,6421,5,132,0,0,6421,6422,3,1384,692,0,6422,6523,1,0,0,
  	0,6423,6424,5,176,0,0,6424,6425,5,388,0,0,6425,6426,3,1384,692,0,6426,
  	6427,5,118,0,0,6427,6428,3,1380,690,0,6428,6429,5,340,0,0,6429,6430,5,
  	132,0,0,6430,6431,3,1384,692,0,6431,6523,1,0,0,0,6432,6433,5,176,0,0,
  	6433,6434,5,236,0,0,6434,6435,5,388,0,0,6435,6436,3,1384,692,0,6436,6437,
  	5,340,0,0,6437,6438,5,132,0,0,6438,6439,3,1384,692,0,6439,6523,1,0,0,
  	0,6440,6441,5,176,0,0,6441,6442,5,349,0,0,6442,6443,3,1410,705,0,6443,
  	6444,5,340,0,0,6444,6445,5,132,0,0,6445,6446,3,1410,705,0,6446,6523,1,
  	0,0,0,6447,6448,5,176,0,0,6448,6449,5,137,0,0,6449,6450,3,1410,705,0,
  	6450,6451,5,340,0,0,6451,6452,5,132,0,0,6452,6453,3,1410,705,0,6453,6523,
  	1,0,0,0,6454,6455,5,176,0,0,6455,6456,5,382,0,0,6456,6457,3,1384,692,
  	0,6457,6458,5,340,0,0,6458,6459,5,132,0,0,6459,6460,3,1384,692,0,6460,
  	6523,1,0,0,0,6461,6462,5,176,0,0,6462,6463,5,373,0,0,6463,6464,3,520,
  	260,0,6464,6465,5,340,0,0,6465,6466,5,132,0,0,6466,6467,3,1384,692,0,
  	6467,6523,1,0,0,0,6468,6469,5,176,0,0,6469,6470,5,386,0,0,6470,6471,5,
  	356,0,0,6471,6472,5,314,0,0,6472,6473,3,520,260,0,6473,6474,5,340,0,0,
  	6474,6475,5,132,0,0,6475,6476,3,1384,692,0,6476,6523,1,0,0,0,6477,6478,
  	5,176,0,0,6478,6479,5,386,0,0,6479,6480,5,356,0,0,6480,6481,5,223,0,0,
  	6481,6482,3,520,260,0,6482,6483,5,340,0,0,6483,6484,5,132,0,0,6484,6485,
  	3,1384,692,0,6485,6523,1,0,0,0,6486,6487,5,176,0,0,6487,6488,5,386,0,
  	0,6488,6489,5,356,0,0,6489,6490,5,384,0,0,6490,6491,3,520,260,0,6491,
  	6492,5,340,0,0,6492,6493,5,132,0,0,6493,6494,3,1384,692,0,6494,6523,1,
  	0,0,0,6495,6496,5,176,0,0,6496,6497,5,386,0,0,6497,6498,5,356,0,0,6498,
  	6499,5,201,0,0,6499,6500,3,520,260,0,6500,6501,5,340,0,0,6501,6502,5,
  	132,0,0,6502,6503,3,1384,692,0,6503,6523,1,0,0,0,6504,6505,5,176,0,0,
  	6505,6506,5,391,0,0,6506,6507,3,520,260,0,6507,6508,5,340,0,0,6508,6509,
  	5,132,0,0,6509,6510,3,1384,692,0,6510,6523,1,0,0,0,6511,6512,5,176,0,
  	0,6512,6513,5,391,0,0,6513,6514,3,520,260,0,6514,6515,5,340,0,0,6515,
  	6516,5,181,0,0,6516,6517,3,1384,692,0,6517,6518,5,132,0,0,6518,6520,3,
  	1384,692,0,6519,6521,3,104,52,0,6520,6519,1,0,0,0,6520,6521,1,0,0,0,6521,
  	6523,1,0,0,0,6522,6035,1,0,0,0,6522,6042,1,0,0,0,6522,6049,1,0,0,0,6522,
  	6056,1,0,0,0,6522,6063,1,0,0,0,6522,6070,1,0,0,0,6522,6079,1,0,0,0,6522,
  	6088,1,0,0,0,6522,6095,1,0,0,0,6522,6102,1,0,0,0,6522,6112,1,0,0,0,6522,
  	6122,1,0,0,0,6522,6132,1,0,0,0,6522,6141,1,0,0,0,6522,6152,1,0,0,0,6522,
  	6159,1,0,0,0,6522,6166,1,0,0,0,6522,6173,1,0,0,0,6522,6180,1,0,0,0,6522,
  	6187,1,0,0,0,6522,6194,1,0,0,0,6522,6201,1,0,0,0,6522,6210,1,0,0,0,6522,
  	6217,1,0,0,0,6522,6226,1,0,0,0,6522,6233,1,0,0,0,6522,6242,1,0,0,0,6522,
  	6250,1,0,0,0,6522,6260,1,0,0,0,6522,6267,1,0,0,0,6522,6276,1,0,0,0,6522,
  	6284,1,0,0,0,6522,6294,1,0,0,0,6522,6305,1,0,0,0,6522,6318,1,0,0,0,6522,
  	6329,1,0,0,0,6522,6342,1,0,0,0,6522,6354,1,0,0,0,6522,6368,1,0,0,0,6522,
  	6377,1,0,0,0,6522,6388,1,0,0,0,6522,6400,1,0,0,0,6522,6414,1,0,0,0,6522,
  	6423,1,0,0,0,6522,6432,1,0,0,0,6522,6440,1,0,0,0,6522,6447,1,0,0,0,6522,
  	6454,1,0,0,0,6522,6461,1,0,0,0,6522,6468,1,0,0,0,6522,6477,1,0,0,0,6522,
  	6486,1,0,0,0,6522,6495,1,0,0,0,6522,6504,1,0,0,0,6522,6511,1,0,0,0,6523,
  	721,1,0,0,0,6524,6525,5,82,0,0,6525,723,1,0,0,0,6526,6527,5,364,0,0,6527,
  	6528,5,212,0,0,6528,725,1,0,0,0,6529,6530,5,176,0,0,6530,6531,5,249,0,
  	0,6531,6533,3,626,313,0,6532,6534,3,728,364,0,6533,6532,1,0,0,0,6533,
  	6534,1,0,0,0,6534,6535,1,0,0,0,6535,6536,5,500,0,0,6536,6537,5,118,0,
  	0,6537,6538,5,242,0,0,6538,6539,3,1384,692,0,6539,6599,1,0,0,0,6540,6541,
  	5,176,0,0,6541,6542,5,327,0,0,6542,6544,3,626,313,0,6543,6545,3,728,364,
  	0,6544,6543,1,0,0,0,6544,6545,1,0,0,0,6545,6546,1,0,0,0,6546,6547,5,500,
  	0,0,6547,6548,5,118,0,0,6548,6549,5,242,0,0,6549,6550,3,1384,692,0,6550,
  	6599,1,0,0,0,6551,6552,5,176,0,0,6552,6553,5,480,0,0,6553,6555,3,626,
  	313,0,6554,6556,3,728,364,0,6555,6554,1,0,0,0,6555,6556,1,0,0,0,6556,
  	6557,1,0,0,0,6557,6558,5,500,0,0,6558,6559,5,118,0,0,6559,6560,5,242,
  	0,0,6560,6561,3,1384,692,0,6561,6599,1,0,0,0,6562,6563,5,176,0,0,6563,
  	6564,5,388,0,0,6564,6565,3,1384,692,0,6565,6566,5,118,0,0,6566,6568,3,
  	1380,690,0,6567,6569,3,728,364,0,6568,6567,1,0,0,0,6568,6569,1,0,0,0,
  	6569,6570,1,0,0,0,6570,6571,5,500,0,0,6571,6572,5,118,0,0,6572,6573,5,
  	242,0,0,6573,6574,3,1384,692,0,6574,6599,1,0,0,0,6575,6576,5,176,0,0,
  	6576,6577,5,289,0,0,6577,6578,5,407,0,0,6578,6580,3,1380,690,0,6579,6581,
  	3,728,364,0,6580,6579,1,0,0,0,6580,6581,1,0,0,0,6581,6582,1,0,0,0,6582,
  	6583,5,500,0,0,6583,6584,5,118,0,0,6584,6585,5,242,0,0,6585,6586,3,1384,
  	692,0,6586,6599,1,0,0,0,6587,6588,5,176,0,0,6588,6589,5,264,0,0,6589,
  	6591,3,1380,690,0,6590,6592,3,728,364,0,6591,6590,1,0,0,0,6591,6592,1,
  	0,0,0,6592,6593,1,0,0,0,6593,6594,5,500,0,0,6594,6595,5,118,0,0,6595,
  	6596,5,242,0,0,6596,6597,3,1384,692,0,6597,6599,1,0,0,0,6598,6529,1,0,
  	0,0,6598,6540,1,0,0,0,6598,6551,1,0,0,0,6598,6562,1,0,0,0,6598,6575,1,
  	0,0,0,6598,6587,1,0,0,0,6599,727,1,0,0,0,6600,6601,5,300,0,0,6601,729,
  	1,0,0,0,6602,6603,5,176,0,0,6603,6604,5,174,0,0,6604,6605,3,650,325,0,
  	6605,6606,5,364,0,0,6606,6607,5,354,0,0,6607,6608,3,1384,692,0,6608,6820,
  	1,0,0,0,6609,6610,5,176,0,0,6610,6611,5,146,0,0,6611,6612,3,520,260,0,
  	6612,6613,5,364,0,0,6613,6614,5,354,0,0,6614,6615,3,1384,692,0,6615,6820,
  	1,0,0,0,6616,6617,5,176,0,0,6617,6618,5,206,0,0,6618,6619,3,520,260,0,
  	6619,6620,5,364,0,0,6620,6621,5,354,0,0,6621,6622,3,1384,692,0,6622,6820,
  	1,0,0,0,6623,6624,5,176,0,0,6624,6625,5,227,0,0,6625,6626,3,520,260,0,
  	6626,6627,5,364,0,0,6627,6628,5,354,0,0,6628,6629,3,1384,692,0,6629,6820,
  	1,0,0,0,6630,6631,5,176,0,0,6631,6632,5,242,0,0,6632,6633,3,1384,692,
  	0,6633,6634,5,364,0,0,6634,6635,5,354,0,0,6635,6636,3,1384,692,0,6636,
  	6820,1,0,0,0,6637,6638,5,176,0,0,6638,6639,5,249,0,0,6639,6640,3,626,
  	313,0,6640,6641,5,364,0,0,6641,6642,5,354,0,0,6642,6643,3,1384,692,0,
  	6643,6820,1,0,0,0,6644,6645,5,176,0,0,6645,6646,5,309,0,0,6646,6647,3,
  	688,344,0,6647,6648,5,364,0,0,6648,6649,5,354,0,0,6649,6650,3,1384,692,
  	0,6650,6820,1,0,0,0,6651,6652,5,176,0,0,6652,6653,5,309,0,0,6653,6654,
  	5,194,0,0,6654,6655,3,520,260,0,6655,6656,5,138,0,0,6656,6657,3,1384,
  	692,0,6657,6658,5,364,0,0,6658,6659,5,354,0,0,6659,6660,3,1384,692,0,
  	6660,6820,1,0,0,0,6661,6662,5,176,0,0,6662,6663,5,309,0,0,6663,6664,5,
  	244,0,0,6664,6665,3,520,260,0,6665,6666,5,138,0,0,6666,6667,3,1384,692,
  	0,6667,6668,5,364,0,0,6668,6669,5,354,0,0,6669,6670,3,1384,692,0,6670,
  	6820,1,0,0,0,6671,6672,5,176,0,0,6672,6673,5,327,0,0,6673,6674,3,626,
  	313,0,6674,6675,5,364,0,0,6675,6676,5,354,0,0,6676,6677,3,1384,692,0,
  	6677,6820,1,0,0,0,6678,6679,5,176,0,0,6679,6680,5,480,0,0,6680,6681,3,
  	626,313,0,6681,6682,5,364,0,0,6682,6683,5,354,0,0,6683,6684,3,1384,692,
  	0,6684,6820,1,0,0,0,6685,6686,5,176,0,0,6686,6687,5,130,0,0,6687,6688,
  	3,1074,537,0,6688,6689,5,364,0,0,6689,6690,5,354,0,0,6690,6691,3,1384,
  	692,0,6691,6820,1,0,0,0,6692,6693,5,176,0,0,6693,6694,5,130,0,0,6694,
  	6695,5,258,0,0,6695,6696,5,427,0,0,6696,6697,3,1074,537,0,6697,6698,5,
  	364,0,0,6698,6699,5,354,0,0,6699,6700,3,1384,692,0,6700,6820,1,0,0,0,
  	6701,6702,5,176,0,0,6702,6703,5,373,0,0,6703,6704,3,520,260,0,6704,6705,
  	5,364,0,0,6705,6706,5,354,0,0,6706,6707,3,1384,692,0,6707,6820,1,0,0,
  	0,6708,6709,5,176,0,0,6709,6710,5,386,0,0,6710,6711,5,356,0,0,6711,6712,
  	5,314,0,0,6712,6713,3,520,260,0,6713,6714,5,364,0,0,6714,6715,5,354,0,
  	0,6715,6716,3,1384,692,0,6716,6820,1,0,0,0,6717,6718,5,176,0,0,6718,6719,
  	5,386,0,0,6719,6720,5,356,0,0,6720,6721,5,223,0,0,6721,6722,3,520,260,
  	0,6722,6723,5,364,0,0,6723,6724,5,354,0,0,6724,6725,3,1384,692,0,6725,
  	6820,1,0,0,0,6726,6727,5,176,0,0,6727,6728,5,386,0,0,6728,6729,5,356,
  	0,0,6729,6730,5,384,0,0,6730,6731,3,520,260,0,6731,6732,5,364,0,0,6732,
  	6733,5,354,0,0,6733,6734,3,1384,692,0,6734,6820,1,0,0,0,6735,6736,5,176,
  	0,0,6736,6737,5,386,0,0,6737,6738,5,356,0,0,6738,6739,5,201,0,0,6739,
  	6740,3,520,260,0,6740,6741,5,364,0,0,6741,6742,5,354,0,0,6742,6743,3,
  	1384,692,0,6743,6820,1,0,0,0,6744,6745,5,176,0,0,6745,6746,5,359,0,0,
  	6746,6747,3,1380,690,0,6747,6748,5,364,0,0,6748,6749,5,354,0,0,6749,6750,
  	3,1384,692,0,6750,6820,1,0,0,0,6751,6752,5,176,0,0,6752,6753,5,359,0,
  	0,6753,6754,5,258,0,0,6754,6755,5,427,0,0,6755,6756,3,1380,690,0,6756,
  	6757,5,364,0,0,6757,6758,5,354,0,0,6758,6759,3,1384,692,0,6759,6820,1,
  	0,0,0,6760,6761,5,176,0,0,6761,6762,5,407,0,0,6762,6763,3,1380,690,0,
  	6763,6764,5,364,0,0,6764,6765,5,354,0,0,6765,6766,3,1384,692,0,6766,6820,
  	1,0,0,0,6767,6768,5,176,0,0,6768,6769,5,407,0,0,6769,6770,5,258,0,0,6770,
  	6771,5,427,0,0,6771,6772,3,1380,690,0,6772,6773,5,364,0,0,6773,6774,5,
  	354,0,0,6774,6775,3,1384,692,0,6775,6820,1,0,0,0,6776,6777,5,176,0,0,
  	6777,6778,5,289,0,0,6778,6779,5,407,0,0,6779,6780,3,1380,690,0,6780,6781,
  	5,364,0,0,6781,6782,5,354,0,0,6782,6783,3,1384,692,0,6783,6820,1,0,0,
  	0,6784,6785,5,176,0,0,6785,6786,5,289,0,0,6786,6787,5,407,0,0,6787,6788,
  	5,258,0,0,6788,6789,5,427,0,0,6789,6790,3,1380,690,0,6790,6791,5,364,
  	0,0,6791,6792,5,354,0,0,6792,6793,3,1384,692,0,6793,6820,1,0,0,0,6794,
  	6795,5,176,0,0,6795,6796,5,101,0,0,6796,6797,5,130,0,0,6797,6798,3,1074,
  	537,0,6798,6799,5,364,0,0,6799,6800,5,354,0,0,6800,6801,3,1384,692,0,
  	6801,6820,1,0,0,0,6802,6803,5,176,0,0,6803,6804,5,101,0,0,6804,6805,5,
  	130,0,0,6805,6806,5,258,0,0,6806,6807,5,427,0,0,6807,6808,3,1074,537,
  	0,6808,6809,5,364,0,0,6809,6810,5,354,0,0,6810,6811,3,1384,692,0,6811,
  	6820,1,0,0,0,6812,6813,5,176,0,0,6813,6814,5,391,0,0,6814,6815,3,520,
  	260,0,6815,6816,5,364,0,0,6816,6817,5,354,0,0,6817,6818,3,1384,692,0,
  	6818,6820,1,0,0,0,6819,6602,1,0,0,0,6819,6609,1,0,0,0,6819,6616,1,0,0,
  	0,6819,6623,1,0,0,0,6819,6630,1,0,0,0,6819,6637,1,0,0,0,6819,6644,1,0,
  	0,0,6819,6651,1,0,0,0,6819,6661,1,0,0,0,6819,6671,1,0,0,0,6819,6678,1,
  	0,0,0,6819,6685,1,0,0,0,6819,6692,1,0,0,0,6819,6701,1,0,0,0,6819,6708,
  	1,0,0,0,6819,6717,1,0,0,0,6819,6726,1,0,0,0,6819,6735,1,0,0,0,6819,6744,
  	1,0,0,0,6819,6751,1,0,0,0,6819,6760,1,0,0,0,6819,6767,1,0,0,0,6819,6776,
  	1,0,0,0,6819,6784,1,0,0,0,6819,6794,1,0,0,0,6819,6802,1,0,0,0,6819,6812,
  	1,0,0,0,6820,731,1,0,0,0,6821,6822,5,176,0,0,6822,6823,5,309,0,0,6823,
  	6824,3,688,344,0,6824,6825,5,364,0,0,6825,6826,5,2,0,0,6826,6827,3,734,
  	367,0,6827,6828,5,3,0,0,6828,733,1,0,0,0,6829,6834,3,736,368,0,6830,6831,
  	5,6,0,0,6831,6833,3,736,368,0,6832,6830,1,0,0,0,6833,6836,1,0,0,0,6834,
  	6832,1,0,0,0,6834,6835,1,0,0,0,6835,735,1,0,0,0,6836,6834,1,0,0,0,6837,
  	6838,3,1422,711,0,6838,6839,5,10,0,0,6839,6840,5,438,0,0,6840,6846,1,
  	0,0,0,6841,6842,3,1422,711,0,6842,6843,5,10,0,0,6843,6844,3,738,369,0,
  	6844,6846,1,0,0,0,6845,6837,1,0,0,0,6845,6841,1,0,0,0,6846,737,1,0,0,
  	0,6847,6853,3,640,320,0,6848,6853,3,1432,716,0,6849,6853,3,1278,639,0,
  	6850,6853,3,288,144,0,6851,6853,3,1402,701,0,6852,6847,1,0,0,0,6852,6848,
  	1,0,0,0,6852,6849,1,0,0,0,6852,6850,1,0,0,0,6852,6851,1,0,0,0,6853,739,
  	1,0,0,0,6854,6855,5,176,0,0,6855,6856,5,391,0,0,6856,6857,3,520,260,0,
  	6857,6858,5,364,0,0,6858,6859,5,2,0,0,6859,6860,3,734,367,0,6860,6861,
  	5,3,0,0,6861,741,1,0,0,0,6862,6863,5,176,0,0,6863,6864,5,174,0,0,6864,
  	6865,3,650,325,0,6865,6866,5,313,0,0,6866,6867,5,132,0,0,6867,6868,3,
  	1412,706,0,6868,7048,1,0,0,0,6869,6870,5,176,0,0,6870,6871,5,146,0,0,
  	6871,6872,3,520,260,0,6872,6873,5,313,0,0,6873,6874,5,132,0,0,6874,6875,
  	3,1412,706,0,6875,7048,1,0,0,0,6876,6877,5,176,0,0,6877,6878,5,206,0,
  	0,6878,6879,3,520,260,0,6879,6880,5,313,0,0,6880,6881,5,132,0,0,6881,
  	6882,3,1412,706,0,6882,7048,1,0,0,0,6883,6884,5,176,0,0,6884,6885,5,213,
  	0,0,6885,6886,3,1384,692,0,6886,6887,5,313,0,0,6887,6888,5,132,0,0,6888,
  	6889,3,1412,706,0,6889,7048,1,0,0,0,6890,6891,5,176,0,0,6891,6892,5,227,
  	0,0,6892,6893,3,520,260,0,6893,6894,5,313,0,0,6894,6895,5,132,0,0,6895,
  	6896,3,1412,706,0,6896,7048,1,0,0,0,6897,6898,5,176,0,0,6898,6899,5,249,
  	0,0,6899,6900,3,626,313,0,6900,6901,5,313,0,0,6901,6902,5,132,0,0,6902,
  	6903,3,1412,706,0,6903,7048,1,0,0,0,6904,6906,5,176,0,0,6905,6907,3,304,
  	152,0,6906,6905,1,0,0,0,6906,6907,1,0,0,0,6907,6908,1,0,0,0,6908,6909,
  	5,276,0,0,6909,6910,3,1384,692,0,6910,6911,5,313,0,0,6911,6912,5,132,
  	0,0,6912,6913,3,1412,706,0,6913,7048,1,0,0,0,6914,6915,5,176,0,0,6915,
  	6916,5,277,0,0,6916,6917,5,305,0,0,6917,6918,3,288,144,0,6918,6919,5,
  	313,0,0,6919,6920,5,132,0,0,6920,6921,3,1412,706,0,6921,7048,1,0,0,0,
  	6922,6923,5,176,0,0,6923,6924,5,309,0,0,6924,6925,3,688,344,0,6925,6926,
  	5,313,0,0,6926,6927,5,132,0,0,6927,6928,3,1412,706,0,6928,7048,1,0,0,
  	0,6929,6930,5,176,0,0,6930,6931,5,309,0,0,6931,6932,5,194,0,0,6932,6933,
  	3,520,260,0,6933,6934,5,138,0,0,6934,6935,3,1384,692,0,6935,6936,5,313,
  	0,0,6936,6937,5,132,0,0,6937,6938,3,1412,706,0,6938,7048,1,0,0,0,6939,
  	6940,5,176,0,0,6940,6941,5,309,0,0,6941,6942,5,244,0,0,6942,6943,3,520,
  	260,0,6943,6944,5,138,0,0,6944,6945,3,1384,692,0,6945,6946,5,313,0,0,
  	6946,6947,5,132,0,0,6947,6948,3,1412,706,0,6948,7048,1,0,0,0,6949,6950,
  	5,176,0,0,6950,6951,5,327,0,0,6951,6952,3,626,313,0,6952,6953,5,313,0,
  	0,6953,6954,5,132,0,0,6954,6955,3,1412,706,0,6955,7048,1,0,0,0,6956,6957,
  	5,176,0,0,6957,6958,5,480,0,0,6958,6959,3,626,313,0,6959,6960,5,313,0,
  	0,6960,6961,5,132,0,0,6961,6962,3,1412,706,0,6962,7048,1,0,0,0,6963,6964,
  	5,176,0,0,6964,6965,5,354,0,0,6965,6966,3,1384,692,0,6966,6967,5,313,
  	0,0,6967,6968,5,132,0,0,6968,6969,3,1412,706,0,6969,7048,1,0,0,0,6970,
  	6971,5,176,0,0,6971,6972,5,391,0,0,6972,6973,3,520,260,0,6973,6974,5,
  	313,0,0,6974,6975,5,132,0,0,6975,6976,3,1412,706,0,6976,7048,1,0,0,0,
  	6977,6978,5,176,0,0,6978,6979,5,382,0,0,6979,6980,3,1384,692,0,6980,6981,
  	5,313,0,0,6981,6982,5,132,0,0,6982,6983,3,1412,706,0,6983,7048,1,0,0,
  	0,6984,6985,5,176,0,0,6985,6986,5,373,0,0,6986,6987,3,520,260,0,6987,
  	6988,5,313,0,0,6988,6989,5,132,0,0,6989,6990,3,1412,706,0,6990,7048,1,
  	0,0,0,6991,6992,5,176,0,0,6992,6993,5,386,0,0,6993,6994,5,356,0,0,6994,
  	6995,5,223,0,0,6995,6996,3,520,260,0,6996,6997,5,313,0,0,6997,6998,5,
  	132,0,0,6998,6999,3,1412,706,0,6999,7048,1,0,0,0,7000,7001,5,176,0,0,
  	7001,7002,5,386,0,0,7002,7003,5,356,0,0,7003,7004,5,201,0,0,7004,7005,
  	3,520,260,0,7005,7006,5,313,0,0,7006,7007,5,132,0,0,7007,7008,3,1412,
  	706,0,7008,7048,1,0,0,0,7009,7010,5,176,0,0,7010,7011,5,101,0,0,7011,
  	7012,5,212,0,0,7012,7013,5,412,0,0,7013,7014,3,1384,692,0,7014,7015,5,
  	313,0,0,7015,7016,5,132,0,0,7016,7017,3,1412,706,0,7017,7048,1,0,0,0,
  	7018,7019,5,176,0,0,7019,7020,5,362,0,0,7020,7021,3,1384,692,0,7021,7022,
  	5,313,0,0,7022,7023,5,132,0,0,7023,7024,3,1412,706,0,7024,7048,1,0,0,
  	0,7025,7026,5,176,0,0,7026,7027,5,236,0,0,7027,7028,5,388,0,0,7028,7029,
  	3,1384,692,0,7029,7030,5,313,0,0,7030,7031,5,132,0,0,7031,7032,3,1412,
  	706,0,7032,7048,1,0,0,0,7033,7034,5,176,0,0,7034,7035,5,490,0,0,7035,
  	7036,3,1384,692,0,7036,7037,5,313,0,0,7037,7038,5,132,0,0,7038,7039,3,
  	1412,706,0,7039,7048,1,0,0,0,7040,7041,5,176,0,0,7041,7042,5,489,0,0,
  	7042,7043,3,1384,692,0,7043,7044,5,313,0,0,7044,7045,5,132,0,0,7045,7046,
  	3,1412,706,0,7046,7048,1,0,0,0,7047,6862,1,0,0,0,7047,6869,1,0,0,0,7047,
  	6876,1,0,0,0,7047,6883,1,0,0,0,7047,6890,1,0,0,0,7047,6897,1,0,0,0,7047,
  	6904,1,0,0,0,7047,6914,1,0,0,0,7047,6922,1,0,0,0,7047,6929,1,0,0,0,7047,
  	6939,1,0,0,0,7047,6949,1,0,0,0,7047,6956,1,0,0,0,7047,6963,1,0,0,0,7047,
  	6970,1,0,0,0,7047,6977,1,0,0,0,7047,6984,1,0,0,0,7047,6991,1,0,0,0,7047,
  	7000,1,0,0,0,7047,7009,1,0,0,0,7047,7018,1,0,0,0,7047,7025,1,0,0,0,7047,
  	7033,1,0,0,0,7047,7040,1,0,0,0,7048,743,1,0,0,0,7049,7050,5,84,0,0,7050,
  	7051,5,490,0,0,7051,7053,3,1384,692,0,7052,7054,3,746,373,0,7053,7052,
  	1,0,0,0,7053,7054,1,0,0,0,7054,7056,1,0,0,0,7055,7057,3,664,332,0,7056,
  	7055,1,0,0,0,7056,7057,1,0,0,0,7057,745,1,0,0,0,7058,7059,3,748,374,0,
  	7059,747,1,0,0,0,7060,7061,5,100,0,0,7061,7062,5,130,0,0,7062,7067,3,
  	1076,538,0,7063,7064,5,100,0,0,7064,7065,5,68,0,0,7065,7067,5,381,0,0,
  	7066,7060,1,0,0,0,7066,7063,1,0,0,0,7067,749,1,0,0,0,7068,7069,5,176,
  	0,0,7069,7070,5,490,0,0,7070,7071,3,1384,692,0,7071,7072,5,364,0,0,7072,
  	7073,3,456,228,0,7073,7096,1,0,0,0,7074,7075,5,176,0,0,7075,7076,5,490,
  	0,0,7076,7077,3,1384,692,0,7077,7078,5,171,0,0,7078,7079,5,130,0,0,7079,
  	7080,3,1076,538,0,7080,7096,1,0,0,0,7081,7082,5,176,0,0,7082,7083,5,490,
  	0,0,7083,7084,3,1384,692,0,7084,7085,5,364,0,0,7085,7086,5,130,0,0,7086,
  	7087,3,1076,538,0,7087,7096,1,0,0,0,7088,7089,5,176,0,0,7089,7090,5,490,
  	0,0,7090,7091,3,1384,692,0,7091,7092,5,229,0,0,7092,7093,5,130,0,0,7093,
  	7094,3,1076,538,0,7094,7096,1,0,0,0,7095,7068,1,0,0,0,7095,7074,1,0,0,
  	0,7095,7081,1,0,0,0,7095,7088,1,0,0,0,7096,751,1,0,0,0,7097,7098,5,84,
  	0,0,7098,7099,5,489,0,0,7099,7100,3,1384,692,0,7100,7101,5,202,0,0,7101,
  	7102,3,1402,701,0,7102,7103,5,490,0,0,7103,7105,3,754,377,0,7104,7106,
  	3,664,332,0,7105,7104,1,0,0,0,7105,7106,1,0,0,0,7106,753,1,0,0,0,7107,
  	7112,3,756,378,0,7108,7109,5,6,0,0,7109,7111,3,756,378,0,7110,7108,1,
  	0,0,0,7111,7114,1,0,0,0,7112,7110,1,0,0,0,7112,7113,1,0,0,0,7113,755,
  	1,0,0,0,7114,7112,1,0,0,0,7115,7116,3,1422,711,0,7116,757,1,0,0,0,7117,
  	7118,5,176,0,0,7118,7119,5,489,0,0,7119,7120,3,1384,692,0,7120,7121,5,
  	364,0,0,7121,7122,3,456,228,0,7122,7157,1,0,0,0,7123,7124,5,176,0,0,7124,
  	7125,5,489,0,0,7125,7126,3,1384,692,0,7126,7127,5,202,0,0,7127,7128,3,
  	1402,701,0,7128,7157,1,0,0,0,7129,7130,5,176,0,0,7130,7131,5,489,0,0,
  	7131,7132,3,1384,692,0,7132,7133,5,336,0,0,7133,7135,5,490,0,0,7134,7136,
  	3,664,332,0,7135,7134,1,0,0,0,7135,7136,1,0,0,0,7136,7157,1,0,0,0,7137,
  	7138,5,176,0,0,7138,7139,5,489,0,0,7139,7140,3,1384,692,0,7140,7141,5,
  	364,0,0,7141,7142,5,490,0,0,7142,7144,3,754,377,0,7143,7145,3,664,332,
  	0,7144,7143,1,0,0,0,7144,7145,1,0,0,0,7145,7157,1,0,0,0,7146,7147,5,176,
  	0,0,7147,7148,5,489,0,0,7148,7149,3,1384,692,0,7149,7150,5,231,0,0,7150,
  	7157,1,0,0,0,7151,7152,5,176,0,0,7152,7153,5,489,0,0,7153,7154,3,1384,
  	692,0,7154,7155,5,224,0,0,7155,7157,1,0,0,0,7156,7117,1,0,0,0,7156,7123,
  	1,0,0,0,7156,7129,1,0,0,0,7156,7137,1,0,0,0,7156,7146,1,0,0,0,7156,7151,
  	1,0,0,0,7157,759,1,0,0,0,7158,7159,5,229,0,0,7159,7160,5,489,0,0,7160,
  	7162,3,1384,692,0,7161,7163,3,104,52,0,7162,7161,1,0,0,0,7162,7163,1,
  	0,0,0,7163,7173,1,0,0,0,7164,7165,5,229,0,0,7165,7166,5,489,0,0,7166,
  	7167,5,258,0,0,7167,7168,5,427,0,0,7168,7170,3,1384,692,0,7169,7171,3,
  	104,52,0,7170,7169,1,0,0,0,7170,7171,1,0,0,0,7171,7173,1,0,0,0,7172,7158,
  	1,0,0,0,7172,7164,1,0,0,0,7173,761,1,0,0,0,7174,7176,5,84,0,0,7175,7177,
  	3,618,309,0,7176,7175,1,0,0,0,7176,7177,1,0,0,0,7177,7178,1,0,0,0,7178,
  	7179,5,352,0,0,7179,7180,3,1384,692,0,7180,7181,5,74,0,0,7181,7182,5,
  	118,0,0,7182,7183,3,772,386,0,7183,7184,5,132,0,0,7184,7186,3,1380,690,
  	0,7185,7187,3,1094,547,0,7186,7185,1,0,0,0,7186,7187,1,0,0,0,7187,7188,
  	1,0,0,0,7188,7190,5,95,0,0,7189,7191,3,774,387,0,7190,7189,1,0,0,0,7190,
  	7191,1,0,0,0,7191,7192,1,0,0,0,7192,7193,3,764,382,0,7193,763,1,0,0,0,
  	7194,7201,5,301,0,0,7195,7201,3,768,384,0,7196,7197,5,2,0,0,7197,7198,
  	3,766,383,0,7198,7199,5,3,0,0,7199,7201,1,0,0,0,7200,7194,1,0,0,0,7200,
  	7195,1,0,0,0,7200,7196,1,0,0,0,7201,765,1,0,0,0,7202,7204,3,770,385,0,
  	7203,7202,1,0,0,0,7203,7204,1,0,0,0,7204,7211,1,0,0,0,7205,7207,5,7,0,
  	0,7206,7208,3,770,385,0,7207,7206,1,0,0,0,7207,7208,1,0,0,0,7208,7210,
  	1,0,0,0,7209,7205,1,0,0,0,7210,7213,1,0,0,0,7211,7209,1,0,0,0,7211,7212,
  	1,0,0,0,7212,767,1,0,0,0,7213,7211,1,0,0,0,7214,7220,3,966,483,0,7215,
  	7220,3,908,454,0,7216,7220,3,948,474,0,7217,7220,3,934,467,0,7218,7220,
  	3,776,388,0,7219,7214,1,0,0,0,7219,7215,1,0,0,0,7219,7216,1,0,0,0,7219,
  	7217,1,0,0,0,7219,7218,1,0,0,0,7220,769,1,0,0,0,7221,7222,3,768,384,0,
  	7222,771,1,0,0,0,7223,7224,7,31,0,0,7224,773,1,0,0,0,7225,7226,7,32,0,
  	0,7226,775,1,0,0,0,7227,7228,5,302,0,0,7228,7230,3,1416,708,0,7229,7231,
  	3,778,389,0,7230,7229,1,0,0,0,7230,7231,1,0,0,0,7231,777,1,0,0,0,7232,
  	7233,5,6,0,0,7233,7234,3,1402,701,0,7234,779,1,0,0,0,7235,7236,5,281,
  	0,0,7236,7237,3,1416,708,0,7237,781,1,0,0,0,7238,7239,5,397,0,0,7239,
  	7243,3,1416,708,0,7240,7241,5,397,0,0,7241,7243,5,9,0,0,7242,7238,1,0,
  	0,0,7242,7240,1,0,0,0,7243,783,1,0,0,0,7244,7246,5,167,0,0,7245,7247,
  	3,786,393,0,7246,7245,1,0,0,0,7246,7247,1,0,0,0,7247,7249,1,0,0,0,7248,
  	7250,3,794,397,0,7249,7248,1,0,0,0,7249,7250,1,0,0,0,7250,7314,1,0,0,
  	0,7251,7253,5,184,0,0,7252,7254,3,786,393,0,7253,7252,1,0,0,0,7253,7254,
  	1,0,0,0,7254,7256,1,0,0,0,7255,7257,3,792,396,0,7256,7255,1,0,0,0,7256,
  	7257,1,0,0,0,7257,7314,1,0,0,0,7258,7259,5,371,0,0,7259,7261,5,387,0,
  	0,7260,7262,3,792,396,0,7261,7260,1,0,0,0,7261,7262,1,0,0,0,7262,7314,
  	1,0,0,0,7263,7265,5,199,0,0,7264,7266,3,786,393,0,7265,7264,1,0,0,0,7265,
  	7266,1,0,0,0,7266,7268,1,0,0,0,7267,7269,3,794,397,0,7268,7267,1,0,0,
  	0,7268,7269,1,0,0,0,7269,7314,1,0,0,0,7270,7272,5,492,0,0,7271,7273,3,
  	786,393,0,7272,7271,1,0,0,0,7272,7273,1,0,0,0,7273,7275,1,0,0,0,7274,
  	7276,3,794,397,0,7275,7274,1,0,0,0,7275,7276,1,0,0,0,7276,7314,1,0,0,
  	0,7277,7279,5,350,0,0,7278,7280,3,786,393,0,7279,7278,1,0,0,0,7279,7280,
  	1,0,0,0,7280,7282,1,0,0,0,7281,7283,3,794,397,0,7282,7281,1,0,0,0,7282,
  	7283,1,0,0,0,7283,7314,1,0,0,0,7284,7285,5,353,0,0,7285,7314,3,1416,708,
  	0,7286,7287,5,339,0,0,7287,7288,5,353,0,0,7288,7314,3,1416,708,0,7289,
  	7290,5,339,0,0,7290,7314,3,1416,708,0,7291,7293,5,350,0,0,7292,7294,3,
  	786,393,0,7293,7292,1,0,0,0,7293,7294,1,0,0,0,7294,7295,1,0,0,0,7295,
  	7296,5,132,0,0,7296,7297,5,353,0,0,7297,7314,3,1416,708,0,7298,7300,5,
  	350,0,0,7299,7301,3,786,393,0,7300,7299,1,0,0,0,7300,7301,1,0,0,0,7301,
  	7302,1,0,0,0,7302,7303,5,132,0,0,7303,7314,3,1416,708,0,7304,7305,5,321,
  	0,0,7305,7306,5,387,0,0,7306,7314,3,1402,701,0,7307,7308,5,199,0,0,7308,
  	7309,5,322,0,0,7309,7314,3,1402,701,0,7310,7311,5,350,0,0,7311,7312,5,
  	322,0,0,7312,7314,3,1402,701,0,7313,7244,1,0,0,0,7313,7251,1,0,0,0,7313,
  	7258,1,0,0,0,7313,7263,1,0,0,0,7313,7270,1,0,0,0,7313,7277,1,0,0,0,7313,
  	7284,1,0,0,0,7313,7286,1,0,0,0,7313,7289,1,0,0,0,7313,7291,1,0,0,0,7313,
  	7298,1,0,0,0,7313,7304,1,0,0,0,7313,7307,1,0,0,0,7313,7310,1,0,0,0,7314,
  	785,1,0,0,0,7315,7316,7,33,0,0,7316,787,1,0,0,0,7317,7318,5,273,0,0,7318,
  	7319,5,280,0,0,7319,7328,3,60,30,0,7320,7321,5,331,0,0,7321,7328,5,119,
  	0,0,7322,7323,5,331,0,0,7323,7328,5,413,0,0,7324,7328,5,92,0,0,7325,7326,
  	5,115,0,0,7326,7328,5,92,0,0,7327,7317,1,0,0,0,7327,7320,1,0,0,0,7327,
  	7322,1,0,0,0,7327,7324,1,0,0,0,7327,7325,1,0,0,0,7328,789,1,0,0,0,7329,
  	7336,3,788,394,0,7330,7332,5,6,0,0,7331,7330,1,0,0,0,7331,7332,1,0,0,
  	0,7332,7333,1,0,0,0,7333,7335,3,788,394,0,7334,7331,1,0,0,0,7335,7338,
  	1,0,0,0,7336,7334,1,0,0,0,7336,7337,1,0,0,0,7337,791,1,0,0,0,7338,7336,
  	1,0,0,0,7339,7340,3,790,395,0,7340,793,1,0,0,0,7341,7343,5,71,0,0,7342,
  	7344,5,300,0,0,7343,7342,1,0,0,0,7343,7344,1,0,0,0,7344,7345,1,0,0,0,
  	7345,7346,5,191,0,0,7346,795,1,0,0,0,7347,7350,5,84,0,0,7348,7349,5,120,
  	0,0,7349,7351,5,342,0,0,7350,7348,1,0,0,0,7350,7351,1,0,0,0,7351,7353,
  	1,0,0,0,7352,7354,3,170,85,0,7353,7352,1,0,0,0,7353,7354,1,0,0,0,7354,
  	7372,1,0,0,0,7355,7356,5,407,0,0,7356,7358,3,1380,690,0,7357,7359,3,210,
  	105,0,7358,7357,1,0,0,0,7358,7359,1,0,0,0,7359,7361,1,0,0,0,7360,7362,
  	3,114,57,0,7361,7360,1,0,0,0,7361,7362,1,0,0,0,7362,7373,1,0,0,0,7363,
  	7364,5,334,0,0,7364,7365,5,407,0,0,7365,7366,3,1380,690,0,7366,7367,5,
  	2,0,0,7367,7368,3,212,106,0,7368,7370,5,3,0,0,7369,7371,3,114,57,0,7370,
  	7369,1,0,0,0,7370,7371,1,0,0,0,7371,7373,1,0,0,0,7372,7355,1,0,0,0,7372,
  	7363,1,0,0,0,7373,7374,1,0,0,0,7374,7375,5,74,0,0,7375,7377,3,966,483,
  	0,7376,7378,3,798,399,0,7377,7376,1,0,0,0,7377,7378,1,0,0,0,7378,797,
  	1,0,0,0,7379,7381,5,143,0,0,7380,7382,7,34,0,0,7381,7380,1,0,0,0,7381,
  	7382,1,0,0,0,7382,7383,1,0,0,0,7383,7384,5,80,0,0,7384,7385,5,310,0,0,
  	7385,799,1,0,0,0,7386,7387,5,282,0,0,7387,7388,3,1388,694,0,7388,801,
  	1,0,0,0,7389,7390,5,84,0,0,7390,7391,5,213,0,0,7391,7393,3,1384,692,0,
  	7392,7394,3,12,6,0,7393,7392,1,0,0,0,7393,7394,1,0,0,0,7394,7396,1,0,
  	0,0,7395,7397,3,804,402,0,7396,7395,1,0,0,0,7396,7397,1,0,0,0,7397,803,
  	1,0,0,0,7398,7399,3,806,403,0,7399,805,1,0,0,0,7400,7402,3,808,404,0,
  	7401,7400,1,0,0,0,7402,7403,1,0,0,0,7403,7401,1,0,0,0,7403,7404,1,0,0,
  	0,7404,807,1,0,0,0,7405,7407,3,810,405,0,7406,7408,3,812,406,0,7407,7406,
  	1,0,0,0,7407,7408,1,0,0,0,7408,7412,1,0,0,0,7409,7413,3,1408,704,0,7410,
  	7413,3,62,31,0,7411,7413,5,91,0,0,7412,7409,1,0,0,0,7412,7410,1,0,0,0,
  	7412,7411,1,0,0,0,7413,809,1,0,0,0,7414,7423,3,1438,719,0,7415,7416,5,
  	202,0,0,7416,7423,5,112,0,0,7417,7423,5,232,0,0,7418,7423,5,284,0,0,7419,
  	7423,5,313,0,0,7420,7423,5,382,0,0,7421,7423,5,384,0,0,7422,7414,1,0,
  	0,0,7422,7415,1,0,0,0,7422,7417,1,0,0,0,7422,7418,1,0,0,0,7422,7419,1,
  	0,0,0,7422,7420,1,0,0,0,7422,7421,1,0,0,0,7423,811,1,0,0,0,7424,7425,
  	5,10,0,0,7425,813,1,0,0,0,7426,7427,5,176,0,0,7427,7428,5,213,0,0,7428,
  	7439,3,1384,692,0,7429,7431,5,143,0,0,7430,7432,3,804,402,0,7431,7430,
  	1,0,0,0,7431,7432,1,0,0,0,7432,7440,1,0,0,0,7433,7435,3,804,402,0,7434,
  	7433,1,0,0,0,7434,7435,1,0,0,0,7435,7440,1,0,0,0,7436,7437,5,364,0,0,
  	7437,7438,5,382,0,0,7438,7440,3,1384,692,0,7439,7429,1,0,0,0,7439,7434,
  	1,0,0,0,7439,7436,1,0,0,0,7440,815,1,0,0,0,7441,7442,5,176,0,0,7442,7443,
  	5,213,0,0,7443,7444,3,1384,692,0,7444,7445,3,76,38,0,7445,817,1,0,0,0,
  	7446,7447,5,229,0,0,7447,7450,5,213,0,0,7448,7449,5,258,0,0,7449,7451,
  	5,427,0,0,7450,7448,1,0,0,0,7450,7451,1,0,0,0,7451,7452,1,0,0,0,7452,
  	7460,3,1384,692,0,7453,7455,3,12,6,0,7454,7453,1,0,0,0,7454,7455,1,0,
  	0,0,7455,7456,1,0,0,0,7456,7457,5,2,0,0,7457,7458,3,820,410,0,7458,7459,
  	5,3,0,0,7459,7461,1,0,0,0,7460,7454,1,0,0,0,7460,7461,1,0,0,0,7461,819,
  	1,0,0,0,7462,7467,3,822,411,0,7463,7464,5,6,0,0,7464,7466,3,822,411,0,
  	7465,7463,1,0,0,0,7466,7469,1,0,0,0,7467,7465,1,0,0,0,7467,7468,1,0,0,
  	0,7468,821,1,0,0,0,7469,7467,1,0,0,0,7470,7471,5,247,0,0,7471,823,1,0,
  	0,0,7472,7473,5,176,0,0,7473,7474,5,146,0,0,7474,7475,3,520,260,0,7475,
  	7476,5,336,0,0,7476,7477,5,406,0,0,7477,825,1,0,0,0,7478,7479,5,176,0,
  	0,7479,7480,5,380,0,0,7480,7481,7,35,0,0,7481,7482,3,50,25,0,7482,827,
  	1,0,0,0,7483,7484,5,84,0,0,7484,7485,5,227,0,0,7485,7487,3,520,260,0,
  	7486,7488,3,832,416,0,7487,7486,1,0,0,0,7487,7488,1,0,0,0,7488,7489,1,
  	0,0,0,7489,7490,3,1118,559,0,7490,7491,3,188,94,0,7491,829,1,0,0,0,7492,
  	7493,5,176,0,0,7493,7494,5,227,0,0,7494,7517,3,520,260,0,7495,7518,3,
  	102,51,0,7496,7497,5,229,0,0,7497,7498,5,115,0,0,7498,7518,5,116,0,0,
  	7499,7500,5,364,0,0,7500,7501,5,115,0,0,7501,7518,5,116,0,0,7502,7503,
  	5,171,0,0,7503,7518,3,204,102,0,7504,7505,5,229,0,0,7505,7508,5,83,0,
  	0,7506,7507,5,258,0,0,7507,7509,5,427,0,0,7508,7506,1,0,0,0,7508,7509,
  	1,0,0,0,7509,7510,1,0,0,0,7510,7512,3,1384,692,0,7511,7513,3,104,52,0,
  	7512,7511,1,0,0,0,7512,7513,1,0,0,0,7513,7518,1,0,0,0,7514,7515,5,403,
  	0,0,7515,7516,5,83,0,0,7516,7518,3,1384,692,0,7517,7495,1,0,0,0,7517,
  	7496,1,0,0,0,7517,7499,1,0,0,0,7517,7502,1,0,0,0,7517,7504,1,0,0,0,7517,
  	7514,1,0,0,0,7518,831,1,0,0,0,7519,7520,5,74,0,0,7520,833,1,0,0,0,7521,
  	7522,5,176,0,0,7522,7523,5,386,0,0,7523,7524,5,356,0,0,7524,7525,5,223,
  	0,0,7525,7526,3,520,260,0,7526,7527,3,456,228,0,7527,835,1,0,0,0,7528,
  	7529,5,176,0,0,7529,7530,5,386,0,0,7530,7531,5,356,0,0,7531,7532,5,201,
  	0,0,7532,7533,3,520,260,0,7533,7534,5,171,0,0,7534,7535,5,286,0,0,7535,
  	7536,5,100,0,0,7536,7537,3,1382,691,0,7537,7538,3,838,419,0,7538,7539,
  	3,518,259,0,7539,7601,1,0,0,0,7540,7541,5,176,0,0,7541,7542,5,386,0,0,
  	7542,7543,5,356,0,0,7543,7544,5,201,0,0,7544,7545,3,520,260,0,7545,7546,
  	5,176,0,0,7546,7547,5,286,0,0,7547,7548,5,100,0,0,7548,7549,3,1382,691,
  	0,7549,7550,3,838,419,0,7550,7551,3,518,259,0,7551,7601,1,0,0,0,7552,
  	7553,5,176,0,0,7553,7554,5,386,0,0,7554,7555,5,356,0,0,7555,7556,5,201,
  	0,0,7556,7557,3,520,260,0,7557,7558,5,176,0,0,7558,7559,5,286,0,0,7559,
  	7560,5,342,0,0,7560,7561,3,520,260,0,7561,7562,3,838,419,0,7562,7563,
  	3,520,260,0,7563,7601,1,0,0,0,7564,7565,5,176,0,0,7565,7566,5,386,0,0,
  	7566,7567,5,356,0,0,7567,7568,5,201,0,0,7568,7569,3,520,260,0,7569,7570,
  	5,176,0,0,7570,7571,5,286,0,0,7571,7572,5,100,0,0,7572,7573,3,1382,691,
  	0,7573,7574,5,342,0,0,7574,7575,3,520,260,0,7575,7576,3,838,419,0,7576,
  	7577,3,520,260,0,7577,7601,1,0,0,0,7578,7579,5,176,0,0,7579,7580,5,386,
  	0,0,7580,7581,5,356,0,0,7581,7582,5,201,0,0,7582,7583,3,520,260,0,7583,
  	7584,5,229,0,0,7584,7585,5,286,0,0,7585,7586,5,100,0,0,7586,7587,3,1382,
  	691,0,7587,7601,1,0,0,0,7588,7589,5,176,0,0,7589,7590,5,386,0,0,7590,
  	7591,5,356,0,0,7591,7592,5,201,0,0,7592,7593,3,520,260,0,7593,7594,5,
  	229,0,0,7594,7595,5,286,0,0,7595,7596,5,258,0,0,7596,7597,5,427,0,0,7597,
  	7598,5,100,0,0,7598,7599,3,1382,691,0,7599,7601,1,0,0,0,7600,7528,1,0,
  	0,0,7600,7540,1,0,0,0,7600,7552,1,0,0,0,7600,7564,1,0,0,0,7600,7578,1,
  	0,0,0,7600,7588,1,0,0,0,7601,837,1,0,0,0,7602,7603,5,143,0,0,7603,839,
  	1,0,0,0,7604,7606,5,84,0,0,7605,7607,3,484,242,0,7606,7605,1,0,0,0,7606,
  	7607,1,0,0,0,7607,7608,1,0,0,0,7608,7609,5,206,0,0,7609,7610,3,520,260,
  	0,7610,7611,5,100,0,0,7611,7612,3,1402,701,0,7612,7613,5,132,0,0,7613,
  	7614,3,1402,701,0,7614,7615,5,102,0,0,7615,7616,3,520,260,0,7616,841,
  	1,0,0,0,7617,7619,5,196,0,0,7618,7620,3,870,435,0,7619,7618,1,0,0,0,7619,
  	7620,1,0,0,0,7620,7621,1,0,0,0,7621,7623,3,1380,690,0,7622,7624,3,844,
  	422,0,7623,7622,1,0,0,0,7623,7624,1,0,0,0,7624,7638,1,0,0,0,7625,7627,
  	5,196,0,0,7626,7628,3,870,435,0,7627,7626,1,0,0,0,7627,7628,1,0,0,0,7628,
  	7638,1,0,0,0,7629,7631,5,196,0,0,7630,7632,3,870,435,0,7631,7630,1,0,
  	0,0,7631,7632,1,0,0,0,7632,7633,1,0,0,0,7633,7634,3,1384,692,0,7634,7635,
  	5,118,0,0,7635,7636,3,1380,690,0,7636,7638,1,0,0,0,7637,7617,1,0,0,0,
  	7637,7625,1,0,0,0,7637,7629,1,0,0,0,7638,843,1,0,0,0,7639,7640,5,138,
  	0,0,7640,7641,3,1384,692,0,7641,845,1,0,0,0,7642,7644,5,401,0,0,7643,
  	7645,3,872,436,0,7644,7643,1,0,0,0,7644,7645,1,0,0,0,7645,7647,1,0,0,
  	0,7646,7648,3,874,437,0,7647,7646,1,0,0,0,7647,7648,1,0,0,0,7648,7650,
  	1,0,0,0,7649,7651,3,870,435,0,7650,7649,1,0,0,0,7650,7651,1,0,0,0,7651,
  	7653,1,0,0,0,7652,7654,3,868,434,0,7653,7652,1,0,0,0,7653,7654,1,0,0,
  	0,7654,7656,1,0,0,0,7655,7657,3,882,441,0,7656,7655,1,0,0,0,7656,7657,
  	1,0,0,0,7657,7666,1,0,0,0,7658,7659,5,401,0,0,7659,7660,5,2,0,0,7660,
  	7661,3,852,426,0,7661,7663,5,3,0,0,7662,7664,3,882,441,0,7663,7662,1,
  	0,0,0,7663,7664,1,0,0,0,7664,7666,1,0,0,0,7665,7642,1,0,0,0,7665,7658,
  	1,0,0,0,7666,847,1,0,0,0,7667,7669,3,854,427,0,7668,7670,3,870,435,0,
  	7669,7668,1,0,0,0,7669,7670,1,0,0,0,7670,7672,1,0,0,0,7671,7673,3,882,
  	441,0,7672,7671,1,0,0,0,7672,7673,1,0,0,0,7673,7682,1,0,0,0,7674,7675,
  	3,854,427,0,7675,7676,5,2,0,0,7676,7677,3,852,426,0,7677,7679,5,3,0,0,
  	7678,7680,3,882,441,0,7679,7678,1,0,0,0,7679,7680,1,0,0,0,7680,7682,1,
  	0,0,0,7681,7667,1,0,0,0,7681,7674,1,0,0,0,7682,849,1,0,0,0,7683,7688,
  	3,856,428,0,7684,7685,5,6,0,0,7685,7687,3,856,428,0,7686,7684,1,0,0,0,
  	7687,7690,1,0,0,0,7688,7686,1,0,0,0,7688,7689,1,0,0,0,7689,851,1,0,0,
  	0,7690,7688,1,0,0,0,7691,7696,3,862,431,0,7692,7693,5,6,0,0,7693,7695,
  	3,862,431,0,7694,7692,1,0,0,0,7695,7698,1,0,0,0,7696,7694,1,0,0,0,7696,
  	7697,1,0,0,0,7697,853,1,0,0,0,7698,7696,1,0,0,0,7699,7700,7,36,0,0,7700,
  	855,1,0,0,0,7701,7703,3,858,429,0,7702,7704,3,860,430,0,7703,7702,1,0,
  	0,0,7703,7704,1,0,0,0,7704,857,1,0,0,0,7705,7709,3,1420,710,0,7706,7709,
  	3,854,427,0,7707,7709,5,67,0,0,7708,7705,1,0,0,0,7708,7706,1,0,0,0,7708,
  	7707,1,0,0,0,7709,859,1,0,0,0,7710,7713,3,62,31,0,7711,7713,3,288,144,
  	0,7712,7710,1,0,0,0,7712,7711,1,0,0,0,7713,861,1,0,0,0,7714,7716,3,864,
  	432,0,7715,7717,3,866,433,0,7716,7715,1,0,0,0,7716,7717,1,0,0,0,7717,
  	863,1,0,0,0,7718,7721,3,1420,710,0,7719,7721,3,854,427,0,7720,7718,1,
  	0,0,0,7720,7719,1,0,0,0,7721,865,1,0,0,0,7722,7725,3,62,31,0,7723,7725,
  	3,288,144,0,7724,7722,1,0,0,0,7724,7723,1,0,0,0,7725,867,1,0,0,0,7726,
  	7727,3,854,427,0,7727,869,1,0,0,0,7728,7729,5,166,0,0,7729,871,1,0,0,
  	0,7730,7731,5,151,0,0,7731,873,1,0,0,0,7732,7733,5,150,0,0,7733,875,1,
  	0,0,0,7734,7735,5,2,0,0,7735,7736,3,1382,691,0,7736,7737,5,3,0,0,7737,
  	877,1,0,0,0,7738,7740,3,1380,690,0,7739,7741,3,876,438,0,7740,7739,1,
  	0,0,0,7740,7741,1,0,0,0,7741,879,1,0,0,0,7742,7747,3,878,439,0,7743,7744,
  	5,6,0,0,7744,7746,3,878,439,0,7745,7743,1,0,0,0,7746,7749,1,0,0,0,7747,
  	7745,1,0,0,0,7747,7748,1,0,0,0,7748,881,1,0,0,0,7749,7747,1,0,0,0,7750,
  	7751,3,880,440,0,7751,883,1,0,0,0,7752,7753,5,241,0,0,7753,7771,3,886,
  	443,0,7754,7755,5,241,0,0,7755,7757,3,854,427,0,7756,7758,3,870,435,0,
  	7757,7756,1,0,0,0,7757,7758,1,0,0,0,7758,7759,1,0,0,0,7759,7760,3,886,
  	443,0,7760,7771,1,0,0,0,7761,7762,5,241,0,0,7762,7763,5,166,0,0,7763,
  	7771,3,886,443,0,7764,7765,5,241,0,0,7765,7766,5,2,0,0,7766,7767,3,888,
  	444,0,7767,7768,5,3,0,0,7768,7769,3,886,443,0,7769,7771,1,0,0,0,7770,
  	7752,1,0,0,0,7770,7754,1,0,0,0,7770,7761,1,0,0,0,7770,7764,1,0,0,0,7771,
  	885,1,0,0,0,7772,7782,3,966,483,0,7773,7782,3,908,454,0,7774,7782,3,948,
  	474,0,7775,7782,3,934,467,0,7776,7782,3,958,479,0,7777,7782,3,260,130,
  	0,7778,7782,3,266,133,0,7779,7782,3,272,136,0,7780,7782,3,902,451,0,7781,
  	7772,1,0,0,0,7781,7773,1,0,0,0,7781,7774,1,0,0,0,7781,7775,1,0,0,0,7781,
  	7776,1,0,0,0,7781,7777,1,0,0,0,7781,7778,1,0,0,0,7781,7779,1,0,0,0,7781,
  	7780,1,0,0,0,7782,887,1,0,0,0,7783,7788,3,890,445,0,7784,7785,5,6,0,0,
  	7785,7787,3,890,445,0,7786,7784,1,0,0,0,7787,7790,1,0,0,0,7788,7786,1,
  	0,0,0,7788,7789,1,0,0,0,7789,889,1,0,0,0,7790,7788,1,0,0,0,7791,7793,
  	3,892,446,0,7792,7794,3,894,447,0,7793,7792,1,0,0,0,7793,7794,1,0,0,0,
  	7794,891,1,0,0,0,7795,7798,3,1420,710,0,7796,7798,3,854,427,0,7797,7795,
  	1,0,0,0,7797,7796,1,0,0,0,7798,893,1,0,0,0,7799,7802,3,62,31,0,7800,7802,
  	3,288,144,0,7801,7799,1,0,0,0,7801,7800,1,0,0,0,7802,895,1,0,0,0,7803,
  	7804,5,321,0,0,7804,7806,3,1384,692,0,7805,7807,3,898,449,0,7806,7805,
  	1,0,0,0,7806,7807,1,0,0,0,7807,7808,1,0,0,0,7808,7809,5,74,0,0,7809,7810,
  	3,900,450,0,7810,897,1,0,0,0,7811,7812,5,2,0,0,7812,7813,3,1288,644,0,
  	7813,7814,5,3,0,0,7814,899,1,0,0,0,7815,7820,3,966,483,0,7816,7820,3,
  	908,454,0,7817,7820,3,948,474,0,7818,7820,3,934,467,0,7819,7815,1,0,0,
  	0,7819,7816,1,0,0,0,7819,7817,1,0,0,0,7819,7818,1,0,0,0,7820,901,1,0,
  	0,0,7821,7822,5,240,0,0,7822,7824,3,1384,692,0,7823,7825,3,904,452,0,
  	7824,7823,1,0,0,0,7824,7825,1,0,0,0,7825,7860,1,0,0,0,7826,7828,5,84,
  	0,0,7827,7829,3,170,85,0,7828,7827,1,0,0,0,7828,7829,1,0,0,0,7829,7830,
  	1,0,0,0,7830,7831,5,130,0,0,7831,7832,3,262,131,0,7832,7833,5,74,0,0,
  	7833,7834,5,240,0,0,7834,7836,3,1384,692,0,7835,7837,3,904,452,0,7836,
  	7835,1,0,0,0,7836,7837,1,0,0,0,7837,7839,1,0,0,0,7838,7840,3,264,132,
  	0,7839,7838,1,0,0,0,7839,7840,1,0,0,0,7840,7860,1,0,0,0,7841,7843,5,84,
  	0,0,7842,7844,3,170,85,0,7843,7842,1,0,0,0,7843,7844,1,0,0,0,7844,7845,
  	1,0,0,0,7845,7846,5,130,0,0,7846,7847,5,258,0,0,7847,7848,5,115,0,0,7848,
  	7849,5,427,0,0,7849,7850,3,262,131,0,7850,7851,5,74,0,0,7851,7852,5,240,
  	0,0,7852,7854,3,1384,692,0,7853,7855,3,904,452,0,7854,7853,1,0,0,0,7854,
  	7855,1,0,0,0,7855,7857,1,0,0,0,7856,7858,3,264,132,0,7857,7856,1,0,0,
  	0,7857,7858,1,0,0,0,7858,7860,1,0,0,0,7859,7821,1,0,0,0,7859,7826,1,0,
  	0,0,7859,7841,1,0,0,0,7860,903,1,0,0,0,7861,7862,5,2,0,0,7862,7863,3,
  	1282,641,0,7863,7864,5,3,0,0,7864,905,1,0,0,0,7865,7866,5,215,0,0,7866,
  	7876,3,1384,692,0,7867,7868,5,215,0,0,7868,7869,5,321,0,0,7869,7876,3,
  	1384,692,0,7870,7871,5,215,0,0,7871,7876,5,68,0,0,7872,7873,5,215,0,0,
  	7873,7874,5,321,0,0,7874,7876,5,68,0,0,7875,7865,1,0,0,0,7875,7867,1,
  	0,0,0,7875,7870,1,0,0,0,7875,7872,1,0,0,0,7876,907,1,0,0,0,7877,7879,
  	3,986,493,0,7878,7877,1,0,0,0,7878,7879,1,0,0,0,7879,7880,1,0,0,0,7880,
  	7881,5,270,0,0,7881,7882,5,109,0,0,7882,7883,3,910,455,0,7883,7885,3,
  	912,456,0,7884,7886,3,920,460,0,7885,7884,1,0,0,0,7885,7886,1,0,0,0,7886,
  	7888,1,0,0,0,7887,7889,3,924,462,0,7888,7887,1,0,0,0,7888,7889,1,0,0,
  	0,7889,909,1,0,0,0,7890,7893,3,1380,690,0,7891,7892,5,74,0,0,7892,7894,
  	3,1416,708,0,7893,7891,1,0,0,0,7893,7894,1,0,0,0,7894,911,1,0,0,0,7895,
  	7915,3,966,483,0,7896,7897,5,501,0,0,7897,7898,3,914,457,0,7898,7899,
  	5,488,0,0,7899,7900,3,966,483,0,7900,7915,1,0,0,0,7901,7902,5,2,0,0,7902,
  	7903,3,916,458,0,7903,7908,5,3,0,0,7904,7905,5,501,0,0,7905,7906,3,914,
  	457,0,7906,7907,5,488,0,0,7907,7909,1,0,0,0,7908,7904,1,0,0,0,7908,7909,
  	1,0,0,0,7909,7910,1,0,0,0,7910,7911,3,966,483,0,7911,7915,1,0,0,0,7912,
  	7913,5,91,0,0,7913,7915,5,453,0,0,7914,7895,1,0,0,0,7914,7896,1,0,0,0,
  	7914,7901,1,0,0,0,7914,7912,1,0,0,0,7915,913,1,0,0,0,7916,7917,7,37,0,
  	0,7917,915,1,0,0,0,7918,7923,3,918,459,0,7919,7920,5,6,0,0,7920,7922,
  	3,918,459,0,7921,7919,1,0,0,0,7922,7925,1,0,0,0,7923,7921,1,0,0,0,7923,
  	7924,1,0,0,0,7924,917,1,0,0,0,7925,7923,1,0,0,0,7926,7927,3,1416,708,
  	0,7927,7928,3,1328,664,0,7928,919,1,0,0,0,7929,7930,5,118,0,0,7930,7932,
  	5,502,0,0,7931,7933,3,922,461,0,7932,7931,1,0,0,0,7932,7933,1,0,0,0,7933,
  	7934,1,0,0,0,7934,7942,5,95,0,0,7935,7936,5,400,0,0,7936,7937,5,364,0,
  	0,7937,7939,3,950,475,0,7938,7940,3,1094,547,0,7939,7938,1,0,0,0,7939,
  	7940,1,0,0,0,7940,7943,1,0,0,0,7941,7943,5,301,0,0,7942,7935,1,0,0,0,
  	7942,7941,1,0,0,0,7943,921,1,0,0,0,7944,7945,5,2,0,0,7945,7946,3,598,
  	299,0,7946,7948,5,3,0,0,7947,7949,3,1094,547,0,7948,7947,1,0,0,0,7948,
  	7949,1,0,0,0,7949,7954,1,0,0,0,7950,7951,5,118,0,0,7951,7952,5,83,0,0,
  	7952,7954,3,1384,692,0,7953,7944,1,0,0,0,7953,7950,1,0,0,0,7954,923,1,
  	0,0,0,7955,7956,5,125,0,0,7956,7957,3,1374,687,0,7957,925,1,0,0,0,7958,
  	7960,5,291,0,0,7959,7961,5,109,0,0,7960,7959,1,0,0,0,7960,7961,1,0,0,
  	0,7961,7962,1,0,0,0,7962,7964,3,1380,690,0,7963,7965,3,1066,533,0,7964,
  	7963,1,0,0,0,7964,7965,1,0,0,0,7965,7966,1,0,0,0,7966,7969,5,138,0,0,
  	7967,7970,3,968,484,0,7968,7970,3,1380,690,0,7969,7967,1,0,0,0,7969,7968,
  	1,0,0,0,7970,7972,1,0,0,0,7971,7973,3,1066,533,0,7972,7971,1,0,0,0,7972,
  	7973,1,0,0,0,7973,7974,1,0,0,0,7974,7975,5,118,0,0,7975,7984,3,1164,582,
  	0,7976,7978,3,928,464,0,7977,7979,3,930,465,0,7978,7977,1,0,0,0,7978,
  	7979,1,0,0,0,7979,7985,1,0,0,0,7980,7982,3,930,465,0,7981,7983,3,928,
  	464,0,7982,7981,1,0,0,0,7982,7983,1,0,0,0,7983,7985,1,0,0,0,7984,7976,
  	1,0,0,0,7984,7980,1,0,0,0,7985,7987,1,0,0,0,7986,7988,3,932,466,0,7987,
  	7986,1,0,0,0,7987,7988,1,0,0,0,7988,927,1,0,0,0,7989,7990,5,140,0,0,7990,
  	7991,5,115,0,0,7991,7994,5,288,0,0,7992,7993,5,71,0,0,7993,7995,3,1164,
  	582,0,7994,7992,1,0,0,0,7994,7995,1,0,0,0,7995,7997,1,0,0,0,7996,7998,
  	5,131,0,0,7997,7996,1,0,0,0,7997,7998,1,0,0,0,7998,7999,1,0,0,0,7999,
  	8004,5,270,0,0,8000,8001,5,2,0,0,8001,8002,3,916,458,0,8002,8003,5,3,
  	0,0,8003,8005,1,0,0,0,8004,8000,1,0,0,0,8004,8005,1,0,0,0,8005,8006,1,
  	0,0,0,8006,8007,3,1058,529,0,8007,929,1,0,0,0,8008,8009,5,140,0,0,8009,
  	8012,5,288,0,0,8010,8011,5,71,0,0,8011,8013,3,1164,582,0,8012,8010,1,
  	0,0,0,8012,8013,1,0,0,0,8013,8015,1,0,0,0,8014,8016,5,131,0,0,8015,8014,
  	1,0,0,0,8015,8016,1,0,0,0,8016,8017,1,0,0,0,8017,8018,5,400,0,0,8018,
  	8019,5,364,0,0,8019,8020,3,950,475,0,8020,931,1,0,0,0,8021,8022,5,140,
  	0,0,8022,8024,5,288,0,0,8023,8025,5,131,0,0,8024,8023,1,0,0,0,8024,8025,
  	1,0,0,0,8025,8026,1,0,0,0,8026,8027,5,220,0,0,8027,933,1,0,0,0,8028,8030,
  	3,986,493,0,8029,8028,1,0,0,0,8029,8030,1,0,0,0,8030,8031,1,0,0,0,8031,
  	8032,5,220,0,0,8032,8033,5,102,0,0,8033,8035,3,1078,539,0,8034,8036,3,
  	936,468,0,8035,8034,1,0,0,0,8035,8036,1,0,0,0,8036,8038,1,0,0,0,8037,
  	8039,3,1096,548,0,8038,8037,1,0,0,0,8038,8039,1,0,0,0,8039,8041,1,0,0,
  	0,8040,8042,3,924,462,0,8041,8040,1,0,0,0,8041,8042,1,0,0,0,8042,935,
  	1,0,0,0,8043,8044,5,138,0,0,8044,8045,3,1062,531,0,8045,937,1,0,0,0,8046,
  	8048,5,285,0,0,8047,8049,3,994,497,0,8048,8047,1,0,0,0,8048,8049,1,0,
  	0,0,8049,8050,1,0,0,0,8050,8052,3,1076,538,0,8051,8053,3,940,470,0,8052,
  	8051,1,0,0,0,8052,8053,1,0,0,0,8053,8055,1,0,0,0,8054,8056,3,944,472,
  	0,8055,8054,1,0,0,0,8055,8056,1,0,0,0,8056,939,1,0,0,0,8057,8058,5,106,
  	0,0,8058,8059,3,942,471,0,8059,8060,5,294,0,0,8060,941,1,0,0,0,8061,8062,
  	5,169,0,0,8062,8074,7,38,0,0,8063,8064,5,445,0,0,8064,8074,7,38,0,0,8065,
  	8070,5,365,0,0,8066,8067,5,400,0,0,8067,8071,5,239,0,0,8068,8069,5,445,
  	0,0,8069,8071,5,239,0,0,8070,8066,1,0,0,0,8070,8068,1,0,0,0,8070,8071,
  	1,0,0,0,8071,8074,1,0,0,0,8072,8074,5,239,0,0,8073,8061,1,0,0,0,8073,
  	8063,1,0,0,0,8073,8065,1,0,0,0,8073,8072,1,0,0,0,8074,943,1,0,0,0,8075,
  	8076,5,303,0,0,8076,945,1,0,0,0,8077,8081,5,303,0,0,8078,8079,5,503,0,
  	0,8079,8081,5,504,0,0,8080,8077,1,0,0,0,8080,8078,1,0,0,0,8081,947,1,
  	0,0,0,8082,8084,3,986,493,0,8083,8082,1,0,0,0,8083,8084,1,0,0,0,8084,
  	8085,1,0,0,0,8085,8086,5,400,0,0,8086,8087,3,1078,539,0,8087,8088,5,364,
  	0,0,8088,8090,3,950,475,0,8089,8091,3,1060,530,0,8090,8089,1,0,0,0,8090,
  	8091,1,0,0,0,8091,8093,1,0,0,0,8092,8094,3,1096,548,0,8093,8092,1,0,0,
  	0,8093,8094,1,0,0,0,8094,8096,1,0,0,0,8095,8097,3,924,462,0,8096,8095,
  	1,0,0,0,8096,8097,1,0,0,0,8097,949,1,0,0,0,8098,8103,3,952,476,0,8099,
  	8100,5,6,0,0,8100,8102,3,952,476,0,8101,8099,1,0,0,0,8102,8105,1,0,0,
  	0,8103,8101,1,0,0,0,8103,8104,1,0,0,0,8104,951,1,0,0,0,8105,8103,1,0,
  	0,0,8106,8107,3,954,477,0,8107,8108,5,10,0,0,8108,8109,3,1164,582,0,8109,
  	8117,1,0,0,0,8110,8111,5,2,0,0,8111,8112,3,956,478,0,8112,8113,5,3,0,
  	0,8113,8114,5,10,0,0,8114,8115,3,1164,582,0,8115,8117,1,0,0,0,8116,8106,
  	1,0,0,0,8116,8110,1,0,0,0,8117,953,1,0,0,0,8118,8119,3,1416,708,0,8119,
  	8120,3,1328,664,0,8120,955,1,0,0,0,8121,8126,3,954,477,0,8122,8123,5,
  	6,0,0,8123,8125,3,954,477,0,8124,8122,1,0,0,0,8125,8128,1,0,0,0,8126,
  	8124,1,0,0,0,8126,8127,1,0,0,0,8127,957,1,0,0,0,8128,8126,1,0,0,0,8129,
  	8130,5,216,0,0,8130,8131,3,960,480,0,8131,8132,3,962,481,0,8132,8134,
  	5,210,0,0,8133,8135,3,964,482,0,8134,8133,1,0,0,0,8134,8135,1,0,0,0,8135,
  	8136,1,0,0,0,8136,8137,5,100,0,0,8137,8138,3,966,483,0,8138,959,1,0,0,
  	0,8139,8140,3,1384,692,0,8140,961,1,0,0,0,8141,8142,5,300,0,0,8142,8147,
  	5,355,0,0,8143,8147,5,355,0,0,8144,8147,5,145,0,0,8145,8147,5,269,0,0,
  	8146,8141,1,0,0,0,8146,8143,1,0,0,0,8146,8144,1,0,0,0,8146,8145,1,0,0,
  	0,8147,8150,1,0,0,0,8148,8146,1,0,0,0,8148,8149,1,0,0,0,8149,963,1,0,
  	0,0,8150,8148,1,0,0,0,8151,8152,5,143,0,0,8152,8156,5,255,0,0,8153,8154,
  	5,410,0,0,8154,8156,5,255,0,0,8155,8151,1,0,0,0,8155,8153,1,0,0,0,8156,
  	965,1,0,0,0,8157,8160,3,970,485,0,8158,8160,3,968,484,0,8159,8157,1,0,
  	0,0,8159,8158,1,0,0,0,8160,967,1,0,0,0,8161,8162,5,2,0,0,8162,8163,3,
  	970,485,0,8163,8164,5,3,0,0,8164,8170,1,0,0,0,8165,8166,5,2,0,0,8166,
  	8167,3,968,484,0,8167,8168,5,3,0,0,8168,8170,1,0,0,0,8169,8161,1,0,0,
  	0,8169,8165,1,0,0,0,8170,969,1,0,0,0,8171,8173,3,972,486,0,8172,8174,
  	3,1002,501,0,8173,8172,1,0,0,0,8173,8174,1,0,0,0,8174,8183,1,0,0,0,8175,
  	8177,3,1046,523,0,8176,8178,3,1012,506,0,8177,8176,1,0,0,0,8177,8178,
  	1,0,0,0,8178,8184,1,0,0,0,8179,8181,3,1010,505,0,8180,8182,3,1048,524,
  	0,8181,8180,1,0,0,0,8181,8182,1,0,0,0,8182,8184,1,0,0,0,8183,8175,1,0,
  	0,0,8183,8179,1,0,0,0,8183,8184,1,0,0,0,8184,8201,1,0,0,0,8185,8186,3,
  	978,489,0,8186,8188,3,972,486,0,8187,8189,3,1002,501,0,8188,8187,1,0,
  	0,0,8188,8189,1,0,0,0,8189,8198,1,0,0,0,8190,8192,3,1046,523,0,8191,8193,
  	3,1012,506,0,8192,8191,1,0,0,0,8192,8193,1,0,0,0,8193,8199,1,0,0,0,8194,
  	8196,3,1010,505,0,8195,8197,3,1048,524,0,8196,8195,1,0,0,0,8196,8197,
  	1,0,0,0,8197,8199,1,0,0,0,8198,8190,1,0,0,0,8198,8194,1,0,0,0,8198,8199,
  	1,0,0,0,8199,8201,1,0,0,0,8200,8171,1,0,0,0,8200,8185,1,0,0,0,8201,971,
  	1,0,0,0,8202,8210,3,974,487,0,8203,8205,7,39,0,0,8204,8206,3,996,498,
  	0,8205,8204,1,0,0,0,8205,8206,1,0,0,0,8206,8207,1,0,0,0,8207,8209,3,974,
  	487,0,8208,8203,1,0,0,0,8209,8212,1,0,0,0,8210,8208,1,0,0,0,8210,8211,
  	1,0,0,0,8211,973,1,0,0,0,8212,8210,1,0,0,0,8213,8221,3,976,488,0,8214,
  	8216,5,108,0,0,8215,8217,3,996,498,0,8216,8215,1,0,0,0,8216,8217,1,0,
  	0,0,8217,8218,1,0,0,0,8218,8220,3,976,488,0,8219,8214,1,0,0,0,8220,8223,
  	1,0,0,0,8221,8219,1,0,0,0,8221,8222,1,0,0,0,8222,975,1,0,0,0,8223,8221,
  	1,0,0,0,8224,8269,5,126,0,0,8225,8227,3,1000,500,0,8226,8225,1,0,0,0,
  	8226,8227,1,0,0,0,8227,8229,1,0,0,0,8228,8230,3,1372,686,0,8229,8228,
  	1,0,0,0,8229,8230,1,0,0,0,8230,8232,1,0,0,0,8231,8233,3,988,494,0,8232,
  	8231,1,0,0,0,8232,8233,1,0,0,0,8233,8235,1,0,0,0,8234,8236,3,1060,530,
  	0,8235,8234,1,0,0,0,8235,8236,1,0,0,0,8236,8238,1,0,0,0,8237,8239,3,1094,
  	547,0,8238,8237,1,0,0,0,8238,8239,1,0,0,0,8239,8241,1,0,0,0,8240,8242,
  	3,1030,515,0,8241,8240,1,0,0,0,8241,8242,1,0,0,0,8242,8244,1,0,0,0,8243,
  	8245,3,1044,522,0,8244,8243,1,0,0,0,8244,8245,1,0,0,0,8245,8247,1,0,0,
  	0,8246,8248,3,1242,621,0,8247,8246,1,0,0,0,8247,8248,1,0,0,0,8248,8270,
  	1,0,0,0,8249,8250,3,998,499,0,8250,8252,3,1374,687,0,8251,8253,3,988,
  	494,0,8252,8251,1,0,0,0,8252,8253,1,0,0,0,8253,8255,1,0,0,0,8254,8256,
  	3,1060,530,0,8255,8254,1,0,0,0,8255,8256,1,0,0,0,8256,8258,1,0,0,0,8257,
  	8259,3,1094,547,0,8258,8257,1,0,0,0,8258,8259,1,0,0,0,8259,8261,1,0,0,
  	0,8260,8262,3,1030,515,0,8261,8260,1,0,0,0,8261,8262,1,0,0,0,8262,8264,
  	1,0,0,0,8263,8265,3,1044,522,0,8264,8263,1,0,0,0,8264,8265,1,0,0,0,8265,
  	8267,1,0,0,0,8266,8268,3,1242,621,0,8267,8266,1,0,0,0,8267,8268,1,0,0,
  	0,8268,8270,1,0,0,0,8269,8226,1,0,0,0,8269,8249,1,0,0,0,8270,8276,1,0,
  	0,0,8271,8276,3,1058,529,0,8272,8273,5,130,0,0,8273,8276,3,1074,537,0,
  	8274,8276,3,968,484,0,8275,8224,1,0,0,0,8275,8271,1,0,0,0,8275,8272,1,
  	0,0,0,8275,8274,1,0,0,0,8276,977,1,0,0,0,8277,8279,5,143,0,0,8278,8280,
  	5,334,0,0,8279,8278,1,0,0,0,8279,8280,1,0,0,0,8280,8281,1,0,0,0,8281,
  	8282,3,980,490,0,8282,979,1,0,0,0,8283,8288,3,982,491,0,8284,8285,5,6,
  	0,0,8285,8287,3,982,491,0,8286,8284,1,0,0,0,8287,8290,1,0,0,0,8288,8286,
  	1,0,0,0,8288,8289,1,0,0,0,8289,981,1,0,0,0,8290,8288,1,0,0,0,8291,8293,
  	3,1384,692,0,8292,8294,3,876,438,0,8293,8292,1,0,0,0,8293,8294,1,0,0,
  	0,8294,8295,1,0,0,0,8295,8297,5,74,0,0,8296,8298,3,984,492,0,8297,8296,
  	1,0,0,0,8297,8298,1,0,0,0,8298,8299,1,0,0,0,8299,8300,5,2,0,0,8300,8301,
  	3,900,450,0,8301,8302,5,3,0,0,8302,983,1,0,0,0,8303,8307,5,289,0,0,8304,
  	8305,5,115,0,0,8305,8307,5,289,0,0,8306,8303,1,0,0,0,8306,8304,1,0,0,
  	0,8307,985,1,0,0,0,8308,8309,3,978,489,0,8309,987,1,0,0,0,8310,8311,5,
  	109,0,0,8311,8312,3,992,496,0,8312,989,1,0,0,0,8313,8314,5,377,0,0,8314,
  	991,1,0,0,0,8315,8317,7,40,0,0,8316,8315,1,0,0,0,8316,8317,1,0,0,0,8317,
  	8318,1,0,0,0,8318,8320,7,12,0,0,8319,8321,3,994,497,0,8320,8319,1,0,0,
  	0,8320,8321,1,0,0,0,8321,8322,1,0,0,0,8322,8332,3,1380,690,0,8323,8325,
  	5,398,0,0,8324,8326,3,994,497,0,8325,8324,1,0,0,0,8325,8326,1,0,0,0,8326,
  	8327,1,0,0,0,8327,8332,3,1380,690,0,8328,8329,5,130,0,0,8329,8332,3,1380,
  	690,0,8330,8332,3,1380,690,0,8331,8316,1,0,0,0,8331,8323,1,0,0,0,8331,
  	8328,1,0,0,0,8331,8330,1,0,0,0,8332,993,1,0,0,0,8333,8334,5,130,0,0,8334,
  	995,1,0,0,0,8335,8336,7,41,0,0,8336,997,1,0,0,0,8337,8343,5,94,0,0,8338,
  	8339,5,118,0,0,8339,8340,5,2,0,0,8340,8341,3,1282,641,0,8341,8342,5,3,
  	0,0,8342,8344,1,0,0,0,8343,8338,1,0,0,0,8343,8344,1,0,0,0,8344,999,1,
  	0,0,0,8345,8346,5,68,0,0,8346,1001,1,0,0,0,8347,8348,3,1004,502,0,8348,
  	1003,1,0,0,0,8349,8350,5,121,0,0,8350,8351,5,185,0,0,8351,8352,3,1006,
  	503,0,8352,1005,1,0,0,0,8353,8358,3,1008,504,0,8354,8355,5,6,0,0,8355,
  	8357,3,1008,504,0,8356,8354,1,0,0,0,8357,8360,1,0,0,0,8358,8356,1,0,0,
  	0,8358,8359,1,0,0,0,8359,1007,1,0,0,0,8360,8358,1,0,0,0,8361,8367,3,1164,
  	582,0,8362,8363,5,138,0,0,8363,8368,3,1278,639,0,8364,8366,3,612,306,
  	0,8365,8364,1,0,0,0,8365,8366,1,0,0,0,8366,8368,1,0,0,0,8367,8362,1,0,
  	0,0,8367,8365,1,0,0,0,8368,8370,1,0,0,0,8369,8371,3,614,307,0,8370,8369,
  	1,0,0,0,8370,8371,1,0,0,0,8371,1009,1,0,0,0,8372,8374,3,1014,507,0,8373,
  	8375,3,1016,508,0,8374,8373,1,0,0,0,8374,8375,1,0,0,0,8375,8381,1,0,0,
  	0,8376,8378,3,1016,508,0,8377,8379,3,1014,507,0,8378,8377,1,0,0,0,8378,
  	8379,1,0,0,0,8379,8381,1,0,0,0,8380,8372,1,0,0,0,8380,8376,1,0,0,0,8381,
  	1011,1,0,0,0,8382,8383,3,1010,505,0,8383,1013,1,0,0,0,8384,8385,5,112,
  	0,0,8385,8388,3,1018,509,0,8386,8387,5,6,0,0,8387,8389,3,1020,510,0,8388,
  	8386,1,0,0,0,8388,8389,1,0,0,0,8389,8408,1,0,0,0,8390,8391,5,99,0,0,8391,
  	8405,3,1028,514,0,8392,8393,3,1022,511,0,8393,8397,3,1026,513,0,8394,
  	8398,5,119,0,0,8395,8396,5,143,0,0,8396,8398,5,505,0,0,8397,8394,1,0,
  	0,0,8397,8395,1,0,0,0,8398,8406,1,0,0,0,8399,8403,3,1026,513,0,8400,8404,
  	5,119,0,0,8401,8402,5,143,0,0,8402,8404,5,505,0,0,8403,8400,1,0,0,0,8403,
  	8401,1,0,0,0,8404,8406,1,0,0,0,8405,8392,1,0,0,0,8405,8399,1,0,0,0,8406,
  	8408,1,0,0,0,8407,8384,1,0,0,0,8407,8390,1,0,0,0,8408,1015,1,0,0,0,8409,
  	8414,5,117,0,0,8410,8415,3,1020,510,0,8411,8412,3,1022,511,0,8412,8413,
  	3,1026,513,0,8413,8415,1,0,0,0,8414,8410,1,0,0,0,8414,8411,1,0,0,0,8415,
  	1017,1,0,0,0,8416,8419,3,1164,582,0,8417,8419,5,68,0,0,8418,8416,1,0,
  	0,0,8418,8417,1,0,0,0,8419,1019,1,0,0,0,8420,8421,3,1164,582,0,8421,1021,
  	1,0,0,0,8422,8428,3,1208,604,0,8423,8424,5,12,0,0,8424,8428,3,1024,512,
  	0,8425,8426,5,13,0,0,8426,8428,3,1024,512,0,8427,8422,1,0,0,0,8427,8423,
  	1,0,0,0,8427,8425,1,0,0,0,8428,1023,1,0,0,0,8429,8432,3,1400,700,0,8430,
  	8432,3,1398,699,0,8431,8429,1,0,0,0,8431,8430,1,0,0,0,8432,1025,1,0,0,
  	0,8433,8434,7,42,0,0,8434,1027,1,0,0,0,8435,8436,7,43,0,0,8436,1029,1,
  	0,0,0,8437,8438,5,104,0,0,8438,8439,5,185,0,0,8439,8440,3,1032,516,0,
  	8440,1031,1,0,0,0,8441,8446,3,1034,517,0,8442,8443,5,6,0,0,8443,8445,
  	3,1034,517,0,8444,8442,1,0,0,0,8445,8448,1,0,0,0,8446,8444,1,0,0,0,8446,
  	8447,1,0,0,0,8447,1033,1,0,0,0,8448,8446,1,0,0,0,8449,8455,3,1036,518,
  	0,8450,8455,3,1040,520,0,8451,8455,3,1038,519,0,8452,8455,3,1042,521,
  	0,8453,8455,3,1164,582,0,8454,8449,1,0,0,0,8454,8450,1,0,0,0,8454,8451,
  	1,0,0,0,8454,8452,1,0,0,0,8454,8453,1,0,0,0,8455,1035,1,0,0,0,8456,8457,
  	5,2,0,0,8457,8458,5,3,0,0,8458,1037,1,0,0,0,8459,8460,5,506,0,0,8460,
  	8461,5,2,0,0,8461,8462,3,1282,641,0,8462,8463,5,3,0,0,8463,1039,1,0,0,
  	0,8464,8465,5,507,0,0,8465,8466,5,2,0,0,8466,8467,3,1282,641,0,8467,8468,
  	5,3,0,0,8468,1041,1,0,0,0,8469,8470,5,508,0,0,8470,8471,5,509,0,0,8471,
  	8472,5,2,0,0,8472,8473,3,1032,516,0,8473,8474,5,3,0,0,8474,1043,1,0,0,
  	0,8475,8476,5,105,0,0,8476,8477,3,1164,582,0,8477,1045,1,0,0,0,8478,8483,
  	3,1050,525,0,8479,8480,5,100,0,0,8480,8481,5,331,0,0,8481,8483,5,119,
  	0,0,8482,8478,1,0,0,0,8482,8479,1,0,0,0,8483,1047,1,0,0,0,8484,8485,3,
  	1046,523,0,8485,1049,1,0,0,0,8486,8488,3,1052,526,0,8487,8486,1,0,0,0,
  	8488,8489,1,0,0,0,8489,8487,1,0,0,0,8489,8490,1,0,0,0,8490,1051,1,0,0,
  	0,8491,8493,3,1054,527,0,8492,8494,3,1056,528,0,8493,8492,1,0,0,0,8493,
  	8494,1,0,0,0,8494,8496,1,0,0,0,8495,8497,3,946,473,0,8496,8495,1,0,0,
  	0,8496,8497,1,0,0,0,8497,1053,1,0,0,0,8498,8508,5,100,0,0,8499,8500,5,
  	300,0,0,8500,8502,5,274,0,0,8501,8499,1,0,0,0,8501,8502,1,0,0,0,8502,
  	8503,1,0,0,0,8503,8509,5,400,0,0,8504,8506,5,274,0,0,8505,8504,1,0,0,
  	0,8505,8506,1,0,0,0,8506,8507,1,0,0,0,8507,8509,5,365,0,0,8508,8501,1,
  	0,0,0,8508,8505,1,0,0,0,8509,1055,1,0,0,0,8510,8511,5,306,0,0,8511,8512,
  	3,1378,689,0,8512,1057,1,0,0,0,8513,8514,5,453,0,0,8514,8515,5,2,0,0,
  	8515,8516,3,1282,641,0,8516,8524,5,3,0,0,8517,8518,5,6,0,0,8518,8519,
  	5,2,0,0,8519,8520,3,1282,641,0,8520,8521,5,3,0,0,8521,8523,1,0,0,0,8522,
  	8517,1,0,0,0,8523,8526,1,0,0,0,8524,8522,1,0,0,0,8524,8525,1,0,0,0,8525,
  	1059,1,0,0,0,8526,8524,1,0,0,0,8527,8528,5,102,0,0,8528,8529,3,1062,531,
  	0,8529,1061,1,0,0,0,8530,8535,3,1064,532,0,8531,8532,5,6,0,0,8532,8534,
  	3,1064,532,0,8533,8531,1,0,0,0,8534,8537,1,0,0,0,8535,8533,1,0,0,0,8535,
  	8536,1,0,0,0,8536,1063,1,0,0,0,8537,8535,1,0,0,0,8538,8540,3,1074,537,
  	0,8539,8541,3,1066,533,0,8540,8539,1,0,0,0,8540,8541,1,0,0,0,8541,8543,
  	1,0,0,0,8542,8544,3,1080,540,0,8543,8542,1,0,0,0,8543,8544,1,0,0,0,8544,
  	8597,1,0,0,0,8545,8547,3,1084,542,0,8546,8548,3,1068,534,0,8547,8546,
  	1,0,0,0,8547,8548,1,0,0,0,8548,8597,1,0,0,0,8549,8551,3,1104,552,0,8550,
  	8552,3,1066,533,0,8551,8550,1,0,0,0,8551,8552,1,0,0,0,8552,8597,1,0,0,
  	0,8553,8555,3,968,484,0,8554,8556,3,1066,533,0,8555,8554,1,0,0,0,8555,
  	8556,1,0,0,0,8556,8597,1,0,0,0,8557,8570,5,110,0,0,8558,8560,3,1104,552,
  	0,8559,8561,3,1066,533,0,8560,8559,1,0,0,0,8560,8561,1,0,0,0,8561,8571,
  	1,0,0,0,8562,8564,3,1084,542,0,8563,8565,3,1068,534,0,8564,8563,1,0,0,
  	0,8564,8565,1,0,0,0,8565,8571,1,0,0,0,8566,8568,3,968,484,0,8567,8569,
  	3,1066,533,0,8568,8567,1,0,0,0,8568,8569,1,0,0,0,8569,8571,1,0,0,0,8570,
  	8558,1,0,0,0,8570,8562,1,0,0,0,8570,8566,1,0,0,0,8571,8597,1,0,0,0,8572,
  	8573,5,2,0,0,8573,8590,3,1064,532,0,8574,8575,5,148,0,0,8575,8576,5,156,
  	0,0,8576,8591,3,1064,532,0,8577,8579,5,159,0,0,8578,8580,3,1070,535,0,
  	8579,8578,1,0,0,0,8579,8580,1,0,0,0,8580,8581,1,0,0,0,8581,8582,5,156,
  	0,0,8582,8591,3,1064,532,0,8583,8585,3,1070,535,0,8584,8583,1,0,0,0,8584,
  	8585,1,0,0,0,8585,8586,1,0,0,0,8586,8587,5,156,0,0,8587,8588,3,1064,532,
  	0,8588,8589,3,1072,536,0,8589,8591,1,0,0,0,8590,8574,1,0,0,0,8590,8577,
  	1,0,0,0,8590,8584,1,0,0,0,8590,8591,1,0,0,0,8591,8592,1,0,0,0,8592,8594,
  	5,3,0,0,8593,8595,3,1066,533,0,8594,8593,1,0,0,0,8594,8595,1,0,0,0,8595,
  	8597,1,0,0,0,8596,8538,1,0,0,0,8596,8545,1,0,0,0,8596,8549,1,0,0,0,8596,
  	8553,1,0,0,0,8596,8557,1,0,0,0,8596,8572,1,0,0,0,8597,8616,1,0,0,0,8598,
  	8599,5,148,0,0,8599,8600,5,156,0,0,8600,8615,3,1064,532,0,8601,8603,5,
  	159,0,0,8602,8604,3,1070,535,0,8603,8602,1,0,0,0,8603,8604,1,0,0,0,8604,
  	8605,1,0,0,0,8605,8606,5,156,0,0,8606,8615,3,1064,532,0,8607,8609,3,1070,
  	535,0,8608,8607,1,0,0,0,8608,8609,1,0,0,0,8609,8610,1,0,0,0,8610,8611,
  	5,156,0,0,8611,8612,3,1064,532,0,8612,8613,3,1072,536,0,8613,8615,1,0,
  	0,0,8614,8598,1,0,0,0,8614,8601,1,0,0,0,8614,8608,1,0,0,0,8615,8618,1,
  	0,0,0,8616,8614,1,0,0,0,8616,8617,1,0,0,0,8617,1065,1,0,0,0,8618,8616,
  	1,0,0,0,8619,8621,5,74,0,0,8620,8619,1,0,0,0,8620,8621,1,0,0,0,8621,8622,
  	1,0,0,0,8622,8627,3,1416,708,0,8623,8624,5,2,0,0,8624,8625,3,1382,691,
  	0,8625,8626,5,3,0,0,8626,8628,1,0,0,0,8627,8623,1,0,0,0,8627,8628,1,0,
  	0,0,8628,1067,1,0,0,0,8629,8642,3,1066,533,0,8630,8632,5,74,0,0,8631,
  	8633,3,1416,708,0,8632,8631,1,0,0,0,8632,8633,1,0,0,0,8633,8636,1,0,0,
  	0,8634,8636,3,1416,708,0,8635,8630,1,0,0,0,8635,8634,1,0,0,0,8636,8637,
  	1,0,0,0,8637,8638,5,2,0,0,8638,8639,3,1100,550,0,8639,8640,5,3,0,0,8640,
  	8642,1,0,0,0,8641,8629,1,0,0,0,8641,8635,1,0,0,0,8642,1069,1,0,0,0,8643,
  	8645,7,44,0,0,8644,8646,5,161,0,0,8645,8644,1,0,0,0,8645,8646,1,0,0,0,
  	8646,1071,1,0,0,0,8647,8648,5,138,0,0,8648,8649,5,2,0,0,8649,8650,3,1382,
  	691,0,8650,8651,5,3,0,0,8651,8655,1,0,0,0,8652,8653,5,118,0,0,8653,8655,
  	3,1164,582,0,8654,8647,1,0,0,0,8654,8652,1,0,0,0,8655,1073,1,0,0,0,8656,
  	8658,3,1380,690,0,8657,8659,5,9,0,0,8658,8657,1,0,0,0,8658,8659,1,0,0,
  	0,8659,8669,1,0,0,0,8660,8666,5,119,0,0,8661,8667,3,1380,690,0,8662,8663,
  	5,2,0,0,8663,8664,3,1380,690,0,8664,8665,5,3,0,0,8665,8667,1,0,0,0,8666,
  	8661,1,0,0,0,8666,8662,1,0,0,0,8667,8669,1,0,0,0,8668,8656,1,0,0,0,8668,
  	8660,1,0,0,0,8669,1075,1,0,0,0,8670,8675,3,1074,537,0,8671,8672,5,6,0,
  	0,8672,8674,3,1074,537,0,8673,8671,1,0,0,0,8674,8677,1,0,0,0,8675,8673,
  	1,0,0,0,8675,8676,1,0,0,0,8676,1077,1,0,0,0,8677,8675,1,0,0,0,8678,8683,
  	3,1074,537,0,8679,8681,5,74,0,0,8680,8679,1,0,0,0,8680,8681,1,0,0,0,8681,
  	8682,1,0,0,0,8682,8684,3,1416,708,0,8683,8680,1,0,0,0,8683,8684,1,0,0,
  	0,8684,1079,1,0,0,0,8685,8686,5,510,0,0,8686,8687,3,1390,695,0,8687,8688,
  	5,2,0,0,8688,8689,3,1282,641,0,8689,8691,5,3,0,0,8690,8692,3,1082,541,
  	0,8691,8690,1,0,0,0,8691,8692,1,0,0,0,8692,1081,1,0,0,0,8693,8694,5,341,
  	0,0,8694,8695,5,2,0,0,8695,8696,3,1164,582,0,8696,8697,5,3,0,0,8697,1083,
  	1,0,0,0,8698,8700,3,1216,608,0,8699,8701,3,1092,546,0,8700,8699,1,0,0,
  	0,8700,8701,1,0,0,0,8701,8711,1,0,0,0,8702,8703,5,351,0,0,8703,8704,5,
  	102,0,0,8704,8705,5,2,0,0,8705,8706,3,1088,544,0,8706,8708,5,3,0,0,8707,
  	8709,3,1092,546,0,8708,8707,1,0,0,0,8708,8709,1,0,0,0,8709,8711,1,0,0,
  	0,8710,8698,1,0,0,0,8710,8702,1,0,0,0,8711,1085,1,0,0,0,8712,8714,3,1216,
  	608,0,8713,8715,3,1090,545,0,8714,8713,1,0,0,0,8714,8715,1,0,0,0,8715,
  	1087,1,0,0,0,8716,8721,3,1086,543,0,8717,8718,5,6,0,0,8718,8720,3,1086,
  	543,0,8719,8717,1,0,0,0,8720,8723,1,0,0,0,8721,8719,1,0,0,0,8721,8722,
  	1,0,0,0,8722,1089,1,0,0,0,8723,8721,1,0,0,0,8724,8725,5,74,0,0,8725,8726,
  	5,2,0,0,8726,8727,3,1100,550,0,8727,8728,5,3,0,0,8728,1091,1,0,0,0,8729,
  	8730,5,143,0,0,8730,8731,5,511,0,0,8731,1093,1,0,0,0,8732,8733,5,141,
  	0,0,8733,8734,3,1164,582,0,8734,1095,1,0,0,0,8735,8740,5,141,0,0,8736,
  	8737,5,472,0,0,8737,8738,5,306,0,0,8738,8741,3,960,480,0,8739,8741,3,
  	1164,582,0,8740,8736,1,0,0,0,8740,8739,1,0,0,0,8741,1097,1,0,0,0,8742,
  	8743,3,1100,550,0,8743,1099,1,0,0,0,8744,8749,3,1102,551,0,8745,8746,
  	5,6,0,0,8746,8748,3,1102,551,0,8747,8745,1,0,0,0,8748,8751,1,0,0,0,8749,
  	8747,1,0,0,0,8749,8750,1,0,0,0,8750,1101,1,0,0,0,8751,8749,1,0,0,0,8752,
  	8753,3,1416,708,0,8753,8755,3,1118,559,0,8754,8756,3,106,53,0,8755,8754,
  	1,0,0,0,8755,8756,1,0,0,0,8756,1103,1,0,0,0,8757,8758,5,512,0,0,8758,
  	8774,5,2,0,0,8759,8760,3,1208,604,0,8760,8761,3,1234,617,0,8761,8762,
  	5,513,0,0,8762,8763,3,1106,553,0,8763,8775,1,0,0,0,8764,8765,5,514,0,
  	0,8765,8766,5,2,0,0,8766,8767,3,1114,557,0,8767,8768,5,3,0,0,8768,8769,
  	5,6,0,0,8769,8770,3,1208,604,0,8770,8771,3,1234,617,0,8771,8772,5,513,
  	0,0,8772,8773,3,1106,553,0,8773,8775,1,0,0,0,8774,8759,1,0,0,0,8774,8764,
  	1,0,0,0,8775,8776,1,0,0,0,8776,8777,5,3,0,0,8777,1105,1,0,0,0,8778,8783,
  	3,1108,554,0,8779,8780,5,6,0,0,8780,8782,3,1108,554,0,8781,8779,1,0,0,
  	0,8782,8785,1,0,0,0,8783,8781,1,0,0,0,8783,8784,1,0,0,0,8784,1107,1,0,
  	0,0,8785,8783,1,0,0,0,8786,8793,3,1416,708,0,8787,8789,3,1118,559,0,8788,
  	8790,3,1110,555,0,8789,8788,1,0,0,0,8789,8790,1,0,0,0,8790,8794,1,0,0,
  	0,8791,8792,5,100,0,0,8792,8794,5,511,0,0,8793,8787,1,0,0,0,8793,8791,
  	1,0,0,0,8794,1109,1,0,0,0,8795,8797,3,1112,556,0,8796,8795,1,0,0,0,8797,
  	8798,1,0,0,0,8798,8796,1,0,0,0,8798,8799,1,0,0,0,8799,1111,1,0,0,0,8800,
  	8801,5,91,0,0,8801,8809,3,1164,582,0,8802,8803,3,1438,719,0,8803,8804,
  	3,1164,582,0,8804,8809,1,0,0,0,8805,8806,5,115,0,0,8806,8809,5,116,0,
  	0,8807,8809,5,116,0,0,8808,8800,1,0,0,0,8808,8802,1,0,0,0,8808,8805,1,
  	0,0,0,8808,8807,1,0,0,0,8809,1113,1,0,0,0,8810,8815,3,1116,558,0,8811,
  	8812,5,6,0,0,8812,8814,3,1116,558,0,8813,8811,1,0,0,0,8814,8817,1,0,0,
  	0,8815,8813,1,0,0,0,8815,8816,1,0,0,0,8816,1115,1,0,0,0,8817,8815,1,0,
  	0,0,8818,8819,3,1206,603,0,8819,8820,5,74,0,0,8820,8821,3,1422,711,0,
  	8821,8825,1,0,0,0,8822,8823,5,91,0,0,8823,8825,3,1206,603,0,8824,8818,
  	1,0,0,0,8824,8822,1,0,0,0,8825,1117,1,0,0,0,8826,8828,5,446,0,0,8827,
  	8826,1,0,0,0,8827,8828,1,0,0,0,8828,8829,1,0,0,0,8829,8838,3,1122,561,
  	0,8830,8839,3,1120,560,0,8831,8836,5,73,0,0,8832,8833,5,4,0,0,8833,8834,
  	3,1400,700,0,8834,8835,5,5,0,0,8835,8837,1,0,0,0,8836,8832,1,0,0,0,8836,
  	8837,1,0,0,0,8837,8839,1,0,0,0,8838,8830,1,0,0,0,8838,8831,1,0,0,0,8839,
  	1119,1,0,0,0,8840,8842,5,4,0,0,8841,8843,3,1400,700,0,8842,8841,1,0,0,
  	0,8842,8843,1,0,0,0,8843,8844,1,0,0,0,8844,8846,5,5,0,0,8845,8840,1,0,
  	0,0,8846,8849,1,0,0,0,8847,8845,1,0,0,0,8847,8848,1,0,0,0,8848,1121,1,
  	0,0,0,8849,8847,1,0,0,0,8850,8867,3,1126,563,0,8851,8867,3,1130,565,0,
  	8852,8867,3,1134,567,0,8853,8867,3,1142,571,0,8854,8867,3,1150,575,0,
  	8855,8863,3,1152,576,0,8856,8858,3,1156,578,0,8857,8856,1,0,0,0,8857,
  	8858,1,0,0,0,8858,8864,1,0,0,0,8859,8860,5,2,0,0,8860,8861,3,1400,700,
  	0,8861,8862,5,3,0,0,8862,8864,1,0,0,0,8863,8857,1,0,0,0,8863,8859,1,0,
  	0,0,8864,8867,1,0,0,0,8865,8867,3,1160,580,0,8866,8850,1,0,0,0,8866,8851,
  	1,0,0,0,8866,8852,1,0,0,0,8866,8853,1,0,0,0,8866,8854,1,0,0,0,8866,8855,
  	1,0,0,0,8866,8865,1,0,0,0,8867,1123,1,0,0,0,8868,8874,3,1130,565,0,8869,
  	8874,3,1136,568,0,8870,8874,3,1144,572,0,8871,8874,3,1150,575,0,8872,
  	8874,3,1160,580,0,8873,8868,1,0,0,0,8873,8869,1,0,0,0,8873,8870,1,0,0,
  	0,8873,8871,1,0,0,0,8873,8872,1,0,0,0,8874,1125,1,0,0,0,8875,8877,3,1418,
  	709,0,8876,8878,3,522,261,0,8877,8876,1,0,0,0,8877,8878,1,0,0,0,8878,
  	8880,1,0,0,0,8879,8881,3,1128,564,0,8880,8879,1,0,0,0,8880,8881,1,0,0,
  	0,8881,1127,1,0,0,0,8882,8883,5,2,0,0,8883,8884,3,1282,641,0,8884,8885,
  	5,3,0,0,8885,1129,1,0,0,0,8886,8911,5,432,0,0,8887,8911,5,433,0,0,8888,
  	8911,5,447,0,0,8889,8911,5,419,0,0,8890,8911,5,444,0,0,8891,8893,5,429,
  	0,0,8892,8894,3,1132,566,0,8893,8892,1,0,0,0,8893,8894,1,0,0,0,8894,8911,
  	1,0,0,0,8895,8896,5,228,0,0,8896,8911,5,443,0,0,8897,8899,5,426,0,0,8898,
  	8900,3,1128,564,0,8899,8898,1,0,0,0,8899,8900,1,0,0,0,8900,8911,1,0,0,
  	0,8901,8903,5,425,0,0,8902,8904,3,1128,564,0,8903,8902,1,0,0,0,8903,8904,
  	1,0,0,0,8904,8911,1,0,0,0,8905,8907,5,440,0,0,8906,8908,3,1128,564,0,
  	8907,8906,1,0,0,0,8907,8908,1,0,0,0,8908,8911,1,0,0,0,8909,8911,5,421,
  	0,0,8910,8886,1,0,0,0,8910,8887,1,0,0,0,8910,8888,1,0,0,0,8910,8889,1,
  	0,0,0,8910,8890,1,0,0,0,8910,8891,1,0,0,0,8910,8895,1,0,0,0,8910,8897,
  	1,0,0,0,8910,8901,1,0,0,0,8910,8905,1,0,0,0,8910,8909,1,0,0,0,8911,1131,
  	1,0,0,0,8912,8913,5,2,0,0,8913,8914,3,1400,700,0,8914,8915,5,3,0,0,8915,
  	1133,1,0,0,0,8916,8919,3,1138,569,0,8917,8919,3,1140,570,0,8918,8916,
  	1,0,0,0,8918,8917,1,0,0,0,8919,1135,1,0,0,0,8920,8923,3,1138,569,0,8921,
  	8923,3,1140,570,0,8922,8920,1,0,0,0,8922,8921,1,0,0,0,8923,1137,1,0,0,
  	0,8924,8926,5,420,0,0,8925,8927,3,1148,574,0,8926,8925,1,0,0,0,8926,8927,
  	1,0,0,0,8927,8928,1,0,0,0,8928,8929,5,2,0,0,8929,8930,3,1282,641,0,8930,
  	8931,5,3,0,0,8931,1139,1,0,0,0,8932,8934,5,420,0,0,8933,8935,3,1148,574,
  	0,8934,8933,1,0,0,0,8934,8935,1,0,0,0,8935,1141,1,0,0,0,8936,8941,3,1146,
  	573,0,8937,8938,5,2,0,0,8938,8939,3,1400,700,0,8939,8940,5,3,0,0,8940,
  	8942,1,0,0,0,8941,8937,1,0,0,0,8941,8942,1,0,0,0,8942,1143,1,0,0,0,8943,
  	8948,3,1146,573,0,8944,8945,5,2,0,0,8945,8946,3,1400,700,0,8946,8947,
  	5,3,0,0,8947,8949,1,0,0,0,8948,8944,1,0,0,0,8948,8949,1,0,0,0,8949,1145,
  	1,0,0,0,8950,8952,7,45,0,0,8951,8953,3,1148,574,0,8952,8951,1,0,0,0,8952,
  	8953,1,0,0,0,8953,8961,1,0,0,0,8954,8961,5,454,0,0,8955,8956,5,436,0,
  	0,8956,8958,7,46,0,0,8957,8959,3,1148,574,0,8958,8957,1,0,0,0,8958,8959,
  	1,0,0,0,8959,8961,1,0,0,0,8960,8950,1,0,0,0,8960,8954,1,0,0,0,8960,8955,
  	1,0,0,0,8961,1147,1,0,0,0,8962,8963,5,405,0,0,8963,1149,1,0,0,0,8964,
  	8969,7,47,0,0,8965,8966,5,2,0,0,8966,8967,3,1400,700,0,8967,8968,5,3,
  	0,0,8968,8970,1,0,0,0,8969,8965,1,0,0,0,8969,8970,1,0,0,0,8970,8972,1,
  	0,0,0,8971,8973,3,1154,577,0,8972,8971,1,0,0,0,8972,8973,1,0,0,0,8973,
  	1151,1,0,0,0,8974,8975,5,434,0,0,8975,1153,1,0,0,0,8976,8977,5,143,0,
  	0,8977,8978,5,449,0,0,8978,8983,5,417,0,0,8979,8980,5,410,0,0,8980,8981,
  	5,449,0,0,8981,8983,5,417,0,0,8982,8976,1,0,0,0,8982,8979,1,0,0,0,8983,
  	1155,1,0,0,0,8984,9010,5,415,0,0,8985,9010,5,295,0,0,8986,9010,5,214,
  	0,0,8987,9010,5,256,0,0,8988,9010,5,292,0,0,8989,9010,3,1158,579,0,8990,
  	8991,5,415,0,0,8991,8992,5,132,0,0,8992,9010,5,295,0,0,8993,8994,5,214,
  	0,0,8994,8998,5,132,0,0,8995,8999,5,256,0,0,8996,8999,5,292,0,0,8997,
  	8999,3,1158,579,0,8998,8995,1,0,0,0,8998,8996,1,0,0,0,8998,8997,1,0,0,
  	0,8999,9010,1,0,0,0,9000,9001,5,256,0,0,9001,9004,5,132,0,0,9002,9005,
  	5,292,0,0,9003,9005,3,1158,579,0,9004,9002,1,0,0,0,9004,9003,1,0,0,0,
  	9005,9010,1,0,0,0,9006,9007,5,292,0,0,9007,9008,5,132,0,0,9008,9010,3,
  	1158,579,0,9009,8984,1,0,0,0,9009,8985,1,0,0,0,9009,8986,1,0,0,0,9009,
  	8987,1,0,0,0,9009,8988,1,0,0,0,9009,8989,1,0,0,0,9009,8990,1,0,0,0,9009,
  	8993,1,0,0,0,9009,9000,1,0,0,0,9009,9006,1,0,0,0,9010,1157,1,0,0,0,9011,
  	9016,5,357,0,0,9012,9013,5,2,0,0,9013,9014,3,1400,700,0,9014,9015,5,3,
  	0,0,9015,9017,1,0,0,0,9016,9012,1,0,0,0,9016,9017,1,0,0,0,9017,1159,1,
  	0,0,0,9018,9019,5,30,0,0,9019,1161,1,0,0,0,9020,9021,5,235,0,0,9021,9022,
  	3,1164,582,0,9022,1163,1,0,0,0,9023,9024,3,1166,583,0,9024,1165,1,0,0,
  	0,9025,9029,3,1168,584,0,9026,9027,4,583,0,0,9027,9030,3,1276,638,0,9028,
  	9030,1,0,0,0,9029,9026,1,0,0,0,9029,9028,1,0,0,0,9030,1167,1,0,0,0,9031,
  	9036,3,1170,585,0,9032,9033,7,48,0,0,9033,9035,3,1170,585,0,9034,9032,
  	1,0,0,0,9035,9038,1,0,0,0,9036,9034,1,0,0,0,9036,9037,1,0,0,0,9037,1169,
  	1,0,0,0,9038,9036,1,0,0,0,9039,9044,3,1172,586,0,9040,9041,5,120,0,0,
  	9041,9043,3,1172,586,0,9042,9040,1,0,0,0,9043,9046,1,0,0,0,9044,9042,
  	1,0,0,0,9044,9045,1,0,0,0,9045,1171,1,0,0,0,9046,9044,1,0,0,0,9047,9052,
  	3,1174,587,0,9048,9049,5,71,0,0,9049,9051,3,1174,587,0,9050,9048,1,0,
  	0,0,9051,9054,1,0,0,0,9052,9050,1,0,0,0,9052,9053,1,0,0,0,9053,1173,1,
  	0,0,0,9054,9052,1,0,0,0,9055,9067,3,1176,588,0,9056,9058,5,115,0,0,9057,
  	9056,1,0,0,0,9057,9058,1,0,0,0,9058,9059,1,0,0,0,9059,9061,5,418,0,0,
  	9060,9062,5,129,0,0,9061,9060,1,0,0,0,9061,9062,1,0,0,0,9062,9063,1,0,
  	0,0,9063,9064,3,1176,588,0,9064,9065,5,71,0,0,9065,9066,3,1176,588,0,
  	9066,9068,1,0,0,0,9067,9057,1,0,0,0,9067,9068,1,0,0,0,9068,1175,1,0,0,
  	0,9069,9075,3,1178,589,0,9070,9072,5,115,0,0,9071,9070,1,0,0,0,9071,9072,
  	1,0,0,0,9072,9073,1,0,0,0,9073,9074,5,106,0,0,9074,9076,3,1308,654,0,
  	9075,9071,1,0,0,0,9075,9076,1,0,0,0,9076,1177,1,0,0,0,9077,9079,5,115,
  	0,0,9078,9077,1,0,0,0,9078,9079,1,0,0,0,9079,9080,1,0,0,0,9080,9081,3,
  	1180,590,0,9081,1179,1,0,0,0,9082,9084,3,1182,591,0,9083,9085,7,49,0,
  	0,9084,9083,1,0,0,0,9084,9085,1,0,0,0,9085,1181,1,0,0,0,9086,9110,3,1184,
  	592,0,9087,9089,5,154,0,0,9088,9090,5,115,0,0,9089,9088,1,0,0,0,9089,
  	9090,1,0,0,0,9090,9108,1,0,0,0,9091,9109,5,116,0,0,9092,9109,5,134,0,
  	0,9093,9109,5,98,0,0,9094,9109,5,396,0,0,9095,9096,5,94,0,0,9096,9097,
  	5,102,0,0,9097,9109,3,1164,582,0,9098,9099,5,306,0,0,9099,9100,5,2,0,
  	0,9100,9101,3,1288,644,0,9101,9102,5,3,0,0,9102,9109,1,0,0,0,9103,9109,
  	5,226,0,0,9104,9106,3,1298,649,0,9105,9104,1,0,0,0,9105,9106,1,0,0,0,
  	9106,9107,1,0,0,0,9107,9109,5,516,0,0,9108,9091,1,0,0,0,9108,9092,1,0,
  	0,0,9108,9093,1,0,0,0,9108,9094,1,0,0,0,9108,9095,1,0,0,0,9108,9098,1,
  	0,0,0,9108,9103,1,0,0,0,9108,9105,1,0,0,0,9109,9111,1,0,0,0,9110,9087,
  	1,0,0,0,9110,9111,1,0,0,0,9111,1183,1,0,0,0,9112,9124,3,1186,593,0,9113,
  	9114,7,50,0,0,9114,9125,3,1186,593,0,9115,9116,3,1280,640,0,9116,9122,
  	3,1270,635,0,9117,9123,3,968,484,0,9118,9119,5,2,0,0,9119,9120,3,1164,
  	582,0,9120,9121,5,3,0,0,9121,9123,1,0,0,0,9122,9117,1,0,0,0,9122,9118,
  	1,0,0,0,9123,9125,1,0,0,0,9124,9113,1,0,0,0,9124,9115,1,0,0,0,9124,9125,
  	1,0,0,0,9125,1185,1,0,0,0,9126,9140,3,1188,594,0,9127,9129,5,115,0,0,
  	9128,9127,1,0,0,0,9128,9129,1,0,0,0,9129,9134,1,0,0,0,9130,9135,5,158,
  	0,0,9131,9135,5,152,0,0,9132,9133,5,165,0,0,9133,9135,5,132,0,0,9134,
  	9130,1,0,0,0,9134,9131,1,0,0,0,9134,9132,1,0,0,0,9135,9136,1,0,0,0,9136,
  	9138,3,1188,594,0,9137,9139,3,1162,581,0,9138,9137,1,0,0,0,9138,9139,
  	1,0,0,0,9139,9141,1,0,0,0,9140,9128,1,0,0,0,9140,9141,1,0,0,0,9141,1187,
  	1,0,0,0,9142,9148,3,1190,595,0,9143,9144,3,1276,638,0,9144,9145,3,1190,
  	595,0,9145,9147,1,0,0,0,9146,9143,1,0,0,0,9147,9150,1,0,0,0,9148,9146,
  	1,0,0,0,9148,9149,1,0,0,0,9149,1189,1,0,0,0,9150,9148,1,0,0,0,9151,9153,
  	3,1276,638,0,9152,9151,1,0,0,0,9152,9153,1,0,0,0,9153,9154,1,0,0,0,9154,
  	9155,3,1192,596,0,9155,1191,1,0,0,0,9156,9161,3,1194,597,0,9157,9158,
  	7,51,0,0,9158,9160,3,1194,597,0,9159,9157,1,0,0,0,9160,9163,1,0,0,0,9161,
  	9159,1,0,0,0,9161,9162,1,0,0,0,9162,1193,1,0,0,0,9163,9161,1,0,0,0,9164,
  	9169,3,1196,598,0,9165,9166,7,52,0,0,9166,9168,3,1196,598,0,9167,9165,
  	1,0,0,0,9168,9171,1,0,0,0,9169,9167,1,0,0,0,9169,9170,1,0,0,0,9170,1195,
  	1,0,0,0,9171,9169,1,0,0,0,9172,9175,3,1198,599,0,9173,9174,5,15,0,0,9174,
  	9176,3,1198,599,0,9175,9173,1,0,0,0,9175,9176,1,0,0,0,9176,1197,1,0,0,
  	0,9177,9179,7,51,0,0,9178,9177,1,0,0,0,9178,9179,1,0,0,0,9179,9180,1,
  	0,0,0,9180,9181,3,1200,600,0,9181,1199,1,0,0,0,9182,9187,3,1202,601,0,
  	9183,9184,5,180,0,0,9184,9185,5,449,0,0,9185,9186,5,417,0,0,9186,9188,
  	3,1164,582,0,9187,9183,1,0,0,0,9187,9188,1,0,0,0,9188,1201,1,0,0,0,9189,
  	9192,3,1204,602,0,9190,9191,5,81,0,0,9191,9193,3,520,260,0,9192,9190,
  	1,0,0,0,9192,9193,1,0,0,0,9193,1203,1,0,0,0,9194,9199,3,1208,604,0,9195,
  	9196,5,26,0,0,9196,9198,3,1118,559,0,9197,9195,1,0,0,0,9198,9201,1,0,
  	0,0,9199,9197,1,0,0,0,9199,9200,1,0,0,0,9200,1205,1,0,0,0,9201,9199,1,
  	0,0,0,9202,9203,6,603,-1,0,9203,9210,3,1208,604,0,9204,9205,7,51,0,0,
  	9205,9210,3,1206,603,9,9206,9207,3,1276,638,0,9207,9208,3,1206,603,3,
  	9208,9210,1,0,0,0,9209,9202,1,0,0,0,9209,9204,1,0,0,0,9209,9206,1,0,0,
  	0,9210,9250,1,0,0,0,9211,9212,10,8,0,0,9212,9213,5,15,0,0,9213,9249,3,
  	1206,603,9,9214,9215,10,7,0,0,9215,9216,7,52,0,0,9216,9249,3,1206,603,
  	8,9217,9218,10,6,0,0,9218,9219,7,51,0,0,9219,9249,3,1206,603,7,9220,9221,
  	10,5,0,0,9221,9222,3,1276,638,0,9222,9223,3,1206,603,6,9223,9249,1,0,
  	0,0,9224,9225,10,4,0,0,9225,9226,7,50,0,0,9226,9249,3,1206,603,5,9227,
  	9228,10,10,0,0,9228,9229,5,26,0,0,9229,9249,3,1118,559,0,9230,9231,10,
  	2,0,0,9231,9249,3,1276,638,0,9232,9233,10,1,0,0,9233,9235,5,154,0,0,9234,
  	9236,5,115,0,0,9235,9234,1,0,0,0,9235,9236,1,0,0,0,9236,9246,1,0,0,0,
  	9237,9238,5,94,0,0,9238,9239,5,102,0,0,9239,9247,3,1206,603,0,9240,9241,
  	5,306,0,0,9241,9242,5,2,0,0,9242,9243,3,1288,644,0,9243,9244,5,3,0,0,
  	9244,9247,1,0,0,0,9245,9247,5,226,0,0,9246,9237,1,0,0,0,9246,9240,1,0,
  	0,0,9246,9245,1,0,0,0,9247,9249,1,0,0,0,9248,9211,1,0,0,0,9248,9214,1,
  	0,0,0,9248,9217,1,0,0,0,9248,9220,1,0,0,0,9248,9224,1,0,0,0,9248,9227,
  	1,0,0,0,9248,9230,1,0,0,0,9248,9232,1,0,0,0,9249,9252,1,0,0,0,9250,9248,
  	1,0,0,0,9250,9251,1,0,0,0,9251,1207,1,0,0,0,9252,9250,1,0,0,0,9253,9254,
  	5,427,0,0,9254,9290,3,968,484,0,9255,9258,5,73,0,0,9256,9259,3,968,484,
  	0,9257,9259,3,1290,645,0,9258,9256,1,0,0,0,9258,9257,1,0,0,0,9259,9290,
  	1,0,0,0,9260,9261,5,28,0,0,9261,9290,3,1328,664,0,9262,9263,5,508,0,0,
  	9263,9264,5,2,0,0,9264,9265,3,1282,641,0,9265,9266,5,3,0,0,9266,9290,
  	1,0,0,0,9267,9268,5,136,0,0,9268,9290,3,968,484,0,9269,9290,3,1320,660,
  	0,9270,9290,3,1392,696,0,9271,9272,5,2,0,0,9272,9273,3,1164,582,0,9273,
  	9274,5,3,0,0,9274,9275,3,1328,664,0,9275,9290,1,0,0,0,9276,9290,3,1310,
  	655,0,9277,9290,3,1214,607,0,9278,9280,3,968,484,0,9279,9281,3,1326,663,
  	0,9280,9279,1,0,0,0,9280,9281,1,0,0,0,9281,9290,1,0,0,0,9282,9290,3,1266,
  	633,0,9283,9290,3,1268,634,0,9284,9285,3,1264,632,0,9285,9286,5,163,0,
  	0,9286,9287,3,1264,632,0,9287,9290,1,0,0,0,9288,9290,5,91,0,0,9289,9253,
  	1,0,0,0,9289,9255,1,0,0,0,9289,9260,1,0,0,0,9289,9262,1,0,0,0,9289,9267,
  	1,0,0,0,9289,9269,1,0,0,0,9289,9270,1,0,0,0,9289,9271,1,0,0,0,9289,9276,
  	1,0,0,0,9289,9277,1,0,0,0,9289,9278,1,0,0,0,9289,9282,1,0,0,0,9289,9283,
  	1,0,0,0,9289,9284,1,0,0,0,9289,9288,1,0,0,0,9290,1209,1,0,0,0,9291,9292,
  	5,582,0,0,9292,1211,1,0,0,0,9293,9294,3,1390,695,0,9294,9316,5,2,0,0,
  	9295,9299,3,1284,642,0,9296,9297,5,6,0,0,9297,9298,5,139,0,0,9298,9300,
  	3,1286,643,0,9299,9296,1,0,0,0,9299,9300,1,0,0,0,9300,9302,1,0,0,0,9301,
  	9303,3,1002,501,0,9302,9301,1,0,0,0,9302,9303,1,0,0,0,9303,9317,1,0,0,
  	0,9304,9305,5,139,0,0,9305,9307,3,1286,643,0,9306,9308,3,1002,501,0,9307,
  	9306,1,0,0,0,9307,9308,1,0,0,0,9308,9317,1,0,0,0,9309,9310,7,41,0,0,9310,
  	9312,3,1284,642,0,9311,9313,3,1002,501,0,9312,9311,1,0,0,0,9312,9313,
  	1,0,0,0,9313,9317,1,0,0,0,9314,9317,5,9,0,0,9315,9317,1,0,0,0,9316,9295,
  	1,0,0,0,9316,9304,1,0,0,0,9316,9309,1,0,0,0,9316,9314,1,0,0,0,9316,9315,
  	1,0,0,0,9317,9318,1,0,0,0,9318,9319,5,3,0,0,9319,1213,1,0,0,0,9320,9322,
  	3,1212,606,0,9321,9323,3,1238,619,0,9322,9321,1,0,0,0,9322,9323,1,0,0,
  	0,9323,9325,1,0,0,0,9324,9326,3,1240,620,0,9325,9324,1,0,0,0,9325,9326,
  	1,0,0,0,9326,9328,1,0,0,0,9327,9329,3,1248,624,0,9328,9327,1,0,0,0,9328,
  	9329,1,0,0,0,9329,9332,1,0,0,0,9330,9332,3,1218,609,0,9331,9320,1,0,0,
  	0,9331,9330,1,0,0,0,9332,1215,1,0,0,0,9333,9336,3,1212,606,0,9334,9336,
  	3,1218,609,0,9335,9333,1,0,0,0,9335,9334,1,0,0,0,9336,1217,1,0,0,0,9337,
  	9338,5,146,0,0,9338,9339,5,100,0,0,9339,9340,5,2,0,0,9340,9341,3,1164,
  	582,0,9341,9342,5,3,0,0,9342,9644,1,0,0,0,9343,9644,5,86,0,0,9344,9349,
  	5,88,0,0,9345,9346,5,2,0,0,9346,9347,3,1400,700,0,9347,9348,5,3,0,0,9348,
  	9350,1,0,0,0,9349,9345,1,0,0,0,9349,9350,1,0,0,0,9350,9644,1,0,0,0,9351,
  	9356,5,89,0,0,9352,9353,5,2,0,0,9353,9354,3,1400,700,0,9354,9355,5,3,
  	0,0,9355,9357,1,0,0,0,9356,9352,1,0,0,0,9356,9357,1,0,0,0,9357,9644,1,
  	0,0,0,9358,9363,5,113,0,0,9359,9360,5,2,0,0,9360,9361,3,1400,700,0,9361,
  	9362,5,3,0,0,9362,9364,1,0,0,0,9363,9359,1,0,0,0,9363,9364,1,0,0,0,9364,
  	9644,1,0,0,0,9365,9370,5,114,0,0,9366,9367,5,2,0,0,9367,9368,3,1400,700,
  	0,9368,9369,5,3,0,0,9369,9371,1,0,0,0,9370,9366,1,0,0,0,9370,9371,1,0,
  	0,0,9371,9644,1,0,0,0,9372,9644,5,87,0,0,9373,9644,5,90,0,0,9374,9644,
  	5,127,0,0,9375,9644,5,42,0,0,9376,9644,5,137,0,0,9377,9644,5,85,0,0,9378,
  	9644,5,149,0,0,9379,9380,5,79,0,0,9380,9381,5,2,0,0,9381,9382,3,1164,
  	582,0,9382,9383,5,74,0,0,9383,9384,3,1118,559,0,9384,9385,5,3,0,0,9385,
  	9644,1,0,0,0,9386,9387,5,428,0,0,9387,9389,5,2,0,0,9388,9390,3,1294,647,
  	0,9389,9388,1,0,0,0,9389,9390,1,0,0,0,9390,9391,1,0,0,0,9391,9644,5,3,
  	0,0,9392,9393,5,527,0,0,9393,9394,5,2,0,0,9394,9397,3,1164,582,0,9395,
  	9396,5,6,0,0,9396,9398,3,1298,649,0,9397,9395,1,0,0,0,9397,9398,1,0,0,
  	0,9398,9399,1,0,0,0,9399,9400,5,3,0,0,9400,9644,1,0,0,0,9401,9402,5,441,
  	0,0,9402,9407,5,2,0,0,9403,9408,3,1300,650,0,9404,9406,3,1284,642,0,9405,
  	9404,1,0,0,0,9405,9406,1,0,0,0,9406,9408,1,0,0,0,9407,9403,1,0,0,0,9407,
  	9405,1,0,0,0,9408,9409,1,0,0,0,9409,9644,5,3,0,0,9410,9411,5,442,0,0,
  	9411,9413,5,2,0,0,9412,9414,3,1302,651,0,9413,9412,1,0,0,0,9413,9414,
  	1,0,0,0,9414,9415,1,0,0,0,9415,9644,5,3,0,0,9416,9417,5,448,0,0,9417,
  	9422,5,2,0,0,9418,9423,3,1304,652,0,9419,9421,3,1284,642,0,9420,9419,
  	1,0,0,0,9420,9421,1,0,0,0,9421,9423,1,0,0,0,9422,9418,1,0,0,0,9422,9420,
  	1,0,0,0,9423,9424,1,0,0,0,9424,9644,5,3,0,0,9425,9426,5,451,0,0,9426,
  	9427,5,2,0,0,9427,9428,3,1164,582,0,9428,9429,5,74,0,0,9429,9430,3,1118,
  	559,0,9430,9431,5,3,0,0,9431,9644,1,0,0,0,9432,9433,5,452,0,0,9433,9435,
  	5,2,0,0,9434,9436,7,53,0,0,9435,9434,1,0,0,0,9435,9436,1,0,0,0,9436,9437,
  	1,0,0,0,9437,9438,3,1306,653,0,9438,9439,5,3,0,0,9439,9644,1,0,0,0,9440,
  	9441,5,439,0,0,9441,9442,5,2,0,0,9442,9443,3,1164,582,0,9443,9444,5,6,
  	0,0,9444,9445,3,1164,582,0,9445,9446,5,3,0,0,9446,9644,1,0,0,0,9447,9448,
  	5,424,0,0,9448,9449,5,2,0,0,9449,9450,3,1282,641,0,9450,9451,5,3,0,0,
  	9451,9644,1,0,0,0,9452,9453,5,430,0,0,9453,9454,5,2,0,0,9454,9455,3,1282,
  	641,0,9455,9456,5,3,0,0,9456,9644,1,0,0,0,9457,9458,5,435,0,0,9458,9459,
  	5,2,0,0,9459,9460,3,1282,641,0,9460,9461,5,3,0,0,9461,9644,1,0,0,0,9462,
  	9463,5,463,0,0,9463,9464,5,2,0,0,9464,9465,3,1282,641,0,9465,9466,5,3,
  	0,0,9466,9644,1,0,0,0,9467,9468,5,464,0,0,9468,9469,5,2,0,0,9469,9470,
  	5,297,0,0,9470,9476,3,1422,711,0,9471,9474,5,6,0,0,9472,9475,3,1224,612,
  	0,9473,9475,3,1282,641,0,9474,9472,1,0,0,0,9474,9473,1,0,0,0,9475,9477,
  	1,0,0,0,9476,9471,1,0,0,0,9476,9477,1,0,0,0,9477,9478,1,0,0,0,9478,9479,
  	5,3,0,0,9479,9644,1,0,0,0,9480,9481,5,465,0,0,9481,9482,5,2,0,0,9482,
  	9483,3,1208,604,0,9483,9484,3,1234,617,0,9484,9485,5,3,0,0,9485,9644,
  	1,0,0,0,9486,9487,5,466,0,0,9487,9488,5,2,0,0,9488,9489,3,1226,613,0,
  	9489,9490,5,3,0,0,9490,9644,1,0,0,0,9491,9492,5,467,0,0,9492,9493,5,2,
  	0,0,9493,9494,3,1230,615,0,9494,9496,3,1164,582,0,9495,9497,3,1232,616,
  	0,9496,9495,1,0,0,0,9496,9497,1,0,0,0,9497,9498,1,0,0,0,9498,9499,5,3,
  	0,0,9499,9644,1,0,0,0,9500,9501,5,468,0,0,9501,9502,5,2,0,0,9502,9503,
  	5,297,0,0,9503,9506,3,1422,711,0,9504,9505,5,6,0,0,9505,9507,3,1164,582,
  	0,9506,9504,1,0,0,0,9506,9507,1,0,0,0,9507,9508,1,0,0,0,9508,9509,5,3,
  	0,0,9509,9644,1,0,0,0,9510,9511,5,469,0,0,9511,9512,5,2,0,0,9512,9513,
  	5,414,0,0,9513,9514,3,1164,582,0,9514,9515,5,6,0,0,9515,9517,3,1220,610,
  	0,9516,9518,3,1222,611,0,9517,9516,1,0,0,0,9517,9518,1,0,0,0,9518,9519,
  	1,0,0,0,9519,9520,5,3,0,0,9520,9644,1,0,0,0,9521,9522,5,470,0,0,9522,
  	9523,5,2,0,0,9523,9524,3,1230,615,0,9524,9525,3,1164,582,0,9525,9526,
  	5,74,0,0,9526,9527,3,1122,561,0,9527,9528,5,3,0,0,9528,9644,1,0,0,0,9529,
  	9530,5,34,0,0,9530,9545,5,2,0,0,9531,9546,3,1284,642,0,9532,9534,3,1358,
  	679,0,9533,9535,3,1362,681,0,9534,9533,1,0,0,0,9534,9535,1,0,0,0,9535,
  	9537,1,0,0,0,9536,9538,3,1356,678,0,9537,9536,1,0,0,0,9537,9538,1,0,0,
  	0,9538,9540,1,0,0,0,9539,9541,3,1352,676,0,9540,9539,1,0,0,0,9540,9541,
  	1,0,0,0,9541,9546,1,0,0,0,9542,9544,3,1352,676,0,9543,9542,1,0,0,0,9543,
  	9544,1,0,0,0,9544,9546,1,0,0,0,9545,9531,1,0,0,0,9545,9532,1,0,0,0,9545,
  	9543,1,0,0,0,9546,9547,1,0,0,0,9547,9644,5,3,0,0,9548,9549,5,31,0,0,9549,
  	9567,5,2,0,0,9550,9552,3,1366,683,0,9551,9553,3,1364,682,0,9552,9551,
  	1,0,0,0,9552,9553,1,0,0,0,9553,9555,1,0,0,0,9554,9556,3,1352,676,0,9555,
  	9554,1,0,0,0,9555,9556,1,0,0,0,9556,9568,1,0,0,0,9557,9559,3,970,485,
  	0,9558,9560,3,1348,674,0,9559,9558,1,0,0,0,9559,9560,1,0,0,0,9560,9562,
  	1,0,0,0,9561,9563,3,1352,676,0,9562,9561,1,0,0,0,9562,9563,1,0,0,0,9563,
  	9568,1,0,0,0,9564,9566,3,1352,676,0,9565,9564,1,0,0,0,9565,9566,1,0,0,
  	0,9566,9568,1,0,0,0,9567,9550,1,0,0,0,9567,9557,1,0,0,0,9567,9565,1,0,
  	0,0,9568,9569,1,0,0,0,9569,9644,5,3,0,0,9570,9571,5,30,0,0,9571,9572,
  	5,2,0,0,9572,9574,3,1346,673,0,9573,9575,3,1356,678,0,9574,9573,1,0,0,
  	0,9574,9575,1,0,0,0,9575,9576,1,0,0,0,9576,9577,5,3,0,0,9577,9644,1,0,
  	0,0,9578,9579,5,37,0,0,9579,9580,5,2,0,0,9580,9581,3,1164,582,0,9581,
  	9582,5,3,0,0,9582,9644,1,0,0,0,9583,9584,5,38,0,0,9584,9585,5,2,0,0,9585,
  	9587,3,1346,673,0,9586,9588,3,1352,676,0,9587,9586,1,0,0,0,9587,9588,
  	1,0,0,0,9588,9589,1,0,0,0,9589,9590,5,3,0,0,9590,9644,1,0,0,0,9591,9592,
  	5,41,0,0,9592,9593,5,2,0,0,9593,9644,5,3,0,0,9594,9595,5,36,0,0,9595,
  	9596,5,2,0,0,9596,9597,3,1346,673,0,9597,9598,5,6,0,0,9598,9600,3,1164,
  	582,0,9599,9601,3,1330,665,0,9600,9599,1,0,0,0,9600,9601,1,0,0,0,9601,
  	9603,1,0,0,0,9602,9604,3,1352,676,0,9603,9602,1,0,0,0,9603,9604,1,0,0,
  	0,9604,9605,1,0,0,0,9605,9607,3,1336,668,0,9606,9608,3,1350,675,0,9607,
  	9606,1,0,0,0,9607,9608,1,0,0,0,9608,9610,1,0,0,0,9609,9611,3,1342,671,
  	0,9610,9609,1,0,0,0,9610,9611,1,0,0,0,9611,9612,1,0,0,0,9612,9613,5,3,
  	0,0,9613,9644,1,0,0,0,9614,9615,5,33,0,0,9615,9616,5,2,0,0,9616,9617,
  	3,1346,673,0,9617,9618,5,6,0,0,9618,9620,3,1164,582,0,9619,9621,3,1330,
  	665,0,9620,9619,1,0,0,0,9620,9621,1,0,0,0,9621,9623,1,0,0,0,9622,9624,
  	3,1344,672,0,9623,9622,1,0,0,0,9623,9624,1,0,0,0,9624,9625,1,0,0,0,9625,
  	9626,5,3,0,0,9626,9644,1,0,0,0,9627,9628,5,40,0,0,9628,9629,5,2,0,0,9629,
  	9630,3,1346,673,0,9630,9631,5,6,0,0,9631,9633,3,1164,582,0,9632,9634,
  	3,1330,665,0,9633,9632,1,0,0,0,9633,9634,1,0,0,0,9634,9636,1,0,0,0,9635,
  	9637,3,1352,676,0,9636,9635,1,0,0,0,9636,9637,1,0,0,0,9637,9639,1,0,0,
  	0,9638,9640,3,1342,671,0,9639,9638,1,0,0,0,9639,9640,1,0,0,0,9640,9641,
  	1,0,0,0,9641,9642,5,3,0,0,9642,9644,1,0,0,0,9643,9337,1,0,0,0,9643,9343,
  	1,0,0,0,9643,9344,1,0,0,0,9643,9351,1,0,0,0,9643,9358,1,0,0,0,9643,9365,
  	1,0,0,0,9643,9372,1,0,0,0,9643,9373,1,0,0,0,9643,9374,1,0,0,0,9643,9375,
  	1,0,0,0,9643,9376,1,0,0,0,9643,9377,1,0,0,0,9643,9378,1,0,0,0,9643,9379,
  	1,0,0,0,9643,9386,1,0,0,0,9643,9392,1,0,0,0,9643,9401,1,0,0,0,9643,9410,
  	1,0,0,0,9643,9416,1,0,0,0,9643,9425,1,0,0,0,9643,9432,1,0,0,0,9643,9440,
  	1,0,0,0,9643,9447,1,0,0,0,9643,9452,1,0,0,0,9643,9457,1,0,0,0,9643,9462,
  	1,0,0,0,9643,9467,1,0,0,0,9643,9480,1,0,0,0,9643,9486,1,0,0,0,9643,9491,
  	1,0,0,0,9643,9500,1,0,0,0,9643,9510,1,0,0,0,9643,9521,1,0,0,0,9643,9529,
  	1,0,0,0,9643,9548,1,0,0,0,9643,9570,1,0,0,0,9643,9578,1,0,0,0,9643,9583,
  	1,0,0,0,9643,9591,1,0,0,0,9643,9594,1,0,0,0,9643,9614,1,0,0,0,9643,9627,
  	1,0,0,0,9644,1219,1,0,0,0,9645,9646,5,406,0,0,9646,9651,3,1164,582,0,
  	9647,9648,5,406,0,0,9648,9649,5,300,0,0,9649,9651,5,488,0,0,9650,9645,
  	1,0,0,0,9650,9647,1,0,0,0,9651,1221,1,0,0,0,9652,9653,5,6,0,0,9653,9654,
  	5,370,0,0,9654,9663,5,416,0,0,9655,9656,5,6,0,0,9656,9657,5,370,0,0,9657,
  	9663,5,300,0,0,9658,9659,5,6,0,0,9659,9660,5,370,0,0,9660,9661,5,300,
  	0,0,9661,9663,5,488,0,0,9662,9652,1,0,0,0,9662,9655,1,0,0,0,9662,9658,
  	1,0,0,0,9663,1223,1,0,0,0,9664,9665,5,455,0,0,9665,9666,5,2,0,0,9666,
  	9667,3,1226,613,0,9667,9668,5,3,0,0,9668,1225,1,0,0,0,9669,9674,3,1228,
  	614,0,9670,9671,5,6,0,0,9671,9673,3,1228,614,0,9672,9670,1,0,0,0,9673,
  	9676,1,0,0,0,9674,9672,1,0,0,0,9674,9675,1,0,0,0,9675,1227,1,0,0,0,9676,
  	9674,1,0,0,0,9677,9680,3,1164,582,0,9678,9679,5,74,0,0,9679,9681,3,1422,
  	711,0,9680,9678,1,0,0,0,9680,9681,1,0,0,0,9681,1229,1,0,0,0,9682,9683,
  	7,54,0,0,9683,1231,1,0,0,0,9684,9685,5,323,0,0,9685,9689,5,409,0,0,9686,
  	9687,5,378,0,0,9687,9689,5,409,0,0,9688,9684,1,0,0,0,9688,9686,1,0,0,
  	0,9689,1233,1,0,0,0,9690,9691,5,317,0,0,9691,9706,3,1208,604,0,9692,9693,
  	5,317,0,0,9693,9694,3,1208,604,0,9694,9695,3,1236,618,0,9695,9706,1,0,
  	0,0,9696,9697,5,317,0,0,9697,9698,3,1236,618,0,9698,9699,3,1208,604,0,
  	9699,9706,1,0,0,0,9700,9701,5,317,0,0,9701,9702,3,1236,618,0,9702,9703,
  	3,1208,604,0,9703,9704,3,1236,618,0,9704,9706,1,0,0,0,9705,9690,1,0,0,
  	0,9705,9692,1,0,0,0,9705,9696,1,0,0,0,9705,9700,1,0,0,0,9706,1235,1,0,
  	0,0,9707,9708,5,185,0,0,9708,9709,7,55,0,0,9709,1237,1,0,0,0,9710,9711,
  	5,517,0,0,9711,9712,5,104,0,0,9712,9713,5,2,0,0,9713,9714,3,1004,502,
  	0,9714,9715,5,3,0,0,9715,1239,1,0,0,0,9716,9717,5,518,0,0,9717,9718,5,
  	2,0,0,9718,9719,5,141,0,0,9719,9720,3,1164,582,0,9720,9721,5,3,0,0,9721,
  	1241,1,0,0,0,9722,9723,5,142,0,0,9723,9724,3,1244,622,0,9724,1243,1,0,
  	0,0,9725,9730,3,1246,623,0,9726,9727,5,6,0,0,9727,9729,3,1246,623,0,9728,
  	9726,1,0,0,0,9729,9732,1,0,0,0,9730,9728,1,0,0,0,9730,9731,1,0,0,0,9731,
  	1245,1,0,0,0,9732,9730,1,0,0,0,9733,9734,3,1416,708,0,9734,9735,5,74,
  	0,0,9735,9736,3,1250,625,0,9736,1247,1,0,0,0,9737,9740,5,162,0,0,9738,
  	9741,3,1250,625,0,9739,9741,3,1416,708,0,9740,9738,1,0,0,0,9740,9739,
  	1,0,0,0,9741,1249,1,0,0,0,9742,9744,5,2,0,0,9743,9745,3,1252,626,0,9744,
  	9743,1,0,0,0,9744,9745,1,0,0,0,9745,9747,1,0,0,0,9746,9748,3,1254,627,
  	0,9747,9746,1,0,0,0,9747,9748,1,0,0,0,9748,9750,1,0,0,0,9749,9751,3,1002,
  	501,0,9750,9749,1,0,0,0,9750,9751,1,0,0,0,9751,9753,1,0,0,0,9752,9754,
  	3,1256,628,0,9753,9752,1,0,0,0,9753,9754,1,0,0,0,9754,9755,1,0,0,0,9755,
  	9756,5,3,0,0,9756,1251,1,0,0,0,9757,9758,3,1416,708,0,9758,1253,1,0,0,
  	0,9759,9760,5,316,0,0,9760,9761,5,185,0,0,9761,9762,3,1282,641,0,9762,
  	1255,1,0,0,0,9763,9764,5,330,0,0,9764,9766,3,1258,629,0,9765,9767,3,1262,
  	631,0,9766,9765,1,0,0,0,9766,9767,1,0,0,0,9767,9779,1,0,0,0,9768,9769,
  	5,351,0,0,9769,9771,3,1258,629,0,9770,9772,3,1262,631,0,9771,9770,1,0,
  	0,0,9771,9772,1,0,0,0,9772,9779,1,0,0,0,9773,9774,5,519,0,0,9774,9776,
  	3,1258,629,0,9775,9777,3,1262,631,0,9776,9775,1,0,0,0,9776,9777,1,0,0,
  	0,9777,9779,1,0,0,0,9778,9763,1,0,0,0,9778,9768,1,0,0,0,9778,9773,1,0,
  	0,0,9779,1257,1,0,0,0,9780,9787,3,1260,630,0,9781,9782,5,418,0,0,9782,
  	9783,3,1260,630,0,9783,9784,5,71,0,0,9784,9785,3,1260,630,0,9785,9787,
  	1,0,0,0,9786,9780,1,0,0,0,9786,9781,1,0,0,0,9787,1259,1,0,0,0,9788,9789,
  	5,393,0,0,9789,9796,7,56,0,0,9790,9791,5,472,0,0,9791,9796,5,445,0,0,
  	9792,9793,3,1164,582,0,9793,9794,7,56,0,0,9794,9796,1,0,0,0,9795,9788,
  	1,0,0,0,9795,9790,1,0,0,0,9795,9792,1,0,0,0,9796,1261,1,0,0,0,9797,9804,
  	5,237,0,0,9798,9799,5,472,0,0,9799,9805,5,445,0,0,9800,9805,5,104,0,0,
  	9801,9805,5,505,0,0,9802,9803,5,300,0,0,9803,9805,5,520,0,0,9804,9798,
  	1,0,0,0,9804,9800,1,0,0,0,9804,9801,1,0,0,0,9804,9802,1,0,0,0,9805,1263,
  	1,0,0,0,9806,9807,5,445,0,0,9807,9809,5,2,0,0,9808,9810,3,1282,641,0,
  	9809,9808,1,0,0,0,9809,9810,1,0,0,0,9810,9811,1,0,0,0,9811,9819,5,3,0,
  	0,9812,9813,5,2,0,0,9813,9814,3,1282,641,0,9814,9815,5,6,0,0,9815,9816,
  	3,1164,582,0,9816,9817,5,3,0,0,9817,9819,1,0,0,0,9818,9806,1,0,0,0,9818,
  	9812,1,0,0,0,9819,1265,1,0,0,0,9820,9821,5,445,0,0,9821,9823,5,2,0,0,
  	9822,9824,3,1282,641,0,9823,9822,1,0,0,0,9823,9824,1,0,0,0,9824,9825,
  	1,0,0,0,9825,9826,5,3,0,0,9826,1267,1,0,0,0,9827,9828,5,2,0,0,9828,9829,
  	3,1282,641,0,9829,9830,5,6,0,0,9830,9831,3,1164,582,0,9831,9832,5,3,0,
  	0,9832,1269,1,0,0,0,9833,9834,7,57,0,0,9834,1271,1,0,0,0,9835,9838,5,
  	29,0,0,9836,9838,3,1274,637,0,9837,9835,1,0,0,0,9837,9836,1,0,0,0,9838,
  	1273,1,0,0,0,9839,9840,7,58,0,0,9840,1275,1,0,0,0,9841,9848,5,29,0,0,
  	9842,9843,5,309,0,0,9843,9844,5,2,0,0,9844,9845,3,684,342,0,9845,9846,
  	5,3,0,0,9846,9848,1,0,0,0,9847,9841,1,0,0,0,9847,9842,1,0,0,0,9848,1277,
  	1,0,0,0,9849,9856,3,1272,636,0,9850,9851,5,309,0,0,9851,9852,5,2,0,0,
  	9852,9853,3,684,342,0,9853,9854,5,3,0,0,9854,9856,1,0,0,0,9855,9849,1,
  	0,0,0,9855,9850,1,0,0,0,9856,1279,1,0,0,0,9857,9870,3,1272,636,0,9858,
  	9859,5,309,0,0,9859,9860,5,2,0,0,9860,9861,3,684,342,0,9861,9862,5,3,
  	0,0,9862,9870,1,0,0,0,9863,9870,5,158,0,0,9864,9865,5,115,0,0,9865,9870,
  	5,158,0,0,9866,9870,5,152,0,0,9867,9868,5,115,0,0,9868,9870,5,152,0,0,
  	9869,9857,1,0,0,0,9869,9858,1,0,0,0,9869,9863,1,0,0,0,9869,9864,1,0,0,
  	0,9869,9866,1,0,0,0,9869,9867,1,0,0,0,9870,1281,1,0,0,0,9871,9876,3,1164,
  	582,0,9872,9873,5,6,0,0,9873,9875,3,1164,582,0,9874,9872,1,0,0,0,9875,
  	9878,1,0,0,0,9876,9874,1,0,0,0,9876,9877,1,0,0,0,9877,1283,1,0,0,0,9878,
  	9876,1,0,0,0,9879,9884,3,1286,643,0,9880,9881,5,6,0,0,9881,9883,3,1286,
  	643,0,9882,9880,1,0,0,0,9883,9886,1,0,0,0,9884,9882,1,0,0,0,9884,9885,
  	1,0,0,0,9885,1285,1,0,0,0,9886,9884,1,0,0,0,9887,9893,3,1164,582,0,9888,
  	9889,3,636,318,0,9889,9890,7,59,0,0,9890,9891,3,1164,582,0,9891,9893,
  	1,0,0,0,9892,9887,1,0,0,0,9892,9888,1,0,0,0,9893,1287,1,0,0,0,9894,9899,
  	3,1118,559,0,9895,9896,5,6,0,0,9896,9898,3,1118,559,0,9897,9895,1,0,0,
  	0,9898,9901,1,0,0,0,9899,9897,1,0,0,0,9899,9900,1,0,0,0,9900,1289,1,0,
  	0,0,9901,9899,1,0,0,0,9902,9905,5,4,0,0,9903,9906,3,1282,641,0,9904,9906,
  	3,1292,646,0,9905,9903,1,0,0,0,9905,9904,1,0,0,0,9905,9906,1,0,0,0,9906,
  	9907,1,0,0,0,9907,9908,5,5,0,0,9908,1291,1,0,0,0,9909,9914,3,1290,645,
  	0,9910,9911,5,6,0,0,9911,9913,3,1290,645,0,9912,9910,1,0,0,0,9913,9916,
  	1,0,0,0,9914,9912,1,0,0,0,9914,9915,1,0,0,0,9915,1293,1,0,0,0,9916,9914,
  	1,0,0,0,9917,9918,3,1296,648,0,9918,9919,5,102,0,0,9919,9920,3,1164,582,
  	0,9920,1295,1,0,0,0,9921,9930,3,1438,719,0,9922,9930,5,415,0,0,9923,9930,
  	5,295,0,0,9924,9930,5,214,0,0,9925,9930,5,256,0,0,9926,9930,5,292,0,0,
  	9927,9930,5,357,0,0,9928,9930,3,1402,701,0,9929,9921,1,0,0,0,9929,9922,
  	1,0,0,0,9929,9923,1,0,0,0,9929,9924,1,0,0,0,9929,9925,1,0,0,0,9929,9926,
  	1,0,0,0,9929,9927,1,0,0,0,9929,9928,1,0,0,0,9930,1297,1,0,0,0,9931,9932,
  	7,60,0,0,9932,1299,1,0,0,0,9933,9934,3,1164,582,0,9934,9935,5,122,0,0,
  	9935,9936,3,1164,582,0,9936,9937,5,102,0,0,9937,9940,3,1164,582,0,9938,
  	9939,5,100,0,0,9939,9941,3,1164,582,0,9940,9938,1,0,0,0,9940,9941,1,0,
  	0,0,9941,1301,1,0,0,0,9942,9943,3,1206,603,0,9943,9944,5,106,0,0,9944,
  	9945,3,1206,603,0,9945,1303,1,0,0,0,9946,9947,3,1164,582,0,9947,9948,
  	5,102,0,0,9948,9949,3,1164,582,0,9949,9950,5,100,0,0,9950,9951,3,1164,
  	582,0,9951,9973,1,0,0,0,9952,9953,3,1164,582,0,9953,9954,5,100,0,0,9954,
  	9955,3,1164,582,0,9955,9956,5,102,0,0,9956,9957,3,1164,582,0,9957,9973,
  	1,0,0,0,9958,9959,3,1164,582,0,9959,9960,5,102,0,0,9960,9961,3,1164,582,
  	0,9961,9973,1,0,0,0,9962,9963,3,1164,582,0,9963,9964,5,100,0,0,9964,9965,
  	3,1164,582,0,9965,9973,1,0,0,0,9966,9967,3,1164,582,0,9967,9968,5,165,
  	0,0,9968,9969,3,1164,582,0,9969,9970,5,235,0,0,9970,9971,3,1164,582,0,
  	9971,9973,1,0,0,0,9972,9946,1,0,0,0,9972,9952,1,0,0,0,9972,9958,1,0,0,
  	0,9972,9962,1,0,0,0,9972,9966,1,0,0,0,9973,1305,1,0,0,0,9974,9975,3,1164,
  	582,0,9975,9976,5,102,0,0,9976,9977,3,1282,641,0,9977,9982,1,0,0,0,9978,
  	9979,5,102,0,0,9979,9982,3,1282,641,0,9980,9982,3,1282,641,0,9981,9974,
  	1,0,0,0,9981,9978,1,0,0,0,9981,9980,1,0,0,0,9982,1307,1,0,0,0,9983,9989,
  	3,968,484,0,9984,9985,5,2,0,0,9985,9986,3,1282,641,0,9986,9987,5,3,0,
  	0,9987,9989,1,0,0,0,9988,9983,1,0,0,0,9988,9984,1,0,0,0,9989,1309,1,0,
  	0,0,9990,9992,5,78,0,0,9991,9993,3,1318,659,0,9992,9991,1,0,0,0,9992,
  	9993,1,0,0,0,9993,9994,1,0,0,0,9994,9996,3,1312,656,0,9995,9997,3,1316,
  	658,0,9996,9995,1,0,0,0,9996,9997,1,0,0,0,9997,9998,1,0,0,0,9998,9999,
  	5,492,0,0,9999,1311,1,0,0,0,10000,10002,3,1314,657,0,10001,10000,1,0,
  	0,0,10002,10003,1,0,0,0,10003,10001,1,0,0,0,10003,10004,1,0,0,0,10004,
  	1313,1,0,0,0,10005,10006,5,140,0,0,10006,10007,3,1164,582,0,10007,10008,
  	5,131,0,0,10008,10009,3,1164,582,0,10009,1315,1,0,0,0,10010,10011,5,96,
  	0,0,10011,10012,3,1164,582,0,10012,1317,1,0,0,0,10013,10014,3,1164,582,
  	0,10014,1319,1,0,0,0,10015,10017,3,1416,708,0,10016,10018,3,1326,663,
  	0,10017,10016,1,0,0,0,10017,10018,1,0,0,0,10018,1321,1,0,0,0,10019,10022,
  	5,11,0,0,10020,10023,3,1386,693,0,10021,10023,5,9,0,0,10022,10020,1,0,
  	0,0,10022,10021,1,0,0,0,10023,10037,1,0,0,0,10024,10033,5,4,0,0,10025,
  	10034,3,1164,582,0,10026,10028,3,1324,662,0,10027,10026,1,0,0,0,10027,
  	10028,1,0,0,0,10028,10029,1,0,0,0,10029,10031,5,8,0,0,10030,10032,3,1324,
  	662,0,10031,10030,1,0,0,0,10031,10032,1,0,0,0,10032,10034,1,0,0,0,10033,
  	10025,1,0,0,0,10033,10027,1,0,0,0,10034,10035,1,0,0,0,10035,10037,5,5,
  	0,0,10036,10019,1,0,0,0,10036,10024,1,0,0,0,10037,1323,1,0,0,0,10038,
  	10039,3,1164,582,0,10039,1325,1,0,0,0,10040,10042,3,1322,661,0,10041,
  	10040,1,0,0,0,10042,10043,1,0,0,0,10043,10041,1,0,0,0,10043,10044,1,0,
  	0,0,10044,1327,1,0,0,0,10045,10047,3,1322,661,0,10046,10045,1,0,0,0,10047,
  	10050,1,0,0,0,10048,10046,1,0,0,0,10048,10049,1,0,0,0,10049,1329,1,0,
  	0,0,10050,10048,1,0,0,0,10051,10052,5,317,0,0,10052,10053,3,1332,666,
  	0,10053,1331,1,0,0,0,10054,10055,6,666,-1,0,10055,10056,3,1334,667,0,
  	10056,10062,1,0,0,0,10057,10058,10,1,0,0,10058,10059,5,6,0,0,10059,10061,
  	3,1334,667,0,10060,10057,1,0,0,0,10061,10064,1,0,0,0,10062,10060,1,0,
  	0,0,10062,10063,1,0,0,0,10063,1333,1,0,0,0,10064,10062,1,0,0,0,10065,
  	10066,3,1346,673,0,10066,10067,5,74,0,0,10067,10068,3,1422,711,0,10068,
  	1335,1,0,0,0,10069,10070,5,410,0,0,10070,10095,5,412,0,0,10071,10072,
  	5,410,0,0,10072,10073,5,73,0,0,10073,10095,5,412,0,0,10074,10075,5,143,
  	0,0,10075,10095,5,412,0,0,10076,10077,5,143,0,0,10077,10078,5,73,0,0,
  	10078,10095,5,412,0,0,10079,10080,5,143,0,0,10080,10081,5,48,0,0,10081,
  	10082,5,73,0,0,10082,10095,5,412,0,0,10083,10084,5,143,0,0,10084,10085,
  	5,65,0,0,10085,10086,5,73,0,0,10086,10095,5,412,0,0,10087,10088,5,143,
  	0,0,10088,10089,5,48,0,0,10089,10095,5,412,0,0,10090,10091,5,143,0,0,
  	10091,10092,5,65,0,0,10092,10095,5,412,0,0,10093,10095,1,0,0,0,10094,
  	10069,1,0,0,0,10094,10071,1,0,0,0,10094,10074,1,0,0,0,10094,10076,1,0,
  	0,0,10094,10079,1,0,0,0,10094,10083,1,0,0,0,10094,10087,1,0,0,0,10094,
  	10090,1,0,0,0,10094,10093,1,0,0,0,10095,1337,1,0,0,0,10096,10097,5,91,
  	0,0,10097,10100,3,1164,582,0,10098,10100,3,1340,670,0,10099,10096,1,0,
  	0,0,10099,10098,1,0,0,0,10100,1339,1,0,0,0,10101,10112,5,529,0,0,10102,
  	10112,5,116,0,0,10103,10112,5,134,0,0,10104,10112,5,98,0,0,10105,10112,
  	5,396,0,0,10106,10107,5,50,0,0,10107,10112,5,73,0,0,10108,10109,5,50,
  	0,0,10109,10112,5,305,0,0,10110,10112,5,50,0,0,10111,10101,1,0,0,0,10111,
  	10102,1,0,0,0,10111,10103,1,0,0,0,10111,10104,1,0,0,0,10111,10105,1,0,
  	0,0,10111,10106,1,0,0,0,10111,10108,1,0,0,0,10111,10110,1,0,0,0,10112,
  	1341,1,0,0,0,10113,10114,3,1338,669,0,10114,10115,5,118,0,0,10115,10116,
  	5,50,0,0,10116,10129,1,0,0,0,10117,10118,3,1338,669,0,10118,10119,5,118,
  	0,0,10119,10120,5,529,0,0,10120,10129,1,0,0,0,10121,10122,3,1338,669,
  	0,10122,10123,5,118,0,0,10123,10124,5,50,0,0,10124,10125,3,1338,669,0,
  	10125,10126,5,118,0,0,10126,10127,5,529,0,0,10127,10129,1,0,0,0,10128,
  	10113,1,0,0,0,10128,10117,1,0,0,0,10128,10121,1,0,0,0,10129,1343,1,0,
  	0,0,10130,10131,3,1338,669,0,10131,10132,5,118,0,0,10132,10133,5,529,
  	0,0,10133,1345,1,0,0,0,10134,10136,3,1164,582,0,10135,10137,3,1348,674,
  	0,10136,10135,1,0,0,0,10136,10137,1,0,0,0,10137,1347,1,0,0,0,10138,10139,
  	5,67,0,0,10139,10140,5,30,0,0,10140,10141,5,232,0,0,10141,10145,3,1384,
  	692,0,10142,10143,5,67,0,0,10143,10145,5,30,0,0,10144,10138,1,0,0,0,10144,
  	10142,1,0,0,0,10145,1349,1,0,0,0,10146,10147,5,53,0,0,10147,10148,5,60,
  	0,0,10148,10149,5,118,0,0,10149,10150,5,61,0,0,10150,10161,5,63,0,0,10151,
  	10152,5,53,0,0,10152,10161,5,60,0,0,10153,10154,5,56,0,0,10154,10155,
  	5,60,0,0,10155,10156,5,118,0,0,10156,10157,5,61,0,0,10157,10161,5,63,
  	0,0,10158,10159,5,56,0,0,10159,10161,5,60,0,0,10160,10146,1,0,0,0,10160,
  	10151,1,0,0,0,10160,10153,1,0,0,0,10160,10158,1,0,0,0,10161,1351,1,0,
  	0,0,10162,10163,5,125,0,0,10163,10165,3,1118,559,0,10164,10166,3,1348,
  	674,0,10165,10164,1,0,0,0,10165,10166,1,0,0,0,10166,1353,1,0,0,0,10167,
  	10177,5,30,0,0,10168,10169,5,30,0,0,10169,10177,5,488,0,0,10170,10171,
  	5,30,0,0,10171,10177,5,73,0,0,10172,10173,5,30,0,0,10173,10177,5,305,
  	0,0,10174,10175,5,30,0,0,10175,10177,5,61,0,0,10176,10167,1,0,0,0,10176,
  	10168,1,0,0,0,10176,10170,1,0,0,0,10176,10172,1,0,0,0,10176,10174,1,0,
  	0,0,10177,1355,1,0,0,0,10178,10179,5,143,0,0,10179,10180,5,136,0,0,10180,
  	10189,5,54,0,0,10181,10182,5,143,0,0,10182,10189,5,136,0,0,10183,10184,
  	5,410,0,0,10184,10185,5,136,0,0,10185,10189,5,54,0,0,10186,10187,5,410,
  	0,0,10187,10189,5,136,0,0,10188,10178,1,0,0,0,10188,10181,1,0,0,0,10188,
  	10183,1,0,0,0,10188,10186,1,0,0,0,10189,1357,1,0,0,0,10190,10191,6,679,
  	-1,0,10191,10192,3,1360,680,0,10192,10198,1,0,0,0,10193,10194,10,1,0,
  	0,10194,10195,5,6,0,0,10195,10197,3,1360,680,0,10196,10193,1,0,0,0,10197,
  	10200,1,0,0,0,10198,10196,1,0,0,0,10198,10199,1,0,0,0,10199,1359,1,0,
  	0,0,10200,10198,1,0,0,0,10201,10202,3,1208,604,0,10202,10203,5,488,0,
  	0,10203,10204,3,1346,673,0,10204,10210,1,0,0,0,10205,10206,3,1164,582,
  	0,10206,10207,5,8,0,0,10207,10208,3,1346,673,0,10208,10210,1,0,0,0,10209,
  	10201,1,0,0,0,10209,10205,1,0,0,0,10210,1361,1,0,0,0,10211,10212,5,116,
  	0,0,10212,10213,5,118,0,0,10213,10218,5,116,0,0,10214,10215,5,43,0,0,
  	10215,10216,5,118,0,0,10216,10218,5,116,0,0,10217,10211,1,0,0,0,10217,
  	10214,1,0,0,0,10218,1363,1,0,0,0,10219,10220,5,116,0,0,10220,10221,5,
  	118,0,0,10221,10226,5,116,0,0,10222,10223,5,43,0,0,10223,10224,5,118,
  	0,0,10224,10226,5,116,0,0,10225,10219,1,0,0,0,10225,10222,1,0,0,0,10226,
  	1365,1,0,0,0,10227,10228,6,683,-1,0,10228,10229,3,1346,673,0,10229,10235,
  	1,0,0,0,10230,10231,10,1,0,0,10231,10232,5,6,0,0,10232,10234,3,1346,673,
  	0,10233,10230,1,0,0,0,10234,10237,1,0,0,0,10235,10233,1,0,0,0,10235,10236,
  	1,0,0,0,10236,1367,1,0,0,0,10237,10235,1,0,0,0,10238,10239,5,35,0,0,10239,
  	10240,5,2,0,0,10240,10242,3,1360,680,0,10241,10243,3,1362,681,0,10242,
  	10241,1,0,0,0,10242,10243,1,0,0,0,10243,10245,1,0,0,0,10244,10246,3,1356,
  	678,0,10245,10244,1,0,0,0,10245,10246,1,0,0,0,10246,10247,1,0,0,0,10247,
  	10248,3,1352,676,0,10248,10249,5,3,0,0,10249,10263,1,0,0,0,10250,10251,
  	5,32,0,0,10251,10252,5,2,0,0,10252,10254,3,1346,673,0,10253,10255,3,1370,
  	685,0,10254,10253,1,0,0,0,10254,10255,1,0,0,0,10255,10257,1,0,0,0,10256,
  	10258,3,1364,682,0,10257,10256,1,0,0,0,10257,10258,1,0,0,0,10258,10259,
  	1,0,0,0,10259,10260,3,1352,676,0,10260,10261,5,3,0,0,10261,10263,1,0,
  	0,0,10262,10238,1,0,0,0,10262,10250,1,0,0,0,10263,1369,1,0,0,0,10264,
  	10265,5,121,0,0,10265,10266,5,185,0,0,10266,10267,3,1006,503,0,10267,
  	1371,1,0,0,0,10268,10269,3,1374,687,0,10269,1373,1,0,0,0,10270,10275,
  	3,1376,688,0,10271,10272,5,6,0,0,10272,10274,3,1376,688,0,10273,10271,
  	1,0,0,0,10274,10277,1,0,0,0,10275,10273,1,0,0,0,10275,10276,1,0,0,0,10276,
  	1375,1,0,0,0,10277,10275,1,0,0,0,10278,10283,3,1164,582,0,10279,10280,
  	5,74,0,0,10280,10284,3,1422,711,0,10281,10284,3,1424,712,0,10282,10284,
  	1,0,0,0,10283,10279,1,0,0,0,10283,10281,1,0,0,0,10283,10282,1,0,0,0,10284,
  	10287,1,0,0,0,10285,10287,5,9,0,0,10286,10278,1,0,0,0,10286,10285,1,0,
  	0,0,10287,1377,1,0,0,0,10288,10293,3,1380,690,0,10289,10290,5,6,0,0,10290,
  	10292,3,1380,690,0,10291,10289,1,0,0,0,10292,10295,1,0,0,0,10293,10291,
  	1,0,0,0,10293,10294,1,0,0,0,10294,1379,1,0,0,0,10295,10293,1,0,0,0,10296,
  	10298,3,1416,708,0,10297,10299,3,1326,663,0,10298,10297,1,0,0,0,10298,
  	10299,1,0,0,0,10299,1381,1,0,0,0,10300,10305,3,1384,692,0,10301,10302,
  	5,6,0,0,10302,10304,3,1384,692,0,10303,10301,1,0,0,0,10304,10307,1,0,
  	0,0,10305,10303,1,0,0,0,10305,10306,1,0,0,0,10306,1383,1,0,0,0,10307,
  	10305,1,0,0,0,10308,10309,3,1416,708,0,10309,1385,1,0,0,0,10310,10311,
  	3,1422,711,0,10311,1387,1,0,0,0,10312,10313,3,1402,701,0,10313,1389,1,
  	0,0,0,10314,10319,3,1418,709,0,10315,10316,3,1416,708,0,10316,10317,3,
  	1326,663,0,10317,10319,1,0,0,0,10318,10314,1,0,0,0,10318,10315,1,0,0,
  	0,10319,1391,1,0,0,0,10320,10356,3,1400,700,0,10321,10356,3,1398,699,
  	0,10322,10356,3,1402,701,0,10323,10356,3,1396,698,0,10324,10356,3,1394,
  	697,0,10325,10335,3,1390,695,0,10326,10336,3,1402,701,0,10327,10328,5,
  	2,0,0,10328,10330,3,1284,642,0,10329,10331,3,1002,501,0,10330,10329,1,
  	0,0,0,10330,10331,1,0,0,0,10331,10332,1,0,0,0,10332,10333,5,3,0,0,10333,
  	10334,3,1402,701,0,10334,10336,1,0,0,0,10335,10326,1,0,0,0,10335,10327,
  	1,0,0,0,10336,10356,1,0,0,0,10337,10338,3,1124,562,0,10338,10339,3,1402,
  	701,0,10339,10356,1,0,0,0,10340,10350,3,1152,576,0,10341,10343,3,1402,
  	701,0,10342,10344,3,1156,578,0,10343,10342,1,0,0,0,10343,10344,1,0,0,
  	0,10344,10351,1,0,0,0,10345,10346,5,2,0,0,10346,10347,3,1400,700,0,10347,
  	10348,5,3,0,0,10348,10349,3,1402,701,0,10349,10351,1,0,0,0,10350,10341,
  	1,0,0,0,10350,10345,1,0,0,0,10351,10356,1,0,0,0,10352,10356,5,134,0,0,
  	10353,10356,5,98,0,0,10354,10356,5,116,0,0,10355,10320,1,0,0,0,10355,
  	10321,1,0,0,0,10355,10322,1,0,0,0,10355,10323,1,0,0,0,10355,10324,1,0,
  	0,0,10355,10325,1,0,0,0,10355,10337,1,0,0,0,10355,10340,1,0,0,0,10355,
  	10352,1,0,0,0,10355,10353,1,0,0,0,10355,10354,1,0,0,0,10356,1393,1,0,
  	0,0,10357,10358,5,572,0,0,10358,1395,1,0,0,0,10359,10360,5,568,0,0,10360,
  	1397,1,0,0,0,10361,10362,5,581,0,0,10362,1399,1,0,0,0,10363,10364,7,61,
  	0,0,10364,1401,1,0,0,0,10365,10367,3,1404,702,0,10366,10368,3,1406,703,
  	0,10367,10366,1,0,0,0,10367,10368,1,0,0,0,10368,1403,1,0,0,0,10369,10381,
  	5,563,0,0,10370,10381,5,565,0,0,10371,10375,5,567,0,0,10372,10374,5,596,
  	0,0,10373,10372,1,0,0,0,10374,10377,1,0,0,0,10375,10373,1,0,0,0,10375,
  	10376,1,0,0,0,10376,10378,1,0,0,0,10377,10375,1,0,0,0,10378,10381,5,597,
  	0,0,10379,10381,5,590,0,0,10380,10369,1,0,0,0,10380,10370,1,0,0,0,10380,
  	10371,1,0,0,0,10380,10379,1,0,0,0,10381,1405,1,0,0,0,10382,10383,5,525,
  	0,0,10383,10384,3,1404,702,0,10384,1407,1,0,0,0,10385,10391,3,1400,700,
  	0,10386,10387,5,12,0,0,10387,10391,3,1400,700,0,10388,10389,5,13,0,0,
  	10389,10391,3,1400,700,0,10390,10385,1,0,0,0,10390,10386,1,0,0,0,10390,
  	10388,1,0,0,0,10391,1409,1,0,0,0,10392,10393,3,1412,706,0,10393,1411,
  	1,0,0,0,10394,10398,3,1420,710,0,10395,10398,5,90,0,0,10396,10398,5,127,
  	0,0,10397,10394,1,0,0,0,10397,10395,1,0,0,0,10397,10396,1,0,0,0,10398,
  	1413,1,0,0,0,10399,10404,3,1412,706,0,10400,10401,5,6,0,0,10401,10403,
  	3,1412,706,0,10402,10400,1,0,0,0,10403,10406,1,0,0,0,10404,10402,1,0,
  	0,0,10404,10405,1,0,0,0,10405,1415,1,0,0,0,10406,10404,1,0,0,0,10407,
  	10411,3,1438,719,0,10408,10411,3,1426,713,0,10409,10411,3,1428,714,0,
  	10410,10407,1,0,0,0,10410,10408,1,0,0,0,10410,10409,1,0,0,0,10411,1417,
  	1,0,0,0,10412,10416,3,1438,719,0,10413,10416,3,1426,713,0,10414,10416,
  	3,1430,715,0,10415,10412,1,0,0,0,10415,10413,1,0,0,0,10415,10414,1,0,
  	0,0,10416,1419,1,0,0,0,10417,10422,3,1438,719,0,10418,10422,3,1426,713,
  	0,10419,10422,3,1428,714,0,10420,10422,3,1430,715,0,10421,10417,1,0,0,
  	0,10421,10418,1,0,0,0,10421,10419,1,0,0,0,10421,10420,1,0,0,0,10422,1421,
  	1,0,0,0,10423,10430,3,1438,719,0,10424,10430,3,1426,713,0,10425,10430,
  	3,1428,714,0,10426,10430,3,1430,715,0,10427,10430,3,1432,716,0,10428,
  	10430,5,541,0,0,10429,10423,1,0,0,0,10429,10424,1,0,0,0,10429,10425,1,
  	0,0,0,10429,10426,1,0,0,0,10429,10427,1,0,0,0,10429,10428,1,0,0,0,10430,
  	1423,1,0,0,0,10431,10434,3,1438,719,0,10432,10434,3,1434,717,0,10433,
  	10431,1,0,0,0,10433,10432,1,0,0,0,10434,1425,1,0,0,0,10435,10436,7,62,
  	0,0,10436,1427,1,0,0,0,10437,10501,5,418,0,0,10438,10501,5,419,0,0,10439,
  	10501,5,420,0,0,10440,10501,5,421,0,0,10441,10501,5,422,0,0,10442,10501,
  	3,1142,571,0,10443,10501,5,424,0,0,10444,10501,5,425,0,0,10445,10501,
  	5,426,0,0,10446,10501,5,427,0,0,10447,10501,5,428,0,0,10448,10501,5,429,
  	0,0,10449,10501,5,430,0,0,10450,10501,5,508,0,0,10451,10501,5,431,0,0,
  	10452,10501,5,432,0,0,10453,10501,5,433,0,0,10454,10501,5,434,0,0,10455,
  	10501,5,30,0,0,10456,10501,5,31,0,0,10457,10501,5,32,0,0,10458,10501,
  	5,33,0,0,10459,10501,5,34,0,0,10460,10501,5,35,0,0,10461,10501,5,36,0,
  	0,10462,10501,5,37,0,0,10463,10501,5,38,0,0,10464,10501,5,39,0,0,10465,
  	10501,5,40,0,0,10466,10501,5,435,0,0,10467,10501,5,41,0,0,10468,10501,
  	5,436,0,0,10469,10501,5,437,0,0,10470,10501,5,438,0,0,10471,10501,5,527,
  	0,0,10472,10501,5,439,0,0,10473,10501,5,440,0,0,10474,10501,5,491,0,0,
  	10475,10501,5,441,0,0,10476,10501,5,442,0,0,10477,10501,5,443,0,0,10478,
  	10501,5,444,0,0,10479,10501,5,445,0,0,10480,10501,5,446,0,0,10481,10501,
  	5,447,0,0,10482,10501,5,448,0,0,10483,10501,5,449,0,0,10484,10501,5,450,
  	0,0,10485,10501,5,451,0,0,10486,10501,5,452,0,0,10487,10501,5,453,0,0,
  	10488,10501,5,454,0,0,10489,10501,5,455,0,0,10490,10501,5,463,0,0,10491,
  	10501,5,464,0,0,10492,10501,5,465,0,0,10493,10501,5,466,0,0,10494,10501,
  	5,514,0,0,10495,10501,5,467,0,0,10496,10501,5,468,0,0,10497,10501,5,469,
  	0,0,10498,10501,5,470,0,0,10499,10501,5,512,0,0,10500,10437,1,0,0,0,10500,
  	10438,1,0,0,0,10500,10439,1,0,0,0,10500,10440,1,0,0,0,10500,10441,1,0,
  	0,0,10500,10442,1,0,0,0,10500,10443,1,0,0,0,10500,10444,1,0,0,0,10500,
  	10445,1,0,0,0,10500,10446,1,0,0,0,10500,10447,1,0,0,0,10500,10448,1,0,
  	0,0,10500,10449,1,0,0,0,10500,10450,1,0,0,0,10500,10451,1,0,0,0,10500,
  	10452,1,0,0,0,10500,10453,1,0,0,0,10500,10454,1,0,0,0,10500,10455,1,0,
  	0,0,10500,10456,1,0,0,0,10500,10457,1,0,0,0,10500,10458,1,0,0,0,10500,
  	10459,1,0,0,0,10500,10460,1,0,0,0,10500,10461,1,0,0,0,10500,10462,1,0,
  	0,0,10500,10463,1,0,0,0,10500,10464,1,0,0,0,10500,10465,1,0,0,0,10500,
  	10466,1,0,0,0,10500,10467,1,0,0,0,10500,10468,1,0,0,0,10500,10469,1,0,
  	0,0,10500,10470,1,0,0,0,10500,10471,1,0,0,0,10500,10472,1,0,0,0,10500,
  	10473,1,0,0,0,10500,10474,1,0,0,0,10500,10475,1,0,0,0,10500,10476,1,0,
  	0,0,10500,10477,1,0,0,0,10500,10478,1,0,0,0,10500,10479,1,0,0,0,10500,
  	10480,1,0,0,0,10500,10481,1,0,0,0,10500,10482,1,0,0,0,10500,10483,1,0,
  	0,0,10500,10484,1,0,0,0,10500,10485,1,0,0,0,10500,10486,1,0,0,0,10500,
  	10487,1,0,0,0,10500,10488,1,0,0,0,10500,10489,1,0,0,0,10500,10490,1,0,
  	0,0,10500,10491,1,0,0,0,10500,10492,1,0,0,0,10500,10493,1,0,0,0,10500,
  	10494,1,0,0,0,10500,10495,1,0,0,0,10500,10496,1,0,0,0,10500,10497,1,0,
  	0,0,10500,10498,1,0,0,0,10500,10499,1,0,0,0,10501,1429,1,0,0,0,10502,
  	10503,7,63,0,0,10503,1431,1,0,0,0,10504,10505,7,64,0,0,10505,1433,1,0,
  	0,0,10506,10507,7,65,0,0,10507,1435,1,0,0,0,10508,10509,3,1416,708,0,
  	10509,1437,1,0,0,0,10510,10512,5,554,0,0,10511,10513,3,1406,703,0,10512,
  	10511,1,0,0,0,10512,10513,1,0,0,0,10513,10518,1,0,0,0,10514,10518,5,555,
  	0,0,10515,10518,5,559,0,0,10516,10518,5,582,0,0,10517,10510,1,0,0,0,10517,
  	10514,1,0,0,0,10517,10515,1,0,0,0,10517,10516,1,0,0,0,10518,1439,1,0,
  	0,0,1051,1446,1450,1454,1581,1590,1599,1605,1611,1626,1638,1644,1652,
  	1663,1667,1675,1683,1701,1704,1709,1718,1727,1731,1743,1749,1765,1778,
  	1785,1793,1798,1805,1811,1818,1829,1833,1837,1850,1854,1859,1864,1876,
  	1885,1898,1903,1914,1920,1926,1931,1942,1948,1954,1963,1973,1988,1994,
  	2001,2006,2013,2024,2048,2055,2064,2073,2081,2091,2100,2109,2117,2125,
  	2134,2143,2147,2154,2162,2172,2178,2182,2186,2190,2194,2199,2202,2206,
  	2227,2233,2328,2335,2351,2365,2375,2377,2382,2386,2389,2395,2397,2425,
  	2435,2448,2455,2461,2465,2471,2476,2479,2481,2486,2490,2494,2498,2502,
  	2505,2509,2517,2521,2525,2534,2541,2546,2553,2558,2565,2570,2588,2593,
  	2605,2610,2619,2626,2633,2639,2644,2648,2651,2654,2657,2660,2663,2668,
  	2671,2674,2677,2680,2683,2689,2693,2696,2699,2702,2705,2707,2716,2729,
  	2737,2743,2747,2752,2759,2766,2777,2784,2787,2792,2795,2802,2811,2818,
  	2823,2826,2829,2831,2836,2843,2853,2863,2876,2879,2882,2889,2897,2900,
  	2903,2910,2914,2920,2923,2926,2929,2941,2944,2947,2951,2965,2983,2994,
  	3009,3025,3046,3051,3054,3058,3061,3067,3070,3072,3081,3090,3109,3113,
  	3124,3133,3139,3145,3149,3152,3155,3158,3161,3167,3171,3178,3184,3188,
  	3191,3194,3197,3205,3209,3213,3219,3223,3229,3243,3252,3269,3274,3277,
  	3279,3289,3296,3301,3304,3307,3314,3317,3319,3325,3334,3344,3349,3358,
  	3367,3371,3378,3388,3399,3509,3517,3520,3530,3535,3545,3556,3568,3581,
  	3591,3604,3607,3614,3623,3626,3633,3635,3643,3653,3655,3663,3667,3672,
  	3683,3687,3692,3702,3708,3721,3727,3729,3736,3744,3749,3764,3777,3779,
  	3783,3803,3820,3823,3826,3829,3832,3840,3843,3846,3892,3895,3898,3916,
  	3923,3932,3938,3945,3955,3963,3968,3980,3997,4003,4010,4018,4032,4060,
  	4067,4081,4096,4109,4118,4143,4154,4221,4232,4238,4246,4257,4271,4280,
  	4290,4302,4317,4328,4336,4346,4353,4356,4362,4365,4380,4393,4422,4429,
  	4444,4453,4464,4466,4475,4486,4488,4495,4510,4516,4524,4530,4538,4548,
  	4554,4562,4568,4576,4583,4592,4594,4619,4626,4637,4643,4652,4657,4663,
  	4670,4675,4679,4682,4688,4837,4841,4846,4857,4868,4879,4890,4901,4912,
  	4923,4935,4946,4954,4961,4967,4975,4980,4985,4990,4996,5003,5009,5015,
  	5020,5026,5033,5038,5044,5051,5054,5067,5076,5088,5090,5107,5114,5119,
  	5123,5127,5131,5133,5193,5200,5206,5217,5220,5227,5230,5240,5243,5245,
  	5264,5276,5285,5294,5306,5308,5314,5318,5321,5324,5329,5335,5338,5341,
  	5344,5347,5351,5355,5358,5364,5370,5373,5376,5379,5382,5384,5390,5408,
  	5412,5415,5418,5421,5424,5429,5432,5434,5447,5459,5473,5477,5489,5491,
  	5500,5509,5517,5526,5528,5532,5541,5546,5552,5557,5561,5566,5574,5581,
  	5586,5601,5610,5621,5627,5666,5676,5683,5694,5708,5716,5721,5729,5737,
  	5743,5751,5757,5765,5767,5773,5781,5783,5789,5797,5799,5823,5830,5840,
  	5852,5857,5870,5882,5894,5896,5902,5907,5915,5922,5967,5972,5979,5983,
  	5987,5993,5997,6002,6006,6009,6011,6033,6104,6299,6312,6323,6336,6348,
  	6362,6394,6408,6520,6522,6533,6544,6555,6568,6580,6591,6598,6819,6834,
  	6845,6852,6906,7047,7053,7056,7066,7095,7105,7112,7135,7144,7156,7162,
  	7170,7172,7176,7186,7190,7200,7203,7207,7211,7219,7230,7242,7246,7249,
  	7253,7256,7261,7265,7268,7272,7275,7279,7282,7293,7300,7313,7327,7331,
  	7336,7343,7350,7353,7358,7361,7370,7372,7377,7381,7393,7396,7403,7407,
  	7412,7422,7431,7434,7439,7450,7454,7460,7467,7487,7508,7512,7517,7600,
  	7606,7619,7623,7627,7631,7637,7644,7647,7650,7653,7656,7663,7665,7669,
  	7672,7679,7681,7688,7696,7703,7708,7712,7716,7720,7724,7740,7747,7757,
  	7770,7781,7788,7793,7797,7801,7806,7819,7824,7828,7836,7839,7843,7854,
  	7857,7859,7875,7878,7885,7888,7893,7908,7914,7923,7932,7939,7942,7948,
  	7953,7960,7964,7969,7972,7978,7982,7984,7987,7994,7997,8004,8012,8015,
  	8024,8029,8035,8038,8041,8048,8052,8055,8070,8073,8080,8083,8090,8093,
  	8096,8103,8116,8126,8134,8146,8148,8155,8159,8169,8173,8177,8181,8183,
  	8188,8192,8196,8198,8200,8205,8210,8216,8221,8226,8229,8232,8235,8238,
  	8241,8244,8247,8252,8255,8258,8261,8264,8267,8269,8275,8279,8288,8293,
  	8297,8306,8316,8320,8325,8331,8343,8358,8365,8367,8370,8374,8378,8380,
  	8388,8397,8403,8405,8407,8414,8418,8427,8431,8446,8454,8482,8489,8493,
  	8496,8501,8505,8508,8524,8535,8540,8543,8547,8551,8555,8560,8564,8568,
  	8570,8579,8584,8590,8594,8596,8603,8608,8614,8616,8620,8627,8632,8635,
  	8641,8645,8654,8658,8666,8668,8675,8680,8683,8691,8700,8708,8710,8714,
  	8721,8740,8749,8755,8774,8783,8789,8793,8798,8808,8815,8824,8827,8836,
  	8838,8842,8847,8857,8863,8866,8873,8877,8880,8893,8899,8903,8907,8910,
  	8918,8922,8926,8934,8941,8948,8952,8958,8960,8969,8972,8982,8998,9004,
  	9009,9016,9029,9036,9044,9052,9057,9061,9067,9071,9075,9078,9084,9089,
  	9105,9108,9110,9122,9124,9128,9134,9138,9140,9148,9152,9161,9169,9175,
  	9178,9187,9192,9199,9209,9235,9246,9248,9250,9258,9280,9289,9299,9302,
  	9307,9312,9316,9322,9325,9328,9331,9335,9349,9356,9363,9370,9389,9397,
  	9405,9407,9413,9420,9422,9435,9474,9476,9496,9506,9517,9534,9537,9540,
  	9543,9545,9552,9555,9559,9562,9565,9567,9574,9587,9600,9603,9607,9610,
  	9620,9623,9633,9636,9639,9643,9650,9662,9674,9680,9688,9705,9730,9740,
  	9744,9747,9750,9753,9766,9771,9776,9778,9786,9795,9804,9809,9818,9823,
  	9837,9847,9855,9869,9876,9884,9892,9899,9905,9914,9929,9940,9972,9981,
  	9988,9992,9996,10003,10017,10022,10027,10031,10033,10036,10043,10048,
  	10062,10094,10099,10111,10128,10136,10144,10160,10165,10176,10188,10198,
  	10209,10217,10225,10235,10242,10245,10254,10257,10262,10275,10283,10286,
  	10293,10298,10305,10318,10330,10335,10343,10350,10355,10367,10375,10380,
  	10390,10397,10404,10410,10415,10421,10429,10433,10500,10512,10517
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  postgresqlparserParserStaticData = std::move(staticData);
}

}

PostgreSQLParser::PostgreSQLParser(TokenStream *input) : PostgreSQLParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

PostgreSQLParser::PostgreSQLParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : PostgreSQLParserBase(input) {
  PostgreSQLParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *postgresqlparserParserStaticData->atn, postgresqlparserParserStaticData->decisionToDFA, postgresqlparserParserStaticData->sharedContextCache, options);
}

PostgreSQLParser::~PostgreSQLParser() {
  delete _interpreter;
}

const atn::ATN& PostgreSQLParser::getATN() const {
  return *postgresqlparserParserStaticData->atn;
}

std::string PostgreSQLParser::getGrammarFileName() const {
  return "PostgreSQLParser.g4";
}

const std::vector<std::string>& PostgreSQLParser::getRuleNames() const {
  return postgresqlparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& PostgreSQLParser::getVocabulary() const {
  return postgresqlparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView PostgreSQLParser::getSerializedATN() const {
  return postgresqlparserParserStaticData->serializedATN;
}


//----------------- RootContext ------------------------------------------------------------------

PostgreSQLParser::RootContext::RootContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::StmtblockContext* PostgreSQLParser::RootContext::stmtblock() {
  return getRuleContext<PostgreSQLParser::StmtblockContext>(0);
}

tree::TerminalNode* PostgreSQLParser::RootContext::EOF() {
  return getToken(PostgreSQLParser::EOF, 0);
}


size_t PostgreSQLParser::RootContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRoot;
}


std::any PostgreSQLParser::RootContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRoot(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RootContext* PostgreSQLParser::root() {
  RootContext *_localctx = _tracker.createInstance<RootContext>(_ctx, getState());
  enterRule(_localctx, 0, PostgreSQLParser::RuleRoot);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1440);
    stmtblock();
    setState(1441);
    match(PostgreSQLParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StmtblockContext ------------------------------------------------------------------

PostgreSQLParser::StmtblockContext::StmtblockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::StmtmultiContext* PostgreSQLParser::StmtblockContext::stmtmulti() {
  return getRuleContext<PostgreSQLParser::StmtmultiContext>(0);
}


size_t PostgreSQLParser::StmtblockContext::getRuleIndex() const {
  return PostgreSQLParser::RuleStmtblock;
}


std::any PostgreSQLParser::StmtblockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitStmtblock(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::StmtblockContext* PostgreSQLParser::stmtblock() {
  StmtblockContext *_localctx = _tracker.createInstance<StmtblockContext>(_ctx, getState());
  enterRule(_localctx, 2, PostgreSQLParser::RuleStmtblock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1443);
    stmtmulti();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StmtmultiContext ------------------------------------------------------------------

PostgreSQLParser::StmtmultiContext::StmtmultiContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::StmtContext *> PostgreSQLParser::StmtmultiContext::stmt() {
  return getRuleContexts<PostgreSQLParser::StmtContext>();
}

PostgreSQLParser::StmtContext* PostgreSQLParser::StmtmultiContext::stmt(size_t i) {
  return getRuleContext<PostgreSQLParser::StmtContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::StmtmultiContext::SEMI() {
  return getTokens(PostgreSQLParser::SEMI);
}

tree::TerminalNode* PostgreSQLParser::StmtmultiContext::SEMI(size_t i) {
  return getToken(PostgreSQLParser::SEMI, i);
}


size_t PostgreSQLParser::StmtmultiContext::getRuleIndex() const {
  return PostgreSQLParser::RuleStmtmulti;
}


std::any PostgreSQLParser::StmtmultiContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitStmtmulti(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::StmtmultiContext* PostgreSQLParser::stmtmulti() {
  StmtmultiContext *_localctx = _tracker.createInstance<StmtmultiContext>(_ctx, getState());
  enterRule(_localctx, 4, PostgreSQLParser::RuleStmtmulti);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1446);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OPEN_PAREN || ((((_la - 69) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 69)) & 2449958215610302467) != 0) || ((((_la - 143) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 143)) & 104710898966331393) != 0) || ((((_la - 207) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 207)) & -9223372011080506623) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 281)) & -8824802370318728173) != 0) || ((((_la - 348) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 348)) & 14075947867505701) != 0) || ((((_la - 453) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 453)) & 550292946945) != 0)) {
      setState(1445);
      stmt();
    }
    setState(1454);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::SEMI) {
      setState(1448);
      match(PostgreSQLParser::SEMI);
      setState(1450);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPEN_PAREN || ((((_la - 69) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 69)) & 2449958215610302467) != 0) || ((((_la - 143) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 143)) & 104710898966331393) != 0) || ((((_la - 207) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 207)) & -9223372011080506623) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 281)) & -8824802370318728173) != 0) || ((((_la - 348) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 348)) & 14075947867505701) != 0) || ((((_la - 453) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 453)) & 550292946945) != 0)) {
        setState(1449);
        stmt();
      }
      setState(1456);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StmtContext ------------------------------------------------------------------

PostgreSQLParser::StmtContext::StmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::AltereventtrigstmtContext* PostgreSQLParser::StmtContext::altereventtrigstmt() {
  return getRuleContext<PostgreSQLParser::AltereventtrigstmtContext>(0);
}

PostgreSQLParser::AltercollationstmtContext* PostgreSQLParser::StmtContext::altercollationstmt() {
  return getRuleContext<PostgreSQLParser::AltercollationstmtContext>(0);
}

PostgreSQLParser::AlterdatabasestmtContext* PostgreSQLParser::StmtContext::alterdatabasestmt() {
  return getRuleContext<PostgreSQLParser::AlterdatabasestmtContext>(0);
}

PostgreSQLParser::AlterdatabasesetstmtContext* PostgreSQLParser::StmtContext::alterdatabasesetstmt() {
  return getRuleContext<PostgreSQLParser::AlterdatabasesetstmtContext>(0);
}

PostgreSQLParser::AlterdefaultprivilegesstmtContext* PostgreSQLParser::StmtContext::alterdefaultprivilegesstmt() {
  return getRuleContext<PostgreSQLParser::AlterdefaultprivilegesstmtContext>(0);
}

PostgreSQLParser::AlterdomainstmtContext* PostgreSQLParser::StmtContext::alterdomainstmt() {
  return getRuleContext<PostgreSQLParser::AlterdomainstmtContext>(0);
}

PostgreSQLParser::AlterenumstmtContext* PostgreSQLParser::StmtContext::alterenumstmt() {
  return getRuleContext<PostgreSQLParser::AlterenumstmtContext>(0);
}

PostgreSQLParser::AlterextensionstmtContext* PostgreSQLParser::StmtContext::alterextensionstmt() {
  return getRuleContext<PostgreSQLParser::AlterextensionstmtContext>(0);
}

PostgreSQLParser::AlterextensioncontentsstmtContext* PostgreSQLParser::StmtContext::alterextensioncontentsstmt() {
  return getRuleContext<PostgreSQLParser::AlterextensioncontentsstmtContext>(0);
}

PostgreSQLParser::AlterfdwstmtContext* PostgreSQLParser::StmtContext::alterfdwstmt() {
  return getRuleContext<PostgreSQLParser::AlterfdwstmtContext>(0);
}

PostgreSQLParser::AlterforeignserverstmtContext* PostgreSQLParser::StmtContext::alterforeignserverstmt() {
  return getRuleContext<PostgreSQLParser::AlterforeignserverstmtContext>(0);
}

PostgreSQLParser::AlterfunctionstmtContext* PostgreSQLParser::StmtContext::alterfunctionstmt() {
  return getRuleContext<PostgreSQLParser::AlterfunctionstmtContext>(0);
}

PostgreSQLParser::AltergroupstmtContext* PostgreSQLParser::StmtContext::altergroupstmt() {
  return getRuleContext<PostgreSQLParser::AltergroupstmtContext>(0);
}

PostgreSQLParser::AlterobjectdependsstmtContext* PostgreSQLParser::StmtContext::alterobjectdependsstmt() {
  return getRuleContext<PostgreSQLParser::AlterobjectdependsstmtContext>(0);
}

PostgreSQLParser::AlterobjectschemastmtContext* PostgreSQLParser::StmtContext::alterobjectschemastmt() {
  return getRuleContext<PostgreSQLParser::AlterobjectschemastmtContext>(0);
}

PostgreSQLParser::AlterownerstmtContext* PostgreSQLParser::StmtContext::alterownerstmt() {
  return getRuleContext<PostgreSQLParser::AlterownerstmtContext>(0);
}

PostgreSQLParser::AlteroperatorstmtContext* PostgreSQLParser::StmtContext::alteroperatorstmt() {
  return getRuleContext<PostgreSQLParser::AlteroperatorstmtContext>(0);
}

PostgreSQLParser::AltertypestmtContext* PostgreSQLParser::StmtContext::altertypestmt() {
  return getRuleContext<PostgreSQLParser::AltertypestmtContext>(0);
}

PostgreSQLParser::AlterpolicystmtContext* PostgreSQLParser::StmtContext::alterpolicystmt() {
  return getRuleContext<PostgreSQLParser::AlterpolicystmtContext>(0);
}

PostgreSQLParser::AlterseqstmtContext* PostgreSQLParser::StmtContext::alterseqstmt() {
  return getRuleContext<PostgreSQLParser::AlterseqstmtContext>(0);
}

PostgreSQLParser::AltersystemstmtContext* PostgreSQLParser::StmtContext::altersystemstmt() {
  return getRuleContext<PostgreSQLParser::AltersystemstmtContext>(0);
}

PostgreSQLParser::AltertablestmtContext* PostgreSQLParser::StmtContext::altertablestmt() {
  return getRuleContext<PostgreSQLParser::AltertablestmtContext>(0);
}

PostgreSQLParser::AltertblspcstmtContext* PostgreSQLParser::StmtContext::altertblspcstmt() {
  return getRuleContext<PostgreSQLParser::AltertblspcstmtContext>(0);
}

PostgreSQLParser::AltercompositetypestmtContext* PostgreSQLParser::StmtContext::altercompositetypestmt() {
  return getRuleContext<PostgreSQLParser::AltercompositetypestmtContext>(0);
}

PostgreSQLParser::AlterpublicationstmtContext* PostgreSQLParser::StmtContext::alterpublicationstmt() {
  return getRuleContext<PostgreSQLParser::AlterpublicationstmtContext>(0);
}

PostgreSQLParser::AlterrolesetstmtContext* PostgreSQLParser::StmtContext::alterrolesetstmt() {
  return getRuleContext<PostgreSQLParser::AlterrolesetstmtContext>(0);
}

PostgreSQLParser::AlterrolestmtContext* PostgreSQLParser::StmtContext::alterrolestmt() {
  return getRuleContext<PostgreSQLParser::AlterrolestmtContext>(0);
}

PostgreSQLParser::AltersubscriptionstmtContext* PostgreSQLParser::StmtContext::altersubscriptionstmt() {
  return getRuleContext<PostgreSQLParser::AltersubscriptionstmtContext>(0);
}

PostgreSQLParser::AlterstatsstmtContext* PostgreSQLParser::StmtContext::alterstatsstmt() {
  return getRuleContext<PostgreSQLParser::AlterstatsstmtContext>(0);
}

PostgreSQLParser::AltertsconfigurationstmtContext* PostgreSQLParser::StmtContext::altertsconfigurationstmt() {
  return getRuleContext<PostgreSQLParser::AltertsconfigurationstmtContext>(0);
}

PostgreSQLParser::AltertsdictionarystmtContext* PostgreSQLParser::StmtContext::altertsdictionarystmt() {
  return getRuleContext<PostgreSQLParser::AltertsdictionarystmtContext>(0);
}

PostgreSQLParser::AlterusermappingstmtContext* PostgreSQLParser::StmtContext::alterusermappingstmt() {
  return getRuleContext<PostgreSQLParser::AlterusermappingstmtContext>(0);
}

PostgreSQLParser::AnalyzestmtContext* PostgreSQLParser::StmtContext::analyzestmt() {
  return getRuleContext<PostgreSQLParser::AnalyzestmtContext>(0);
}

PostgreSQLParser::CallstmtContext* PostgreSQLParser::StmtContext::callstmt() {
  return getRuleContext<PostgreSQLParser::CallstmtContext>(0);
}

PostgreSQLParser::CheckpointstmtContext* PostgreSQLParser::StmtContext::checkpointstmt() {
  return getRuleContext<PostgreSQLParser::CheckpointstmtContext>(0);
}

PostgreSQLParser::CloseportalstmtContext* PostgreSQLParser::StmtContext::closeportalstmt() {
  return getRuleContext<PostgreSQLParser::CloseportalstmtContext>(0);
}

PostgreSQLParser::ClusterstmtContext* PostgreSQLParser::StmtContext::clusterstmt() {
  return getRuleContext<PostgreSQLParser::ClusterstmtContext>(0);
}

PostgreSQLParser::CommentstmtContext* PostgreSQLParser::StmtContext::commentstmt() {
  return getRuleContext<PostgreSQLParser::CommentstmtContext>(0);
}

PostgreSQLParser::ConstraintssetstmtContext* PostgreSQLParser::StmtContext::constraintssetstmt() {
  return getRuleContext<PostgreSQLParser::ConstraintssetstmtContext>(0);
}

PostgreSQLParser::CopystmtContext* PostgreSQLParser::StmtContext::copystmt() {
  return getRuleContext<PostgreSQLParser::CopystmtContext>(0);
}

PostgreSQLParser::CreateamstmtContext* PostgreSQLParser::StmtContext::createamstmt() {
  return getRuleContext<PostgreSQLParser::CreateamstmtContext>(0);
}

PostgreSQLParser::CreateasstmtContext* PostgreSQLParser::StmtContext::createasstmt() {
  return getRuleContext<PostgreSQLParser::CreateasstmtContext>(0);
}

PostgreSQLParser::CreateassertionstmtContext* PostgreSQLParser::StmtContext::createassertionstmt() {
  return getRuleContext<PostgreSQLParser::CreateassertionstmtContext>(0);
}

PostgreSQLParser::CreatecaststmtContext* PostgreSQLParser::StmtContext::createcaststmt() {
  return getRuleContext<PostgreSQLParser::CreatecaststmtContext>(0);
}

PostgreSQLParser::CreateconversionstmtContext* PostgreSQLParser::StmtContext::createconversionstmt() {
  return getRuleContext<PostgreSQLParser::CreateconversionstmtContext>(0);
}

PostgreSQLParser::CreatedomainstmtContext* PostgreSQLParser::StmtContext::createdomainstmt() {
  return getRuleContext<PostgreSQLParser::CreatedomainstmtContext>(0);
}

PostgreSQLParser::CreateextensionstmtContext* PostgreSQLParser::StmtContext::createextensionstmt() {
  return getRuleContext<PostgreSQLParser::CreateextensionstmtContext>(0);
}

PostgreSQLParser::CreatefdwstmtContext* PostgreSQLParser::StmtContext::createfdwstmt() {
  return getRuleContext<PostgreSQLParser::CreatefdwstmtContext>(0);
}

PostgreSQLParser::CreateforeignserverstmtContext* PostgreSQLParser::StmtContext::createforeignserverstmt() {
  return getRuleContext<PostgreSQLParser::CreateforeignserverstmtContext>(0);
}

PostgreSQLParser::CreateforeigntablestmtContext* PostgreSQLParser::StmtContext::createforeigntablestmt() {
  return getRuleContext<PostgreSQLParser::CreateforeigntablestmtContext>(0);
}

PostgreSQLParser::CreatefunctionstmtContext* PostgreSQLParser::StmtContext::createfunctionstmt() {
  return getRuleContext<PostgreSQLParser::CreatefunctionstmtContext>(0);
}

PostgreSQLParser::CreategroupstmtContext* PostgreSQLParser::StmtContext::creategroupstmt() {
  return getRuleContext<PostgreSQLParser::CreategroupstmtContext>(0);
}

PostgreSQLParser::CreatematviewstmtContext* PostgreSQLParser::StmtContext::creatematviewstmt() {
  return getRuleContext<PostgreSQLParser::CreatematviewstmtContext>(0);
}

PostgreSQLParser::CreateopclassstmtContext* PostgreSQLParser::StmtContext::createopclassstmt() {
  return getRuleContext<PostgreSQLParser::CreateopclassstmtContext>(0);
}

PostgreSQLParser::CreateopfamilystmtContext* PostgreSQLParser::StmtContext::createopfamilystmt() {
  return getRuleContext<PostgreSQLParser::CreateopfamilystmtContext>(0);
}

PostgreSQLParser::CreatepublicationstmtContext* PostgreSQLParser::StmtContext::createpublicationstmt() {
  return getRuleContext<PostgreSQLParser::CreatepublicationstmtContext>(0);
}

PostgreSQLParser::AlteropfamilystmtContext* PostgreSQLParser::StmtContext::alteropfamilystmt() {
  return getRuleContext<PostgreSQLParser::AlteropfamilystmtContext>(0);
}

PostgreSQLParser::CreatepolicystmtContext* PostgreSQLParser::StmtContext::createpolicystmt() {
  return getRuleContext<PostgreSQLParser::CreatepolicystmtContext>(0);
}

PostgreSQLParser::CreateplangstmtContext* PostgreSQLParser::StmtContext::createplangstmt() {
  return getRuleContext<PostgreSQLParser::CreateplangstmtContext>(0);
}

PostgreSQLParser::CreateschemastmtContext* PostgreSQLParser::StmtContext::createschemastmt() {
  return getRuleContext<PostgreSQLParser::CreateschemastmtContext>(0);
}

PostgreSQLParser::CreateseqstmtContext* PostgreSQLParser::StmtContext::createseqstmt() {
  return getRuleContext<PostgreSQLParser::CreateseqstmtContext>(0);
}

PostgreSQLParser::CreatestmtContext* PostgreSQLParser::StmtContext::createstmt() {
  return getRuleContext<PostgreSQLParser::CreatestmtContext>(0);
}

PostgreSQLParser::CreatesubscriptionstmtContext* PostgreSQLParser::StmtContext::createsubscriptionstmt() {
  return getRuleContext<PostgreSQLParser::CreatesubscriptionstmtContext>(0);
}

PostgreSQLParser::CreatestatsstmtContext* PostgreSQLParser::StmtContext::createstatsstmt() {
  return getRuleContext<PostgreSQLParser::CreatestatsstmtContext>(0);
}

PostgreSQLParser::CreatetablespacestmtContext* PostgreSQLParser::StmtContext::createtablespacestmt() {
  return getRuleContext<PostgreSQLParser::CreatetablespacestmtContext>(0);
}

PostgreSQLParser::CreatetransformstmtContext* PostgreSQLParser::StmtContext::createtransformstmt() {
  return getRuleContext<PostgreSQLParser::CreatetransformstmtContext>(0);
}

PostgreSQLParser::CreatetrigstmtContext* PostgreSQLParser::StmtContext::createtrigstmt() {
  return getRuleContext<PostgreSQLParser::CreatetrigstmtContext>(0);
}

PostgreSQLParser::CreateeventtrigstmtContext* PostgreSQLParser::StmtContext::createeventtrigstmt() {
  return getRuleContext<PostgreSQLParser::CreateeventtrigstmtContext>(0);
}

PostgreSQLParser::CreaterolestmtContext* PostgreSQLParser::StmtContext::createrolestmt() {
  return getRuleContext<PostgreSQLParser::CreaterolestmtContext>(0);
}

PostgreSQLParser::CreateuserstmtContext* PostgreSQLParser::StmtContext::createuserstmt() {
  return getRuleContext<PostgreSQLParser::CreateuserstmtContext>(0);
}

PostgreSQLParser::CreateusermappingstmtContext* PostgreSQLParser::StmtContext::createusermappingstmt() {
  return getRuleContext<PostgreSQLParser::CreateusermappingstmtContext>(0);
}

PostgreSQLParser::CreatedbstmtContext* PostgreSQLParser::StmtContext::createdbstmt() {
  return getRuleContext<PostgreSQLParser::CreatedbstmtContext>(0);
}

PostgreSQLParser::DeallocatestmtContext* PostgreSQLParser::StmtContext::deallocatestmt() {
  return getRuleContext<PostgreSQLParser::DeallocatestmtContext>(0);
}

PostgreSQLParser::DeclarecursorstmtContext* PostgreSQLParser::StmtContext::declarecursorstmt() {
  return getRuleContext<PostgreSQLParser::DeclarecursorstmtContext>(0);
}

PostgreSQLParser::DefinestmtContext* PostgreSQLParser::StmtContext::definestmt() {
  return getRuleContext<PostgreSQLParser::DefinestmtContext>(0);
}

PostgreSQLParser::DeletestmtContext* PostgreSQLParser::StmtContext::deletestmt() {
  return getRuleContext<PostgreSQLParser::DeletestmtContext>(0);
}

PostgreSQLParser::DiscardstmtContext* PostgreSQLParser::StmtContext::discardstmt() {
  return getRuleContext<PostgreSQLParser::DiscardstmtContext>(0);
}

PostgreSQLParser::DostmtContext* PostgreSQLParser::StmtContext::dostmt() {
  return getRuleContext<PostgreSQLParser::DostmtContext>(0);
}

PostgreSQLParser::DropcaststmtContext* PostgreSQLParser::StmtContext::dropcaststmt() {
  return getRuleContext<PostgreSQLParser::DropcaststmtContext>(0);
}

PostgreSQLParser::DropopclassstmtContext* PostgreSQLParser::StmtContext::dropopclassstmt() {
  return getRuleContext<PostgreSQLParser::DropopclassstmtContext>(0);
}

PostgreSQLParser::DropopfamilystmtContext* PostgreSQLParser::StmtContext::dropopfamilystmt() {
  return getRuleContext<PostgreSQLParser::DropopfamilystmtContext>(0);
}

PostgreSQLParser::DropownedstmtContext* PostgreSQLParser::StmtContext::dropownedstmt() {
  return getRuleContext<PostgreSQLParser::DropownedstmtContext>(0);
}

PostgreSQLParser::DropstmtContext* PostgreSQLParser::StmtContext::dropstmt() {
  return getRuleContext<PostgreSQLParser::DropstmtContext>(0);
}

PostgreSQLParser::DropsubscriptionstmtContext* PostgreSQLParser::StmtContext::dropsubscriptionstmt() {
  return getRuleContext<PostgreSQLParser::DropsubscriptionstmtContext>(0);
}

PostgreSQLParser::DroptablespacestmtContext* PostgreSQLParser::StmtContext::droptablespacestmt() {
  return getRuleContext<PostgreSQLParser::DroptablespacestmtContext>(0);
}

PostgreSQLParser::DroptransformstmtContext* PostgreSQLParser::StmtContext::droptransformstmt() {
  return getRuleContext<PostgreSQLParser::DroptransformstmtContext>(0);
}

PostgreSQLParser::DroprolestmtContext* PostgreSQLParser::StmtContext::droprolestmt() {
  return getRuleContext<PostgreSQLParser::DroprolestmtContext>(0);
}

PostgreSQLParser::DropusermappingstmtContext* PostgreSQLParser::StmtContext::dropusermappingstmt() {
  return getRuleContext<PostgreSQLParser::DropusermappingstmtContext>(0);
}

PostgreSQLParser::DropdbstmtContext* PostgreSQLParser::StmtContext::dropdbstmt() {
  return getRuleContext<PostgreSQLParser::DropdbstmtContext>(0);
}

PostgreSQLParser::ExecutestmtContext* PostgreSQLParser::StmtContext::executestmt() {
  return getRuleContext<PostgreSQLParser::ExecutestmtContext>(0);
}

PostgreSQLParser::ExplainstmtContext* PostgreSQLParser::StmtContext::explainstmt() {
  return getRuleContext<PostgreSQLParser::ExplainstmtContext>(0);
}

PostgreSQLParser::FetchstmtContext* PostgreSQLParser::StmtContext::fetchstmt() {
  return getRuleContext<PostgreSQLParser::FetchstmtContext>(0);
}

PostgreSQLParser::GrantstmtContext* PostgreSQLParser::StmtContext::grantstmt() {
  return getRuleContext<PostgreSQLParser::GrantstmtContext>(0);
}

PostgreSQLParser::GrantrolestmtContext* PostgreSQLParser::StmtContext::grantrolestmt() {
  return getRuleContext<PostgreSQLParser::GrantrolestmtContext>(0);
}

PostgreSQLParser::ImportforeignschemastmtContext* PostgreSQLParser::StmtContext::importforeignschemastmt() {
  return getRuleContext<PostgreSQLParser::ImportforeignschemastmtContext>(0);
}

PostgreSQLParser::IndexstmtContext* PostgreSQLParser::StmtContext::indexstmt() {
  return getRuleContext<PostgreSQLParser::IndexstmtContext>(0);
}

PostgreSQLParser::InsertstmtContext* PostgreSQLParser::StmtContext::insertstmt() {
  return getRuleContext<PostgreSQLParser::InsertstmtContext>(0);
}

PostgreSQLParser::MergestmtContext* PostgreSQLParser::StmtContext::mergestmt() {
  return getRuleContext<PostgreSQLParser::MergestmtContext>(0);
}

PostgreSQLParser::ListenstmtContext* PostgreSQLParser::StmtContext::listenstmt() {
  return getRuleContext<PostgreSQLParser::ListenstmtContext>(0);
}

PostgreSQLParser::RefreshmatviewstmtContext* PostgreSQLParser::StmtContext::refreshmatviewstmt() {
  return getRuleContext<PostgreSQLParser::RefreshmatviewstmtContext>(0);
}

PostgreSQLParser::LoadstmtContext* PostgreSQLParser::StmtContext::loadstmt() {
  return getRuleContext<PostgreSQLParser::LoadstmtContext>(0);
}

PostgreSQLParser::LockstmtContext* PostgreSQLParser::StmtContext::lockstmt() {
  return getRuleContext<PostgreSQLParser::LockstmtContext>(0);
}

PostgreSQLParser::NotifystmtContext* PostgreSQLParser::StmtContext::notifystmt() {
  return getRuleContext<PostgreSQLParser::NotifystmtContext>(0);
}

PostgreSQLParser::PreparestmtContext* PostgreSQLParser::StmtContext::preparestmt() {
  return getRuleContext<PostgreSQLParser::PreparestmtContext>(0);
}

PostgreSQLParser::ReassignownedstmtContext* PostgreSQLParser::StmtContext::reassignownedstmt() {
  return getRuleContext<PostgreSQLParser::ReassignownedstmtContext>(0);
}

PostgreSQLParser::ReindexstmtContext* PostgreSQLParser::StmtContext::reindexstmt() {
  return getRuleContext<PostgreSQLParser::ReindexstmtContext>(0);
}

PostgreSQLParser::RemoveaggrstmtContext* PostgreSQLParser::StmtContext::removeaggrstmt() {
  return getRuleContext<PostgreSQLParser::RemoveaggrstmtContext>(0);
}

PostgreSQLParser::RemovefuncstmtContext* PostgreSQLParser::StmtContext::removefuncstmt() {
  return getRuleContext<PostgreSQLParser::RemovefuncstmtContext>(0);
}

PostgreSQLParser::RemoveoperstmtContext* PostgreSQLParser::StmtContext::removeoperstmt() {
  return getRuleContext<PostgreSQLParser::RemoveoperstmtContext>(0);
}

PostgreSQLParser::RenamestmtContext* PostgreSQLParser::StmtContext::renamestmt() {
  return getRuleContext<PostgreSQLParser::RenamestmtContext>(0);
}

PostgreSQLParser::RevokestmtContext* PostgreSQLParser::StmtContext::revokestmt() {
  return getRuleContext<PostgreSQLParser::RevokestmtContext>(0);
}

PostgreSQLParser::RevokerolestmtContext* PostgreSQLParser::StmtContext::revokerolestmt() {
  return getRuleContext<PostgreSQLParser::RevokerolestmtContext>(0);
}

PostgreSQLParser::RulestmtContext* PostgreSQLParser::StmtContext::rulestmt() {
  return getRuleContext<PostgreSQLParser::RulestmtContext>(0);
}

PostgreSQLParser::SeclabelstmtContext* PostgreSQLParser::StmtContext::seclabelstmt() {
  return getRuleContext<PostgreSQLParser::SeclabelstmtContext>(0);
}

PostgreSQLParser::SelectstmtContext* PostgreSQLParser::StmtContext::selectstmt() {
  return getRuleContext<PostgreSQLParser::SelectstmtContext>(0);
}

PostgreSQLParser::TransactionstmtContext* PostgreSQLParser::StmtContext::transactionstmt() {
  return getRuleContext<PostgreSQLParser::TransactionstmtContext>(0);
}

PostgreSQLParser::TruncatestmtContext* PostgreSQLParser::StmtContext::truncatestmt() {
  return getRuleContext<PostgreSQLParser::TruncatestmtContext>(0);
}

PostgreSQLParser::UnlistenstmtContext* PostgreSQLParser::StmtContext::unlistenstmt() {
  return getRuleContext<PostgreSQLParser::UnlistenstmtContext>(0);
}

PostgreSQLParser::UpdatestmtContext* PostgreSQLParser::StmtContext::updatestmt() {
  return getRuleContext<PostgreSQLParser::UpdatestmtContext>(0);
}

PostgreSQLParser::VacuumstmtContext* PostgreSQLParser::StmtContext::vacuumstmt() {
  return getRuleContext<PostgreSQLParser::VacuumstmtContext>(0);
}

PostgreSQLParser::VariableresetstmtContext* PostgreSQLParser::StmtContext::variableresetstmt() {
  return getRuleContext<PostgreSQLParser::VariableresetstmtContext>(0);
}

PostgreSQLParser::VariablesetstmtContext* PostgreSQLParser::StmtContext::variablesetstmt() {
  return getRuleContext<PostgreSQLParser::VariablesetstmtContext>(0);
}

PostgreSQLParser::VariableshowstmtContext* PostgreSQLParser::StmtContext::variableshowstmt() {
  return getRuleContext<PostgreSQLParser::VariableshowstmtContext>(0);
}

PostgreSQLParser::ViewstmtContext* PostgreSQLParser::StmtContext::viewstmt() {
  return getRuleContext<PostgreSQLParser::ViewstmtContext>(0);
}


size_t PostgreSQLParser::StmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleStmt;
}


std::any PostgreSQLParser::StmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitStmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::StmtContext* PostgreSQLParser::stmt() {
  StmtContext *_localctx = _tracker.createInstance<StmtContext>(_ctx, getState());
  enterRule(_localctx, 6, PostgreSQLParser::RuleStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1581);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1457);
      altereventtrigstmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1458);
      altercollationstmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1459);
      alterdatabasestmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1460);
      alterdatabasesetstmt();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1461);
      alterdefaultprivilegesstmt();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1462);
      alterdomainstmt();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1463);
      alterenumstmt();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1464);
      alterextensionstmt();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1465);
      alterextensioncontentsstmt();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1466);
      alterfdwstmt();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1467);
      alterforeignserverstmt();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1468);
      alterfunctionstmt();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(1469);
      altergroupstmt();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(1470);
      alterobjectdependsstmt();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(1471);
      alterobjectschemastmt();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(1472);
      alterownerstmt();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(1473);
      alteroperatorstmt();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(1474);
      altertypestmt();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(1475);
      alterpolicystmt();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(1476);
      alterseqstmt();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(1477);
      altersystemstmt();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(1478);
      altertablestmt();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(1479);
      altertblspcstmt();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(1480);
      altercompositetypestmt();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(1481);
      alterpublicationstmt();
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(1482);
      alterrolesetstmt();
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(1483);
      alterrolestmt();
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(1484);
      altersubscriptionstmt();
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(1485);
      alterstatsstmt();
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(1486);
      altertsconfigurationstmt();
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(1487);
      altertsdictionarystmt();
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(1488);
      alterusermappingstmt();
      break;
    }

    case 33: {
      enterOuterAlt(_localctx, 33);
      setState(1489);
      analyzestmt();
      break;
    }

    case 34: {
      enterOuterAlt(_localctx, 34);
      setState(1490);
      callstmt();
      break;
    }

    case 35: {
      enterOuterAlt(_localctx, 35);
      setState(1491);
      checkpointstmt();
      break;
    }

    case 36: {
      enterOuterAlt(_localctx, 36);
      setState(1492);
      closeportalstmt();
      break;
    }

    case 37: {
      enterOuterAlt(_localctx, 37);
      setState(1493);
      clusterstmt();
      break;
    }

    case 38: {
      enterOuterAlt(_localctx, 38);
      setState(1494);
      commentstmt();
      break;
    }

    case 39: {
      enterOuterAlt(_localctx, 39);
      setState(1495);
      constraintssetstmt();
      break;
    }

    case 40: {
      enterOuterAlt(_localctx, 40);
      setState(1496);
      copystmt();
      break;
    }

    case 41: {
      enterOuterAlt(_localctx, 41);
      setState(1497);
      createamstmt();
      break;
    }

    case 42: {
      enterOuterAlt(_localctx, 42);
      setState(1498);
      createasstmt();
      break;
    }

    case 43: {
      enterOuterAlt(_localctx, 43);
      setState(1499);
      createassertionstmt();
      break;
    }

    case 44: {
      enterOuterAlt(_localctx, 44);
      setState(1500);
      createcaststmt();
      break;
    }

    case 45: {
      enterOuterAlt(_localctx, 45);
      setState(1501);
      createconversionstmt();
      break;
    }

    case 46: {
      enterOuterAlt(_localctx, 46);
      setState(1502);
      createdomainstmt();
      break;
    }

    case 47: {
      enterOuterAlt(_localctx, 47);
      setState(1503);
      createextensionstmt();
      break;
    }

    case 48: {
      enterOuterAlt(_localctx, 48);
      setState(1504);
      createfdwstmt();
      break;
    }

    case 49: {
      enterOuterAlt(_localctx, 49);
      setState(1505);
      createforeignserverstmt();
      break;
    }

    case 50: {
      enterOuterAlt(_localctx, 50);
      setState(1506);
      createforeigntablestmt();
      break;
    }

    case 51: {
      enterOuterAlt(_localctx, 51);
      setState(1507);
      createfunctionstmt();
      break;
    }

    case 52: {
      enterOuterAlt(_localctx, 52);
      setState(1508);
      creategroupstmt();
      break;
    }

    case 53: {
      enterOuterAlt(_localctx, 53);
      setState(1509);
      creatematviewstmt();
      break;
    }

    case 54: {
      enterOuterAlt(_localctx, 54);
      setState(1510);
      createopclassstmt();
      break;
    }

    case 55: {
      enterOuterAlt(_localctx, 55);
      setState(1511);
      createopfamilystmt();
      break;
    }

    case 56: {
      enterOuterAlt(_localctx, 56);
      setState(1512);
      createpublicationstmt();
      break;
    }

    case 57: {
      enterOuterAlt(_localctx, 57);
      setState(1513);
      alteropfamilystmt();
      break;
    }

    case 58: {
      enterOuterAlt(_localctx, 58);
      setState(1514);
      createpolicystmt();
      break;
    }

    case 59: {
      enterOuterAlt(_localctx, 59);
      setState(1515);
      createplangstmt();
      break;
    }

    case 60: {
      enterOuterAlt(_localctx, 60);
      setState(1516);
      createschemastmt();
      break;
    }

    case 61: {
      enterOuterAlt(_localctx, 61);
      setState(1517);
      createseqstmt();
      break;
    }

    case 62: {
      enterOuterAlt(_localctx, 62);
      setState(1518);
      createstmt();
      break;
    }

    case 63: {
      enterOuterAlt(_localctx, 63);
      setState(1519);
      createsubscriptionstmt();
      break;
    }

    case 64: {
      enterOuterAlt(_localctx, 64);
      setState(1520);
      createstatsstmt();
      break;
    }

    case 65: {
      enterOuterAlt(_localctx, 65);
      setState(1521);
      createtablespacestmt();
      break;
    }

    case 66: {
      enterOuterAlt(_localctx, 66);
      setState(1522);
      createtransformstmt();
      break;
    }

    case 67: {
      enterOuterAlt(_localctx, 67);
      setState(1523);
      createtrigstmt();
      break;
    }

    case 68: {
      enterOuterAlt(_localctx, 68);
      setState(1524);
      createeventtrigstmt();
      break;
    }

    case 69: {
      enterOuterAlt(_localctx, 69);
      setState(1525);
      createrolestmt();
      break;
    }

    case 70: {
      enterOuterAlt(_localctx, 70);
      setState(1526);
      createuserstmt();
      break;
    }

    case 71: {
      enterOuterAlt(_localctx, 71);
      setState(1527);
      createusermappingstmt();
      break;
    }

    case 72: {
      enterOuterAlt(_localctx, 72);
      setState(1528);
      createdbstmt();
      break;
    }

    case 73: {
      enterOuterAlt(_localctx, 73);
      setState(1529);
      deallocatestmt();
      break;
    }

    case 74: {
      enterOuterAlt(_localctx, 74);
      setState(1530);
      declarecursorstmt();
      break;
    }

    case 75: {
      enterOuterAlt(_localctx, 75);
      setState(1531);
      definestmt();
      break;
    }

    case 76: {
      enterOuterAlt(_localctx, 76);
      setState(1532);
      deletestmt();
      break;
    }

    case 77: {
      enterOuterAlt(_localctx, 77);
      setState(1533);
      discardstmt();
      break;
    }

    case 78: {
      enterOuterAlt(_localctx, 78);
      setState(1534);
      dostmt();
      break;
    }

    case 79: {
      enterOuterAlt(_localctx, 79);
      setState(1535);
      dropcaststmt();
      break;
    }

    case 80: {
      enterOuterAlt(_localctx, 80);
      setState(1536);
      dropopclassstmt();
      break;
    }

    case 81: {
      enterOuterAlt(_localctx, 81);
      setState(1537);
      dropopfamilystmt();
      break;
    }

    case 82: {
      enterOuterAlt(_localctx, 82);
      setState(1538);
      dropownedstmt();
      break;
    }

    case 83: {
      enterOuterAlt(_localctx, 83);
      setState(1539);
      dropstmt();
      break;
    }

    case 84: {
      enterOuterAlt(_localctx, 84);
      setState(1540);
      dropsubscriptionstmt();
      break;
    }

    case 85: {
      enterOuterAlt(_localctx, 85);
      setState(1541);
      droptablespacestmt();
      break;
    }

    case 86: {
      enterOuterAlt(_localctx, 86);
      setState(1542);
      droptransformstmt();
      break;
    }

    case 87: {
      enterOuterAlt(_localctx, 87);
      setState(1543);
      droprolestmt();
      break;
    }

    case 88: {
      enterOuterAlt(_localctx, 88);
      setState(1544);
      dropusermappingstmt();
      break;
    }

    case 89: {
      enterOuterAlt(_localctx, 89);
      setState(1545);
      dropdbstmt();
      break;
    }

    case 90: {
      enterOuterAlt(_localctx, 90);
      setState(1546);
      executestmt();
      break;
    }

    case 91: {
      enterOuterAlt(_localctx, 91);
      setState(1547);
      explainstmt();
      break;
    }

    case 92: {
      enterOuterAlt(_localctx, 92);
      setState(1548);
      fetchstmt();
      break;
    }

    case 93: {
      enterOuterAlt(_localctx, 93);
      setState(1549);
      grantstmt();
      break;
    }

    case 94: {
      enterOuterAlt(_localctx, 94);
      setState(1550);
      grantrolestmt();
      break;
    }

    case 95: {
      enterOuterAlt(_localctx, 95);
      setState(1551);
      importforeignschemastmt();
      break;
    }

    case 96: {
      enterOuterAlt(_localctx, 96);
      setState(1552);
      indexstmt();
      break;
    }

    case 97: {
      enterOuterAlt(_localctx, 97);
      setState(1553);
      insertstmt();
      break;
    }

    case 98: {
      enterOuterAlt(_localctx, 98);
      setState(1554);
      mergestmt();
      break;
    }

    case 99: {
      enterOuterAlt(_localctx, 99);
      setState(1555);
      listenstmt();
      break;
    }

    case 100: {
      enterOuterAlt(_localctx, 100);
      setState(1556);
      refreshmatviewstmt();
      break;
    }

    case 101: {
      enterOuterAlt(_localctx, 101);
      setState(1557);
      loadstmt();
      break;
    }

    case 102: {
      enterOuterAlt(_localctx, 102);
      setState(1558);
      lockstmt();
      break;
    }

    case 103: {
      enterOuterAlt(_localctx, 103);
      setState(1559);
      notifystmt();
      break;
    }

    case 104: {
      enterOuterAlt(_localctx, 104);
      setState(1560);
      preparestmt();
      break;
    }

    case 105: {
      enterOuterAlt(_localctx, 105);
      setState(1561);
      reassignownedstmt();
      break;
    }

    case 106: {
      enterOuterAlt(_localctx, 106);
      setState(1562);
      reindexstmt();
      break;
    }

    case 107: {
      enterOuterAlt(_localctx, 107);
      setState(1563);
      removeaggrstmt();
      break;
    }

    case 108: {
      enterOuterAlt(_localctx, 108);
      setState(1564);
      removefuncstmt();
      break;
    }

    case 109: {
      enterOuterAlt(_localctx, 109);
      setState(1565);
      removeoperstmt();
      break;
    }

    case 110: {
      enterOuterAlt(_localctx, 110);
      setState(1566);
      renamestmt();
      break;
    }

    case 111: {
      enterOuterAlt(_localctx, 111);
      setState(1567);
      revokestmt();
      break;
    }

    case 112: {
      enterOuterAlt(_localctx, 112);
      setState(1568);
      revokerolestmt();
      break;
    }

    case 113: {
      enterOuterAlt(_localctx, 113);
      setState(1569);
      rulestmt();
      break;
    }

    case 114: {
      enterOuterAlt(_localctx, 114);
      setState(1570);
      seclabelstmt();
      break;
    }

    case 115: {
      enterOuterAlt(_localctx, 115);
      setState(1571);
      selectstmt();
      break;
    }

    case 116: {
      enterOuterAlt(_localctx, 116);
      setState(1572);
      transactionstmt();
      break;
    }

    case 117: {
      enterOuterAlt(_localctx, 117);
      setState(1573);
      truncatestmt();
      break;
    }

    case 118: {
      enterOuterAlt(_localctx, 118);
      setState(1574);
      unlistenstmt();
      break;
    }

    case 119: {
      enterOuterAlt(_localctx, 119);
      setState(1575);
      updatestmt();
      break;
    }

    case 120: {
      enterOuterAlt(_localctx, 120);
      setState(1576);
      vacuumstmt();
      break;
    }

    case 121: {
      enterOuterAlt(_localctx, 121);
      setState(1577);
      variableresetstmt();
      break;
    }

    case 122: {
      enterOuterAlt(_localctx, 122);
      setState(1578);
      variablesetstmt();
      break;
    }

    case 123: {
      enterOuterAlt(_localctx, 123);
      setState(1579);
      variableshowstmt();
      break;
    }

    case 124: {
      enterOuterAlt(_localctx, 124);
      setState(1580);
      viewstmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CallstmtContext ------------------------------------------------------------------

PostgreSQLParser::CallstmtContext::CallstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CallstmtContext::CALL() {
  return getToken(PostgreSQLParser::CALL, 0);
}

PostgreSQLParser::Func_applicationContext* PostgreSQLParser::CallstmtContext::func_application() {
  return getRuleContext<PostgreSQLParser::Func_applicationContext>(0);
}


size_t PostgreSQLParser::CallstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCallstmt;
}


std::any PostgreSQLParser::CallstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCallstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CallstmtContext* PostgreSQLParser::callstmt() {
  CallstmtContext *_localctx = _tracker.createInstance<CallstmtContext>(_ctx, getState());
  enterRule(_localctx, 8, PostgreSQLParser::RuleCallstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1583);
    match(PostgreSQLParser::CALL);
    setState(1584);
    func_application();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreaterolestmtContext ------------------------------------------------------------------

PostgreSQLParser::CreaterolestmtContext::CreaterolestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreaterolestmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreaterolestmtContext::ROLE() {
  return getToken(PostgreSQLParser::ROLE, 0);
}

PostgreSQLParser::RoleidContext* PostgreSQLParser::CreaterolestmtContext::roleid() {
  return getRuleContext<PostgreSQLParser::RoleidContext>(0);
}

PostgreSQLParser::OptrolelistContext* PostgreSQLParser::CreaterolestmtContext::optrolelist() {
  return getRuleContext<PostgreSQLParser::OptrolelistContext>(0);
}

PostgreSQLParser::With_Context* PostgreSQLParser::CreaterolestmtContext::with_() {
  return getRuleContext<PostgreSQLParser::With_Context>(0);
}


size_t PostgreSQLParser::CreaterolestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreaterolestmt;
}


std::any PostgreSQLParser::CreaterolestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreaterolestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreaterolestmtContext* PostgreSQLParser::createrolestmt() {
  CreaterolestmtContext *_localctx = _tracker.createInstance<CreaterolestmtContext>(_ctx, getState());
  enterRule(_localctx, 10, PostgreSQLParser::RuleCreaterolestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1586);
    match(PostgreSQLParser::CREATE);
    setState(1587);
    match(PostgreSQLParser::ROLE);
    setState(1588);
    roleid();
    setState(1590);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(1589);
      with_();
    }
    setState(1592);
    optrolelist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_Context ------------------------------------------------------------------

PostgreSQLParser::With_Context::With_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::With_Context::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}


size_t PostgreSQLParser::With_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleWith_;
}


std::any PostgreSQLParser::With_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitWith_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::With_Context* PostgreSQLParser::with_() {
  With_Context *_localctx = _tracker.createInstance<With_Context>(_ctx, getState());
  enterRule(_localctx, 12, PostgreSQLParser::RuleWith_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1594);
    match(PostgreSQLParser::WITH);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptrolelistContext ------------------------------------------------------------------

PostgreSQLParser::OptrolelistContext::OptrolelistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::CreateoptroleelemContext *> PostgreSQLParser::OptrolelistContext::createoptroleelem() {
  return getRuleContexts<PostgreSQLParser::CreateoptroleelemContext>();
}

PostgreSQLParser::CreateoptroleelemContext* PostgreSQLParser::OptrolelistContext::createoptroleelem(size_t i) {
  return getRuleContext<PostgreSQLParser::CreateoptroleelemContext>(i);
}


size_t PostgreSQLParser::OptrolelistContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOptrolelist;
}


std::any PostgreSQLParser::OptrolelistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOptrolelist(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::OptrolelistContext* PostgreSQLParser::optrolelist() {
  OptrolelistContext *_localctx = _tracker.createInstance<OptrolelistContext>(_ctx, getState());
  enterRule(_localctx, 14, PostgreSQLParser::RuleOptrolelist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1599);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::IN_P

    || _la == PostgreSQLParser::USER || ((((_la - 172) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 172)) & 2305843010287435777) != 0) || _la == PostgreSQLParser::INHERIT

    || _la == PostgreSQLParser::PASSWORD || ((((_la - 349) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 349)) & 9077569072660481) != 0) || ((((_la - 554) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 554)) & 268435491) != 0)) {
      setState(1596);
      createoptroleelem();
      setState(1601);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlteroptrolelistContext ------------------------------------------------------------------

PostgreSQLParser::AlteroptrolelistContext::AlteroptrolelistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::AlteroptroleelemContext *> PostgreSQLParser::AlteroptrolelistContext::alteroptroleelem() {
  return getRuleContexts<PostgreSQLParser::AlteroptroleelemContext>();
}

PostgreSQLParser::AlteroptroleelemContext* PostgreSQLParser::AlteroptrolelistContext::alteroptroleelem(size_t i) {
  return getRuleContext<PostgreSQLParser::AlteroptroleelemContext>(i);
}


size_t PostgreSQLParser::AlteroptrolelistContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlteroptrolelist;
}


std::any PostgreSQLParser::AlteroptrolelistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlteroptrolelist(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlteroptrolelistContext* PostgreSQLParser::alteroptrolelist() {
  AlteroptrolelistContext *_localctx = _tracker.createInstance<AlteroptrolelistContext>(_ctx, getState());
  enterRule(_localctx, 16, PostgreSQLParser::RuleAlteroptrolelist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1605);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::USER || _la == PostgreSQLParser::CONNECTION

    || _la == PostgreSQLParser::ENCRYPTED || _la == PostgreSQLParser::INHERIT

    || _la == PostgreSQLParser::PASSWORD || _la == PostgreSQLParser::UNENCRYPTED

    || _la == PostgreSQLParser::VALID || ((((_la - 554) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 554)) & 268435491) != 0)) {
      setState(1602);
      alteroptroleelem();
      setState(1607);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlteroptroleelemContext ------------------------------------------------------------------

PostgreSQLParser::AlteroptroleelemContext::AlteroptroleelemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlteroptroleelemContext::PASSWORD() {
  return getToken(PostgreSQLParser::PASSWORD, 0);
}

PostgreSQLParser::SconstContext* PostgreSQLParser::AlteroptroleelemContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlteroptroleelemContext::NULL_P() {
  return getToken(PostgreSQLParser::NULL_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AlteroptroleelemContext::ENCRYPTED() {
  return getToken(PostgreSQLParser::ENCRYPTED, 0);
}

tree::TerminalNode* PostgreSQLParser::AlteroptroleelemContext::UNENCRYPTED() {
  return getToken(PostgreSQLParser::UNENCRYPTED, 0);
}

tree::TerminalNode* PostgreSQLParser::AlteroptroleelemContext::INHERIT() {
  return getToken(PostgreSQLParser::INHERIT, 0);
}

tree::TerminalNode* PostgreSQLParser::AlteroptroleelemContext::CONNECTION() {
  return getToken(PostgreSQLParser::CONNECTION, 0);
}

tree::TerminalNode* PostgreSQLParser::AlteroptroleelemContext::LIMIT() {
  return getToken(PostgreSQLParser::LIMIT, 0);
}

PostgreSQLParser::SignediconstContext* PostgreSQLParser::AlteroptroleelemContext::signediconst() {
  return getRuleContext<PostgreSQLParser::SignediconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlteroptroleelemContext::VALID() {
  return getToken(PostgreSQLParser::VALID, 0);
}

tree::TerminalNode* PostgreSQLParser::AlteroptroleelemContext::UNTIL() {
  return getToken(PostgreSQLParser::UNTIL, 0);
}

tree::TerminalNode* PostgreSQLParser::AlteroptroleelemContext::USER() {
  return getToken(PostgreSQLParser::USER, 0);
}

PostgreSQLParser::Role_listContext* PostgreSQLParser::AlteroptroleelemContext::role_list() {
  return getRuleContext<PostgreSQLParser::Role_listContext>(0);
}

PostgreSQLParser::IdentifierContext* PostgreSQLParser::AlteroptroleelemContext::identifier() {
  return getRuleContext<PostgreSQLParser::IdentifierContext>(0);
}


size_t PostgreSQLParser::AlteroptroleelemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlteroptroleelem;
}


std::any PostgreSQLParser::AlteroptroleelemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlteroptroleelem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlteroptroleelemContext* PostgreSQLParser::alteroptroleelem() {
  AlteroptroleelemContext *_localctx = _tracker.createInstance<AlteroptroleelemContext>(_ctx, getState());
  enterRule(_localctx, 18, PostgreSQLParser::RuleAlteroptroleelem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1626);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::PASSWORD: {
        enterOuterAlt(_localctx, 1);
        setState(1608);
        match(PostgreSQLParser::PASSWORD);
        setState(1611);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case PostgreSQLParser::StringConstant:
          case PostgreSQLParser::UnicodeEscapeStringConstant:
          case PostgreSQLParser::BeginDollarStringConstant:
          case PostgreSQLParser::EscapeStringConstant: {
            setState(1609);
            sconst();
            break;
          }

          case PostgreSQLParser::NULL_P: {
            setState(1610);
            match(PostgreSQLParser::NULL_P);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::UNENCRYPTED: {
        enterOuterAlt(_localctx, 2);
        setState(1613);
        _la = _input->LA(1);
        if (!(_la == PostgreSQLParser::ENCRYPTED || _la == PostgreSQLParser::UNENCRYPTED)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1614);
        match(PostgreSQLParser::PASSWORD);
        setState(1615);
        sconst();
        break;
      }

      case PostgreSQLParser::INHERIT: {
        enterOuterAlt(_localctx, 3);
        setState(1616);
        match(PostgreSQLParser::INHERIT);
        break;
      }

      case PostgreSQLParser::CONNECTION: {
        enterOuterAlt(_localctx, 4);
        setState(1617);
        match(PostgreSQLParser::CONNECTION);
        setState(1618);
        match(PostgreSQLParser::LIMIT);
        setState(1619);
        signediconst();
        break;
      }

      case PostgreSQLParser::VALID: {
        enterOuterAlt(_localctx, 5);
        setState(1620);
        match(PostgreSQLParser::VALID);
        setState(1621);
        match(PostgreSQLParser::UNTIL);
        setState(1622);
        sconst();
        break;
      }

      case PostgreSQLParser::USER: {
        enterOuterAlt(_localctx, 6);
        setState(1623);
        match(PostgreSQLParser::USER);
        setState(1624);
        role_list();
        break;
      }

      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 7);
        setState(1625);
        identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateoptroleelemContext ------------------------------------------------------------------

PostgreSQLParser::CreateoptroleelemContext::CreateoptroleelemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::AlteroptroleelemContext* PostgreSQLParser::CreateoptroleelemContext::alteroptroleelem() {
  return getRuleContext<PostgreSQLParser::AlteroptroleelemContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateoptroleelemContext::SYSID() {
  return getToken(PostgreSQLParser::SYSID, 0);
}

PostgreSQLParser::IconstContext* PostgreSQLParser::CreateoptroleelemContext::iconst() {
  return getRuleContext<PostgreSQLParser::IconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateoptroleelemContext::ADMIN() {
  return getToken(PostgreSQLParser::ADMIN, 0);
}

PostgreSQLParser::Role_listContext* PostgreSQLParser::CreateoptroleelemContext::role_list() {
  return getRuleContext<PostgreSQLParser::Role_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateoptroleelemContext::ROLE() {
  return getToken(PostgreSQLParser::ROLE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateoptroleelemContext::IN_P() {
  return getToken(PostgreSQLParser::IN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateoptroleelemContext::GROUP_P() {
  return getToken(PostgreSQLParser::GROUP_P, 0);
}


size_t PostgreSQLParser::CreateoptroleelemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreateoptroleelem;
}


std::any PostgreSQLParser::CreateoptroleelemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateoptroleelem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreateoptroleelemContext* PostgreSQLParser::createoptroleelem() {
  CreateoptroleelemContext *_localctx = _tracker.createInstance<CreateoptroleelemContext>(_ctx, getState());
  enterRule(_localctx, 20, PostgreSQLParser::RuleCreateoptroleelem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1638);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::USER:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 1);
        setState(1628);
        alteroptroleelem();
        break;
      }

      case PostgreSQLParser::SYSID: {
        enterOuterAlt(_localctx, 2);
        setState(1629);
        match(PostgreSQLParser::SYSID);
        setState(1630);
        iconst();
        break;
      }

      case PostgreSQLParser::ADMIN: {
        enterOuterAlt(_localctx, 3);
        setState(1631);
        match(PostgreSQLParser::ADMIN);
        setState(1632);
        role_list();
        break;
      }

      case PostgreSQLParser::ROLE: {
        enterOuterAlt(_localctx, 4);
        setState(1633);
        match(PostgreSQLParser::ROLE);
        setState(1634);
        role_list();
        break;
      }

      case PostgreSQLParser::IN_P: {
        enterOuterAlt(_localctx, 5);
        setState(1635);
        match(PostgreSQLParser::IN_P);
        setState(1636);
        _la = _input->LA(1);
        if (!(_la == PostgreSQLParser::GROUP_P || _la == PostgreSQLParser::ROLE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1637);
        role_list();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateuserstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreateuserstmtContext::CreateuserstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreateuserstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateuserstmtContext::USER() {
  return getToken(PostgreSQLParser::USER, 0);
}

PostgreSQLParser::RoleidContext* PostgreSQLParser::CreateuserstmtContext::roleid() {
  return getRuleContext<PostgreSQLParser::RoleidContext>(0);
}

PostgreSQLParser::OptrolelistContext* PostgreSQLParser::CreateuserstmtContext::optrolelist() {
  return getRuleContext<PostgreSQLParser::OptrolelistContext>(0);
}

PostgreSQLParser::With_Context* PostgreSQLParser::CreateuserstmtContext::with_() {
  return getRuleContext<PostgreSQLParser::With_Context>(0);
}


size_t PostgreSQLParser::CreateuserstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreateuserstmt;
}


std::any PostgreSQLParser::CreateuserstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateuserstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreateuserstmtContext* PostgreSQLParser::createuserstmt() {
  CreateuserstmtContext *_localctx = _tracker.createInstance<CreateuserstmtContext>(_ctx, getState());
  enterRule(_localctx, 22, PostgreSQLParser::RuleCreateuserstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1640);
    match(PostgreSQLParser::CREATE);
    setState(1641);
    match(PostgreSQLParser::USER);
    setState(1642);
    roleid();
    setState(1644);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(1643);
      with_();
    }
    setState(1646);
    optrolelist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterrolestmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterrolestmtContext::AlterrolestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterrolestmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

PostgreSQLParser::RolespecContext* PostgreSQLParser::AlterrolestmtContext::rolespec() {
  return getRuleContext<PostgreSQLParser::RolespecContext>(0);
}

PostgreSQLParser::AlteroptrolelistContext* PostgreSQLParser::AlterrolestmtContext::alteroptrolelist() {
  return getRuleContext<PostgreSQLParser::AlteroptrolelistContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterrolestmtContext::ROLE() {
  return getToken(PostgreSQLParser::ROLE, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterrolestmtContext::USER() {
  return getToken(PostgreSQLParser::USER, 0);
}

PostgreSQLParser::With_Context* PostgreSQLParser::AlterrolestmtContext::with_() {
  return getRuleContext<PostgreSQLParser::With_Context>(0);
}


size_t PostgreSQLParser::AlterrolestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterrolestmt;
}


std::any PostgreSQLParser::AlterrolestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterrolestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterrolestmtContext* PostgreSQLParser::alterrolestmt() {
  AlterrolestmtContext *_localctx = _tracker.createInstance<AlterrolestmtContext>(_ctx, getState());
  enterRule(_localctx, 24, PostgreSQLParser::RuleAlterrolestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1648);
    match(PostgreSQLParser::ALTER);
    setState(1649);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::USER || _la == PostgreSQLParser::ROLE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1650);
    rolespec();
    setState(1652);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(1651);
      with_();
    }
    setState(1654);
    alteroptrolelist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- In_database_Context ------------------------------------------------------------------

PostgreSQLParser::In_database_Context::In_database_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::In_database_Context::IN_P() {
  return getToken(PostgreSQLParser::IN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::In_database_Context::DATABASE() {
  return getToken(PostgreSQLParser::DATABASE, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::In_database_Context::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}


size_t PostgreSQLParser::In_database_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleIn_database_;
}


std::any PostgreSQLParser::In_database_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitIn_database_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::In_database_Context* PostgreSQLParser::in_database_() {
  In_database_Context *_localctx = _tracker.createInstance<In_database_Context>(_ctx, getState());
  enterRule(_localctx, 26, PostgreSQLParser::RuleIn_database_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1656);
    match(PostgreSQLParser::IN_P);
    setState(1657);
    match(PostgreSQLParser::DATABASE);
    setState(1658);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterrolesetstmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterrolesetstmtContext::AlterrolesetstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterrolesetstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

PostgreSQLParser::RolespecContext* PostgreSQLParser::AlterrolesetstmtContext::rolespec() {
  return getRuleContext<PostgreSQLParser::RolespecContext>(0);
}

PostgreSQLParser::SetresetclauseContext* PostgreSQLParser::AlterrolesetstmtContext::setresetclause() {
  return getRuleContext<PostgreSQLParser::SetresetclauseContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterrolesetstmtContext::ROLE() {
  return getToken(PostgreSQLParser::ROLE, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterrolesetstmtContext::USER() {
  return getToken(PostgreSQLParser::USER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterrolesetstmtContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}

PostgreSQLParser::In_database_Context* PostgreSQLParser::AlterrolesetstmtContext::in_database_() {
  return getRuleContext<PostgreSQLParser::In_database_Context>(0);
}


size_t PostgreSQLParser::AlterrolesetstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterrolesetstmt;
}


std::any PostgreSQLParser::AlterrolesetstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterrolesetstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterrolesetstmtContext* PostgreSQLParser::alterrolesetstmt() {
  AlterrolesetstmtContext *_localctx = _tracker.createInstance<AlterrolesetstmtContext>(_ctx, getState());
  enterRule(_localctx, 28, PostgreSQLParser::RuleAlterrolesetstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1660);
    match(PostgreSQLParser::ALTER);
    setState(1661);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::USER || _la == PostgreSQLParser::ROLE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1663);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::ALL) {
      setState(1662);
      match(PostgreSQLParser::ALL);
    }
    setState(1665);
    rolespec();
    setState(1667);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::IN_P) {
      setState(1666);
      in_database_();
    }
    setState(1669);
    setresetclause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DroprolestmtContext ------------------------------------------------------------------

PostgreSQLParser::DroprolestmtContext::DroprolestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DroprolestmtContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

PostgreSQLParser::Role_listContext* PostgreSQLParser::DroprolestmtContext::role_list() {
  return getRuleContext<PostgreSQLParser::Role_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DroprolestmtContext::ROLE() {
  return getToken(PostgreSQLParser::ROLE, 0);
}

tree::TerminalNode* PostgreSQLParser::DroprolestmtContext::USER() {
  return getToken(PostgreSQLParser::USER, 0);
}

tree::TerminalNode* PostgreSQLParser::DroprolestmtContext::GROUP_P() {
  return getToken(PostgreSQLParser::GROUP_P, 0);
}

tree::TerminalNode* PostgreSQLParser::DroprolestmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::DroprolestmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}


size_t PostgreSQLParser::DroprolestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDroprolestmt;
}


std::any PostgreSQLParser::DroprolestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDroprolestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DroprolestmtContext* PostgreSQLParser::droprolestmt() {
  DroprolestmtContext *_localctx = _tracker.createInstance<DroprolestmtContext>(_ctx, getState());
  enterRule(_localctx, 30, PostgreSQLParser::RuleDroprolestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1671);
    match(PostgreSQLParser::DROP);
    setState(1672);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::GROUP_P

    || _la == PostgreSQLParser::USER || _la == PostgreSQLParser::ROLE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1675);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
    case 1: {
      setState(1673);
      match(PostgreSQLParser::IF_P);
      setState(1674);
      match(PostgreSQLParser::EXISTS);
      break;
    }

    default:
      break;
    }
    setState(1677);
    role_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreategroupstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreategroupstmtContext::CreategroupstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreategroupstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreategroupstmtContext::GROUP_P() {
  return getToken(PostgreSQLParser::GROUP_P, 0);
}

PostgreSQLParser::RoleidContext* PostgreSQLParser::CreategroupstmtContext::roleid() {
  return getRuleContext<PostgreSQLParser::RoleidContext>(0);
}

PostgreSQLParser::OptrolelistContext* PostgreSQLParser::CreategroupstmtContext::optrolelist() {
  return getRuleContext<PostgreSQLParser::OptrolelistContext>(0);
}

PostgreSQLParser::With_Context* PostgreSQLParser::CreategroupstmtContext::with_() {
  return getRuleContext<PostgreSQLParser::With_Context>(0);
}


size_t PostgreSQLParser::CreategroupstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreategroupstmt;
}


std::any PostgreSQLParser::CreategroupstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreategroupstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreategroupstmtContext* PostgreSQLParser::creategroupstmt() {
  CreategroupstmtContext *_localctx = _tracker.createInstance<CreategroupstmtContext>(_ctx, getState());
  enterRule(_localctx, 32, PostgreSQLParser::RuleCreategroupstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1679);
    match(PostgreSQLParser::CREATE);
    setState(1680);
    match(PostgreSQLParser::GROUP_P);
    setState(1681);
    roleid();
    setState(1683);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(1682);
      with_();
    }
    setState(1685);
    optrolelist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AltergroupstmtContext ------------------------------------------------------------------

PostgreSQLParser::AltergroupstmtContext::AltergroupstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AltergroupstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AltergroupstmtContext::GROUP_P() {
  return getToken(PostgreSQLParser::GROUP_P, 0);
}

PostgreSQLParser::RolespecContext* PostgreSQLParser::AltergroupstmtContext::rolespec() {
  return getRuleContext<PostgreSQLParser::RolespecContext>(0);
}

PostgreSQLParser::Add_dropContext* PostgreSQLParser::AltergroupstmtContext::add_drop() {
  return getRuleContext<PostgreSQLParser::Add_dropContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AltergroupstmtContext::USER() {
  return getToken(PostgreSQLParser::USER, 0);
}

PostgreSQLParser::Role_listContext* PostgreSQLParser::AltergroupstmtContext::role_list() {
  return getRuleContext<PostgreSQLParser::Role_listContext>(0);
}


size_t PostgreSQLParser::AltergroupstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAltergroupstmt;
}


std::any PostgreSQLParser::AltergroupstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAltergroupstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AltergroupstmtContext* PostgreSQLParser::altergroupstmt() {
  AltergroupstmtContext *_localctx = _tracker.createInstance<AltergroupstmtContext>(_ctx, getState());
  enterRule(_localctx, 34, PostgreSQLParser::RuleAltergroupstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1687);
    match(PostgreSQLParser::ALTER);
    setState(1688);
    match(PostgreSQLParser::GROUP_P);
    setState(1689);
    rolespec();
    setState(1690);
    add_drop();
    setState(1691);
    match(PostgreSQLParser::USER);
    setState(1692);
    role_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Add_dropContext ------------------------------------------------------------------

PostgreSQLParser::Add_dropContext::Add_dropContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Add_dropContext::ADD_P() {
  return getToken(PostgreSQLParser::ADD_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Add_dropContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}


size_t PostgreSQLParser::Add_dropContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAdd_drop;
}


std::any PostgreSQLParser::Add_dropContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAdd_drop(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Add_dropContext* PostgreSQLParser::add_drop() {
  Add_dropContext *_localctx = _tracker.createInstance<Add_dropContext>(_ctx, getState());
  enterRule(_localctx, 36, PostgreSQLParser::RuleAdd_drop);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1694);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::ADD_P

    || _la == PostgreSQLParser::DROP)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateschemastmtContext ------------------------------------------------------------------

PostgreSQLParser::CreateschemastmtContext::CreateschemastmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreateschemastmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateschemastmtContext::SCHEMA() {
  return getToken(PostgreSQLParser::SCHEMA, 0);
}

PostgreSQLParser::OptschemaeltlistContext* PostgreSQLParser::CreateschemastmtContext::optschemaeltlist() {
  return getRuleContext<PostgreSQLParser::OptschemaeltlistContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateschemastmtContext::AUTHORIZATION() {
  return getToken(PostgreSQLParser::AUTHORIZATION, 0);
}

PostgreSQLParser::RolespecContext* PostgreSQLParser::CreateschemastmtContext::rolespec() {
  return getRuleContext<PostgreSQLParser::RolespecContext>(0);
}

PostgreSQLParser::ColidContext* PostgreSQLParser::CreateschemastmtContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateschemastmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateschemastmtContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateschemastmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

PostgreSQLParser::OptschemanameContext* PostgreSQLParser::CreateschemastmtContext::optschemaname() {
  return getRuleContext<PostgreSQLParser::OptschemanameContext>(0);
}


size_t PostgreSQLParser::CreateschemastmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreateschemastmt;
}


std::any PostgreSQLParser::CreateschemastmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateschemastmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreateschemastmtContext* PostgreSQLParser::createschemastmt() {
  CreateschemastmtContext *_localctx = _tracker.createInstance<CreateschemastmtContext>(_ctx, getState());
  enterRule(_localctx, 38, PostgreSQLParser::RuleCreateschemastmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1696);
    match(PostgreSQLParser::CREATE);
    setState(1697);
    match(PostgreSQLParser::SCHEMA);
    setState(1701);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx)) {
    case 1: {
      setState(1698);
      match(PostgreSQLParser::IF_P);
      setState(1699);
      match(PostgreSQLParser::NOT);
      setState(1700);
      match(PostgreSQLParser::EXISTS);
      break;
    }

    default:
      break;
    }
    setState(1709);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
    case 1: {
      setState(1704);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 30) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 30)) & 137438949375) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 553)) & 536870983) != 0)) {
        setState(1703);
        optschemaname();
      }
      setState(1706);
      match(PostgreSQLParser::AUTHORIZATION);
      setState(1707);
      rolespec();
      break;
    }

    case 2: {
      setState(1708);
      colid();
      break;
    }

    default:
      break;
    }
    setState(1711);
    optschemaeltlist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptschemanameContext ------------------------------------------------------------------

PostgreSQLParser::OptschemanameContext::OptschemanameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::OptschemanameContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}


size_t PostgreSQLParser::OptschemanameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOptschemaname;
}


std::any PostgreSQLParser::OptschemanameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOptschemaname(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::OptschemanameContext* PostgreSQLParser::optschemaname() {
  OptschemanameContext *_localctx = _tracker.createInstance<OptschemanameContext>(_ctx, getState());
  enterRule(_localctx, 40, PostgreSQLParser::RuleOptschemaname);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1713);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptschemaeltlistContext ------------------------------------------------------------------

PostgreSQLParser::OptschemaeltlistContext::OptschemaeltlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Schema_stmtContext *> PostgreSQLParser::OptschemaeltlistContext::schema_stmt() {
  return getRuleContexts<PostgreSQLParser::Schema_stmtContext>();
}

PostgreSQLParser::Schema_stmtContext* PostgreSQLParser::OptschemaeltlistContext::schema_stmt(size_t i) {
  return getRuleContext<PostgreSQLParser::Schema_stmtContext>(i);
}


size_t PostgreSQLParser::OptschemaeltlistContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOptschemaeltlist;
}


std::any PostgreSQLParser::OptschemaeltlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOptschemaeltlist(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::OptschemaeltlistContext* PostgreSQLParser::optschemaeltlist() {
  OptschemaeltlistContext *_localctx = _tracker.createInstance<OptschemaeltlistContext>(_ctx, getState());
  enterRule(_localctx, 42, PostgreSQLParser::RuleOptschemaeltlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1718);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::CREATE

    || _la == PostgreSQLParser::GRANT) {
      setState(1715);
      schema_stmt();
      setState(1720);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Schema_stmtContext ------------------------------------------------------------------

PostgreSQLParser::Schema_stmtContext::Schema_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::CreatestmtContext* PostgreSQLParser::Schema_stmtContext::createstmt() {
  return getRuleContext<PostgreSQLParser::CreatestmtContext>(0);
}

PostgreSQLParser::IndexstmtContext* PostgreSQLParser::Schema_stmtContext::indexstmt() {
  return getRuleContext<PostgreSQLParser::IndexstmtContext>(0);
}

PostgreSQLParser::CreateseqstmtContext* PostgreSQLParser::Schema_stmtContext::createseqstmt() {
  return getRuleContext<PostgreSQLParser::CreateseqstmtContext>(0);
}

PostgreSQLParser::CreatetrigstmtContext* PostgreSQLParser::Schema_stmtContext::createtrigstmt() {
  return getRuleContext<PostgreSQLParser::CreatetrigstmtContext>(0);
}

PostgreSQLParser::GrantstmtContext* PostgreSQLParser::Schema_stmtContext::grantstmt() {
  return getRuleContext<PostgreSQLParser::GrantstmtContext>(0);
}

PostgreSQLParser::ViewstmtContext* PostgreSQLParser::Schema_stmtContext::viewstmt() {
  return getRuleContext<PostgreSQLParser::ViewstmtContext>(0);
}


size_t PostgreSQLParser::Schema_stmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSchema_stmt;
}


std::any PostgreSQLParser::Schema_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSchema_stmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Schema_stmtContext* PostgreSQLParser::schema_stmt() {
  Schema_stmtContext *_localctx = _tracker.createInstance<Schema_stmtContext>(_ctx, getState());
  enterRule(_localctx, 44, PostgreSQLParser::RuleSchema_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1727);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1721);
      createstmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1722);
      indexstmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1723);
      createseqstmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1724);
      createtrigstmt();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1725);
      grantstmt();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1726);
      viewstmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariablesetstmtContext ------------------------------------------------------------------

PostgreSQLParser::VariablesetstmtContext::VariablesetstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::VariablesetstmtContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

PostgreSQLParser::Set_restContext* PostgreSQLParser::VariablesetstmtContext::set_rest() {
  return getRuleContext<PostgreSQLParser::Set_restContext>(0);
}

tree::TerminalNode* PostgreSQLParser::VariablesetstmtContext::LOCAL() {
  return getToken(PostgreSQLParser::LOCAL, 0);
}

tree::TerminalNode* PostgreSQLParser::VariablesetstmtContext::SESSION() {
  return getToken(PostgreSQLParser::SESSION, 0);
}


size_t PostgreSQLParser::VariablesetstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleVariablesetstmt;
}


std::any PostgreSQLParser::VariablesetstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitVariablesetstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::VariablesetstmtContext* PostgreSQLParser::variablesetstmt() {
  VariablesetstmtContext *_localctx = _tracker.createInstance<VariablesetstmtContext>(_ctx, getState());
  enterRule(_localctx, 46, PostgreSQLParser::RuleVariablesetstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1729);
    match(PostgreSQLParser::SET);
    setState(1731);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
    case 1: {
      setState(1730);
      _la = _input->LA(1);
      if (!(_la == PostgreSQLParser::LOCAL || _la == PostgreSQLParser::SESSION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(1733);
    set_rest();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_restContext ------------------------------------------------------------------

PostgreSQLParser::Set_restContext::Set_restContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Set_restContext::TRANSACTION() {
  return getToken(PostgreSQLParser::TRANSACTION, 0);
}

PostgreSQLParser::Transaction_mode_listContext* PostgreSQLParser::Set_restContext::transaction_mode_list() {
  return getRuleContext<PostgreSQLParser::Transaction_mode_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Set_restContext::SESSION() {
  return getToken(PostgreSQLParser::SESSION, 0);
}

tree::TerminalNode* PostgreSQLParser::Set_restContext::CHARACTERISTICS() {
  return getToken(PostgreSQLParser::CHARACTERISTICS, 0);
}

tree::TerminalNode* PostgreSQLParser::Set_restContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

PostgreSQLParser::Set_rest_moreContext* PostgreSQLParser::Set_restContext::set_rest_more() {
  return getRuleContext<PostgreSQLParser::Set_rest_moreContext>(0);
}


size_t PostgreSQLParser::Set_restContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSet_rest;
}


std::any PostgreSQLParser::Set_restContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSet_rest(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Set_restContext* PostgreSQLParser::set_rest() {
  Set_restContext *_localctx = _tracker.createInstance<Set_restContext>(_ctx, getState());
  enterRule(_localctx, 48, PostgreSQLParser::RuleSet_rest);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1743);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1735);
      match(PostgreSQLParser::TRANSACTION);
      setState(1736);
      transaction_mode_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1737);
      match(PostgreSQLParser::SESSION);
      setState(1738);
      match(PostgreSQLParser::CHARACTERISTICS);
      setState(1739);
      match(PostgreSQLParser::AS);
      setState(1740);
      match(PostgreSQLParser::TRANSACTION);
      setState(1741);
      transaction_mode_list();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1742);
      set_rest_more();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generic_setContext ------------------------------------------------------------------

PostgreSQLParser::Generic_setContext::Generic_setContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Var_nameContext* PostgreSQLParser::Generic_setContext::var_name() {
  return getRuleContext<PostgreSQLParser::Var_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Generic_setContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}

tree::TerminalNode* PostgreSQLParser::Generic_setContext::EQUAL() {
  return getToken(PostgreSQLParser::EQUAL, 0);
}

PostgreSQLParser::Var_listContext* PostgreSQLParser::Generic_setContext::var_list() {
  return getRuleContext<PostgreSQLParser::Var_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Generic_setContext::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}


size_t PostgreSQLParser::Generic_setContext::getRuleIndex() const {
  return PostgreSQLParser::RuleGeneric_set;
}


std::any PostgreSQLParser::Generic_setContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitGeneric_set(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Generic_setContext* PostgreSQLParser::generic_set() {
  Generic_setContext *_localctx = _tracker.createInstance<Generic_setContext>(_ctx, getState());
  enterRule(_localctx, 50, PostgreSQLParser::RuleGeneric_set);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1745);
    var_name();
    setState(1746);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::EQUAL || _la == PostgreSQLParser::TO)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1749);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::PLUS:
      case PostgreSQLParser::MINUS:
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::FALSE_P:
      case PostgreSQLParser::ON:
      case PostgreSQLParser::TRUE_P:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::Integral:
      case PostgreSQLParser::BinaryIntegral:
      case PostgreSQLParser::OctalIntegral:
      case PostgreSQLParser::HexadecimalIntegral:
      case PostgreSQLParser::Numeric:
      case PostgreSQLParser::PLSQLVARIABLENAME:
      case PostgreSQLParser::EscapeStringConstant: {
        setState(1747);
        var_list();
        break;
      }

      case PostgreSQLParser::DEFAULT: {
        setState(1748);
        match(PostgreSQLParser::DEFAULT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_rest_moreContext ------------------------------------------------------------------

PostgreSQLParser::Set_rest_moreContext::Set_rest_moreContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Generic_setContext* PostgreSQLParser::Set_rest_moreContext::generic_set() {
  return getRuleContext<PostgreSQLParser::Generic_setContext>(0);
}

PostgreSQLParser::Var_nameContext* PostgreSQLParser::Set_rest_moreContext::var_name() {
  return getRuleContext<PostgreSQLParser::Var_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Set_rest_moreContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

tree::TerminalNode* PostgreSQLParser::Set_rest_moreContext::CURRENT_P() {
  return getToken(PostgreSQLParser::CURRENT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Set_rest_moreContext::TIME() {
  return getToken(PostgreSQLParser::TIME, 0);
}

tree::TerminalNode* PostgreSQLParser::Set_rest_moreContext::ZONE() {
  return getToken(PostgreSQLParser::ZONE, 0);
}

PostgreSQLParser::Zone_valueContext* PostgreSQLParser::Set_rest_moreContext::zone_value() {
  return getRuleContext<PostgreSQLParser::Zone_valueContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Set_rest_moreContext::CATALOG() {
  return getToken(PostgreSQLParser::CATALOG, 0);
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Set_rest_moreContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Set_rest_moreContext::SCHEMA() {
  return getToken(PostgreSQLParser::SCHEMA, 0);
}

tree::TerminalNode* PostgreSQLParser::Set_rest_moreContext::NAMES() {
  return getToken(PostgreSQLParser::NAMES, 0);
}

PostgreSQLParser::Encoding_Context* PostgreSQLParser::Set_rest_moreContext::encoding_() {
  return getRuleContext<PostgreSQLParser::Encoding_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::Set_rest_moreContext::ROLE() {
  return getToken(PostgreSQLParser::ROLE, 0);
}

PostgreSQLParser::Nonreservedword_or_sconstContext* PostgreSQLParser::Set_rest_moreContext::nonreservedword_or_sconst() {
  return getRuleContext<PostgreSQLParser::Nonreservedword_or_sconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Set_rest_moreContext::SESSION() {
  return getToken(PostgreSQLParser::SESSION, 0);
}

tree::TerminalNode* PostgreSQLParser::Set_rest_moreContext::AUTHORIZATION() {
  return getToken(PostgreSQLParser::AUTHORIZATION, 0);
}

tree::TerminalNode* PostgreSQLParser::Set_rest_moreContext::XML_P() {
  return getToken(PostgreSQLParser::XML_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Set_rest_moreContext::OPTION() {
  return getToken(PostgreSQLParser::OPTION, 0);
}

PostgreSQLParser::Document_or_contentContext* PostgreSQLParser::Set_rest_moreContext::document_or_content() {
  return getRuleContext<PostgreSQLParser::Document_or_contentContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Set_rest_moreContext::TRANSACTION() {
  return getToken(PostgreSQLParser::TRANSACTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Set_rest_moreContext::SNAPSHOT() {
  return getToken(PostgreSQLParser::SNAPSHOT, 0);
}


size_t PostgreSQLParser::Set_rest_moreContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSet_rest_more;
}


std::any PostgreSQLParser::Set_rest_moreContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSet_rest_more(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Set_rest_moreContext* PostgreSQLParser::set_rest_more() {
  Set_rest_moreContext *_localctx = _tracker.createInstance<Set_rest_moreContext>(_ctx, getState());
  enterRule(_localctx, 52, PostgreSQLParser::RuleSet_rest_more);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1778);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1751);
      generic_set();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1752);
      var_name();
      setState(1753);
      match(PostgreSQLParser::FROM);
      setState(1754);
      match(PostgreSQLParser::CURRENT_P);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1756);
      match(PostgreSQLParser::TIME);
      setState(1757);
      match(PostgreSQLParser::ZONE);
      setState(1758);
      zone_value();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1759);
      match(PostgreSQLParser::CATALOG);
      setState(1760);
      sconst();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1761);
      match(PostgreSQLParser::SCHEMA);
      setState(1762);
      sconst();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1763);
      match(PostgreSQLParser::NAMES);
      setState(1765);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::DEFAULT || ((((_la - 563) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 563)) & 134217749) != 0)) {
        setState(1764);
        encoding_();
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1767);
      match(PostgreSQLParser::ROLE);
      setState(1768);
      nonreservedword_or_sconst();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1769);
      match(PostgreSQLParser::SESSION);
      setState(1770);
      match(PostgreSQLParser::AUTHORIZATION);
      setState(1771);
      nonreservedword_or_sconst();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1772);
      match(PostgreSQLParser::XML_P);
      setState(1773);
      match(PostgreSQLParser::OPTION);
      setState(1774);
      document_or_content();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1775);
      match(PostgreSQLParser::TRANSACTION);
      setState(1776);
      match(PostgreSQLParser::SNAPSHOT);
      setState(1777);
      sconst();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Var_nameContext ------------------------------------------------------------------

PostgreSQLParser::Var_nameContext::Var_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::ColidContext *> PostgreSQLParser::Var_nameContext::colid() {
  return getRuleContexts<PostgreSQLParser::ColidContext>();
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Var_nameContext::colid(size_t i) {
  return getRuleContext<PostgreSQLParser::ColidContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Var_nameContext::DOT() {
  return getTokens(PostgreSQLParser::DOT);
}

tree::TerminalNode* PostgreSQLParser::Var_nameContext::DOT(size_t i) {
  return getToken(PostgreSQLParser::DOT, i);
}


size_t PostgreSQLParser::Var_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleVar_name;
}


std::any PostgreSQLParser::Var_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitVar_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Var_nameContext* PostgreSQLParser::var_name() {
  Var_nameContext *_localctx = _tracker.createInstance<Var_nameContext>(_ctx, getState());
  enterRule(_localctx, 54, PostgreSQLParser::RuleVar_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1780);
    colid();
    setState(1785);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::DOT) {
      setState(1781);
      match(PostgreSQLParser::DOT);
      setState(1782);
      colid();
      setState(1787);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Var_listContext ------------------------------------------------------------------

PostgreSQLParser::Var_listContext::Var_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Var_valueContext *> PostgreSQLParser::Var_listContext::var_value() {
  return getRuleContexts<PostgreSQLParser::Var_valueContext>();
}

PostgreSQLParser::Var_valueContext* PostgreSQLParser::Var_listContext::var_value(size_t i) {
  return getRuleContext<PostgreSQLParser::Var_valueContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Var_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Var_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Var_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleVar_list;
}


std::any PostgreSQLParser::Var_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitVar_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Var_listContext* PostgreSQLParser::var_list() {
  Var_listContext *_localctx = _tracker.createInstance<Var_listContext>(_ctx, getState());
  enterRule(_localctx, 56, PostgreSQLParser::RuleVar_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1788);
    var_value();
    setState(1793);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(1789);
      match(PostgreSQLParser::COMMA);
      setState(1790);
      var_value();
      setState(1795);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Var_valueContext ------------------------------------------------------------------

PostgreSQLParser::Var_valueContext::Var_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Boolean_or_string_Context* PostgreSQLParser::Var_valueContext::boolean_or_string_() {
  return getRuleContext<PostgreSQLParser::Boolean_or_string_Context>(0);
}

PostgreSQLParser::NumericonlyContext* PostgreSQLParser::Var_valueContext::numericonly() {
  return getRuleContext<PostgreSQLParser::NumericonlyContext>(0);
}


size_t PostgreSQLParser::Var_valueContext::getRuleIndex() const {
  return PostgreSQLParser::RuleVar_value;
}


std::any PostgreSQLParser::Var_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitVar_value(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Var_valueContext* PostgreSQLParser::var_value() {
  Var_valueContext *_localctx = _tracker.createInstance<Var_valueContext>(_ctx, getState());
  enterRule(_localctx, 58, PostgreSQLParser::RuleVar_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1798);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::FALSE_P:
      case PostgreSQLParser::ON:
      case PostgreSQLParser::TRUE_P:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::PLSQLVARIABLENAME:
      case PostgreSQLParser::EscapeStringConstant: {
        enterOuterAlt(_localctx, 1);
        setState(1796);
        boolean_or_string_();
        break;
      }

      case PostgreSQLParser::PLUS:
      case PostgreSQLParser::MINUS:
      case PostgreSQLParser::Integral:
      case PostgreSQLParser::BinaryIntegral:
      case PostgreSQLParser::OctalIntegral:
      case PostgreSQLParser::HexadecimalIntegral:
      case PostgreSQLParser::Numeric: {
        enterOuterAlt(_localctx, 2);
        setState(1797);
        numericonly();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Iso_levelContext ------------------------------------------------------------------

PostgreSQLParser::Iso_levelContext::Iso_levelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Iso_levelContext::READ() {
  return getToken(PostgreSQLParser::READ, 0);
}

tree::TerminalNode* PostgreSQLParser::Iso_levelContext::UNCOMMITTED() {
  return getToken(PostgreSQLParser::UNCOMMITTED, 0);
}

tree::TerminalNode* PostgreSQLParser::Iso_levelContext::COMMITTED() {
  return getToken(PostgreSQLParser::COMMITTED, 0);
}

tree::TerminalNode* PostgreSQLParser::Iso_levelContext::REPEATABLE() {
  return getToken(PostgreSQLParser::REPEATABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Iso_levelContext::SERIALIZABLE() {
  return getToken(PostgreSQLParser::SERIALIZABLE, 0);
}


size_t PostgreSQLParser::Iso_levelContext::getRuleIndex() const {
  return PostgreSQLParser::RuleIso_level;
}


std::any PostgreSQLParser::Iso_levelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitIso_level(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Iso_levelContext* PostgreSQLParser::iso_level() {
  Iso_levelContext *_localctx = _tracker.createInstance<Iso_levelContext>(_ctx, getState());
  enterRule(_localctx, 60, PostgreSQLParser::RuleIso_level);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1805);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::READ: {
        enterOuterAlt(_localctx, 1);
        setState(1800);
        match(PostgreSQLParser::READ);
        setState(1801);
        _la = _input->LA(1);
        if (!(_la == PostgreSQLParser::COMMITTED || _la == PostgreSQLParser::UNCOMMITTED)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case PostgreSQLParser::REPEATABLE: {
        enterOuterAlt(_localctx, 2);
        setState(1802);
        match(PostgreSQLParser::REPEATABLE);
        setState(1803);
        match(PostgreSQLParser::READ);
        break;
      }

      case PostgreSQLParser::SERIALIZABLE: {
        enterOuterAlt(_localctx, 3);
        setState(1804);
        match(PostgreSQLParser::SERIALIZABLE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Boolean_or_string_Context ------------------------------------------------------------------

PostgreSQLParser::Boolean_or_string_Context::Boolean_or_string_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Boolean_or_string_Context::TRUE_P() {
  return getToken(PostgreSQLParser::TRUE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Boolean_or_string_Context::FALSE_P() {
  return getToken(PostgreSQLParser::FALSE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Boolean_or_string_Context::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

PostgreSQLParser::Nonreservedword_or_sconstContext* PostgreSQLParser::Boolean_or_string_Context::nonreservedword_or_sconst() {
  return getRuleContext<PostgreSQLParser::Nonreservedword_or_sconstContext>(0);
}


size_t PostgreSQLParser::Boolean_or_string_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleBoolean_or_string_;
}


std::any PostgreSQLParser::Boolean_or_string_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitBoolean_or_string_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Boolean_or_string_Context* PostgreSQLParser::boolean_or_string_() {
  Boolean_or_string_Context *_localctx = _tracker.createInstance<Boolean_or_string_Context>(_ctx, getState());
  enterRule(_localctx, 62, PostgreSQLParser::RuleBoolean_or_string_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1811);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::TRUE_P: {
        enterOuterAlt(_localctx, 1);
        setState(1807);
        match(PostgreSQLParser::TRUE_P);
        break;
      }

      case PostgreSQLParser::FALSE_P: {
        enterOuterAlt(_localctx, 2);
        setState(1808);
        match(PostgreSQLParser::FALSE_P);
        break;
      }

      case PostgreSQLParser::ON: {
        enterOuterAlt(_localctx, 3);
        setState(1809);
        match(PostgreSQLParser::ON);
        break;
      }

      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::PLSQLVARIABLENAME:
      case PostgreSQLParser::EscapeStringConstant: {
        enterOuterAlt(_localctx, 4);
        setState(1810);
        nonreservedword_or_sconst();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Zone_valueContext ------------------------------------------------------------------

PostgreSQLParser::Zone_valueContext::Zone_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Zone_valueContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}

PostgreSQLParser::IdentifierContext* PostgreSQLParser::Zone_valueContext::identifier() {
  return getRuleContext<PostgreSQLParser::IdentifierContext>(0);
}

PostgreSQLParser::ConstintervalContext* PostgreSQLParser::Zone_valueContext::constinterval() {
  return getRuleContext<PostgreSQLParser::ConstintervalContext>(0);
}

PostgreSQLParser::Interval_Context* PostgreSQLParser::Zone_valueContext::interval_() {
  return getRuleContext<PostgreSQLParser::Interval_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::Zone_valueContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::IconstContext* PostgreSQLParser::Zone_valueContext::iconst() {
  return getRuleContext<PostgreSQLParser::IconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Zone_valueContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::NumericonlyContext* PostgreSQLParser::Zone_valueContext::numericonly() {
  return getRuleContext<PostgreSQLParser::NumericonlyContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Zone_valueContext::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}

tree::TerminalNode* PostgreSQLParser::Zone_valueContext::LOCAL() {
  return getToken(PostgreSQLParser::LOCAL, 0);
}


size_t PostgreSQLParser::Zone_valueContext::getRuleIndex() const {
  return PostgreSQLParser::RuleZone_value;
}


std::any PostgreSQLParser::Zone_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitZone_value(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Zone_valueContext* PostgreSQLParser::zone_value() {
  Zone_valueContext *_localctx = _tracker.createInstance<Zone_valueContext>(_ctx, getState());
  enterRule(_localctx, 64, PostgreSQLParser::RuleZone_value);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1829);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1813);
      sconst();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1814);
      identifier();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1815);
      constinterval();
      setState(1816);
      sconst();
      setState(1818);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::DAY_P

      || _la == PostgreSQLParser::HOUR_P || _la == PostgreSQLParser::MINUTE_P

      || _la == PostgreSQLParser::MONTH_P || _la == PostgreSQLParser::SECOND_P

      || _la == PostgreSQLParser::YEAR_P) {
        setState(1817);
        interval_();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1820);
      constinterval();
      setState(1821);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(1822);
      iconst();
      setState(1823);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(1824);
      sconst();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1826);
      numericonly();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1827);
      match(PostgreSQLParser::DEFAULT);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1828);
      match(PostgreSQLParser::LOCAL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Encoding_Context ------------------------------------------------------------------

PostgreSQLParser::Encoding_Context::Encoding_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Encoding_Context::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Encoding_Context::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}


size_t PostgreSQLParser::Encoding_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleEncoding_;
}


std::any PostgreSQLParser::Encoding_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitEncoding_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Encoding_Context* PostgreSQLParser::encoding_() {
  Encoding_Context *_localctx = _tracker.createInstance<Encoding_Context>(_ctx, getState());
  enterRule(_localctx, 66, PostgreSQLParser::RuleEncoding_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1833);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::EscapeStringConstant: {
        enterOuterAlt(_localctx, 1);
        setState(1831);
        sconst();
        break;
      }

      case PostgreSQLParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(1832);
        match(PostgreSQLParser::DEFAULT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nonreservedword_or_sconstContext ------------------------------------------------------------------

PostgreSQLParser::Nonreservedword_or_sconstContext::Nonreservedword_or_sconstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::NonreservedwordContext* PostgreSQLParser::Nonreservedword_or_sconstContext::nonreservedword() {
  return getRuleContext<PostgreSQLParser::NonreservedwordContext>(0);
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Nonreservedword_or_sconstContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}


size_t PostgreSQLParser::Nonreservedword_or_sconstContext::getRuleIndex() const {
  return PostgreSQLParser::RuleNonreservedword_or_sconst;
}


std::any PostgreSQLParser::Nonreservedword_or_sconstContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitNonreservedword_or_sconst(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Nonreservedword_or_sconstContext* PostgreSQLParser::nonreservedword_or_sconst() {
  Nonreservedword_or_sconstContext *_localctx = _tracker.createInstance<Nonreservedword_or_sconstContext>(_ctx, getState());
  enterRule(_localctx, 68, PostgreSQLParser::RuleNonreservedword_or_sconst);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1837);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 1);
        setState(1835);
        nonreservedword();
        break;
      }

      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::EscapeStringConstant: {
        enterOuterAlt(_localctx, 2);
        setState(1836);
        sconst();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableresetstmtContext ------------------------------------------------------------------

PostgreSQLParser::VariableresetstmtContext::VariableresetstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::VariableresetstmtContext::RESET() {
  return getToken(PostgreSQLParser::RESET, 0);
}

PostgreSQLParser::Reset_restContext* PostgreSQLParser::VariableresetstmtContext::reset_rest() {
  return getRuleContext<PostgreSQLParser::Reset_restContext>(0);
}


size_t PostgreSQLParser::VariableresetstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleVariableresetstmt;
}


std::any PostgreSQLParser::VariableresetstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitVariableresetstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::VariableresetstmtContext* PostgreSQLParser::variableresetstmt() {
  VariableresetstmtContext *_localctx = _tracker.createInstance<VariableresetstmtContext>(_ctx, getState());
  enterRule(_localctx, 70, PostgreSQLParser::RuleVariableresetstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1839);
    match(PostgreSQLParser::RESET);
    setState(1840);
    reset_rest();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reset_restContext ------------------------------------------------------------------

PostgreSQLParser::Reset_restContext::Reset_restContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Generic_resetContext* PostgreSQLParser::Reset_restContext::generic_reset() {
  return getRuleContext<PostgreSQLParser::Generic_resetContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Reset_restContext::TIME() {
  return getToken(PostgreSQLParser::TIME, 0);
}

tree::TerminalNode* PostgreSQLParser::Reset_restContext::ZONE() {
  return getToken(PostgreSQLParser::ZONE, 0);
}

tree::TerminalNode* PostgreSQLParser::Reset_restContext::TRANSACTION() {
  return getToken(PostgreSQLParser::TRANSACTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Reset_restContext::ISOLATION() {
  return getToken(PostgreSQLParser::ISOLATION, 0);
}

tree::TerminalNode* PostgreSQLParser::Reset_restContext::LEVEL() {
  return getToken(PostgreSQLParser::LEVEL, 0);
}

tree::TerminalNode* PostgreSQLParser::Reset_restContext::SESSION() {
  return getToken(PostgreSQLParser::SESSION, 0);
}

tree::TerminalNode* PostgreSQLParser::Reset_restContext::AUTHORIZATION() {
  return getToken(PostgreSQLParser::AUTHORIZATION, 0);
}


size_t PostgreSQLParser::Reset_restContext::getRuleIndex() const {
  return PostgreSQLParser::RuleReset_rest;
}


std::any PostgreSQLParser::Reset_restContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitReset_rest(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Reset_restContext* PostgreSQLParser::reset_rest() {
  Reset_restContext *_localctx = _tracker.createInstance<Reset_restContext>(_ctx, getState());
  enterRule(_localctx, 72, PostgreSQLParser::RuleReset_rest);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1850);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1842);
      generic_reset();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1843);
      match(PostgreSQLParser::TIME);
      setState(1844);
      match(PostgreSQLParser::ZONE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1845);
      match(PostgreSQLParser::TRANSACTION);
      setState(1846);
      match(PostgreSQLParser::ISOLATION);
      setState(1847);
      match(PostgreSQLParser::LEVEL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1848);
      match(PostgreSQLParser::SESSION);
      setState(1849);
      match(PostgreSQLParser::AUTHORIZATION);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generic_resetContext ------------------------------------------------------------------

PostgreSQLParser::Generic_resetContext::Generic_resetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Var_nameContext* PostgreSQLParser::Generic_resetContext::var_name() {
  return getRuleContext<PostgreSQLParser::Var_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Generic_resetContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}


size_t PostgreSQLParser::Generic_resetContext::getRuleIndex() const {
  return PostgreSQLParser::RuleGeneric_reset;
}


std::any PostgreSQLParser::Generic_resetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitGeneric_reset(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Generic_resetContext* PostgreSQLParser::generic_reset() {
  Generic_resetContext *_localctx = _tracker.createInstance<Generic_resetContext>(_ctx, getState());
  enterRule(_localctx, 74, PostgreSQLParser::RuleGeneric_reset);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1854);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 1);
        setState(1852);
        var_name();
        break;
      }

      case PostgreSQLParser::ALL: {
        enterOuterAlt(_localctx, 2);
        setState(1853);
        match(PostgreSQLParser::ALL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetresetclauseContext ------------------------------------------------------------------

PostgreSQLParser::SetresetclauseContext::SetresetclauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::SetresetclauseContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

PostgreSQLParser::Set_restContext* PostgreSQLParser::SetresetclauseContext::set_rest() {
  return getRuleContext<PostgreSQLParser::Set_restContext>(0);
}

PostgreSQLParser::VariableresetstmtContext* PostgreSQLParser::SetresetclauseContext::variableresetstmt() {
  return getRuleContext<PostgreSQLParser::VariableresetstmtContext>(0);
}


size_t PostgreSQLParser::SetresetclauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSetresetclause;
}


std::any PostgreSQLParser::SetresetclauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSetresetclause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::SetresetclauseContext* PostgreSQLParser::setresetclause() {
  SetresetclauseContext *_localctx = _tracker.createInstance<SetresetclauseContext>(_ctx, getState());
  enterRule(_localctx, 76, PostgreSQLParser::RuleSetresetclause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1859);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::SET: {
        enterOuterAlt(_localctx, 1);
        setState(1856);
        match(PostgreSQLParser::SET);
        setState(1857);
        set_rest();
        break;
      }

      case PostgreSQLParser::RESET: {
        enterOuterAlt(_localctx, 2);
        setState(1858);
        variableresetstmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionsetresetclauseContext ------------------------------------------------------------------

PostgreSQLParser::FunctionsetresetclauseContext::FunctionsetresetclauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::FunctionsetresetclauseContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

PostgreSQLParser::Set_rest_moreContext* PostgreSQLParser::FunctionsetresetclauseContext::set_rest_more() {
  return getRuleContext<PostgreSQLParser::Set_rest_moreContext>(0);
}

PostgreSQLParser::VariableresetstmtContext* PostgreSQLParser::FunctionsetresetclauseContext::variableresetstmt() {
  return getRuleContext<PostgreSQLParser::VariableresetstmtContext>(0);
}


size_t PostgreSQLParser::FunctionsetresetclauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunctionsetresetclause;
}


std::any PostgreSQLParser::FunctionsetresetclauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunctionsetresetclause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::FunctionsetresetclauseContext* PostgreSQLParser::functionsetresetclause() {
  FunctionsetresetclauseContext *_localctx = _tracker.createInstance<FunctionsetresetclauseContext>(_ctx, getState());
  enterRule(_localctx, 78, PostgreSQLParser::RuleFunctionsetresetclause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1864);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::SET: {
        enterOuterAlt(_localctx, 1);
        setState(1861);
        match(PostgreSQLParser::SET);
        setState(1862);
        set_rest_more();
        break;
      }

      case PostgreSQLParser::RESET: {
        enterOuterAlt(_localctx, 2);
        setState(1863);
        variableresetstmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableshowstmtContext ------------------------------------------------------------------

PostgreSQLParser::VariableshowstmtContext::VariableshowstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::VariableshowstmtContext::SHOW() {
  return getToken(PostgreSQLParser::SHOW, 0);
}

PostgreSQLParser::Var_nameContext* PostgreSQLParser::VariableshowstmtContext::var_name() {
  return getRuleContext<PostgreSQLParser::Var_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::VariableshowstmtContext::TIME() {
  return getToken(PostgreSQLParser::TIME, 0);
}

tree::TerminalNode* PostgreSQLParser::VariableshowstmtContext::ZONE() {
  return getToken(PostgreSQLParser::ZONE, 0);
}

tree::TerminalNode* PostgreSQLParser::VariableshowstmtContext::TRANSACTION() {
  return getToken(PostgreSQLParser::TRANSACTION, 0);
}

tree::TerminalNode* PostgreSQLParser::VariableshowstmtContext::ISOLATION() {
  return getToken(PostgreSQLParser::ISOLATION, 0);
}

tree::TerminalNode* PostgreSQLParser::VariableshowstmtContext::LEVEL() {
  return getToken(PostgreSQLParser::LEVEL, 0);
}

tree::TerminalNode* PostgreSQLParser::VariableshowstmtContext::SESSION() {
  return getToken(PostgreSQLParser::SESSION, 0);
}

tree::TerminalNode* PostgreSQLParser::VariableshowstmtContext::AUTHORIZATION() {
  return getToken(PostgreSQLParser::AUTHORIZATION, 0);
}

tree::TerminalNode* PostgreSQLParser::VariableshowstmtContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}


size_t PostgreSQLParser::VariableshowstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleVariableshowstmt;
}


std::any PostgreSQLParser::VariableshowstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitVariableshowstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::VariableshowstmtContext* PostgreSQLParser::variableshowstmt() {
  VariableshowstmtContext *_localctx = _tracker.createInstance<VariableshowstmtContext>(_ctx, getState());
  enterRule(_localctx, 80, PostgreSQLParser::RuleVariableshowstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1866);
    match(PostgreSQLParser::SHOW);
    setState(1876);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
    case 1: {
      setState(1867);
      var_name();
      break;
    }

    case 2: {
      setState(1868);
      match(PostgreSQLParser::TIME);
      setState(1869);
      match(PostgreSQLParser::ZONE);
      break;
    }

    case 3: {
      setState(1870);
      match(PostgreSQLParser::TRANSACTION);
      setState(1871);
      match(PostgreSQLParser::ISOLATION);
      setState(1872);
      match(PostgreSQLParser::LEVEL);
      break;
    }

    case 4: {
      setState(1873);
      match(PostgreSQLParser::SESSION);
      setState(1874);
      match(PostgreSQLParser::AUTHORIZATION);
      break;
    }

    case 5: {
      setState(1875);
      match(PostgreSQLParser::ALL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintssetstmtContext ------------------------------------------------------------------

PostgreSQLParser::ConstraintssetstmtContext::ConstraintssetstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::ConstraintssetstmtContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintssetstmtContext::CONSTRAINTS() {
  return getToken(PostgreSQLParser::CONSTRAINTS, 0);
}

PostgreSQLParser::Constraints_set_listContext* PostgreSQLParser::ConstraintssetstmtContext::constraints_set_list() {
  return getRuleContext<PostgreSQLParser::Constraints_set_listContext>(0);
}

PostgreSQLParser::Constraints_set_modeContext* PostgreSQLParser::ConstraintssetstmtContext::constraints_set_mode() {
  return getRuleContext<PostgreSQLParser::Constraints_set_modeContext>(0);
}


size_t PostgreSQLParser::ConstraintssetstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleConstraintssetstmt;
}


std::any PostgreSQLParser::ConstraintssetstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitConstraintssetstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ConstraintssetstmtContext* PostgreSQLParser::constraintssetstmt() {
  ConstraintssetstmtContext *_localctx = _tracker.createInstance<ConstraintssetstmtContext>(_ctx, getState());
  enterRule(_localctx, 82, PostgreSQLParser::RuleConstraintssetstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1878);
    match(PostgreSQLParser::SET);
    setState(1879);
    match(PostgreSQLParser::CONSTRAINTS);
    setState(1880);
    constraints_set_list();
    setState(1881);
    constraints_set_mode();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constraints_set_listContext ------------------------------------------------------------------

PostgreSQLParser::Constraints_set_listContext::Constraints_set_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Constraints_set_listContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}

PostgreSQLParser::Qualified_name_listContext* PostgreSQLParser::Constraints_set_listContext::qualified_name_list() {
  return getRuleContext<PostgreSQLParser::Qualified_name_listContext>(0);
}


size_t PostgreSQLParser::Constraints_set_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleConstraints_set_list;
}


std::any PostgreSQLParser::Constraints_set_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitConstraints_set_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Constraints_set_listContext* PostgreSQLParser::constraints_set_list() {
  Constraints_set_listContext *_localctx = _tracker.createInstance<Constraints_set_listContext>(_ctx, getState());
  enterRule(_localctx, 84, PostgreSQLParser::RuleConstraints_set_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1885);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::ALL: {
        enterOuterAlt(_localctx, 1);
        setState(1883);
        match(PostgreSQLParser::ALL);
        break;
      }

      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 2);
        setState(1884);
        qualified_name_list();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constraints_set_modeContext ------------------------------------------------------------------

PostgreSQLParser::Constraints_set_modeContext::Constraints_set_modeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Constraints_set_modeContext::DEFERRED() {
  return getToken(PostgreSQLParser::DEFERRED, 0);
}

tree::TerminalNode* PostgreSQLParser::Constraints_set_modeContext::IMMEDIATE() {
  return getToken(PostgreSQLParser::IMMEDIATE, 0);
}


size_t PostgreSQLParser::Constraints_set_modeContext::getRuleIndex() const {
  return PostgreSQLParser::RuleConstraints_set_mode;
}


std::any PostgreSQLParser::Constraints_set_modeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitConstraints_set_mode(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Constraints_set_modeContext* PostgreSQLParser::constraints_set_mode() {
  Constraints_set_modeContext *_localctx = _tracker.createInstance<Constraints_set_modeContext>(_ctx, getState());
  enterRule(_localctx, 86, PostgreSQLParser::RuleConstraints_set_mode);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1887);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::DEFERRED

    || _la == PostgreSQLParser::IMMEDIATE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CheckpointstmtContext ------------------------------------------------------------------

PostgreSQLParser::CheckpointstmtContext::CheckpointstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CheckpointstmtContext::CHECKPOINT() {
  return getToken(PostgreSQLParser::CHECKPOINT, 0);
}


size_t PostgreSQLParser::CheckpointstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCheckpointstmt;
}


std::any PostgreSQLParser::CheckpointstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCheckpointstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CheckpointstmtContext* PostgreSQLParser::checkpointstmt() {
  CheckpointstmtContext *_localctx = _tracker.createInstance<CheckpointstmtContext>(_ctx, getState());
  enterRule(_localctx, 88, PostgreSQLParser::RuleCheckpointstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1889);
    match(PostgreSQLParser::CHECKPOINT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DiscardstmtContext ------------------------------------------------------------------

PostgreSQLParser::DiscardstmtContext::DiscardstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DiscardstmtContext::DISCARD() {
  return getToken(PostgreSQLParser::DISCARD, 0);
}

tree::TerminalNode* PostgreSQLParser::DiscardstmtContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}

tree::TerminalNode* PostgreSQLParser::DiscardstmtContext::TEMP() {
  return getToken(PostgreSQLParser::TEMP, 0);
}

tree::TerminalNode* PostgreSQLParser::DiscardstmtContext::TEMPORARY() {
  return getToken(PostgreSQLParser::TEMPORARY, 0);
}

tree::TerminalNode* PostgreSQLParser::DiscardstmtContext::PLANS() {
  return getToken(PostgreSQLParser::PLANS, 0);
}

tree::TerminalNode* PostgreSQLParser::DiscardstmtContext::SEQUENCES() {
  return getToken(PostgreSQLParser::SEQUENCES, 0);
}


size_t PostgreSQLParser::DiscardstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDiscardstmt;
}


std::any PostgreSQLParser::DiscardstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDiscardstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DiscardstmtContext* PostgreSQLParser::discardstmt() {
  DiscardstmtContext *_localctx = _tracker.createInstance<DiscardstmtContext>(_ctx, getState());
  enterRule(_localctx, 90, PostgreSQLParser::RuleDiscardstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1891);
    match(PostgreSQLParser::DISCARD);
    setState(1892);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::ALL || _la == PostgreSQLParser::PLANS

    || _la == PostgreSQLParser::SEQUENCES || _la == PostgreSQLParser::TEMP

    || _la == PostgreSQLParser::TEMPORARY)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AltertablestmtContext ------------------------------------------------------------------

PostgreSQLParser::AltertablestmtContext::AltertablestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AltertablestmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertablestmtContext::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}

PostgreSQLParser::Relation_exprContext* PostgreSQLParser::AltertablestmtContext::relation_expr() {
  return getRuleContext<PostgreSQLParser::Relation_exprContext>(0);
}

PostgreSQLParser::Alter_table_cmdsContext* PostgreSQLParser::AltertablestmtContext::alter_table_cmds() {
  return getRuleContext<PostgreSQLParser::Alter_table_cmdsContext>(0);
}

PostgreSQLParser::Partition_cmdContext* PostgreSQLParser::AltertablestmtContext::partition_cmd() {
  return getRuleContext<PostgreSQLParser::Partition_cmdContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AltertablestmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertablestmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertablestmtContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertablestmtContext::IN_P() {
  return getToken(PostgreSQLParser::IN_P, 0);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::AltertablestmtContext::TABLESPACE() {
  return getTokens(PostgreSQLParser::TABLESPACE);
}

tree::TerminalNode* PostgreSQLParser::AltertablestmtContext::TABLESPACE(size_t i) {
  return getToken(PostgreSQLParser::TABLESPACE, i);
}

std::vector<PostgreSQLParser::NameContext *> PostgreSQLParser::AltertablestmtContext::name() {
  return getRuleContexts<PostgreSQLParser::NameContext>();
}

PostgreSQLParser::NameContext* PostgreSQLParser::AltertablestmtContext::name(size_t i) {
  return getRuleContext<PostgreSQLParser::NameContext>(i);
}

tree::TerminalNode* PostgreSQLParser::AltertablestmtContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertablestmtContext::OWNED() {
  return getToken(PostgreSQLParser::OWNED, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertablestmtContext::BY() {
  return getToken(PostgreSQLParser::BY, 0);
}

PostgreSQLParser::Role_listContext* PostgreSQLParser::AltertablestmtContext::role_list() {
  return getRuleContext<PostgreSQLParser::Role_listContext>(0);
}

PostgreSQLParser::Nowait_Context* PostgreSQLParser::AltertablestmtContext::nowait_() {
  return getRuleContext<PostgreSQLParser::Nowait_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::AltertablestmtContext::INDEX() {
  return getToken(PostgreSQLParser::INDEX, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::AltertablestmtContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

PostgreSQLParser::Index_partition_cmdContext* PostgreSQLParser::AltertablestmtContext::index_partition_cmd() {
  return getRuleContext<PostgreSQLParser::Index_partition_cmdContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AltertablestmtContext::SEQUENCE() {
  return getToken(PostgreSQLParser::SEQUENCE, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertablestmtContext::VIEW() {
  return getToken(PostgreSQLParser::VIEW, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertablestmtContext::MATERIALIZED() {
  return getToken(PostgreSQLParser::MATERIALIZED, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertablestmtContext::FOREIGN() {
  return getToken(PostgreSQLParser::FOREIGN, 0);
}


size_t PostgreSQLParser::AltertablestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAltertablestmt;
}


std::any PostgreSQLParser::AltertablestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAltertablestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AltertablestmtContext* PostgreSQLParser::altertablestmt() {
  AltertablestmtContext *_localctx = _tracker.createInstance<AltertablestmtContext>(_ctx, getState());
  enterRule(_localctx, 92, PostgreSQLParser::RuleAltertablestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2006);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1894);
      match(PostgreSQLParser::ALTER);
      setState(1895);
      match(PostgreSQLParser::TABLE);
      setState(1898);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx)) {
      case 1: {
        setState(1896);
        match(PostgreSQLParser::IF_P);
        setState(1897);
        match(PostgreSQLParser::EXISTS);
        break;
      }

      default:
        break;
      }
      setState(1900);
      relation_expr();
      setState(1903);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case PostgreSQLParser::NOT:
        case PostgreSQLParser::ADD_P:
        case PostgreSQLParser::ALTER:
        case PostgreSQLParser::CLUSTER:
        case PostgreSQLParser::DISABLE_P:
        case PostgreSQLParser::DROP:
        case PostgreSQLParser::ENABLE_P:
        case PostgreSQLParser::FORCE:
        case PostgreSQLParser::INHERIT:
        case PostgreSQLParser::NO:
        case PostgreSQLParser::OF:
        case PostgreSQLParser::OPTIONS:
        case PostgreSQLParser::OWNER:
        case PostgreSQLParser::REPLICA:
        case PostgreSQLParser::RESET:
        case PostgreSQLParser::SET:
        case PostgreSQLParser::VALIDATE: {
          setState(1901);
          alter_table_cmds();
          break;
        }

        case PostgreSQLParser::ATTACH:
        case PostgreSQLParser::DETACH: {
          setState(1902);
          partition_cmd();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1905);
      match(PostgreSQLParser::ALTER);
      setState(1906);
      match(PostgreSQLParser::TABLE);
      setState(1907);
      match(PostgreSQLParser::ALL);
      setState(1908);
      match(PostgreSQLParser::IN_P);
      setState(1909);
      match(PostgreSQLParser::TABLESPACE);
      setState(1910);
      name();
      setState(1914);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OWNED) {
        setState(1911);
        match(PostgreSQLParser::OWNED);
        setState(1912);
        match(PostgreSQLParser::BY);
        setState(1913);
        role_list();
      }
      setState(1916);
      match(PostgreSQLParser::SET);
      setState(1917);
      match(PostgreSQLParser::TABLESPACE);
      setState(1918);
      name();
      setState(1920);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::NOWAIT) {
        setState(1919);
        nowait_();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1922);
      match(PostgreSQLParser::ALTER);
      setState(1923);
      match(PostgreSQLParser::INDEX);
      setState(1926);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
      case 1: {
        setState(1924);
        match(PostgreSQLParser::IF_P);
        setState(1925);
        match(PostgreSQLParser::EXISTS);
        break;
      }

      default:
        break;
      }
      setState(1928);
      qualified_name();
      setState(1931);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case PostgreSQLParser::NOT:
        case PostgreSQLParser::ADD_P:
        case PostgreSQLParser::ALTER:
        case PostgreSQLParser::CLUSTER:
        case PostgreSQLParser::DISABLE_P:
        case PostgreSQLParser::DROP:
        case PostgreSQLParser::ENABLE_P:
        case PostgreSQLParser::FORCE:
        case PostgreSQLParser::INHERIT:
        case PostgreSQLParser::NO:
        case PostgreSQLParser::OF:
        case PostgreSQLParser::OPTIONS:
        case PostgreSQLParser::OWNER:
        case PostgreSQLParser::REPLICA:
        case PostgreSQLParser::RESET:
        case PostgreSQLParser::SET:
        case PostgreSQLParser::VALIDATE: {
          setState(1929);
          alter_table_cmds();
          break;
        }

        case PostgreSQLParser::ATTACH: {
          setState(1930);
          index_partition_cmd();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1933);
      match(PostgreSQLParser::ALTER);
      setState(1934);
      match(PostgreSQLParser::INDEX);
      setState(1935);
      match(PostgreSQLParser::ALL);
      setState(1936);
      match(PostgreSQLParser::IN_P);
      setState(1937);
      match(PostgreSQLParser::TABLESPACE);
      setState(1938);
      name();
      setState(1942);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OWNED) {
        setState(1939);
        match(PostgreSQLParser::OWNED);
        setState(1940);
        match(PostgreSQLParser::BY);
        setState(1941);
        role_list();
      }
      setState(1944);
      match(PostgreSQLParser::SET);
      setState(1945);
      match(PostgreSQLParser::TABLESPACE);
      setState(1946);
      name();
      setState(1948);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::NOWAIT) {
        setState(1947);
        nowait_();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1950);
      match(PostgreSQLParser::ALTER);
      setState(1951);
      match(PostgreSQLParser::SEQUENCE);
      setState(1954);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
      case 1: {
        setState(1952);
        match(PostgreSQLParser::IF_P);
        setState(1953);
        match(PostgreSQLParser::EXISTS);
        break;
      }

      default:
        break;
      }
      setState(1956);
      qualified_name();
      setState(1957);
      alter_table_cmds();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1959);
      match(PostgreSQLParser::ALTER);
      setState(1960);
      match(PostgreSQLParser::VIEW);
      setState(1963);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx)) {
      case 1: {
        setState(1961);
        match(PostgreSQLParser::IF_P);
        setState(1962);
        match(PostgreSQLParser::EXISTS);
        break;
      }

      default:
        break;
      }
      setState(1965);
      qualified_name();
      setState(1966);
      alter_table_cmds();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1968);
      match(PostgreSQLParser::ALTER);
      setState(1969);
      match(PostgreSQLParser::MATERIALIZED);
      setState(1970);
      match(PostgreSQLParser::VIEW);
      setState(1973);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
      case 1: {
        setState(1971);
        match(PostgreSQLParser::IF_P);
        setState(1972);
        match(PostgreSQLParser::EXISTS);
        break;
      }

      default:
        break;
      }
      setState(1975);
      qualified_name();
      setState(1976);
      alter_table_cmds();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1978);
      match(PostgreSQLParser::ALTER);
      setState(1979);
      match(PostgreSQLParser::MATERIALIZED);
      setState(1980);
      match(PostgreSQLParser::VIEW);
      setState(1981);
      match(PostgreSQLParser::ALL);
      setState(1982);
      match(PostgreSQLParser::IN_P);
      setState(1983);
      match(PostgreSQLParser::TABLESPACE);
      setState(1984);
      name();
      setState(1988);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OWNED) {
        setState(1985);
        match(PostgreSQLParser::OWNED);
        setState(1986);
        match(PostgreSQLParser::BY);
        setState(1987);
        role_list();
      }
      setState(1990);
      match(PostgreSQLParser::SET);
      setState(1991);
      match(PostgreSQLParser::TABLESPACE);
      setState(1992);
      name();
      setState(1994);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::NOWAIT) {
        setState(1993);
        nowait_();
      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1996);
      match(PostgreSQLParser::ALTER);
      setState(1997);
      match(PostgreSQLParser::FOREIGN);
      setState(1998);
      match(PostgreSQLParser::TABLE);
      setState(2001);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx)) {
      case 1: {
        setState(1999);
        match(PostgreSQLParser::IF_P);
        setState(2000);
        match(PostgreSQLParser::EXISTS);
        break;
      }

      default:
        break;
      }
      setState(2003);
      relation_expr();
      setState(2004);
      alter_table_cmds();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_table_cmdsContext ------------------------------------------------------------------

PostgreSQLParser::Alter_table_cmdsContext::Alter_table_cmdsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Alter_table_cmdContext *> PostgreSQLParser::Alter_table_cmdsContext::alter_table_cmd() {
  return getRuleContexts<PostgreSQLParser::Alter_table_cmdContext>();
}

PostgreSQLParser::Alter_table_cmdContext* PostgreSQLParser::Alter_table_cmdsContext::alter_table_cmd(size_t i) {
  return getRuleContext<PostgreSQLParser::Alter_table_cmdContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Alter_table_cmdsContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdsContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Alter_table_cmdsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlter_table_cmds;
}


std::any PostgreSQLParser::Alter_table_cmdsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlter_table_cmds(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Alter_table_cmdsContext* PostgreSQLParser::alter_table_cmds() {
  Alter_table_cmdsContext *_localctx = _tracker.createInstance<Alter_table_cmdsContext>(_ctx, getState());
  enterRule(_localctx, 94, PostgreSQLParser::RuleAlter_table_cmds);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2008);
    alter_table_cmd();
    setState(2013);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(2009);
      match(PostgreSQLParser::COMMA);
      setState(2010);
      alter_table_cmd();
      setState(2015);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Partition_cmdContext ------------------------------------------------------------------

PostgreSQLParser::Partition_cmdContext::Partition_cmdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Partition_cmdContext::ATTACH() {
  return getToken(PostgreSQLParser::ATTACH, 0);
}

tree::TerminalNode* PostgreSQLParser::Partition_cmdContext::PARTITION() {
  return getToken(PostgreSQLParser::PARTITION, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::Partition_cmdContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

PostgreSQLParser::PartitionboundspecContext* PostgreSQLParser::Partition_cmdContext::partitionboundspec() {
  return getRuleContext<PostgreSQLParser::PartitionboundspecContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Partition_cmdContext::DETACH() {
  return getToken(PostgreSQLParser::DETACH, 0);
}


size_t PostgreSQLParser::Partition_cmdContext::getRuleIndex() const {
  return PostgreSQLParser::RulePartition_cmd;
}


std::any PostgreSQLParser::Partition_cmdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitPartition_cmd(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Partition_cmdContext* PostgreSQLParser::partition_cmd() {
  Partition_cmdContext *_localctx = _tracker.createInstance<Partition_cmdContext>(_ctx, getState());
  enterRule(_localctx, 96, PostgreSQLParser::RulePartition_cmd);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2024);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::ATTACH: {
        enterOuterAlt(_localctx, 1);
        setState(2016);
        match(PostgreSQLParser::ATTACH);
        setState(2017);
        match(PostgreSQLParser::PARTITION);
        setState(2018);
        qualified_name();
        setState(2019);
        partitionboundspec();
        break;
      }

      case PostgreSQLParser::DETACH: {
        enterOuterAlt(_localctx, 2);
        setState(2021);
        match(PostgreSQLParser::DETACH);
        setState(2022);
        match(PostgreSQLParser::PARTITION);
        setState(2023);
        qualified_name();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_partition_cmdContext ------------------------------------------------------------------

PostgreSQLParser::Index_partition_cmdContext::Index_partition_cmdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Index_partition_cmdContext::ATTACH() {
  return getToken(PostgreSQLParser::ATTACH, 0);
}

tree::TerminalNode* PostgreSQLParser::Index_partition_cmdContext::PARTITION() {
  return getToken(PostgreSQLParser::PARTITION, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::Index_partition_cmdContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}


size_t PostgreSQLParser::Index_partition_cmdContext::getRuleIndex() const {
  return PostgreSQLParser::RuleIndex_partition_cmd;
}


std::any PostgreSQLParser::Index_partition_cmdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitIndex_partition_cmd(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Index_partition_cmdContext* PostgreSQLParser::index_partition_cmd() {
  Index_partition_cmdContext *_localctx = _tracker.createInstance<Index_partition_cmdContext>(_ctx, getState());
  enterRule(_localctx, 98, PostgreSQLParser::RuleIndex_partition_cmd);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2026);
    match(PostgreSQLParser::ATTACH);
    setState(2027);
    match(PostgreSQLParser::PARTITION);
    setState(2028);
    qualified_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_table_cmdContext ------------------------------------------------------------------

PostgreSQLParser::Alter_table_cmdContext::Alter_table_cmdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::ADD_P() {
  return getToken(PostgreSQLParser::ADD_P, 0);
}

PostgreSQLParser::ColumnDefContext* PostgreSQLParser::Alter_table_cmdContext::columnDef() {
  return getRuleContext<PostgreSQLParser::ColumnDefContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::COLUMN() {
  return getToken(PostgreSQLParser::COLUMN, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

std::vector<PostgreSQLParser::ColidContext *> PostgreSQLParser::Alter_table_cmdContext::colid() {
  return getRuleContexts<PostgreSQLParser::ColidContext>();
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Alter_table_cmdContext::colid(size_t i) {
  return getRuleContext<PostgreSQLParser::ColidContext>(i);
}

PostgreSQLParser::Alter_column_defaultContext* PostgreSQLParser::Alter_table_cmdContext::alter_column_default() {
  return getRuleContext<PostgreSQLParser::Alter_column_defaultContext>(0);
}

PostgreSQLParser::Column_Context* PostgreSQLParser::Alter_table_cmdContext::column_() {
  return getRuleContext<PostgreSQLParser::Column_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::NULL_P() {
  return getToken(PostgreSQLParser::NULL_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::EXPRESSION() {
  return getToken(PostgreSQLParser::EXPRESSION, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::STATISTICS() {
  return getToken(PostgreSQLParser::STATISTICS, 0);
}

PostgreSQLParser::SignediconstContext* PostgreSQLParser::Alter_table_cmdContext::signediconst() {
  return getRuleContext<PostgreSQLParser::SignediconstContext>(0);
}

PostgreSQLParser::IconstContext* PostgreSQLParser::Alter_table_cmdContext::iconst() {
  return getRuleContext<PostgreSQLParser::IconstContext>(0);
}

PostgreSQLParser::ReloptionsContext* PostgreSQLParser::Alter_table_cmdContext::reloptions() {
  return getRuleContext<PostgreSQLParser::ReloptionsContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::RESET() {
  return getToken(PostgreSQLParser::RESET, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::STORAGE() {
  return getToken(PostgreSQLParser::STORAGE, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::GENERATED() {
  return getToken(PostgreSQLParser::GENERATED, 0);
}

PostgreSQLParser::Generated_whenContext* PostgreSQLParser::Alter_table_cmdContext::generated_when() {
  return getRuleContext<PostgreSQLParser::Generated_whenContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::IDENTITY_P() {
  return getToken(PostgreSQLParser::IDENTITY_P, 0);
}

PostgreSQLParser::OptparenthesizedseqoptlistContext* PostgreSQLParser::Alter_table_cmdContext::optparenthesizedseqoptlist() {
  return getRuleContext<PostgreSQLParser::OptparenthesizedseqoptlistContext>(0);
}

PostgreSQLParser::Alter_identity_column_option_listContext* PostgreSQLParser::Alter_table_cmdContext::alter_identity_column_option_list() {
  return getRuleContext<PostgreSQLParser::Alter_identity_column_option_listContext>(0);
}

PostgreSQLParser::Drop_behavior_Context* PostgreSQLParser::Alter_table_cmdContext::drop_behavior_() {
  return getRuleContext<PostgreSQLParser::Drop_behavior_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::Alter_table_cmdContext::typename_() {
  return getRuleContext<PostgreSQLParser::TypenameContext>(0);
}

PostgreSQLParser::Set_data_Context* PostgreSQLParser::Alter_table_cmdContext::set_data_() {
  return getRuleContext<PostgreSQLParser::Set_data_Context>(0);
}

PostgreSQLParser::Collate_clause_Context* PostgreSQLParser::Alter_table_cmdContext::collate_clause_() {
  return getRuleContext<PostgreSQLParser::Collate_clause_Context>(0);
}

PostgreSQLParser::Alter_usingContext* PostgreSQLParser::Alter_table_cmdContext::alter_using() {
  return getRuleContext<PostgreSQLParser::Alter_usingContext>(0);
}

PostgreSQLParser::Alter_generic_optionsContext* PostgreSQLParser::Alter_table_cmdContext::alter_generic_options() {
  return getRuleContext<PostgreSQLParser::Alter_generic_optionsContext>(0);
}

PostgreSQLParser::TableconstraintContext* PostgreSQLParser::Alter_table_cmdContext::tableconstraint() {
  return getRuleContext<PostgreSQLParser::TableconstraintContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::CONSTRAINT() {
  return getToken(PostgreSQLParser::CONSTRAINT, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::Alter_table_cmdContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::ConstraintattributespecContext* PostgreSQLParser::Alter_table_cmdContext::constraintattributespec() {
  return getRuleContext<PostgreSQLParser::ConstraintattributespecContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::VALIDATE() {
  return getToken(PostgreSQLParser::VALIDATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::WITHOUT() {
  return getToken(PostgreSQLParser::WITHOUT, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::OIDS() {
  return getToken(PostgreSQLParser::OIDS, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::CLUSTER() {
  return getToken(PostgreSQLParser::CLUSTER, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::LOGGED() {
  return getToken(PostgreSQLParser::LOGGED, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::UNLOGGED() {
  return getToken(PostgreSQLParser::UNLOGGED, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::ENABLE_P() {
  return getToken(PostgreSQLParser::ENABLE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::TRIGGER() {
  return getToken(PostgreSQLParser::TRIGGER, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::ALWAYS() {
  return getToken(PostgreSQLParser::ALWAYS, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::REPLICA() {
  return getToken(PostgreSQLParser::REPLICA, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::USER() {
  return getToken(PostgreSQLParser::USER, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::DISABLE_P() {
  return getToken(PostgreSQLParser::DISABLE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::RULE() {
  return getToken(PostgreSQLParser::RULE, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::INHERIT() {
  return getToken(PostgreSQLParser::INHERIT, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::Alter_table_cmdContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::NO() {
  return getToken(PostgreSQLParser::NO, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::OF() {
  return getToken(PostgreSQLParser::OF, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::Alter_table_cmdContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::OWNER() {
  return getToken(PostgreSQLParser::OWNER, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}

PostgreSQLParser::RolespecContext* PostgreSQLParser::Alter_table_cmdContext::rolespec() {
  return getRuleContext<PostgreSQLParser::RolespecContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::TABLESPACE() {
  return getToken(PostgreSQLParser::TABLESPACE, 0);
}

PostgreSQLParser::Replica_identityContext* PostgreSQLParser::Alter_table_cmdContext::replica_identity() {
  return getRuleContext<PostgreSQLParser::Replica_identityContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::ROW() {
  return getToken(PostgreSQLParser::ROW, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::LEVEL() {
  return getToken(PostgreSQLParser::LEVEL, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::SECURITY() {
  return getToken(PostgreSQLParser::SECURITY, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_table_cmdContext::FORCE() {
  return getToken(PostgreSQLParser::FORCE, 0);
}


size_t PostgreSQLParser::Alter_table_cmdContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlter_table_cmd;
}


std::any PostgreSQLParser::Alter_table_cmdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlter_table_cmd(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Alter_table_cmdContext* PostgreSQLParser::alter_table_cmd() {
  Alter_table_cmdContext *_localctx = _tracker.createInstance<Alter_table_cmdContext>(_ctx, getState());
  enterRule(_localctx, 100, PostgreSQLParser::RuleAlter_table_cmd);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2328);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2030);
      match(PostgreSQLParser::ADD_P);
      setState(2031);
      columnDef();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2032);
      match(PostgreSQLParser::ADD_P);
      setState(2033);
      match(PostgreSQLParser::IF_P);
      setState(2034);
      match(PostgreSQLParser::NOT);
      setState(2035);
      match(PostgreSQLParser::EXISTS);
      setState(2036);
      columnDef();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2037);
      match(PostgreSQLParser::ADD_P);
      setState(2038);
      match(PostgreSQLParser::COLUMN);
      setState(2039);
      columnDef();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2040);
      match(PostgreSQLParser::ADD_P);
      setState(2041);
      match(PostgreSQLParser::COLUMN);
      setState(2042);
      match(PostgreSQLParser::IF_P);
      setState(2043);
      match(PostgreSQLParser::NOT);
      setState(2044);
      match(PostgreSQLParser::EXISTS);
      setState(2045);
      columnDef();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2046);
      match(PostgreSQLParser::ALTER);
      setState(2048);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(2047);
        column_();
      }
      setState(2050);
      colid();
      setState(2051);
      alter_column_default();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2053);
      match(PostgreSQLParser::ALTER);
      setState(2055);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(2054);
        column_();
      }
      setState(2057);
      colid();
      setState(2058);
      match(PostgreSQLParser::DROP);
      setState(2059);
      match(PostgreSQLParser::NOT);
      setState(2060);
      match(PostgreSQLParser::NULL_P);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2062);
      match(PostgreSQLParser::ALTER);
      setState(2064);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(2063);
        column_();
      }
      setState(2066);
      colid();
      setState(2067);
      match(PostgreSQLParser::SET);
      setState(2068);
      match(PostgreSQLParser::NOT);
      setState(2069);
      match(PostgreSQLParser::NULL_P);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2071);
      match(PostgreSQLParser::ALTER);
      setState(2073);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(2072);
        column_();
      }
      setState(2075);
      colid();
      setState(2076);
      match(PostgreSQLParser::DROP);
      setState(2077);
      match(PostgreSQLParser::EXPRESSION);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2079);
      match(PostgreSQLParser::ALTER);
      setState(2081);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(2080);
        column_();
      }
      setState(2083);
      colid();
      setState(2084);
      match(PostgreSQLParser::DROP);
      setState(2085);
      match(PostgreSQLParser::EXPRESSION);
      setState(2086);
      match(PostgreSQLParser::IF_P);
      setState(2087);
      match(PostgreSQLParser::EXISTS);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2089);
      match(PostgreSQLParser::ALTER);
      setState(2091);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(2090);
        column_();
      }
      setState(2093);
      colid();
      setState(2094);
      match(PostgreSQLParser::SET);
      setState(2095);
      match(PostgreSQLParser::STATISTICS);
      setState(2096);
      signediconst();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(2098);
      match(PostgreSQLParser::ALTER);
      setState(2100);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(2099);
        column_();
      }
      setState(2102);
      iconst();
      setState(2103);
      match(PostgreSQLParser::SET);
      setState(2104);
      match(PostgreSQLParser::STATISTICS);
      setState(2105);
      signediconst();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(2107);
      match(PostgreSQLParser::ALTER);
      setState(2109);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(2108);
        column_();
      }
      setState(2111);
      colid();
      setState(2112);
      match(PostgreSQLParser::SET);
      setState(2113);
      reloptions();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(2115);
      match(PostgreSQLParser::ALTER);
      setState(2117);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(2116);
        column_();
      }
      setState(2119);
      colid();
      setState(2120);
      match(PostgreSQLParser::RESET);
      setState(2121);
      reloptions();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(2123);
      match(PostgreSQLParser::ALTER);
      setState(2125);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(2124);
        column_();
      }
      setState(2127);
      colid();
      setState(2128);
      match(PostgreSQLParser::SET);
      setState(2129);
      match(PostgreSQLParser::STORAGE);
      setState(2130);
      colid();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(2132);
      match(PostgreSQLParser::ALTER);
      setState(2134);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(2133);
        column_();
      }
      setState(2136);
      colid();
      setState(2137);
      match(PostgreSQLParser::ADD_P);
      setState(2138);
      match(PostgreSQLParser::GENERATED);
      setState(2139);
      generated_when();
      setState(2140);
      match(PostgreSQLParser::AS);
      setState(2141);
      match(PostgreSQLParser::IDENTITY_P);
      setState(2143);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPEN_PAREN) {
        setState(2142);
        optparenthesizedseqoptlist();
      }
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(2145);
      match(PostgreSQLParser::ALTER);
      setState(2147);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(2146);
        column_();
      }
      setState(2149);
      colid();
      setState(2150);
      alter_identity_column_option_list();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(2152);
      match(PostgreSQLParser::ALTER);
      setState(2154);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(2153);
        column_();
      }
      setState(2156);
      colid();
      setState(2157);
      match(PostgreSQLParser::DROP);
      setState(2158);
      match(PostgreSQLParser::IDENTITY_P);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(2160);
      match(PostgreSQLParser::ALTER);
      setState(2162);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(2161);
        column_();
      }
      setState(2164);
      colid();
      setState(2165);
      match(PostgreSQLParser::DROP);
      setState(2166);
      match(PostgreSQLParser::IDENTITY_P);
      setState(2167);
      match(PostgreSQLParser::IF_P);
      setState(2168);
      match(PostgreSQLParser::EXISTS);
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(2170);
      match(PostgreSQLParser::DROP);
      setState(2172);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(2171);
        column_();
      }
      setState(2174);
      match(PostgreSQLParser::IF_P);
      setState(2175);
      match(PostgreSQLParser::EXISTS);
      setState(2176);
      colid();
      setState(2178);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(2177);
        drop_behavior_();
      }
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(2180);
      match(PostgreSQLParser::DROP);
      setState(2182);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(2181);
        column_();
      }
      setState(2184);
      colid();
      setState(2186);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(2185);
        drop_behavior_();
      }
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(2188);
      match(PostgreSQLParser::ALTER);
      setState(2190);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(2189);
        column_();
      }
      setState(2192);
      colid();
      setState(2194);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::SET) {
        setState(2193);
        set_data_();
      }
      setState(2196);
      match(PostgreSQLParser::TYPE_P);
      setState(2197);
      typename_();
      setState(2199);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLLATE) {
        setState(2198);
        collate_clause_();
      }
      setState(2202);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::USING) {
        setState(2201);
        alter_using();
      }
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(2204);
      match(PostgreSQLParser::ALTER);
      setState(2206);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(2205);
        column_();
      }
      setState(2208);
      colid();
      setState(2209);
      alter_generic_options();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(2211);
      match(PostgreSQLParser::ADD_P);
      setState(2212);
      tableconstraint();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(2213);
      match(PostgreSQLParser::ALTER);
      setState(2214);
      match(PostgreSQLParser::CONSTRAINT);
      setState(2215);
      name();
      setState(2216);
      constraintattributespec();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(2218);
      match(PostgreSQLParser::VALIDATE);
      setState(2219);
      match(PostgreSQLParser::CONSTRAINT);
      setState(2220);
      name();
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(2221);
      match(PostgreSQLParser::DROP);
      setState(2222);
      match(PostgreSQLParser::CONSTRAINT);
      setState(2223);
      match(PostgreSQLParser::IF_P);
      setState(2224);
      match(PostgreSQLParser::EXISTS);
      setState(2225);
      name();
      setState(2227);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(2226);
        drop_behavior_();
      }
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(2229);
      match(PostgreSQLParser::DROP);
      setState(2230);
      match(PostgreSQLParser::CONSTRAINT);
      setState(2231);
      name();
      setState(2233);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(2232);
        drop_behavior_();
      }
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(2235);
      match(PostgreSQLParser::SET);
      setState(2236);
      match(PostgreSQLParser::WITHOUT);
      setState(2237);
      match(PostgreSQLParser::OIDS);
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(2238);
      match(PostgreSQLParser::CLUSTER);
      setState(2239);
      match(PostgreSQLParser::ON);
      setState(2240);
      name();
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(2241);
      match(PostgreSQLParser::SET);
      setState(2242);
      match(PostgreSQLParser::WITHOUT);
      setState(2243);
      match(PostgreSQLParser::CLUSTER);
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(2244);
      match(PostgreSQLParser::SET);
      setState(2245);
      match(PostgreSQLParser::LOGGED);
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(2246);
      match(PostgreSQLParser::SET);
      setState(2247);
      match(PostgreSQLParser::UNLOGGED);
      break;
    }

    case 33: {
      enterOuterAlt(_localctx, 33);
      setState(2248);
      match(PostgreSQLParser::ENABLE_P);
      setState(2249);
      match(PostgreSQLParser::TRIGGER);
      setState(2250);
      name();
      break;
    }

    case 34: {
      enterOuterAlt(_localctx, 34);
      setState(2251);
      match(PostgreSQLParser::ENABLE_P);
      setState(2252);
      match(PostgreSQLParser::ALWAYS);
      setState(2253);
      match(PostgreSQLParser::TRIGGER);
      setState(2254);
      name();
      break;
    }

    case 35: {
      enterOuterAlt(_localctx, 35);
      setState(2255);
      match(PostgreSQLParser::ENABLE_P);
      setState(2256);
      match(PostgreSQLParser::REPLICA);
      setState(2257);
      match(PostgreSQLParser::TRIGGER);
      setState(2258);
      name();
      break;
    }

    case 36: {
      enterOuterAlt(_localctx, 36);
      setState(2259);
      match(PostgreSQLParser::ENABLE_P);
      setState(2260);
      match(PostgreSQLParser::TRIGGER);
      setState(2261);
      match(PostgreSQLParser::ALL);
      break;
    }

    case 37: {
      enterOuterAlt(_localctx, 37);
      setState(2262);
      match(PostgreSQLParser::ENABLE_P);
      setState(2263);
      match(PostgreSQLParser::TRIGGER);
      setState(2264);
      match(PostgreSQLParser::USER);
      break;
    }

    case 38: {
      enterOuterAlt(_localctx, 38);
      setState(2265);
      match(PostgreSQLParser::DISABLE_P);
      setState(2266);
      match(PostgreSQLParser::TRIGGER);
      setState(2267);
      name();
      break;
    }

    case 39: {
      enterOuterAlt(_localctx, 39);
      setState(2268);
      match(PostgreSQLParser::DISABLE_P);
      setState(2269);
      match(PostgreSQLParser::TRIGGER);
      setState(2270);
      match(PostgreSQLParser::ALL);
      break;
    }

    case 40: {
      enterOuterAlt(_localctx, 40);
      setState(2271);
      match(PostgreSQLParser::DISABLE_P);
      setState(2272);
      match(PostgreSQLParser::TRIGGER);
      setState(2273);
      match(PostgreSQLParser::USER);
      break;
    }

    case 41: {
      enterOuterAlt(_localctx, 41);
      setState(2274);
      match(PostgreSQLParser::ENABLE_P);
      setState(2275);
      match(PostgreSQLParser::RULE);
      setState(2276);
      name();
      break;
    }

    case 42: {
      enterOuterAlt(_localctx, 42);
      setState(2277);
      match(PostgreSQLParser::ENABLE_P);
      setState(2278);
      match(PostgreSQLParser::ALWAYS);
      setState(2279);
      match(PostgreSQLParser::RULE);
      setState(2280);
      name();
      break;
    }

    case 43: {
      enterOuterAlt(_localctx, 43);
      setState(2281);
      match(PostgreSQLParser::ENABLE_P);
      setState(2282);
      match(PostgreSQLParser::REPLICA);
      setState(2283);
      match(PostgreSQLParser::RULE);
      setState(2284);
      name();
      break;
    }

    case 44: {
      enterOuterAlt(_localctx, 44);
      setState(2285);
      match(PostgreSQLParser::DISABLE_P);
      setState(2286);
      match(PostgreSQLParser::RULE);
      setState(2287);
      name();
      break;
    }

    case 45: {
      enterOuterAlt(_localctx, 45);
      setState(2288);
      match(PostgreSQLParser::INHERIT);
      setState(2289);
      qualified_name();
      break;
    }

    case 46: {
      enterOuterAlt(_localctx, 46);
      setState(2290);
      match(PostgreSQLParser::NO);
      setState(2291);
      match(PostgreSQLParser::INHERIT);
      setState(2292);
      qualified_name();
      break;
    }

    case 47: {
      enterOuterAlt(_localctx, 47);
      setState(2293);
      match(PostgreSQLParser::OF);
      setState(2294);
      any_name();
      break;
    }

    case 48: {
      enterOuterAlt(_localctx, 48);
      setState(2295);
      match(PostgreSQLParser::NOT);
      setState(2296);
      match(PostgreSQLParser::OF);
      break;
    }

    case 49: {
      enterOuterAlt(_localctx, 49);
      setState(2297);
      match(PostgreSQLParser::OWNER);
      setState(2298);
      match(PostgreSQLParser::TO);
      setState(2299);
      rolespec();
      break;
    }

    case 50: {
      enterOuterAlt(_localctx, 50);
      setState(2300);
      match(PostgreSQLParser::SET);
      setState(2301);
      match(PostgreSQLParser::TABLESPACE);
      setState(2302);
      name();
      break;
    }

    case 51: {
      enterOuterAlt(_localctx, 51);
      setState(2303);
      match(PostgreSQLParser::SET);
      setState(2304);
      reloptions();
      break;
    }

    case 52: {
      enterOuterAlt(_localctx, 52);
      setState(2305);
      match(PostgreSQLParser::RESET);
      setState(2306);
      reloptions();
      break;
    }

    case 53: {
      enterOuterAlt(_localctx, 53);
      setState(2307);
      match(PostgreSQLParser::REPLICA);
      setState(2308);
      match(PostgreSQLParser::IDENTITY_P);
      setState(2309);
      replica_identity();
      break;
    }

    case 54: {
      enterOuterAlt(_localctx, 54);
      setState(2310);
      match(PostgreSQLParser::ENABLE_P);
      setState(2311);
      match(PostgreSQLParser::ROW);
      setState(2312);
      match(PostgreSQLParser::LEVEL);
      setState(2313);
      match(PostgreSQLParser::SECURITY);
      break;
    }

    case 55: {
      enterOuterAlt(_localctx, 55);
      setState(2314);
      match(PostgreSQLParser::DISABLE_P);
      setState(2315);
      match(PostgreSQLParser::ROW);
      setState(2316);
      match(PostgreSQLParser::LEVEL);
      setState(2317);
      match(PostgreSQLParser::SECURITY);
      break;
    }

    case 56: {
      enterOuterAlt(_localctx, 56);
      setState(2318);
      match(PostgreSQLParser::FORCE);
      setState(2319);
      match(PostgreSQLParser::ROW);
      setState(2320);
      match(PostgreSQLParser::LEVEL);
      setState(2321);
      match(PostgreSQLParser::SECURITY);
      break;
    }

    case 57: {
      enterOuterAlt(_localctx, 57);
      setState(2322);
      match(PostgreSQLParser::NO);
      setState(2323);
      match(PostgreSQLParser::FORCE);
      setState(2324);
      match(PostgreSQLParser::ROW);
      setState(2325);
      match(PostgreSQLParser::LEVEL);
      setState(2326);
      match(PostgreSQLParser::SECURITY);
      break;
    }

    case 58: {
      enterOuterAlt(_localctx, 58);
      setState(2327);
      alter_generic_options();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_column_defaultContext ------------------------------------------------------------------

PostgreSQLParser::Alter_column_defaultContext::Alter_column_defaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Alter_column_defaultContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_column_defaultContext::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Alter_column_defaultContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Alter_column_defaultContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}


size_t PostgreSQLParser::Alter_column_defaultContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlter_column_default;
}


std::any PostgreSQLParser::Alter_column_defaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlter_column_default(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Alter_column_defaultContext* PostgreSQLParser::alter_column_default() {
  Alter_column_defaultContext *_localctx = _tracker.createInstance<Alter_column_defaultContext>(_ctx, getState());
  enterRule(_localctx, 102, PostgreSQLParser::RuleAlter_column_default);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2335);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::SET: {
        enterOuterAlt(_localctx, 1);
        setState(2330);
        match(PostgreSQLParser::SET);
        setState(2331);
        match(PostgreSQLParser::DEFAULT);
        setState(2332);
        a_expr();
        break;
      }

      case PostgreSQLParser::DROP: {
        enterOuterAlt(_localctx, 2);
        setState(2333);
        match(PostgreSQLParser::DROP);
        setState(2334);
        match(PostgreSQLParser::DEFAULT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_behavior_Context ------------------------------------------------------------------

PostgreSQLParser::Drop_behavior_Context::Drop_behavior_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Drop_behavior_Context::CASCADE() {
  return getToken(PostgreSQLParser::CASCADE, 0);
}

tree::TerminalNode* PostgreSQLParser::Drop_behavior_Context::RESTRICT() {
  return getToken(PostgreSQLParser::RESTRICT, 0);
}


size_t PostgreSQLParser::Drop_behavior_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleDrop_behavior_;
}


std::any PostgreSQLParser::Drop_behavior_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDrop_behavior_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Drop_behavior_Context* PostgreSQLParser::drop_behavior_() {
  Drop_behavior_Context *_localctx = _tracker.createInstance<Drop_behavior_Context>(_ctx, getState());
  enterRule(_localctx, 104, PostgreSQLParser::RuleDrop_behavior_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2337);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Collate_clause_Context ------------------------------------------------------------------

PostgreSQLParser::Collate_clause_Context::Collate_clause_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Collate_clause_Context::COLLATE() {
  return getToken(PostgreSQLParser::COLLATE, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::Collate_clause_Context::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}


size_t PostgreSQLParser::Collate_clause_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleCollate_clause_;
}


std::any PostgreSQLParser::Collate_clause_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCollate_clause_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Collate_clause_Context* PostgreSQLParser::collate_clause_() {
  Collate_clause_Context *_localctx = _tracker.createInstance<Collate_clause_Context>(_ctx, getState());
  enterRule(_localctx, 106, PostgreSQLParser::RuleCollate_clause_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2339);
    match(PostgreSQLParser::COLLATE);
    setState(2340);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_usingContext ------------------------------------------------------------------

PostgreSQLParser::Alter_usingContext::Alter_usingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Alter_usingContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Alter_usingContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}


size_t PostgreSQLParser::Alter_usingContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlter_using;
}


std::any PostgreSQLParser::Alter_usingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlter_using(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Alter_usingContext* PostgreSQLParser::alter_using() {
  Alter_usingContext *_localctx = _tracker.createInstance<Alter_usingContext>(_ctx, getState());
  enterRule(_localctx, 108, PostgreSQLParser::RuleAlter_using);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2342);
    match(PostgreSQLParser::USING);
    setState(2343);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Replica_identityContext ------------------------------------------------------------------

PostgreSQLParser::Replica_identityContext::Replica_identityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Replica_identityContext::NOTHING() {
  return getToken(PostgreSQLParser::NOTHING, 0);
}

tree::TerminalNode* PostgreSQLParser::Replica_identityContext::FULL() {
  return getToken(PostgreSQLParser::FULL, 0);
}

tree::TerminalNode* PostgreSQLParser::Replica_identityContext::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}

tree::TerminalNode* PostgreSQLParser::Replica_identityContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

tree::TerminalNode* PostgreSQLParser::Replica_identityContext::INDEX() {
  return getToken(PostgreSQLParser::INDEX, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::Replica_identityContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}


size_t PostgreSQLParser::Replica_identityContext::getRuleIndex() const {
  return PostgreSQLParser::RuleReplica_identity;
}


std::any PostgreSQLParser::Replica_identityContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitReplica_identity(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Replica_identityContext* PostgreSQLParser::replica_identity() {
  Replica_identityContext *_localctx = _tracker.createInstance<Replica_identityContext>(_ctx, getState());
  enterRule(_localctx, 110, PostgreSQLParser::RuleReplica_identity);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2351);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::NOTHING: {
        enterOuterAlt(_localctx, 1);
        setState(2345);
        match(PostgreSQLParser::NOTHING);
        break;
      }

      case PostgreSQLParser::FULL: {
        enterOuterAlt(_localctx, 2);
        setState(2346);
        match(PostgreSQLParser::FULL);
        break;
      }

      case PostgreSQLParser::DEFAULT: {
        enterOuterAlt(_localctx, 3);
        setState(2347);
        match(PostgreSQLParser::DEFAULT);
        break;
      }

      case PostgreSQLParser::USING: {
        enterOuterAlt(_localctx, 4);
        setState(2348);
        match(PostgreSQLParser::USING);
        setState(2349);
        match(PostgreSQLParser::INDEX);
        setState(2350);
        name();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReloptionsContext ------------------------------------------------------------------

PostgreSQLParser::ReloptionsContext::ReloptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::ReloptionsContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Reloption_listContext* PostgreSQLParser::ReloptionsContext::reloption_list() {
  return getRuleContext<PostgreSQLParser::Reloption_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ReloptionsContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::ReloptionsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleReloptions;
}


std::any PostgreSQLParser::ReloptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitReloptions(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ReloptionsContext* PostgreSQLParser::reloptions() {
  ReloptionsContext *_localctx = _tracker.createInstance<ReloptionsContext>(_ctx, getState());
  enterRule(_localctx, 112, PostgreSQLParser::RuleReloptions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2353);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(2354);
    reloption_list();
    setState(2355);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reloptions_Context ------------------------------------------------------------------

PostgreSQLParser::Reloptions_Context::Reloptions_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Reloptions_Context::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

PostgreSQLParser::ReloptionsContext* PostgreSQLParser::Reloptions_Context::reloptions() {
  return getRuleContext<PostgreSQLParser::ReloptionsContext>(0);
}


size_t PostgreSQLParser::Reloptions_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleReloptions_;
}


std::any PostgreSQLParser::Reloptions_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitReloptions_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Reloptions_Context* PostgreSQLParser::reloptions_() {
  Reloptions_Context *_localctx = _tracker.createInstance<Reloptions_Context>(_ctx, getState());
  enterRule(_localctx, 114, PostgreSQLParser::RuleReloptions_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2357);
    match(PostgreSQLParser::WITH);
    setState(2358);
    reloptions();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reloption_listContext ------------------------------------------------------------------

PostgreSQLParser::Reloption_listContext::Reloption_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Reloption_elemContext *> PostgreSQLParser::Reloption_listContext::reloption_elem() {
  return getRuleContexts<PostgreSQLParser::Reloption_elemContext>();
}

PostgreSQLParser::Reloption_elemContext* PostgreSQLParser::Reloption_listContext::reloption_elem(size_t i) {
  return getRuleContext<PostgreSQLParser::Reloption_elemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Reloption_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Reloption_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Reloption_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleReloption_list;
}


std::any PostgreSQLParser::Reloption_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitReloption_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Reloption_listContext* PostgreSQLParser::reloption_list() {
  Reloption_listContext *_localctx = _tracker.createInstance<Reloption_listContext>(_ctx, getState());
  enterRule(_localctx, 116, PostgreSQLParser::RuleReloption_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2360);
    reloption_elem();
    setState(2365);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(2361);
      match(PostgreSQLParser::COMMA);
      setState(2362);
      reloption_elem();
      setState(2367);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reloption_elemContext ------------------------------------------------------------------

PostgreSQLParser::Reloption_elemContext::Reloption_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::ColLabelContext *> PostgreSQLParser::Reloption_elemContext::colLabel() {
  return getRuleContexts<PostgreSQLParser::ColLabelContext>();
}

PostgreSQLParser::ColLabelContext* PostgreSQLParser::Reloption_elemContext::colLabel(size_t i) {
  return getRuleContext<PostgreSQLParser::ColLabelContext>(i);
}

tree::TerminalNode* PostgreSQLParser::Reloption_elemContext::EQUAL() {
  return getToken(PostgreSQLParser::EQUAL, 0);
}

PostgreSQLParser::Def_argContext* PostgreSQLParser::Reloption_elemContext::def_arg() {
  return getRuleContext<PostgreSQLParser::Def_argContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Reloption_elemContext::DOT() {
  return getToken(PostgreSQLParser::DOT, 0);
}


size_t PostgreSQLParser::Reloption_elemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleReloption_elem;
}


std::any PostgreSQLParser::Reloption_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitReloption_elem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Reloption_elemContext* PostgreSQLParser::reloption_elem() {
  Reloption_elemContext *_localctx = _tracker.createInstance<Reloption_elemContext>(_ctx, getState());
  enterRule(_localctx, 118, PostgreSQLParser::RuleReloption_elem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2368);
    colLabel();
    setState(2377);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::EQUAL: {
        setState(2369);
        match(PostgreSQLParser::EQUAL);
        setState(2370);
        def_arg();
        break;
      }

      case PostgreSQLParser::DOT: {
        setState(2371);
        match(PostgreSQLParser::DOT);
        setState(2372);
        colLabel();
        setState(2375);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::EQUAL) {
          setState(2373);
          match(PostgreSQLParser::EQUAL);
          setState(2374);
          def_arg();
        }
        break;
      }

      case PostgreSQLParser::CLOSE_PAREN:
      case PostgreSQLParser::COMMA: {
        break;
      }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_identity_column_option_listContext ------------------------------------------------------------------

PostgreSQLParser::Alter_identity_column_option_listContext::Alter_identity_column_option_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Alter_identity_column_optionContext *> PostgreSQLParser::Alter_identity_column_option_listContext::alter_identity_column_option() {
  return getRuleContexts<PostgreSQLParser::Alter_identity_column_optionContext>();
}

PostgreSQLParser::Alter_identity_column_optionContext* PostgreSQLParser::Alter_identity_column_option_listContext::alter_identity_column_option(size_t i) {
  return getRuleContext<PostgreSQLParser::Alter_identity_column_optionContext>(i);
}


size_t PostgreSQLParser::Alter_identity_column_option_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlter_identity_column_option_list;
}


std::any PostgreSQLParser::Alter_identity_column_option_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlter_identity_column_option_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Alter_identity_column_option_listContext* PostgreSQLParser::alter_identity_column_option_list() {
  Alter_identity_column_option_listContext *_localctx = _tracker.createInstance<Alter_identity_column_option_listContext>(_ctx, getState());
  enterRule(_localctx, 120, PostgreSQLParser::RuleAlter_identity_column_option_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2380); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2379);
      alter_identity_column_option();
      setState(2382); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == PostgreSQLParser::RESTART

    || _la == PostgreSQLParser::SET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_identity_column_optionContext ------------------------------------------------------------------

PostgreSQLParser::Alter_identity_column_optionContext::Alter_identity_column_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Alter_identity_column_optionContext::RESTART() {
  return getToken(PostgreSQLParser::RESTART, 0);
}

PostgreSQLParser::NumericonlyContext* PostgreSQLParser::Alter_identity_column_optionContext::numericonly() {
  return getRuleContext<PostgreSQLParser::NumericonlyContext>(0);
}

PostgreSQLParser::With_Context* PostgreSQLParser::Alter_identity_column_optionContext::with_() {
  return getRuleContext<PostgreSQLParser::With_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::Alter_identity_column_optionContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

PostgreSQLParser::SeqoptelemContext* PostgreSQLParser::Alter_identity_column_optionContext::seqoptelem() {
  return getRuleContext<PostgreSQLParser::SeqoptelemContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Alter_identity_column_optionContext::GENERATED() {
  return getToken(PostgreSQLParser::GENERATED, 0);
}

PostgreSQLParser::Generated_whenContext* PostgreSQLParser::Alter_identity_column_optionContext::generated_when() {
  return getRuleContext<PostgreSQLParser::Generated_whenContext>(0);
}


size_t PostgreSQLParser::Alter_identity_column_optionContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlter_identity_column_option;
}


std::any PostgreSQLParser::Alter_identity_column_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlter_identity_column_option(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Alter_identity_column_optionContext* PostgreSQLParser::alter_identity_column_option() {
  Alter_identity_column_optionContext *_localctx = _tracker.createInstance<Alter_identity_column_optionContext>(_ctx, getState());
  enterRule(_localctx, 122, PostgreSQLParser::RuleAlter_identity_column_option);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2397);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::RESTART: {
        enterOuterAlt(_localctx, 1);
        setState(2384);
        match(PostgreSQLParser::RESTART);
        setState(2389);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::PLUS

        || _la == PostgreSQLParser::MINUS || _la == PostgreSQLParser::WITH || ((((_la - 576) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 576)) & 47) != 0)) {
          setState(2386);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == PostgreSQLParser::WITH) {
            setState(2385);
            with_();
          }
          setState(2388);
          numericonly();
        }
        break;
      }

      case PostgreSQLParser::SET: {
        enterOuterAlt(_localctx, 2);
        setState(2391);
        match(PostgreSQLParser::SET);
        setState(2395);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case PostgreSQLParser::AS:
          case PostgreSQLParser::CACHE:
          case PostgreSQLParser::CYCLE:
          case PostgreSQLParser::INCREMENT:
          case PostgreSQLParser::MAXVALUE:
          case PostgreSQLParser::MINVALUE:
          case PostgreSQLParser::NO:
          case PostgreSQLParser::OWNED:
          case PostgreSQLParser::RESTART:
          case PostgreSQLParser::SEQUENCE:
          case PostgreSQLParser::START: {
            setState(2392);
            seqoptelem();
            break;
          }

          case PostgreSQLParser::GENERATED: {
            setState(2393);
            match(PostgreSQLParser::GENERATED);
            setState(2394);
            generated_when();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionboundspecContext ------------------------------------------------------------------

PostgreSQLParser::PartitionboundspecContext::PartitionboundspecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::PartitionboundspecContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

tree::TerminalNode* PostgreSQLParser::PartitionboundspecContext::VALUES() {
  return getToken(PostgreSQLParser::VALUES, 0);
}

tree::TerminalNode* PostgreSQLParser::PartitionboundspecContext::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::PartitionboundspecContext::OPEN_PAREN() {
  return getTokens(PostgreSQLParser::OPEN_PAREN);
}

tree::TerminalNode* PostgreSQLParser::PartitionboundspecContext::OPEN_PAREN(size_t i) {
  return getToken(PostgreSQLParser::OPEN_PAREN, i);
}

PostgreSQLParser::Hash_partboundContext* PostgreSQLParser::PartitionboundspecContext::hash_partbound() {
  return getRuleContext<PostgreSQLParser::Hash_partboundContext>(0);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::PartitionboundspecContext::CLOSE_PAREN() {
  return getTokens(PostgreSQLParser::CLOSE_PAREN);
}

tree::TerminalNode* PostgreSQLParser::PartitionboundspecContext::CLOSE_PAREN(size_t i) {
  return getToken(PostgreSQLParser::CLOSE_PAREN, i);
}

tree::TerminalNode* PostgreSQLParser::PartitionboundspecContext::IN_P() {
  return getToken(PostgreSQLParser::IN_P, 0);
}

std::vector<PostgreSQLParser::Expr_listContext *> PostgreSQLParser::PartitionboundspecContext::expr_list() {
  return getRuleContexts<PostgreSQLParser::Expr_listContext>();
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::PartitionboundspecContext::expr_list(size_t i) {
  return getRuleContext<PostgreSQLParser::Expr_listContext>(i);
}

tree::TerminalNode* PostgreSQLParser::PartitionboundspecContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

tree::TerminalNode* PostgreSQLParser::PartitionboundspecContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}

tree::TerminalNode* PostgreSQLParser::PartitionboundspecContext::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}


size_t PostgreSQLParser::PartitionboundspecContext::getRuleIndex() const {
  return PostgreSQLParser::RulePartitionboundspec;
}


std::any PostgreSQLParser::PartitionboundspecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitPartitionboundspec(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::PartitionboundspecContext* PostgreSQLParser::partitionboundspec() {
  PartitionboundspecContext *_localctx = _tracker.createInstance<PartitionboundspecContext>(_ctx, getState());
  enterRule(_localctx, 124, PostgreSQLParser::RulePartitionboundspec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2425);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2399);
      match(PostgreSQLParser::FOR);
      setState(2400);
      match(PostgreSQLParser::VALUES);
      setState(2401);
      match(PostgreSQLParser::WITH);
      setState(2402);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(2403);
      hash_partbound();
      setState(2404);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2406);
      match(PostgreSQLParser::FOR);
      setState(2407);
      match(PostgreSQLParser::VALUES);
      setState(2408);
      match(PostgreSQLParser::IN_P);
      setState(2409);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(2410);
      expr_list();
      setState(2411);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2413);
      match(PostgreSQLParser::FOR);
      setState(2414);
      match(PostgreSQLParser::VALUES);
      setState(2415);
      match(PostgreSQLParser::FROM);
      setState(2416);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(2417);
      expr_list();
      setState(2418);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(2419);
      match(PostgreSQLParser::TO);
      setState(2420);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(2421);
      expr_list();
      setState(2422);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2424);
      match(PostgreSQLParser::DEFAULT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hash_partbound_elemContext ------------------------------------------------------------------

PostgreSQLParser::Hash_partbound_elemContext::Hash_partbound_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::NonreservedwordContext* PostgreSQLParser::Hash_partbound_elemContext::nonreservedword() {
  return getRuleContext<PostgreSQLParser::NonreservedwordContext>(0);
}

PostgreSQLParser::IconstContext* PostgreSQLParser::Hash_partbound_elemContext::iconst() {
  return getRuleContext<PostgreSQLParser::IconstContext>(0);
}


size_t PostgreSQLParser::Hash_partbound_elemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleHash_partbound_elem;
}


std::any PostgreSQLParser::Hash_partbound_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitHash_partbound_elem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Hash_partbound_elemContext* PostgreSQLParser::hash_partbound_elem() {
  Hash_partbound_elemContext *_localctx = _tracker.createInstance<Hash_partbound_elemContext>(_ctx, getState());
  enterRule(_localctx, 126, PostgreSQLParser::RuleHash_partbound_elem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2427);
    nonreservedword();
    setState(2428);
    iconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hash_partboundContext ------------------------------------------------------------------

PostgreSQLParser::Hash_partboundContext::Hash_partboundContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Hash_partbound_elemContext *> PostgreSQLParser::Hash_partboundContext::hash_partbound_elem() {
  return getRuleContexts<PostgreSQLParser::Hash_partbound_elemContext>();
}

PostgreSQLParser::Hash_partbound_elemContext* PostgreSQLParser::Hash_partboundContext::hash_partbound_elem(size_t i) {
  return getRuleContext<PostgreSQLParser::Hash_partbound_elemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Hash_partboundContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Hash_partboundContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Hash_partboundContext::getRuleIndex() const {
  return PostgreSQLParser::RuleHash_partbound;
}


std::any PostgreSQLParser::Hash_partboundContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitHash_partbound(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Hash_partboundContext* PostgreSQLParser::hash_partbound() {
  Hash_partboundContext *_localctx = _tracker.createInstance<Hash_partboundContext>(_ctx, getState());
  enterRule(_localctx, 128, PostgreSQLParser::RuleHash_partbound);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2430);
    hash_partbound_elem();
    setState(2435);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(2431);
      match(PostgreSQLParser::COMMA);
      setState(2432);
      hash_partbound_elem();
      setState(2437);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AltercompositetypestmtContext ------------------------------------------------------------------

PostgreSQLParser::AltercompositetypestmtContext::AltercompositetypestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AltercompositetypestmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AltercompositetypestmtContext::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::AltercompositetypestmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

PostgreSQLParser::Alter_type_cmdsContext* PostgreSQLParser::AltercompositetypestmtContext::alter_type_cmds() {
  return getRuleContext<PostgreSQLParser::Alter_type_cmdsContext>(0);
}


size_t PostgreSQLParser::AltercompositetypestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAltercompositetypestmt;
}


std::any PostgreSQLParser::AltercompositetypestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAltercompositetypestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AltercompositetypestmtContext* PostgreSQLParser::altercompositetypestmt() {
  AltercompositetypestmtContext *_localctx = _tracker.createInstance<AltercompositetypestmtContext>(_ctx, getState());
  enterRule(_localctx, 130, PostgreSQLParser::RuleAltercompositetypestmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2438);
    match(PostgreSQLParser::ALTER);
    setState(2439);
    match(PostgreSQLParser::TYPE_P);
    setState(2440);
    any_name();
    setState(2441);
    alter_type_cmds();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_type_cmdsContext ------------------------------------------------------------------

PostgreSQLParser::Alter_type_cmdsContext::Alter_type_cmdsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Alter_type_cmdContext *> PostgreSQLParser::Alter_type_cmdsContext::alter_type_cmd() {
  return getRuleContexts<PostgreSQLParser::Alter_type_cmdContext>();
}

PostgreSQLParser::Alter_type_cmdContext* PostgreSQLParser::Alter_type_cmdsContext::alter_type_cmd(size_t i) {
  return getRuleContext<PostgreSQLParser::Alter_type_cmdContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Alter_type_cmdsContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Alter_type_cmdsContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Alter_type_cmdsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlter_type_cmds;
}


std::any PostgreSQLParser::Alter_type_cmdsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlter_type_cmds(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Alter_type_cmdsContext* PostgreSQLParser::alter_type_cmds() {
  Alter_type_cmdsContext *_localctx = _tracker.createInstance<Alter_type_cmdsContext>(_ctx, getState());
  enterRule(_localctx, 132, PostgreSQLParser::RuleAlter_type_cmds);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2443);
    alter_type_cmd();
    setState(2448);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(2444);
      match(PostgreSQLParser::COMMA);
      setState(2445);
      alter_type_cmd();
      setState(2450);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_type_cmdContext ------------------------------------------------------------------

PostgreSQLParser::Alter_type_cmdContext::Alter_type_cmdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Alter_type_cmdContext::ADD_P() {
  return getToken(PostgreSQLParser::ADD_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_type_cmdContext::ATTRIBUTE() {
  return getToken(PostgreSQLParser::ATTRIBUTE, 0);
}

PostgreSQLParser::TablefuncelementContext* PostgreSQLParser::Alter_type_cmdContext::tablefuncelement() {
  return getRuleContext<PostgreSQLParser::TablefuncelementContext>(0);
}

PostgreSQLParser::Drop_behavior_Context* PostgreSQLParser::Alter_type_cmdContext::drop_behavior_() {
  return getRuleContext<PostgreSQLParser::Drop_behavior_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::Alter_type_cmdContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Alter_type_cmdContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Alter_type_cmdContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_type_cmdContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_type_cmdContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_type_cmdContext::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::Alter_type_cmdContext::typename_() {
  return getRuleContext<PostgreSQLParser::TypenameContext>(0);
}

PostgreSQLParser::Set_data_Context* PostgreSQLParser::Alter_type_cmdContext::set_data_() {
  return getRuleContext<PostgreSQLParser::Set_data_Context>(0);
}

PostgreSQLParser::Collate_clause_Context* PostgreSQLParser::Alter_type_cmdContext::collate_clause_() {
  return getRuleContext<PostgreSQLParser::Collate_clause_Context>(0);
}


size_t PostgreSQLParser::Alter_type_cmdContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlter_type_cmd;
}


std::any PostgreSQLParser::Alter_type_cmdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlter_type_cmd(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Alter_type_cmdContext* PostgreSQLParser::alter_type_cmd() {
  Alter_type_cmdContext *_localctx = _tracker.createInstance<Alter_type_cmdContext>(_ctx, getState());
  enterRule(_localctx, 134, PostgreSQLParser::RuleAlter_type_cmd);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2481);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::ADD_P: {
        enterOuterAlt(_localctx, 1);
        setState(2451);
        match(PostgreSQLParser::ADD_P);
        setState(2452);
        match(PostgreSQLParser::ATTRIBUTE);
        setState(2453);
        tablefuncelement();
        setState(2455);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
          setState(2454);
          drop_behavior_();
        }
        break;
      }

      case PostgreSQLParser::DROP: {
        enterOuterAlt(_localctx, 2);
        setState(2457);
        match(PostgreSQLParser::DROP);
        setState(2458);
        match(PostgreSQLParser::ATTRIBUTE);
        setState(2461);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 99, _ctx)) {
        case 1: {
          setState(2459);
          match(PostgreSQLParser::IF_P);
          setState(2460);
          match(PostgreSQLParser::EXISTS);
          break;
        }

        default:
          break;
        }
        setState(2463);
        colid();
        setState(2465);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
          setState(2464);
          drop_behavior_();
        }
        break;
      }

      case PostgreSQLParser::ALTER: {
        enterOuterAlt(_localctx, 3);
        setState(2467);
        match(PostgreSQLParser::ALTER);
        setState(2468);
        match(PostgreSQLParser::ATTRIBUTE);
        setState(2469);
        colid();
        setState(2471);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::SET) {
          setState(2470);
          set_data_();
        }
        setState(2473);
        match(PostgreSQLParser::TYPE_P);
        setState(2474);
        typename_();
        setState(2476);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::COLLATE) {
          setState(2475);
          collate_clause_();
        }
        setState(2479);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
          setState(2478);
          drop_behavior_();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CloseportalstmtContext ------------------------------------------------------------------

PostgreSQLParser::CloseportalstmtContext::CloseportalstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CloseportalstmtContext::CLOSE() {
  return getToken(PostgreSQLParser::CLOSE, 0);
}

PostgreSQLParser::Cursor_nameContext* PostgreSQLParser::CloseportalstmtContext::cursor_name() {
  return getRuleContext<PostgreSQLParser::Cursor_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CloseportalstmtContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}


size_t PostgreSQLParser::CloseportalstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCloseportalstmt;
}


std::any PostgreSQLParser::CloseportalstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCloseportalstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CloseportalstmtContext* PostgreSQLParser::closeportalstmt() {
  CloseportalstmtContext *_localctx = _tracker.createInstance<CloseportalstmtContext>(_ctx, getState());
  enterRule(_localctx, 136, PostgreSQLParser::RuleCloseportalstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2483);
    match(PostgreSQLParser::CLOSE);
    setState(2486);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        setState(2484);
        cursor_name();
        break;
      }

      case PostgreSQLParser::ALL: {
        setState(2485);
        match(PostgreSQLParser::ALL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CopystmtContext ------------------------------------------------------------------

PostgreSQLParser::CopystmtContext::CopystmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CopystmtContext::COPY() {
  return getToken(PostgreSQLParser::COPY, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::CopystmtContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

PostgreSQLParser::Copy_fromContext* PostgreSQLParser::CopystmtContext::copy_from() {
  return getRuleContext<PostgreSQLParser::Copy_fromContext>(0);
}

PostgreSQLParser::Copy_file_nameContext* PostgreSQLParser::CopystmtContext::copy_file_name() {
  return getRuleContext<PostgreSQLParser::Copy_file_nameContext>(0);
}

PostgreSQLParser::Copy_optionsContext* PostgreSQLParser::CopystmtContext::copy_options() {
  return getRuleContext<PostgreSQLParser::Copy_optionsContext>(0);
}

PostgreSQLParser::Binary_Context* PostgreSQLParser::CopystmtContext::binary_() {
  return getRuleContext<PostgreSQLParser::Binary_Context>(0);
}

PostgreSQLParser::Column_list_Context* PostgreSQLParser::CopystmtContext::column_list_() {
  return getRuleContext<PostgreSQLParser::Column_list_Context>(0);
}

PostgreSQLParser::Program_Context* PostgreSQLParser::CopystmtContext::program_() {
  return getRuleContext<PostgreSQLParser::Program_Context>(0);
}

PostgreSQLParser::Copy_delimiterContext* PostgreSQLParser::CopystmtContext::copy_delimiter() {
  return getRuleContext<PostgreSQLParser::Copy_delimiterContext>(0);
}

PostgreSQLParser::With_Context* PostgreSQLParser::CopystmtContext::with_() {
  return getRuleContext<PostgreSQLParser::With_Context>(0);
}

PostgreSQLParser::Where_clauseContext* PostgreSQLParser::CopystmtContext::where_clause() {
  return getRuleContext<PostgreSQLParser::Where_clauseContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CopystmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::PreparablestmtContext* PostgreSQLParser::CopystmtContext::preparablestmt() {
  return getRuleContext<PostgreSQLParser::PreparablestmtContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CopystmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::CopystmtContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}


size_t PostgreSQLParser::CopystmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCopystmt;
}


std::any PostgreSQLParser::CopystmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCopystmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CopystmtContext* PostgreSQLParser::copystmt() {
  CopystmtContext *_localctx = _tracker.createInstance<CopystmtContext>(_ctx, getState());
  enterRule(_localctx, 138, PostgreSQLParser::RuleCopystmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2525);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2488);
      match(PostgreSQLParser::COPY);
      setState(2490);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::BINARY) {
        setState(2489);
        binary_();
      }
      setState(2492);
      qualified_name();
      setState(2494);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPEN_PAREN) {
        setState(2493);
        column_list_();
      }
      setState(2496);
      copy_from();
      setState(2498);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::PROGRAM) {
        setState(2497);
        program_();
      }
      setState(2500);
      copy_file_name();
      setState(2502);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::USING || _la == PostgreSQLParser::DELIMITERS) {
        setState(2501);
        copy_delimiter();
      }
      setState(2505);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::WITH) {
        setState(2504);
        with_();
      }
      setState(2507);
      copy_options();
      setState(2509);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::WHERE) {
        setState(2508);
        where_clause();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2511);
      match(PostgreSQLParser::COPY);
      setState(2512);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(2513);
      preparablestmt();
      setState(2514);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(2515);
      match(PostgreSQLParser::TO);
      setState(2517);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::PROGRAM) {
        setState(2516);
        program_();
      }
      setState(2519);
      copy_file_name();
      setState(2521);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::WITH) {
        setState(2520);
        with_();
      }
      setState(2523);
      copy_options();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_fromContext ------------------------------------------------------------------

PostgreSQLParser::Copy_fromContext::Copy_fromContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Copy_fromContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

tree::TerminalNode* PostgreSQLParser::Copy_fromContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}


size_t PostgreSQLParser::Copy_fromContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCopy_from;
}


std::any PostgreSQLParser::Copy_fromContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCopy_from(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Copy_fromContext* PostgreSQLParser::copy_from() {
  Copy_fromContext *_localctx = _tracker.createInstance<Copy_fromContext>(_ctx, getState());
  enterRule(_localctx, 140, PostgreSQLParser::RuleCopy_from);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2527);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::FROM

    || _la == PostgreSQLParser::TO)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Program_Context ------------------------------------------------------------------

PostgreSQLParser::Program_Context::Program_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Program_Context::PROGRAM() {
  return getToken(PostgreSQLParser::PROGRAM, 0);
}


size_t PostgreSQLParser::Program_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleProgram_;
}


std::any PostgreSQLParser::Program_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitProgram_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Program_Context* PostgreSQLParser::program_() {
  Program_Context *_localctx = _tracker.createInstance<Program_Context>(_ctx, getState());
  enterRule(_localctx, 142, PostgreSQLParser::RuleProgram_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2529);
    match(PostgreSQLParser::PROGRAM);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_file_nameContext ------------------------------------------------------------------

PostgreSQLParser::Copy_file_nameContext::Copy_file_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Copy_file_nameContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Copy_file_nameContext::STDIN() {
  return getToken(PostgreSQLParser::STDIN, 0);
}

tree::TerminalNode* PostgreSQLParser::Copy_file_nameContext::STDOUT() {
  return getToken(PostgreSQLParser::STDOUT, 0);
}


size_t PostgreSQLParser::Copy_file_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCopy_file_name;
}


std::any PostgreSQLParser::Copy_file_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCopy_file_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Copy_file_nameContext* PostgreSQLParser::copy_file_name() {
  Copy_file_nameContext *_localctx = _tracker.createInstance<Copy_file_nameContext>(_ctx, getState());
  enterRule(_localctx, 144, PostgreSQLParser::RuleCopy_file_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2534);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::EscapeStringConstant: {
        enterOuterAlt(_localctx, 1);
        setState(2531);
        sconst();
        break;
      }

      case PostgreSQLParser::STDIN: {
        enterOuterAlt(_localctx, 2);
        setState(2532);
        match(PostgreSQLParser::STDIN);
        break;
      }

      case PostgreSQLParser::STDOUT: {
        enterOuterAlt(_localctx, 3);
        setState(2533);
        match(PostgreSQLParser::STDOUT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_optionsContext ------------------------------------------------------------------

PostgreSQLParser::Copy_optionsContext::Copy_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Copy_opt_listContext* PostgreSQLParser::Copy_optionsContext::copy_opt_list() {
  return getRuleContext<PostgreSQLParser::Copy_opt_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Copy_optionsContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Copy_generic_opt_listContext* PostgreSQLParser::Copy_optionsContext::copy_generic_opt_list() {
  return getRuleContext<PostgreSQLParser::Copy_generic_opt_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Copy_optionsContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Copy_optionsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCopy_options;
}


std::any PostgreSQLParser::Copy_optionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCopy_options(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Copy_optionsContext* PostgreSQLParser::copy_options() {
  Copy_optionsContext *_localctx = _tracker.createInstance<Copy_optionsContext>(_ctx, getState());
  enterRule(_localctx, 146, PostgreSQLParser::RuleCopy_options);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2541);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::EOF:
      case PostgreSQLParser::SEMI:
      case PostgreSQLParser::NULL_P:
      case PostgreSQLParser::WHERE:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::QUOTE: {
        enterOuterAlt(_localctx, 1);
        setState(2536);
        copy_opt_list();
        break;
      }

      case PostgreSQLParser::OPEN_PAREN: {
        enterOuterAlt(_localctx, 2);
        setState(2537);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(2538);
        copy_generic_opt_list();
        setState(2539);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_opt_listContext ------------------------------------------------------------------

PostgreSQLParser::Copy_opt_listContext::Copy_opt_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Copy_opt_itemContext *> PostgreSQLParser::Copy_opt_listContext::copy_opt_item() {
  return getRuleContexts<PostgreSQLParser::Copy_opt_itemContext>();
}

PostgreSQLParser::Copy_opt_itemContext* PostgreSQLParser::Copy_opt_listContext::copy_opt_item(size_t i) {
  return getRuleContext<PostgreSQLParser::Copy_opt_itemContext>(i);
}


size_t PostgreSQLParser::Copy_opt_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCopy_opt_list;
}


std::any PostgreSQLParser::Copy_opt_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCopy_opt_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Copy_opt_listContext* PostgreSQLParser::copy_opt_list() {
  Copy_opt_listContext *_localctx = _tracker.createInstance<Copy_opt_listContext>(_ctx, getState());
  enterRule(_localctx, 148, PostgreSQLParser::RuleCopy_opt_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2546);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 116) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 116)) & 17716740097) != 0) || ((((_la - 209) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 209)) & 35459325497345) != 0) || _la == PostgreSQLParser::QUOTE) {
      setState(2543);
      copy_opt_item();
      setState(2548);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_opt_itemContext ------------------------------------------------------------------

PostgreSQLParser::Copy_opt_itemContext::Copy_opt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Copy_opt_itemContext::BINARY() {
  return getToken(PostgreSQLParser::BINARY, 0);
}

tree::TerminalNode* PostgreSQLParser::Copy_opt_itemContext::FREEZE() {
  return getToken(PostgreSQLParser::FREEZE, 0);
}

tree::TerminalNode* PostgreSQLParser::Copy_opt_itemContext::DELIMITER() {
  return getToken(PostgreSQLParser::DELIMITER, 0);
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Copy_opt_itemContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}

PostgreSQLParser::As_Context* PostgreSQLParser::Copy_opt_itemContext::as_() {
  return getRuleContext<PostgreSQLParser::As_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::Copy_opt_itemContext::NULL_P() {
  return getToken(PostgreSQLParser::NULL_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Copy_opt_itemContext::CSV() {
  return getToken(PostgreSQLParser::CSV, 0);
}

tree::TerminalNode* PostgreSQLParser::Copy_opt_itemContext::HEADER_P() {
  return getToken(PostgreSQLParser::HEADER_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Copy_opt_itemContext::QUOTE() {
  return getToken(PostgreSQLParser::QUOTE, 0);
}

tree::TerminalNode* PostgreSQLParser::Copy_opt_itemContext::ESCAPE() {
  return getToken(PostgreSQLParser::ESCAPE, 0);
}

tree::TerminalNode* PostgreSQLParser::Copy_opt_itemContext::FORCE() {
  return getToken(PostgreSQLParser::FORCE, 0);
}

PostgreSQLParser::ColumnlistContext* PostgreSQLParser::Copy_opt_itemContext::columnlist() {
  return getRuleContext<PostgreSQLParser::ColumnlistContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Copy_opt_itemContext::STAR() {
  return getToken(PostgreSQLParser::STAR, 0);
}

tree::TerminalNode* PostgreSQLParser::Copy_opt_itemContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::Copy_opt_itemContext::ENCODING() {
  return getToken(PostgreSQLParser::ENCODING, 0);
}


size_t PostgreSQLParser::Copy_opt_itemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCopy_opt_item;
}


std::any PostgreSQLParser::Copy_opt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCopy_opt_item(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Copy_opt_itemContext* PostgreSQLParser::copy_opt_item() {
  Copy_opt_itemContext *_localctx = _tracker.createInstance<Copy_opt_itemContext>(_ctx, getState());
  enterRule(_localctx, 150, PostgreSQLParser::RuleCopy_opt_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2588);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2549);
      match(PostgreSQLParser::BINARY);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2550);
      match(PostgreSQLParser::FREEZE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2551);
      match(PostgreSQLParser::DELIMITER);
      setState(2553);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::AS) {
        setState(2552);
        as_();
      }
      setState(2555);
      sconst();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2556);
      match(PostgreSQLParser::NULL_P);
      setState(2558);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::AS) {
        setState(2557);
        as_();
      }
      setState(2560);
      sconst();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2561);
      match(PostgreSQLParser::CSV);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2562);
      match(PostgreSQLParser::HEADER_P);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2563);
      match(PostgreSQLParser::QUOTE);
      setState(2565);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::AS) {
        setState(2564);
        as_();
      }
      setState(2567);
      sconst();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2568);
      match(PostgreSQLParser::ESCAPE);
      setState(2570);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::AS) {
        setState(2569);
        as_();
      }
      setState(2572);
      sconst();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2573);
      match(PostgreSQLParser::FORCE);
      setState(2574);
      match(PostgreSQLParser::QUOTE);
      setState(2575);
      columnlist();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2576);
      match(PostgreSQLParser::FORCE);
      setState(2577);
      match(PostgreSQLParser::QUOTE);
      setState(2578);
      match(PostgreSQLParser::STAR);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(2579);
      match(PostgreSQLParser::FORCE);
      setState(2580);
      match(PostgreSQLParser::NOT);
      setState(2581);
      match(PostgreSQLParser::NULL_P);
      setState(2582);
      columnlist();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(2583);
      match(PostgreSQLParser::FORCE);
      setState(2584);
      match(PostgreSQLParser::NULL_P);
      setState(2585);
      columnlist();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(2586);
      match(PostgreSQLParser::ENCODING);
      setState(2587);
      sconst();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Binary_Context ------------------------------------------------------------------

PostgreSQLParser::Binary_Context::Binary_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Binary_Context::BINARY() {
  return getToken(PostgreSQLParser::BINARY, 0);
}


size_t PostgreSQLParser::Binary_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleBinary_;
}


std::any PostgreSQLParser::Binary_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitBinary_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Binary_Context* PostgreSQLParser::binary_() {
  Binary_Context *_localctx = _tracker.createInstance<Binary_Context>(_ctx, getState());
  enterRule(_localctx, 152, PostgreSQLParser::RuleBinary_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2590);
    match(PostgreSQLParser::BINARY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_delimiterContext ------------------------------------------------------------------

PostgreSQLParser::Copy_delimiterContext::Copy_delimiterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Copy_delimiterContext::DELIMITERS() {
  return getToken(PostgreSQLParser::DELIMITERS, 0);
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Copy_delimiterContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}

PostgreSQLParser::Using_Context* PostgreSQLParser::Copy_delimiterContext::using_() {
  return getRuleContext<PostgreSQLParser::Using_Context>(0);
}


size_t PostgreSQLParser::Copy_delimiterContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCopy_delimiter;
}


std::any PostgreSQLParser::Copy_delimiterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCopy_delimiter(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Copy_delimiterContext* PostgreSQLParser::copy_delimiter() {
  Copy_delimiterContext *_localctx = _tracker.createInstance<Copy_delimiterContext>(_ctx, getState());
  enterRule(_localctx, 154, PostgreSQLParser::RuleCopy_delimiter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2593);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::USING) {
      setState(2592);
      using_();
    }
    setState(2595);
    match(PostgreSQLParser::DELIMITERS);
    setState(2596);
    sconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Using_Context ------------------------------------------------------------------

PostgreSQLParser::Using_Context::Using_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Using_Context::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}


size_t PostgreSQLParser::Using_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleUsing_;
}


std::any PostgreSQLParser::Using_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitUsing_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Using_Context* PostgreSQLParser::using_() {
  Using_Context *_localctx = _tracker.createInstance<Using_Context>(_ctx, getState());
  enterRule(_localctx, 156, PostgreSQLParser::RuleUsing_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2598);
    match(PostgreSQLParser::USING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_generic_opt_listContext ------------------------------------------------------------------

PostgreSQLParser::Copy_generic_opt_listContext::Copy_generic_opt_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Copy_generic_opt_elemContext *> PostgreSQLParser::Copy_generic_opt_listContext::copy_generic_opt_elem() {
  return getRuleContexts<PostgreSQLParser::Copy_generic_opt_elemContext>();
}

PostgreSQLParser::Copy_generic_opt_elemContext* PostgreSQLParser::Copy_generic_opt_listContext::copy_generic_opt_elem(size_t i) {
  return getRuleContext<PostgreSQLParser::Copy_generic_opt_elemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Copy_generic_opt_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Copy_generic_opt_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Copy_generic_opt_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCopy_generic_opt_list;
}


std::any PostgreSQLParser::Copy_generic_opt_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCopy_generic_opt_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Copy_generic_opt_listContext* PostgreSQLParser::copy_generic_opt_list() {
  Copy_generic_opt_listContext *_localctx = _tracker.createInstance<Copy_generic_opt_listContext>(_ctx, getState());
  enterRule(_localctx, 158, PostgreSQLParser::RuleCopy_generic_opt_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2600);
    copy_generic_opt_elem();
    setState(2605);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(2601);
      match(PostgreSQLParser::COMMA);
      setState(2602);
      copy_generic_opt_elem();
      setState(2607);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_generic_opt_elemContext ------------------------------------------------------------------

PostgreSQLParser::Copy_generic_opt_elemContext::Copy_generic_opt_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColLabelContext* PostgreSQLParser::Copy_generic_opt_elemContext::colLabel() {
  return getRuleContext<PostgreSQLParser::ColLabelContext>(0);
}

PostgreSQLParser::Copy_generic_opt_argContext* PostgreSQLParser::Copy_generic_opt_elemContext::copy_generic_opt_arg() {
  return getRuleContext<PostgreSQLParser::Copy_generic_opt_argContext>(0);
}


size_t PostgreSQLParser::Copy_generic_opt_elemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCopy_generic_opt_elem;
}


std::any PostgreSQLParser::Copy_generic_opt_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCopy_generic_opt_elem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Copy_generic_opt_elemContext* PostgreSQLParser::copy_generic_opt_elem() {
  Copy_generic_opt_elemContext *_localctx = _tracker.createInstance<Copy_generic_opt_elemContext>(_ctx, getState());
  enterRule(_localctx, 160, PostgreSQLParser::RuleCopy_generic_opt_elem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2608);
    colLabel();
    setState(2610);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -4399120240124) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 18014415689351175) != 0) || ((((_la - 134) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 134)) & -1023) != 0) || ((((_la - 198) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 198)) & -1) != 0) || ((((_la - 262) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 262)) & -1) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & -129) != 0) || ((((_la - 390) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 390)) & -1) != 0) || ((((_la - 454) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 454)) & -2305843284091601405) != 0) || ((((_la - 518) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 518)) & -4899175083207029761) != 0) || _la == PostgreSQLParser::PLSQLVARIABLENAME

    || _la == PostgreSQLParser::EscapeStringConstant) {
      setState(2609);
      copy_generic_opt_arg();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_generic_opt_argContext ------------------------------------------------------------------

PostgreSQLParser::Copy_generic_opt_argContext::Copy_generic_opt_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Boolean_or_string_Context* PostgreSQLParser::Copy_generic_opt_argContext::boolean_or_string_() {
  return getRuleContext<PostgreSQLParser::Boolean_or_string_Context>(0);
}

PostgreSQLParser::NumericonlyContext* PostgreSQLParser::Copy_generic_opt_argContext::numericonly() {
  return getRuleContext<PostgreSQLParser::NumericonlyContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Copy_generic_opt_argContext::STAR() {
  return getToken(PostgreSQLParser::STAR, 0);
}

tree::TerminalNode* PostgreSQLParser::Copy_generic_opt_argContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Copy_generic_opt_arg_listContext* PostgreSQLParser::Copy_generic_opt_argContext::copy_generic_opt_arg_list() {
  return getRuleContext<PostgreSQLParser::Copy_generic_opt_arg_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Copy_generic_opt_argContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Copy_generic_opt_argContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCopy_generic_opt_arg;
}


std::any PostgreSQLParser::Copy_generic_opt_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCopy_generic_opt_arg(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Copy_generic_opt_argContext* PostgreSQLParser::copy_generic_opt_arg() {
  Copy_generic_opt_argContext *_localctx = _tracker.createInstance<Copy_generic_opt_argContext>(_ctx, getState());
  enterRule(_localctx, 162, PostgreSQLParser::RuleCopy_generic_opt_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2619);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::FALSE_P:
      case PostgreSQLParser::ON:
      case PostgreSQLParser::TRUE_P:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::PLSQLVARIABLENAME:
      case PostgreSQLParser::EscapeStringConstant: {
        enterOuterAlt(_localctx, 1);
        setState(2612);
        boolean_or_string_();
        break;
      }

      case PostgreSQLParser::PLUS:
      case PostgreSQLParser::MINUS:
      case PostgreSQLParser::Integral:
      case PostgreSQLParser::BinaryIntegral:
      case PostgreSQLParser::OctalIntegral:
      case PostgreSQLParser::HexadecimalIntegral:
      case PostgreSQLParser::Numeric: {
        enterOuterAlt(_localctx, 2);
        setState(2613);
        numericonly();
        break;
      }

      case PostgreSQLParser::STAR: {
        enterOuterAlt(_localctx, 3);
        setState(2614);
        match(PostgreSQLParser::STAR);
        break;
      }

      case PostgreSQLParser::OPEN_PAREN: {
        enterOuterAlt(_localctx, 4);
        setState(2615);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(2616);
        copy_generic_opt_arg_list();
        setState(2617);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_generic_opt_arg_listContext ------------------------------------------------------------------

PostgreSQLParser::Copy_generic_opt_arg_listContext::Copy_generic_opt_arg_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Copy_generic_opt_arg_list_itemContext *> PostgreSQLParser::Copy_generic_opt_arg_listContext::copy_generic_opt_arg_list_item() {
  return getRuleContexts<PostgreSQLParser::Copy_generic_opt_arg_list_itemContext>();
}

PostgreSQLParser::Copy_generic_opt_arg_list_itemContext* PostgreSQLParser::Copy_generic_opt_arg_listContext::copy_generic_opt_arg_list_item(size_t i) {
  return getRuleContext<PostgreSQLParser::Copy_generic_opt_arg_list_itemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Copy_generic_opt_arg_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Copy_generic_opt_arg_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Copy_generic_opt_arg_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCopy_generic_opt_arg_list;
}


std::any PostgreSQLParser::Copy_generic_opt_arg_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCopy_generic_opt_arg_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Copy_generic_opt_arg_listContext* PostgreSQLParser::copy_generic_opt_arg_list() {
  Copy_generic_opt_arg_listContext *_localctx = _tracker.createInstance<Copy_generic_opt_arg_listContext>(_ctx, getState());
  enterRule(_localctx, 164, PostgreSQLParser::RuleCopy_generic_opt_arg_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2621);
    copy_generic_opt_arg_list_item();
    setState(2626);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(2622);
      match(PostgreSQLParser::COMMA);
      setState(2623);
      copy_generic_opt_arg_list_item();
      setState(2628);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Copy_generic_opt_arg_list_itemContext ------------------------------------------------------------------

PostgreSQLParser::Copy_generic_opt_arg_list_itemContext::Copy_generic_opt_arg_list_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Boolean_or_string_Context* PostgreSQLParser::Copy_generic_opt_arg_list_itemContext::boolean_or_string_() {
  return getRuleContext<PostgreSQLParser::Boolean_or_string_Context>(0);
}


size_t PostgreSQLParser::Copy_generic_opt_arg_list_itemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCopy_generic_opt_arg_list_item;
}


std::any PostgreSQLParser::Copy_generic_opt_arg_list_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCopy_generic_opt_arg_list_item(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Copy_generic_opt_arg_list_itemContext* PostgreSQLParser::copy_generic_opt_arg_list_item() {
  Copy_generic_opt_arg_list_itemContext *_localctx = _tracker.createInstance<Copy_generic_opt_arg_list_itemContext>(_ctx, getState());
  enterRule(_localctx, 166, PostgreSQLParser::RuleCopy_generic_opt_arg_list_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2629);
    boolean_or_string_();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreatestmtContext ------------------------------------------------------------------

PostgreSQLParser::CreatestmtContext::CreatestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreatestmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatestmtContext::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}

std::vector<PostgreSQLParser::Qualified_nameContext *> PostgreSQLParser::CreatestmtContext::qualified_name() {
  return getRuleContexts<PostgreSQLParser::Qualified_nameContext>();
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::CreatestmtContext::qualified_name(size_t i) {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(i);
}

tree::TerminalNode* PostgreSQLParser::CreatestmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatestmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatestmtContext::OF() {
  return getToken(PostgreSQLParser::OF, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::CreatestmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatestmtContext::PARTITION() {
  return getToken(PostgreSQLParser::PARTITION, 0);
}

PostgreSQLParser::PartitionboundspecContext* PostgreSQLParser::CreatestmtContext::partitionboundspec() {
  return getRuleContext<PostgreSQLParser::PartitionboundspecContext>(0);
}

PostgreSQLParser::OpttempContext* PostgreSQLParser::CreatestmtContext::opttemp() {
  return getRuleContext<PostgreSQLParser::OpttempContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatestmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatestmtContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatestmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

PostgreSQLParser::OpttableelementlistContext* PostgreSQLParser::CreatestmtContext::opttableelementlist() {
  return getRuleContext<PostgreSQLParser::OpttableelementlistContext>(0);
}

PostgreSQLParser::OptinheritContext* PostgreSQLParser::CreatestmtContext::optinherit() {
  return getRuleContext<PostgreSQLParser::OptinheritContext>(0);
}

PostgreSQLParser::OptpartitionspecContext* PostgreSQLParser::CreatestmtContext::optpartitionspec() {
  return getRuleContext<PostgreSQLParser::OptpartitionspecContext>(0);
}

PostgreSQLParser::Table_access_method_clauseContext* PostgreSQLParser::CreatestmtContext::table_access_method_clause() {
  return getRuleContext<PostgreSQLParser::Table_access_method_clauseContext>(0);
}

PostgreSQLParser::OptwithContext* PostgreSQLParser::CreatestmtContext::optwith() {
  return getRuleContext<PostgreSQLParser::OptwithContext>(0);
}

PostgreSQLParser::OncommitoptionContext* PostgreSQLParser::CreatestmtContext::oncommitoption() {
  return getRuleContext<PostgreSQLParser::OncommitoptionContext>(0);
}

PostgreSQLParser::OpttablespaceContext* PostgreSQLParser::CreatestmtContext::opttablespace() {
  return getRuleContext<PostgreSQLParser::OpttablespaceContext>(0);
}

PostgreSQLParser::OpttypedtableelementlistContext* PostgreSQLParser::CreatestmtContext::opttypedtableelementlist() {
  return getRuleContext<PostgreSQLParser::OpttypedtableelementlistContext>(0);
}


size_t PostgreSQLParser::CreatestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatestmt;
}


std::any PostgreSQLParser::CreatestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreatestmtContext* PostgreSQLParser::createstmt() {
  CreatestmtContext *_localctx = _tracker.createInstance<CreatestmtContext>(_ctx, getState());
  enterRule(_localctx, 168, PostgreSQLParser::RuleCreatestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2631);
    match(PostgreSQLParser::CREATE);
    setState(2633);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::GLOBAL

    || _la == PostgreSQLParser::LOCAL || ((((_la - 383) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 383)) & 32773) != 0)) {
      setState(2632);
      opttemp();
    }
    setState(2635);
    match(PostgreSQLParser::TABLE);
    setState(2639);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx)) {
    case 1: {
      setState(2636);
      match(PostgreSQLParser::IF_P);
      setState(2637);
      match(PostgreSQLParser::NOT);
      setState(2638);
      match(PostgreSQLParser::EXISTS);
      break;
    }

    default:
      break;
    }
    setState(2641);
    qualified_name();
    setState(2707);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::OPEN_PAREN: {
        setState(2642);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(2644);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & -4399120252928) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 576460889742966791) != 0) || ((((_la - 136) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 136)) & -2076180479) != 0) || ((((_la - 200) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 200)) & -1) != 0) || ((((_la - 264) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 264)) & -1) != 0) || ((((_la - 328) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 328)) & -33) != 0) || ((((_la - 392) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 392)) & -1) != 0) || ((((_la - 463) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 463)) & -4644337652596737) != 0) || ((((_la - 527) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 527)) & 36028801783726085) != 0)) {
          setState(2643);
          opttableelementlist();
        }
        setState(2646);
        match(PostgreSQLParser::CLOSE_PAREN);
        setState(2648);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::INHERITS) {
          setState(2647);
          optinherit();
        }
        setState(2651);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::PARTITION) {
          setState(2650);
          optpartitionspec();
        }
        setState(2654);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::USING) {
          setState(2653);
          table_access_method_clause();
        }
        setState(2657);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::WITH || _la == PostgreSQLParser::WITHOUT) {
          setState(2656);
          optwith();
        }
        setState(2660);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::ON) {
          setState(2659);
          oncommitoption();
        }
        setState(2663);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::TABLESPACE) {
          setState(2662);
          opttablespace();
        }
        break;
      }

      case PostgreSQLParser::OF: {
        setState(2665);
        match(PostgreSQLParser::OF);
        setState(2666);
        any_name();
        setState(2668);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::OPEN_PAREN) {
          setState(2667);
          opttypedtableelementlist();
        }
        setState(2671);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::PARTITION) {
          setState(2670);
          optpartitionspec();
        }
        setState(2674);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::USING) {
          setState(2673);
          table_access_method_clause();
        }
        setState(2677);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::WITH || _la == PostgreSQLParser::WITHOUT) {
          setState(2676);
          optwith();
        }
        setState(2680);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::ON) {
          setState(2679);
          oncommitoption();
        }
        setState(2683);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::TABLESPACE) {
          setState(2682);
          opttablespace();
        }
        break;
      }

      case PostgreSQLParser::PARTITION: {
        setState(2685);
        match(PostgreSQLParser::PARTITION);
        setState(2686);
        match(PostgreSQLParser::OF);
        setState(2687);
        qualified_name();
        setState(2689);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::OPEN_PAREN) {
          setState(2688);
          opttypedtableelementlist();
        }
        setState(2691);
        partitionboundspec();
        setState(2693);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::PARTITION) {
          setState(2692);
          optpartitionspec();
        }
        setState(2696);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::USING) {
          setState(2695);
          table_access_method_clause();
        }
        setState(2699);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::WITH || _la == PostgreSQLParser::WITHOUT) {
          setState(2698);
          optwith();
        }
        setState(2702);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::ON) {
          setState(2701);
          oncommitoption();
        }
        setState(2705);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::TABLESPACE) {
          setState(2704);
          opttablespace();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OpttempContext ------------------------------------------------------------------

PostgreSQLParser::OpttempContext::OpttempContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::OpttempContext::TEMPORARY() {
  return getToken(PostgreSQLParser::TEMPORARY, 0);
}

tree::TerminalNode* PostgreSQLParser::OpttempContext::TEMP() {
  return getToken(PostgreSQLParser::TEMP, 0);
}

tree::TerminalNode* PostgreSQLParser::OpttempContext::LOCAL() {
  return getToken(PostgreSQLParser::LOCAL, 0);
}

tree::TerminalNode* PostgreSQLParser::OpttempContext::GLOBAL() {
  return getToken(PostgreSQLParser::GLOBAL, 0);
}

tree::TerminalNode* PostgreSQLParser::OpttempContext::UNLOGGED() {
  return getToken(PostgreSQLParser::UNLOGGED, 0);
}


size_t PostgreSQLParser::OpttempContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOpttemp;
}


std::any PostgreSQLParser::OpttempContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOpttemp(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::OpttempContext* PostgreSQLParser::opttemp() {
  OpttempContext *_localctx = _tracker.createInstance<OpttempContext>(_ctx, getState());
  enterRule(_localctx, 170, PostgreSQLParser::RuleOpttemp);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2716);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::TEMPORARY: {
        enterOuterAlt(_localctx, 1);
        setState(2709);
        match(PostgreSQLParser::TEMPORARY);
        break;
      }

      case PostgreSQLParser::TEMP: {
        enterOuterAlt(_localctx, 2);
        setState(2710);
        match(PostgreSQLParser::TEMP);
        break;
      }

      case PostgreSQLParser::LOCAL: {
        enterOuterAlt(_localctx, 3);
        setState(2711);
        match(PostgreSQLParser::LOCAL);
        setState(2712);
        _la = _input->LA(1);
        if (!(_la == PostgreSQLParser::TEMP

        || _la == PostgreSQLParser::TEMPORARY)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case PostgreSQLParser::GLOBAL: {
        enterOuterAlt(_localctx, 4);
        setState(2713);
        match(PostgreSQLParser::GLOBAL);
        setState(2714);
        _la = _input->LA(1);
        if (!(_la == PostgreSQLParser::TEMP

        || _la == PostgreSQLParser::TEMPORARY)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case PostgreSQLParser::UNLOGGED: {
        enterOuterAlt(_localctx, 5);
        setState(2715);
        match(PostgreSQLParser::UNLOGGED);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OpttableelementlistContext ------------------------------------------------------------------

PostgreSQLParser::OpttableelementlistContext::OpttableelementlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::TableelementlistContext* PostgreSQLParser::OpttableelementlistContext::tableelementlist() {
  return getRuleContext<PostgreSQLParser::TableelementlistContext>(0);
}


size_t PostgreSQLParser::OpttableelementlistContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOpttableelementlist;
}


std::any PostgreSQLParser::OpttableelementlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOpttableelementlist(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::OpttableelementlistContext* PostgreSQLParser::opttableelementlist() {
  OpttableelementlistContext *_localctx = _tracker.createInstance<OpttableelementlistContext>(_ctx, getState());
  enterRule(_localctx, 172, PostgreSQLParser::RuleOpttableelementlist);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2718);
    tableelementlist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OpttypedtableelementlistContext ------------------------------------------------------------------

PostgreSQLParser::OpttypedtableelementlistContext::OpttypedtableelementlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::OpttypedtableelementlistContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::TypedtableelementlistContext* PostgreSQLParser::OpttypedtableelementlistContext::typedtableelementlist() {
  return getRuleContext<PostgreSQLParser::TypedtableelementlistContext>(0);
}

tree::TerminalNode* PostgreSQLParser::OpttypedtableelementlistContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::OpttypedtableelementlistContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOpttypedtableelementlist;
}


std::any PostgreSQLParser::OpttypedtableelementlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOpttypedtableelementlist(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::OpttypedtableelementlistContext* PostgreSQLParser::opttypedtableelementlist() {
  OpttypedtableelementlistContext *_localctx = _tracker.createInstance<OpttypedtableelementlistContext>(_ctx, getState());
  enterRule(_localctx, 174, PostgreSQLParser::RuleOpttypedtableelementlist);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2720);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(2721);
    typedtableelementlist();
    setState(2722);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableelementlistContext ------------------------------------------------------------------

PostgreSQLParser::TableelementlistContext::TableelementlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::TableelementContext *> PostgreSQLParser::TableelementlistContext::tableelement() {
  return getRuleContexts<PostgreSQLParser::TableelementContext>();
}

PostgreSQLParser::TableelementContext* PostgreSQLParser::TableelementlistContext::tableelement(size_t i) {
  return getRuleContext<PostgreSQLParser::TableelementContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::TableelementlistContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::TableelementlistContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::TableelementlistContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTableelementlist;
}


std::any PostgreSQLParser::TableelementlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTableelementlist(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TableelementlistContext* PostgreSQLParser::tableelementlist() {
  TableelementlistContext *_localctx = _tracker.createInstance<TableelementlistContext>(_ctx, getState());
  enterRule(_localctx, 176, PostgreSQLParser::RuleTableelementlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2724);
    tableelement();
    setState(2729);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(2725);
      match(PostgreSQLParser::COMMA);
      setState(2726);
      tableelement();
      setState(2731);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypedtableelementlistContext ------------------------------------------------------------------

PostgreSQLParser::TypedtableelementlistContext::TypedtableelementlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::TypedtableelementContext *> PostgreSQLParser::TypedtableelementlistContext::typedtableelement() {
  return getRuleContexts<PostgreSQLParser::TypedtableelementContext>();
}

PostgreSQLParser::TypedtableelementContext* PostgreSQLParser::TypedtableelementlistContext::typedtableelement(size_t i) {
  return getRuleContext<PostgreSQLParser::TypedtableelementContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::TypedtableelementlistContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::TypedtableelementlistContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::TypedtableelementlistContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTypedtableelementlist;
}


std::any PostgreSQLParser::TypedtableelementlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTypedtableelementlist(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TypedtableelementlistContext* PostgreSQLParser::typedtableelementlist() {
  TypedtableelementlistContext *_localctx = _tracker.createInstance<TypedtableelementlistContext>(_ctx, getState());
  enterRule(_localctx, 178, PostgreSQLParser::RuleTypedtableelementlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2732);
    typedtableelement();
    setState(2737);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(2733);
      match(PostgreSQLParser::COMMA);
      setState(2734);
      typedtableelement();
      setState(2739);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableelementContext ------------------------------------------------------------------

PostgreSQLParser::TableelementContext::TableelementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::TableconstraintContext* PostgreSQLParser::TableelementContext::tableconstraint() {
  return getRuleContext<PostgreSQLParser::TableconstraintContext>(0);
}

PostgreSQLParser::TablelikeclauseContext* PostgreSQLParser::TableelementContext::tablelikeclause() {
  return getRuleContext<PostgreSQLParser::TablelikeclauseContext>(0);
}

PostgreSQLParser::ColumnDefContext* PostgreSQLParser::TableelementContext::columnDef() {
  return getRuleContext<PostgreSQLParser::ColumnDefContext>(0);
}


size_t PostgreSQLParser::TableelementContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTableelement;
}


std::any PostgreSQLParser::TableelementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTableelement(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TableelementContext* PostgreSQLParser::tableelement() {
  TableelementContext *_localctx = _tracker.createInstance<TableelementContext>(_ctx, getState());
  enterRule(_localctx, 180, PostgreSQLParser::RuleTableelement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2743);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 153, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2740);
      tableconstraint();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2741);
      tablelikeclause();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2742);
      columnDef();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypedtableelementContext ------------------------------------------------------------------

PostgreSQLParser::TypedtableelementContext::TypedtableelementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColumnOptionsContext* PostgreSQLParser::TypedtableelementContext::columnOptions() {
  return getRuleContext<PostgreSQLParser::ColumnOptionsContext>(0);
}

PostgreSQLParser::TableconstraintContext* PostgreSQLParser::TypedtableelementContext::tableconstraint() {
  return getRuleContext<PostgreSQLParser::TableconstraintContext>(0);
}


size_t PostgreSQLParser::TypedtableelementContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTypedtableelement;
}


std::any PostgreSQLParser::TypedtableelementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTypedtableelement(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TypedtableelementContext* PostgreSQLParser::typedtableelement() {
  TypedtableelementContext *_localctx = _tracker.createInstance<TypedtableelementContext>(_ctx, getState());
  enterRule(_localctx, 182, PostgreSQLParser::RuleTypedtableelement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2747);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2745);
      columnOptions();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2746);
      tableconstraint();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnDefContext ------------------------------------------------------------------

PostgreSQLParser::ColumnDefContext::ColumnDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::ColumnDefContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::ColumnDefContext::typename_() {
  return getRuleContext<PostgreSQLParser::TypenameContext>(0);
}

PostgreSQLParser::ColquallistContext* PostgreSQLParser::ColumnDefContext::colquallist() {
  return getRuleContext<PostgreSQLParser::ColquallistContext>(0);
}

PostgreSQLParser::Create_generic_optionsContext* PostgreSQLParser::ColumnDefContext::create_generic_options() {
  return getRuleContext<PostgreSQLParser::Create_generic_optionsContext>(0);
}


size_t PostgreSQLParser::ColumnDefContext::getRuleIndex() const {
  return PostgreSQLParser::RuleColumnDef;
}


std::any PostgreSQLParser::ColumnDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitColumnDef(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ColumnDefContext* PostgreSQLParser::columnDef() {
  ColumnDefContext *_localctx = _tracker.createInstance<ColumnDefContext>(_ctx, getState());
  enterRule(_localctx, 184, PostgreSQLParser::RuleColumnDef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2749);
    colid();
    setState(2750);
    typename_();
    setState(2752);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OPTIONS) {
      setState(2751);
      create_generic_options();
    }
    setState(2754);
    colquallist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnOptionsContext ------------------------------------------------------------------

PostgreSQLParser::ColumnOptionsContext::ColumnOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::ColumnOptionsContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

PostgreSQLParser::ColquallistContext* PostgreSQLParser::ColumnOptionsContext::colquallist() {
  return getRuleContext<PostgreSQLParser::ColquallistContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ColumnOptionsContext::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

tree::TerminalNode* PostgreSQLParser::ColumnOptionsContext::OPTIONS() {
  return getToken(PostgreSQLParser::OPTIONS, 0);
}


size_t PostgreSQLParser::ColumnOptionsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleColumnOptions;
}


std::any PostgreSQLParser::ColumnOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitColumnOptions(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ColumnOptionsContext* PostgreSQLParser::columnOptions() {
  ColumnOptionsContext *_localctx = _tracker.createInstance<ColumnOptionsContext>(_ctx, getState());
  enterRule(_localctx, 186, PostgreSQLParser::RuleColumnOptions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2756);
    colid();
    setState(2759);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(2757);
      match(PostgreSQLParser::WITH);
      setState(2758);
      match(PostgreSQLParser::OPTIONS);
    }
    setState(2761);
    colquallist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColquallistContext ------------------------------------------------------------------

PostgreSQLParser::ColquallistContext::ColquallistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::ColconstraintContext *> PostgreSQLParser::ColquallistContext::colconstraint() {
  return getRuleContexts<PostgreSQLParser::ColconstraintContext>();
}

PostgreSQLParser::ColconstraintContext* PostgreSQLParser::ColquallistContext::colconstraint(size_t i) {
  return getRuleContext<PostgreSQLParser::ColconstraintContext>(i);
}


size_t PostgreSQLParser::ColquallistContext::getRuleIndex() const {
  return PostgreSQLParser::RuleColquallist;
}


std::any PostgreSQLParser::ColquallistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitColquallist(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ColquallistContext* PostgreSQLParser::colquallist() {
  ColquallistContext *_localctx = _tracker.createInstance<ColquallistContext>(_ctx, getState());
  enterRule(_localctx, 188, PostgreSQLParser::RuleColquallist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2766);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 80) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 80)) & 72084085530433547) != 0) || _la == PostgreSQLParser::GENERATED) {
      setState(2763);
      colconstraint();
      setState(2768);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColconstraintContext ------------------------------------------------------------------

PostgreSQLParser::ColconstraintContext::ColconstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::ColconstraintContext::CONSTRAINT() {
  return getToken(PostgreSQLParser::CONSTRAINT, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::ColconstraintContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::ColconstraintelemContext* PostgreSQLParser::ColconstraintContext::colconstraintelem() {
  return getRuleContext<PostgreSQLParser::ColconstraintelemContext>(0);
}

PostgreSQLParser::ConstraintattrContext* PostgreSQLParser::ColconstraintContext::constraintattr() {
  return getRuleContext<PostgreSQLParser::ConstraintattrContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ColconstraintContext::COLLATE() {
  return getToken(PostgreSQLParser::COLLATE, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::ColconstraintContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}


size_t PostgreSQLParser::ColconstraintContext::getRuleIndex() const {
  return PostgreSQLParser::RuleColconstraint;
}


std::any PostgreSQLParser::ColconstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitColconstraint(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ColconstraintContext* PostgreSQLParser::colconstraint() {
  ColconstraintContext *_localctx = _tracker.createInstance<ColconstraintContext>(_ctx, getState());
  enterRule(_localctx, 190, PostgreSQLParser::RuleColconstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2777);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 158, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2769);
      match(PostgreSQLParser::CONSTRAINT);
      setState(2770);
      name();
      setState(2771);
      colconstraintelem();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2773);
      colconstraintelem();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2774);
      constraintattr();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2775);
      match(PostgreSQLParser::COLLATE);
      setState(2776);
      any_name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColconstraintelemContext ------------------------------------------------------------------

PostgreSQLParser::ColconstraintelemContext::ColconstraintelemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::ColconstraintelemContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::ColconstraintelemContext::NULL_P() {
  return getToken(PostgreSQLParser::NULL_P, 0);
}

tree::TerminalNode* PostgreSQLParser::ColconstraintelemContext::UNIQUE() {
  return getToken(PostgreSQLParser::UNIQUE, 0);
}

PostgreSQLParser::Definition_Context* PostgreSQLParser::ColconstraintelemContext::definition_() {
  return getRuleContext<PostgreSQLParser::Definition_Context>(0);
}

PostgreSQLParser::OptconstablespaceContext* PostgreSQLParser::ColconstraintelemContext::optconstablespace() {
  return getRuleContext<PostgreSQLParser::OptconstablespaceContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ColconstraintelemContext::PRIMARY() {
  return getToken(PostgreSQLParser::PRIMARY, 0);
}

tree::TerminalNode* PostgreSQLParser::ColconstraintelemContext::KEY() {
  return getToken(PostgreSQLParser::KEY, 0);
}

tree::TerminalNode* PostgreSQLParser::ColconstraintelemContext::CHECK() {
  return getToken(PostgreSQLParser::CHECK, 0);
}

tree::TerminalNode* PostgreSQLParser::ColconstraintelemContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::ColconstraintelemContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ColconstraintelemContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::No_inherit_Context* PostgreSQLParser::ColconstraintelemContext::no_inherit_() {
  return getRuleContext<PostgreSQLParser::No_inherit_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::ColconstraintelemContext::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}

PostgreSQLParser::B_exprContext* PostgreSQLParser::ColconstraintelemContext::b_expr() {
  return getRuleContext<PostgreSQLParser::B_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ColconstraintelemContext::GENERATED() {
  return getToken(PostgreSQLParser::GENERATED, 0);
}

PostgreSQLParser::Generated_whenContext* PostgreSQLParser::ColconstraintelemContext::generated_when() {
  return getRuleContext<PostgreSQLParser::Generated_whenContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ColconstraintelemContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

tree::TerminalNode* PostgreSQLParser::ColconstraintelemContext::IDENTITY_P() {
  return getToken(PostgreSQLParser::IDENTITY_P, 0);
}

tree::TerminalNode* PostgreSQLParser::ColconstraintelemContext::STORED() {
  return getToken(PostgreSQLParser::STORED, 0);
}

PostgreSQLParser::OptparenthesizedseqoptlistContext* PostgreSQLParser::ColconstraintelemContext::optparenthesizedseqoptlist() {
  return getRuleContext<PostgreSQLParser::OptparenthesizedseqoptlistContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ColconstraintelemContext::REFERENCES() {
  return getToken(PostgreSQLParser::REFERENCES, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::ColconstraintelemContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

PostgreSQLParser::Column_list_Context* PostgreSQLParser::ColconstraintelemContext::column_list_() {
  return getRuleContext<PostgreSQLParser::Column_list_Context>(0);
}

PostgreSQLParser::Key_matchContext* PostgreSQLParser::ColconstraintelemContext::key_match() {
  return getRuleContext<PostgreSQLParser::Key_matchContext>(0);
}

PostgreSQLParser::Key_actionsContext* PostgreSQLParser::ColconstraintelemContext::key_actions() {
  return getRuleContext<PostgreSQLParser::Key_actionsContext>(0);
}


size_t PostgreSQLParser::ColconstraintelemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleColconstraintelem;
}


std::any PostgreSQLParser::ColconstraintelemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitColconstraintelem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ColconstraintelemContext* PostgreSQLParser::colconstraintelem() {
  ColconstraintelemContext *_localctx = _tracker.createInstance<ColconstraintelemContext>(_ctx, getState());
  enterRule(_localctx, 192, PostgreSQLParser::RuleColconstraintelem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2831);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::NOT: {
        enterOuterAlt(_localctx, 1);
        setState(2779);
        match(PostgreSQLParser::NOT);
        setState(2780);
        match(PostgreSQLParser::NULL_P);
        break;
      }

      case PostgreSQLParser::NULL_P: {
        enterOuterAlt(_localctx, 2);
        setState(2781);
        match(PostgreSQLParser::NULL_P);
        break;
      }

      case PostgreSQLParser::UNIQUE: {
        enterOuterAlt(_localctx, 3);
        setState(2782);
        match(PostgreSQLParser::UNIQUE);
        setState(2784);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::WITH) {
          setState(2783);
          definition_();
        }
        setState(2787);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::USING) {
          setState(2786);
          optconstablespace();
        }
        break;
      }

      case PostgreSQLParser::PRIMARY: {
        enterOuterAlt(_localctx, 4);
        setState(2789);
        match(PostgreSQLParser::PRIMARY);
        setState(2790);
        match(PostgreSQLParser::KEY);
        setState(2792);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::WITH) {
          setState(2791);
          definition_();
        }
        setState(2795);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::USING) {
          setState(2794);
          optconstablespace();
        }
        break;
      }

      case PostgreSQLParser::CHECK: {
        enterOuterAlt(_localctx, 5);
        setState(2797);
        match(PostgreSQLParser::CHECK);
        setState(2798);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(2799);
        a_expr();
        setState(2800);
        match(PostgreSQLParser::CLOSE_PAREN);
        setState(2802);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::NO) {
          setState(2801);
          no_inherit_();
        }
        break;
      }

      case PostgreSQLParser::DEFAULT: {
        enterOuterAlt(_localctx, 6);
        setState(2804);
        match(PostgreSQLParser::DEFAULT);
        setState(2805);
        b_expr(0);
        break;
      }

      case PostgreSQLParser::GENERATED: {
        enterOuterAlt(_localctx, 7);
        setState(2806);
        match(PostgreSQLParser::GENERATED);
        setState(2807);
        generated_when();
        setState(2808);
        match(PostgreSQLParser::AS);
        setState(2818);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case PostgreSQLParser::IDENTITY_P: {
            setState(2809);
            match(PostgreSQLParser::IDENTITY_P);
            setState(2811);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::OPEN_PAREN) {
              setState(2810);
              optparenthesizedseqoptlist();
            }
            break;
          }

          case PostgreSQLParser::OPEN_PAREN: {
            setState(2813);
            match(PostgreSQLParser::OPEN_PAREN);
            setState(2814);
            a_expr();
            setState(2815);
            match(PostgreSQLParser::CLOSE_PAREN);
            setState(2816);
            match(PostgreSQLParser::STORED);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case PostgreSQLParser::REFERENCES: {
        enterOuterAlt(_localctx, 8);
        setState(2820);
        match(PostgreSQLParser::REFERENCES);
        setState(2821);
        qualified_name();
        setState(2823);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::OPEN_PAREN) {
          setState(2822);
          column_list_();
        }
        setState(2826);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::MATCH) {
          setState(2825);
          key_match();
        }
        setState(2829);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::ON) {
          setState(2828);
          key_actions();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generated_whenContext ------------------------------------------------------------------

PostgreSQLParser::Generated_whenContext::Generated_whenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Generated_whenContext::ALWAYS() {
  return getToken(PostgreSQLParser::ALWAYS, 0);
}

tree::TerminalNode* PostgreSQLParser::Generated_whenContext::BY() {
  return getToken(PostgreSQLParser::BY, 0);
}

tree::TerminalNode* PostgreSQLParser::Generated_whenContext::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}


size_t PostgreSQLParser::Generated_whenContext::getRuleIndex() const {
  return PostgreSQLParser::RuleGenerated_when;
}


std::any PostgreSQLParser::Generated_whenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitGenerated_when(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Generated_whenContext* PostgreSQLParser::generated_when() {
  Generated_whenContext *_localctx = _tracker.createInstance<Generated_whenContext>(_ctx, getState());
  enterRule(_localctx, 194, PostgreSQLParser::RuleGenerated_when);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2836);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::ALWAYS: {
        enterOuterAlt(_localctx, 1);
        setState(2833);
        match(PostgreSQLParser::ALWAYS);
        break;
      }

      case PostgreSQLParser::BY: {
        enterOuterAlt(_localctx, 2);
        setState(2834);
        match(PostgreSQLParser::BY);
        setState(2835);
        match(PostgreSQLParser::DEFAULT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintattrContext ------------------------------------------------------------------

PostgreSQLParser::ConstraintattrContext::ConstraintattrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::ConstraintattrContext::DEFERRABLE() {
  return getToken(PostgreSQLParser::DEFERRABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintattrContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintattrContext::INITIALLY() {
  return getToken(PostgreSQLParser::INITIALLY, 0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintattrContext::DEFERRED() {
  return getToken(PostgreSQLParser::DEFERRED, 0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintattrContext::IMMEDIATE() {
  return getToken(PostgreSQLParser::IMMEDIATE, 0);
}


size_t PostgreSQLParser::ConstraintattrContext::getRuleIndex() const {
  return PostgreSQLParser::RuleConstraintattr;
}


std::any PostgreSQLParser::ConstraintattrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitConstraintattr(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ConstraintattrContext* PostgreSQLParser::constraintattr() {
  ConstraintattrContext *_localctx = _tracker.createInstance<ConstraintattrContext>(_ctx, getState());
  enterRule(_localctx, 196, PostgreSQLParser::RuleConstraintattr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2843);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::DEFERRABLE: {
        enterOuterAlt(_localctx, 1);
        setState(2838);
        match(PostgreSQLParser::DEFERRABLE);
        break;
      }

      case PostgreSQLParser::NOT: {
        enterOuterAlt(_localctx, 2);
        setState(2839);
        match(PostgreSQLParser::NOT);
        setState(2840);
        match(PostgreSQLParser::DEFERRABLE);
        break;
      }

      case PostgreSQLParser::INITIALLY: {
        enterOuterAlt(_localctx, 3);
        setState(2841);
        match(PostgreSQLParser::INITIALLY);
        setState(2842);
        _la = _input->LA(1);
        if (!(_la == PostgreSQLParser::DEFERRED

        || _la == PostgreSQLParser::IMMEDIATE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablelikeclauseContext ------------------------------------------------------------------

PostgreSQLParser::TablelikeclauseContext::TablelikeclauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::TablelikeclauseContext::LIKE() {
  return getToken(PostgreSQLParser::LIKE, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::TablelikeclauseContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

PostgreSQLParser::TablelikeoptionlistContext* PostgreSQLParser::TablelikeclauseContext::tablelikeoptionlist() {
  return getRuleContext<PostgreSQLParser::TablelikeoptionlistContext>(0);
}


size_t PostgreSQLParser::TablelikeclauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTablelikeclause;
}


std::any PostgreSQLParser::TablelikeclauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTablelikeclause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TablelikeclauseContext* PostgreSQLParser::tablelikeclause() {
  TablelikeclauseContext *_localctx = _tracker.createInstance<TablelikeclauseContext>(_ctx, getState());
  enterRule(_localctx, 198, PostgreSQLParser::RuleTablelikeclause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2845);
    match(PostgreSQLParser::LIKE);
    setState(2846);
    qualified_name();
    setState(2847);
    tablelikeoptionlist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablelikeoptionlistContext ------------------------------------------------------------------

PostgreSQLParser::TablelikeoptionlistContext::TablelikeoptionlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::TablelikeoptionContext *> PostgreSQLParser::TablelikeoptionlistContext::tablelikeoption() {
  return getRuleContexts<PostgreSQLParser::TablelikeoptionContext>();
}

PostgreSQLParser::TablelikeoptionContext* PostgreSQLParser::TablelikeoptionlistContext::tablelikeoption(size_t i) {
  return getRuleContext<PostgreSQLParser::TablelikeoptionContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::TablelikeoptionlistContext::INCLUDING() {
  return getTokens(PostgreSQLParser::INCLUDING);
}

tree::TerminalNode* PostgreSQLParser::TablelikeoptionlistContext::INCLUDING(size_t i) {
  return getToken(PostgreSQLParser::INCLUDING, i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::TablelikeoptionlistContext::EXCLUDING() {
  return getTokens(PostgreSQLParser::EXCLUDING);
}

tree::TerminalNode* PostgreSQLParser::TablelikeoptionlistContext::EXCLUDING(size_t i) {
  return getToken(PostgreSQLParser::EXCLUDING, i);
}


size_t PostgreSQLParser::TablelikeoptionlistContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTablelikeoptionlist;
}


std::any PostgreSQLParser::TablelikeoptionlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTablelikeoptionlist(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TablelikeoptionlistContext* PostgreSQLParser::tablelikeoptionlist() {
  TablelikeoptionlistContext *_localctx = _tracker.createInstance<TablelikeoptionlistContext>(_ctx, getState());
  enterRule(_localctx, 200, PostgreSQLParser::RuleTablelikeoptionlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2853);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::EXCLUDING

    || _la == PostgreSQLParser::INCLUDING) {
      setState(2849);
      _la = _input->LA(1);
      if (!(_la == PostgreSQLParser::EXCLUDING

      || _la == PostgreSQLParser::INCLUDING)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2850);
      tablelikeoption();
      setState(2855);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablelikeoptionContext ------------------------------------------------------------------

PostgreSQLParser::TablelikeoptionContext::TablelikeoptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::TablelikeoptionContext::COMMENTS() {
  return getToken(PostgreSQLParser::COMMENTS, 0);
}

tree::TerminalNode* PostgreSQLParser::TablelikeoptionContext::CONSTRAINTS() {
  return getToken(PostgreSQLParser::CONSTRAINTS, 0);
}

tree::TerminalNode* PostgreSQLParser::TablelikeoptionContext::DEFAULTS() {
  return getToken(PostgreSQLParser::DEFAULTS, 0);
}

tree::TerminalNode* PostgreSQLParser::TablelikeoptionContext::IDENTITY_P() {
  return getToken(PostgreSQLParser::IDENTITY_P, 0);
}

tree::TerminalNode* PostgreSQLParser::TablelikeoptionContext::GENERATED() {
  return getToken(PostgreSQLParser::GENERATED, 0);
}

tree::TerminalNode* PostgreSQLParser::TablelikeoptionContext::INDEXES() {
  return getToken(PostgreSQLParser::INDEXES, 0);
}

tree::TerminalNode* PostgreSQLParser::TablelikeoptionContext::STATISTICS() {
  return getToken(PostgreSQLParser::STATISTICS, 0);
}

tree::TerminalNode* PostgreSQLParser::TablelikeoptionContext::STORAGE() {
  return getToken(PostgreSQLParser::STORAGE, 0);
}

tree::TerminalNode* PostgreSQLParser::TablelikeoptionContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}


size_t PostgreSQLParser::TablelikeoptionContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTablelikeoption;
}


std::any PostgreSQLParser::TablelikeoptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTablelikeoption(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TablelikeoptionContext* PostgreSQLParser::tablelikeoption() {
  TablelikeoptionContext *_localctx = _tracker.createInstance<TablelikeoptionContext>(_ctx, getState());
  enterRule(_localctx, 202, PostgreSQLParser::RuleTablelikeoption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2856);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::ALL || ((((_la - 198) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 198)) & 576460752303947809) != 0) || _la == PostgreSQLParser::INDEXES || _la == PostgreSQLParser::STATISTICS

    || _la == PostgreSQLParser::STORAGE || _la == PostgreSQLParser::GENERATED)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableconstraintContext ------------------------------------------------------------------

PostgreSQLParser::TableconstraintContext::TableconstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::TableconstraintContext::CONSTRAINT() {
  return getToken(PostgreSQLParser::CONSTRAINT, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::TableconstraintContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::ConstraintelemContext* PostgreSQLParser::TableconstraintContext::constraintelem() {
  return getRuleContext<PostgreSQLParser::ConstraintelemContext>(0);
}


size_t PostgreSQLParser::TableconstraintContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTableconstraint;
}


std::any PostgreSQLParser::TableconstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTableconstraint(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TableconstraintContext* PostgreSQLParser::tableconstraint() {
  TableconstraintContext *_localctx = _tracker.createInstance<TableconstraintContext>(_ctx, getState());
  enterRule(_localctx, 204, PostgreSQLParser::RuleTableconstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2863);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::CONSTRAINT: {
        enterOuterAlt(_localctx, 1);
        setState(2858);
        match(PostgreSQLParser::CONSTRAINT);
        setState(2859);
        name();
        setState(2860);
        constraintelem();
        break;
      }

      case PostgreSQLParser::CHECK:
      case PostgreSQLParser::FOREIGN:
      case PostgreSQLParser::PRIMARY:
      case PostgreSQLParser::UNIQUE:
      case PostgreSQLParser::EXCLUDE: {
        enterOuterAlt(_localctx, 2);
        setState(2862);
        constraintelem();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintelemContext ------------------------------------------------------------------

PostgreSQLParser::ConstraintelemContext::ConstraintelemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::ConstraintelemContext::CHECK() {
  return getToken(PostgreSQLParser::CHECK, 0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintelemContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::ConstraintelemContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintelemContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::ConstraintattributespecContext* PostgreSQLParser::ConstraintelemContext::constraintattributespec() {
  return getRuleContext<PostgreSQLParser::ConstraintattributespecContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintelemContext::UNIQUE() {
  return getToken(PostgreSQLParser::UNIQUE, 0);
}

PostgreSQLParser::ColumnlistContext* PostgreSQLParser::ConstraintelemContext::columnlist() {
  return getRuleContext<PostgreSQLParser::ColumnlistContext>(0);
}

PostgreSQLParser::ExistingindexContext* PostgreSQLParser::ConstraintelemContext::existingindex() {
  return getRuleContext<PostgreSQLParser::ExistingindexContext>(0);
}

PostgreSQLParser::C_include_Context* PostgreSQLParser::ConstraintelemContext::c_include_() {
  return getRuleContext<PostgreSQLParser::C_include_Context>(0);
}

PostgreSQLParser::Definition_Context* PostgreSQLParser::ConstraintelemContext::definition_() {
  return getRuleContext<PostgreSQLParser::Definition_Context>(0);
}

PostgreSQLParser::OptconstablespaceContext* PostgreSQLParser::ConstraintelemContext::optconstablespace() {
  return getRuleContext<PostgreSQLParser::OptconstablespaceContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintelemContext::PRIMARY() {
  return getToken(PostgreSQLParser::PRIMARY, 0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintelemContext::KEY() {
  return getToken(PostgreSQLParser::KEY, 0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintelemContext::EXCLUDE() {
  return getToken(PostgreSQLParser::EXCLUDE, 0);
}

PostgreSQLParser::ExclusionconstraintlistContext* PostgreSQLParser::ConstraintelemContext::exclusionconstraintlist() {
  return getRuleContext<PostgreSQLParser::ExclusionconstraintlistContext>(0);
}

PostgreSQLParser::Access_method_clauseContext* PostgreSQLParser::ConstraintelemContext::access_method_clause() {
  return getRuleContext<PostgreSQLParser::Access_method_clauseContext>(0);
}

PostgreSQLParser::ExclusionwhereclauseContext* PostgreSQLParser::ConstraintelemContext::exclusionwhereclause() {
  return getRuleContext<PostgreSQLParser::ExclusionwhereclauseContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintelemContext::FOREIGN() {
  return getToken(PostgreSQLParser::FOREIGN, 0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintelemContext::REFERENCES() {
  return getToken(PostgreSQLParser::REFERENCES, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::ConstraintelemContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

PostgreSQLParser::Column_list_Context* PostgreSQLParser::ConstraintelemContext::column_list_() {
  return getRuleContext<PostgreSQLParser::Column_list_Context>(0);
}

PostgreSQLParser::Key_matchContext* PostgreSQLParser::ConstraintelemContext::key_match() {
  return getRuleContext<PostgreSQLParser::Key_matchContext>(0);
}

PostgreSQLParser::Key_actionsContext* PostgreSQLParser::ConstraintelemContext::key_actions() {
  return getRuleContext<PostgreSQLParser::Key_actionsContext>(0);
}


size_t PostgreSQLParser::ConstraintelemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleConstraintelem;
}


std::any PostgreSQLParser::ConstraintelemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitConstraintelem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ConstraintelemContext* PostgreSQLParser::constraintelem() {
  ConstraintelemContext *_localctx = _tracker.createInstance<ConstraintelemContext>(_ctx, getState());
  enterRule(_localctx, 206, PostgreSQLParser::RuleConstraintelem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2951);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::CHECK: {
        enterOuterAlt(_localctx, 1);
        setState(2865);
        match(PostgreSQLParser::CHECK);
        setState(2866);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(2867);
        a_expr();
        setState(2868);
        match(PostgreSQLParser::CLOSE_PAREN);
        setState(2869);
        constraintattributespec();
        break;
      }

      case PostgreSQLParser::UNIQUE: {
        enterOuterAlt(_localctx, 2);
        setState(2871);
        match(PostgreSQLParser::UNIQUE);
        setState(2889);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case PostgreSQLParser::OPEN_PAREN: {
            setState(2872);
            match(PostgreSQLParser::OPEN_PAREN);
            setState(2873);
            columnlist();
            setState(2874);
            match(PostgreSQLParser::CLOSE_PAREN);
            setState(2876);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::INCLUDE) {
              setState(2875);
              c_include_();
            }
            setState(2879);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::WITH) {
              setState(2878);
              definition_();
            }
            setState(2882);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::USING) {
              setState(2881);
              optconstablespace();
            }
            setState(2884);
            constraintattributespec();
            break;
          }

          case PostgreSQLParser::USING: {
            setState(2886);
            existingindex();
            setState(2887);
            constraintattributespec();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case PostgreSQLParser::PRIMARY: {
        enterOuterAlt(_localctx, 3);
        setState(2891);
        match(PostgreSQLParser::PRIMARY);
        setState(2892);
        match(PostgreSQLParser::KEY);
        setState(2910);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case PostgreSQLParser::OPEN_PAREN: {
            setState(2893);
            match(PostgreSQLParser::OPEN_PAREN);
            setState(2894);
            columnlist();
            setState(2895);
            match(PostgreSQLParser::CLOSE_PAREN);
            setState(2897);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::INCLUDE) {
              setState(2896);
              c_include_();
            }
            setState(2900);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::WITH) {
              setState(2899);
              definition_();
            }
            setState(2903);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::USING) {
              setState(2902);
              optconstablespace();
            }
            setState(2905);
            constraintattributespec();
            break;
          }

          case PostgreSQLParser::USING: {
            setState(2907);
            existingindex();
            setState(2908);
            constraintattributespec();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case PostgreSQLParser::EXCLUDE: {
        enterOuterAlt(_localctx, 4);
        setState(2912);
        match(PostgreSQLParser::EXCLUDE);
        setState(2914);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::USING) {
          setState(2913);
          access_method_clause();
        }
        setState(2916);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(2917);
        exclusionconstraintlist();
        setState(2918);
        match(PostgreSQLParser::CLOSE_PAREN);
        setState(2920);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::INCLUDE) {
          setState(2919);
          c_include_();
        }
        setState(2923);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::WITH) {
          setState(2922);
          definition_();
        }
        setState(2926);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::USING) {
          setState(2925);
          optconstablespace();
        }
        setState(2929);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::WHERE) {
          setState(2928);
          exclusionwhereclause();
        }
        setState(2931);
        constraintattributespec();
        break;
      }

      case PostgreSQLParser::FOREIGN: {
        enterOuterAlt(_localctx, 5);
        setState(2933);
        match(PostgreSQLParser::FOREIGN);
        setState(2934);
        match(PostgreSQLParser::KEY);
        setState(2935);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(2936);
        columnlist();
        setState(2937);
        match(PostgreSQLParser::CLOSE_PAREN);
        setState(2938);
        match(PostgreSQLParser::REFERENCES);
        setState(2939);
        qualified_name();
        setState(2941);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::OPEN_PAREN) {
          setState(2940);
          column_list_();
        }
        setState(2944);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::MATCH) {
          setState(2943);
          key_match();
        }
        setState(2947);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::ON) {
          setState(2946);
          key_actions();
        }
        setState(2949);
        constraintattributespec();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- No_inherit_Context ------------------------------------------------------------------

PostgreSQLParser::No_inherit_Context::No_inherit_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::No_inherit_Context::NO() {
  return getToken(PostgreSQLParser::NO, 0);
}

tree::TerminalNode* PostgreSQLParser::No_inherit_Context::INHERIT() {
  return getToken(PostgreSQLParser::INHERIT, 0);
}


size_t PostgreSQLParser::No_inherit_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleNo_inherit_;
}


std::any PostgreSQLParser::No_inherit_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitNo_inherit_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::No_inherit_Context* PostgreSQLParser::no_inherit_() {
  No_inherit_Context *_localctx = _tracker.createInstance<No_inherit_Context>(_ctx, getState());
  enterRule(_localctx, 208, PostgreSQLParser::RuleNo_inherit_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2953);
    match(PostgreSQLParser::NO);
    setState(2954);
    match(PostgreSQLParser::INHERIT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_list_Context ------------------------------------------------------------------

PostgreSQLParser::Column_list_Context::Column_list_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Column_list_Context::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::ColumnlistContext* PostgreSQLParser::Column_list_Context::columnlist() {
  return getRuleContext<PostgreSQLParser::ColumnlistContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Column_list_Context::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Column_list_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleColumn_list_;
}


std::any PostgreSQLParser::Column_list_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitColumn_list_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Column_list_Context* PostgreSQLParser::column_list_() {
  Column_list_Context *_localctx = _tracker.createInstance<Column_list_Context>(_ctx, getState());
  enterRule(_localctx, 210, PostgreSQLParser::RuleColumn_list_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2956);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(2957);
    columnlist();
    setState(2958);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnlistContext ------------------------------------------------------------------

PostgreSQLParser::ColumnlistContext::ColumnlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::ColumnElemContext *> PostgreSQLParser::ColumnlistContext::columnElem() {
  return getRuleContexts<PostgreSQLParser::ColumnElemContext>();
}

PostgreSQLParser::ColumnElemContext* PostgreSQLParser::ColumnlistContext::columnElem(size_t i) {
  return getRuleContext<PostgreSQLParser::ColumnElemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::ColumnlistContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::ColumnlistContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::ColumnlistContext::getRuleIndex() const {
  return PostgreSQLParser::RuleColumnlist;
}


std::any PostgreSQLParser::ColumnlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitColumnlist(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ColumnlistContext* PostgreSQLParser::columnlist() {
  ColumnlistContext *_localctx = _tracker.createInstance<ColumnlistContext>(_ctx, getState());
  enterRule(_localctx, 212, PostgreSQLParser::RuleColumnlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2960);
    columnElem();
    setState(2965);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(2961);
      match(PostgreSQLParser::COMMA);
      setState(2962);
      columnElem();
      setState(2967);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnElemContext ------------------------------------------------------------------

PostgreSQLParser::ColumnElemContext::ColumnElemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::ColumnElemContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}


size_t PostgreSQLParser::ColumnElemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleColumnElem;
}


std::any PostgreSQLParser::ColumnElemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitColumnElem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ColumnElemContext* PostgreSQLParser::columnElem() {
  ColumnElemContext *_localctx = _tracker.createInstance<ColumnElemContext>(_ctx, getState());
  enterRule(_localctx, 214, PostgreSQLParser::RuleColumnElem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2968);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- C_include_Context ------------------------------------------------------------------

PostgreSQLParser::C_include_Context::C_include_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::C_include_Context::INCLUDE() {
  return getToken(PostgreSQLParser::INCLUDE, 0);
}

tree::TerminalNode* PostgreSQLParser::C_include_Context::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::ColumnlistContext* PostgreSQLParser::C_include_Context::columnlist() {
  return getRuleContext<PostgreSQLParser::ColumnlistContext>(0);
}

tree::TerminalNode* PostgreSQLParser::C_include_Context::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::C_include_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleC_include_;
}


std::any PostgreSQLParser::C_include_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitC_include_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::C_include_Context* PostgreSQLParser::c_include_() {
  C_include_Context *_localctx = _tracker.createInstance<C_include_Context>(_ctx, getState());
  enterRule(_localctx, 216, PostgreSQLParser::RuleC_include_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2970);
    match(PostgreSQLParser::INCLUDE);
    setState(2971);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(2972);
    columnlist();
    setState(2973);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Key_matchContext ------------------------------------------------------------------

PostgreSQLParser::Key_matchContext::Key_matchContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Key_matchContext::MATCH() {
  return getToken(PostgreSQLParser::MATCH, 0);
}

tree::TerminalNode* PostgreSQLParser::Key_matchContext::FULL() {
  return getToken(PostgreSQLParser::FULL, 0);
}

tree::TerminalNode* PostgreSQLParser::Key_matchContext::PARTIAL() {
  return getToken(PostgreSQLParser::PARTIAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Key_matchContext::SIMPLE() {
  return getToken(PostgreSQLParser::SIMPLE, 0);
}


size_t PostgreSQLParser::Key_matchContext::getRuleIndex() const {
  return PostgreSQLParser::RuleKey_match;
}


std::any PostgreSQLParser::Key_matchContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitKey_match(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Key_matchContext* PostgreSQLParser::key_match() {
  Key_matchContext *_localctx = _tracker.createInstance<Key_matchContext>(_ctx, getState());
  enterRule(_localctx, 218, PostgreSQLParser::RuleKey_match);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2975);
    match(PostgreSQLParser::MATCH);
    setState(2976);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::FULL || _la == PostgreSQLParser::PARTIAL

    || _la == PostgreSQLParser::SIMPLE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExclusionconstraintlistContext ------------------------------------------------------------------

PostgreSQLParser::ExclusionconstraintlistContext::ExclusionconstraintlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::ExclusionconstraintelemContext *> PostgreSQLParser::ExclusionconstraintlistContext::exclusionconstraintelem() {
  return getRuleContexts<PostgreSQLParser::ExclusionconstraintelemContext>();
}

PostgreSQLParser::ExclusionconstraintelemContext* PostgreSQLParser::ExclusionconstraintlistContext::exclusionconstraintelem(size_t i) {
  return getRuleContext<PostgreSQLParser::ExclusionconstraintelemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::ExclusionconstraintlistContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::ExclusionconstraintlistContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::ExclusionconstraintlistContext::getRuleIndex() const {
  return PostgreSQLParser::RuleExclusionconstraintlist;
}


std::any PostgreSQLParser::ExclusionconstraintlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitExclusionconstraintlist(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ExclusionconstraintlistContext* PostgreSQLParser::exclusionconstraintlist() {
  ExclusionconstraintlistContext *_localctx = _tracker.createInstance<ExclusionconstraintlistContext>(_ctx, getState());
  enterRule(_localctx, 220, PostgreSQLParser::RuleExclusionconstraintlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2978);
    exclusionconstraintelem();
    setState(2983);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(2979);
      match(PostgreSQLParser::COMMA);
      setState(2980);
      exclusionconstraintelem();
      setState(2985);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExclusionconstraintelemContext ------------------------------------------------------------------

PostgreSQLParser::ExclusionconstraintelemContext::ExclusionconstraintelemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Index_elemContext* PostgreSQLParser::ExclusionconstraintelemContext::index_elem() {
  return getRuleContext<PostgreSQLParser::Index_elemContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ExclusionconstraintelemContext::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

PostgreSQLParser::Any_operatorContext* PostgreSQLParser::ExclusionconstraintelemContext::any_operator() {
  return getRuleContext<PostgreSQLParser::Any_operatorContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ExclusionconstraintelemContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

tree::TerminalNode* PostgreSQLParser::ExclusionconstraintelemContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::ExclusionconstraintelemContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::ExclusionconstraintelemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleExclusionconstraintelem;
}


std::any PostgreSQLParser::ExclusionconstraintelemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitExclusionconstraintelem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ExclusionconstraintelemContext* PostgreSQLParser::exclusionconstraintelem() {
  ExclusionconstraintelemContext *_localctx = _tracker.createInstance<ExclusionconstraintelemContext>(_ctx, getState());
  enterRule(_localctx, 222, PostgreSQLParser::RuleExclusionconstraintelem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2986);
    index_elem();
    setState(2987);
    match(PostgreSQLParser::WITH);
    setState(2994);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 193, _ctx)) {
    case 1: {
      setState(2988);
      any_operator();
      break;
    }

    case 2: {
      setState(2989);
      match(PostgreSQLParser::OPERATOR);
      setState(2990);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(2991);
      any_operator();
      setState(2992);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExclusionwhereclauseContext ------------------------------------------------------------------

PostgreSQLParser::ExclusionwhereclauseContext::ExclusionwhereclauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::ExclusionwhereclauseContext::WHERE() {
  return getToken(PostgreSQLParser::WHERE, 0);
}

tree::TerminalNode* PostgreSQLParser::ExclusionwhereclauseContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::ExclusionwhereclauseContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ExclusionwhereclauseContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::ExclusionwhereclauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleExclusionwhereclause;
}


std::any PostgreSQLParser::ExclusionwhereclauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitExclusionwhereclause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ExclusionwhereclauseContext* PostgreSQLParser::exclusionwhereclause() {
  ExclusionwhereclauseContext *_localctx = _tracker.createInstance<ExclusionwhereclauseContext>(_ctx, getState());
  enterRule(_localctx, 224, PostgreSQLParser::RuleExclusionwhereclause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2996);
    match(PostgreSQLParser::WHERE);
    setState(2997);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(2998);
    a_expr();
    setState(2999);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Key_actionsContext ------------------------------------------------------------------

PostgreSQLParser::Key_actionsContext::Key_actionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Key_updateContext* PostgreSQLParser::Key_actionsContext::key_update() {
  return getRuleContext<PostgreSQLParser::Key_updateContext>(0);
}

PostgreSQLParser::Key_deleteContext* PostgreSQLParser::Key_actionsContext::key_delete() {
  return getRuleContext<PostgreSQLParser::Key_deleteContext>(0);
}


size_t PostgreSQLParser::Key_actionsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleKey_actions;
}


std::any PostgreSQLParser::Key_actionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitKey_actions(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Key_actionsContext* PostgreSQLParser::key_actions() {
  Key_actionsContext *_localctx = _tracker.createInstance<Key_actionsContext>(_ctx, getState());
  enterRule(_localctx, 226, PostgreSQLParser::RuleKey_actions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3009);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 194, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3001);
      key_update();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3002);
      key_delete();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3003);
      key_update();
      setState(3004);
      key_delete();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3006);
      key_delete();
      setState(3007);
      key_update();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Key_updateContext ------------------------------------------------------------------

PostgreSQLParser::Key_updateContext::Key_updateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Key_updateContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

tree::TerminalNode* PostgreSQLParser::Key_updateContext::UPDATE() {
  return getToken(PostgreSQLParser::UPDATE, 0);
}

PostgreSQLParser::Key_actionContext* PostgreSQLParser::Key_updateContext::key_action() {
  return getRuleContext<PostgreSQLParser::Key_actionContext>(0);
}


size_t PostgreSQLParser::Key_updateContext::getRuleIndex() const {
  return PostgreSQLParser::RuleKey_update;
}


std::any PostgreSQLParser::Key_updateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitKey_update(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Key_updateContext* PostgreSQLParser::key_update() {
  Key_updateContext *_localctx = _tracker.createInstance<Key_updateContext>(_ctx, getState());
  enterRule(_localctx, 228, PostgreSQLParser::RuleKey_update);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3011);
    match(PostgreSQLParser::ON);
    setState(3012);
    match(PostgreSQLParser::UPDATE);
    setState(3013);
    key_action();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Key_deleteContext ------------------------------------------------------------------

PostgreSQLParser::Key_deleteContext::Key_deleteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Key_deleteContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

tree::TerminalNode* PostgreSQLParser::Key_deleteContext::DELETE_P() {
  return getToken(PostgreSQLParser::DELETE_P, 0);
}

PostgreSQLParser::Key_actionContext* PostgreSQLParser::Key_deleteContext::key_action() {
  return getRuleContext<PostgreSQLParser::Key_actionContext>(0);
}


size_t PostgreSQLParser::Key_deleteContext::getRuleIndex() const {
  return PostgreSQLParser::RuleKey_delete;
}


std::any PostgreSQLParser::Key_deleteContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitKey_delete(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Key_deleteContext* PostgreSQLParser::key_delete() {
  Key_deleteContext *_localctx = _tracker.createInstance<Key_deleteContext>(_ctx, getState());
  enterRule(_localctx, 230, PostgreSQLParser::RuleKey_delete);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3015);
    match(PostgreSQLParser::ON);
    setState(3016);
    match(PostgreSQLParser::DELETE_P);
    setState(3017);
    key_action();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Key_actionContext ------------------------------------------------------------------

PostgreSQLParser::Key_actionContext::Key_actionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Key_actionContext::NO() {
  return getToken(PostgreSQLParser::NO, 0);
}

tree::TerminalNode* PostgreSQLParser::Key_actionContext::ACTION() {
  return getToken(PostgreSQLParser::ACTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Key_actionContext::RESTRICT() {
  return getToken(PostgreSQLParser::RESTRICT, 0);
}

tree::TerminalNode* PostgreSQLParser::Key_actionContext::CASCADE() {
  return getToken(PostgreSQLParser::CASCADE, 0);
}

tree::TerminalNode* PostgreSQLParser::Key_actionContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

tree::TerminalNode* PostgreSQLParser::Key_actionContext::NULL_P() {
  return getToken(PostgreSQLParser::NULL_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Key_actionContext::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}


size_t PostgreSQLParser::Key_actionContext::getRuleIndex() const {
  return PostgreSQLParser::RuleKey_action;
}


std::any PostgreSQLParser::Key_actionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitKey_action(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Key_actionContext* PostgreSQLParser::key_action() {
  Key_actionContext *_localctx = _tracker.createInstance<Key_actionContext>(_ctx, getState());
  enterRule(_localctx, 232, PostgreSQLParser::RuleKey_action);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3025);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::NO: {
        enterOuterAlt(_localctx, 1);
        setState(3019);
        match(PostgreSQLParser::NO);
        setState(3020);
        match(PostgreSQLParser::ACTION);
        break;
      }

      case PostgreSQLParser::RESTRICT: {
        enterOuterAlt(_localctx, 2);
        setState(3021);
        match(PostgreSQLParser::RESTRICT);
        break;
      }

      case PostgreSQLParser::CASCADE: {
        enterOuterAlt(_localctx, 3);
        setState(3022);
        match(PostgreSQLParser::CASCADE);
        break;
      }

      case PostgreSQLParser::SET: {
        enterOuterAlt(_localctx, 4);
        setState(3023);
        match(PostgreSQLParser::SET);
        setState(3024);
        _la = _input->LA(1);
        if (!(_la == PostgreSQLParser::DEFAULT

        || _la == PostgreSQLParser::NULL_P)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptinheritContext ------------------------------------------------------------------

PostgreSQLParser::OptinheritContext::OptinheritContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::OptinheritContext::INHERITS() {
  return getToken(PostgreSQLParser::INHERITS, 0);
}

tree::TerminalNode* PostgreSQLParser::OptinheritContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Qualified_name_listContext* PostgreSQLParser::OptinheritContext::qualified_name_list() {
  return getRuleContext<PostgreSQLParser::Qualified_name_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::OptinheritContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::OptinheritContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOptinherit;
}


std::any PostgreSQLParser::OptinheritContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOptinherit(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::OptinheritContext* PostgreSQLParser::optinherit() {
  OptinheritContext *_localctx = _tracker.createInstance<OptinheritContext>(_ctx, getState());
  enterRule(_localctx, 234, PostgreSQLParser::RuleOptinherit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3027);
    match(PostgreSQLParser::INHERITS);
    setState(3028);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(3029);
    qualified_name_list();
    setState(3030);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptpartitionspecContext ------------------------------------------------------------------

PostgreSQLParser::OptpartitionspecContext::OptpartitionspecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::PartitionspecContext* PostgreSQLParser::OptpartitionspecContext::partitionspec() {
  return getRuleContext<PostgreSQLParser::PartitionspecContext>(0);
}


size_t PostgreSQLParser::OptpartitionspecContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOptpartitionspec;
}


std::any PostgreSQLParser::OptpartitionspecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOptpartitionspec(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::OptpartitionspecContext* PostgreSQLParser::optpartitionspec() {
  OptpartitionspecContext *_localctx = _tracker.createInstance<OptpartitionspecContext>(_ctx, getState());
  enterRule(_localctx, 236, PostgreSQLParser::RuleOptpartitionspec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3032);
    partitionspec();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionspecContext ------------------------------------------------------------------

PostgreSQLParser::PartitionspecContext::PartitionspecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::PartitionspecContext::PARTITION() {
  return getToken(PostgreSQLParser::PARTITION, 0);
}

tree::TerminalNode* PostgreSQLParser::PartitionspecContext::BY() {
  return getToken(PostgreSQLParser::BY, 0);
}

PostgreSQLParser::ColidContext* PostgreSQLParser::PartitionspecContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

tree::TerminalNode* PostgreSQLParser::PartitionspecContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Part_paramsContext* PostgreSQLParser::PartitionspecContext::part_params() {
  return getRuleContext<PostgreSQLParser::Part_paramsContext>(0);
}

tree::TerminalNode* PostgreSQLParser::PartitionspecContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::PartitionspecContext::getRuleIndex() const {
  return PostgreSQLParser::RulePartitionspec;
}


std::any PostgreSQLParser::PartitionspecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitPartitionspec(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::PartitionspecContext* PostgreSQLParser::partitionspec() {
  PartitionspecContext *_localctx = _tracker.createInstance<PartitionspecContext>(_ctx, getState());
  enterRule(_localctx, 238, PostgreSQLParser::RulePartitionspec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3034);
    match(PostgreSQLParser::PARTITION);
    setState(3035);
    match(PostgreSQLParser::BY);
    setState(3036);
    colid();
    setState(3037);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(3038);
    part_params();
    setState(3039);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Part_paramsContext ------------------------------------------------------------------

PostgreSQLParser::Part_paramsContext::Part_paramsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Part_elemContext *> PostgreSQLParser::Part_paramsContext::part_elem() {
  return getRuleContexts<PostgreSQLParser::Part_elemContext>();
}

PostgreSQLParser::Part_elemContext* PostgreSQLParser::Part_paramsContext::part_elem(size_t i) {
  return getRuleContext<PostgreSQLParser::Part_elemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Part_paramsContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Part_paramsContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Part_paramsContext::getRuleIndex() const {
  return PostgreSQLParser::RulePart_params;
}


std::any PostgreSQLParser::Part_paramsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitPart_params(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Part_paramsContext* PostgreSQLParser::part_params() {
  Part_paramsContext *_localctx = _tracker.createInstance<Part_paramsContext>(_ctx, getState());
  enterRule(_localctx, 240, PostgreSQLParser::RulePart_params);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3041);
    part_elem();
    setState(3046);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(3042);
      match(PostgreSQLParser::COMMA);
      setState(3043);
      part_elem();
      setState(3048);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Part_elemContext ------------------------------------------------------------------

PostgreSQLParser::Part_elemContext::Part_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Part_elemContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

PostgreSQLParser::Collate_Context* PostgreSQLParser::Part_elemContext::collate_() {
  return getRuleContext<PostgreSQLParser::Collate_Context>(0);
}

PostgreSQLParser::Class_Context* PostgreSQLParser::Part_elemContext::class_() {
  return getRuleContext<PostgreSQLParser::Class_Context>(0);
}

PostgreSQLParser::Func_expr_windowlessContext* PostgreSQLParser::Part_elemContext::func_expr_windowless() {
  return getRuleContext<PostgreSQLParser::Func_expr_windowlessContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Part_elemContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Part_elemContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Part_elemContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Part_elemContext::getRuleIndex() const {
  return PostgreSQLParser::RulePart_elem;
}


std::any PostgreSQLParser::Part_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitPart_elem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Part_elemContext* PostgreSQLParser::part_elem() {
  Part_elemContext *_localctx = _tracker.createInstance<Part_elemContext>(_ctx, getState());
  enterRule(_localctx, 242, PostgreSQLParser::RulePart_elem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3072);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 203, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3049);
      colid();
      setState(3051);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLLATE) {
        setState(3050);
        collate_();
      }
      setState(3054);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 30) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 30)) & 137438949375) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 553)) & 536870983) != 0)) {
        setState(3053);
        class_();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3056);
      func_expr_windowless();
      setState(3058);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLLATE) {
        setState(3057);
        collate_();
      }
      setState(3061);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 30) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 30)) & 137438949375) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 553)) & 536870983) != 0)) {
        setState(3060);
        class_();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3063);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(3064);
      a_expr();
      setState(3065);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(3067);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLLATE) {
        setState(3066);
        collate_();
      }
      setState(3070);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 30) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 30)) & 137438949375) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 553)) & 536870983) != 0)) {
        setState(3069);
        class_();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_access_method_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Table_access_method_clauseContext::Table_access_method_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Table_access_method_clauseContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::Table_access_method_clauseContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}


size_t PostgreSQLParser::Table_access_method_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTable_access_method_clause;
}


std::any PostgreSQLParser::Table_access_method_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTable_access_method_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Table_access_method_clauseContext* PostgreSQLParser::table_access_method_clause() {
  Table_access_method_clauseContext *_localctx = _tracker.createInstance<Table_access_method_clauseContext>(_ctx, getState());
  enterRule(_localctx, 244, PostgreSQLParser::RuleTable_access_method_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3074);
    match(PostgreSQLParser::USING);
    setState(3075);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptwithContext ------------------------------------------------------------------

PostgreSQLParser::OptwithContext::OptwithContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::OptwithContext::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

PostgreSQLParser::ReloptionsContext* PostgreSQLParser::OptwithContext::reloptions() {
  return getRuleContext<PostgreSQLParser::ReloptionsContext>(0);
}

tree::TerminalNode* PostgreSQLParser::OptwithContext::WITHOUT() {
  return getToken(PostgreSQLParser::WITHOUT, 0);
}

tree::TerminalNode* PostgreSQLParser::OptwithContext::OIDS() {
  return getToken(PostgreSQLParser::OIDS, 0);
}


size_t PostgreSQLParser::OptwithContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOptwith;
}


std::any PostgreSQLParser::OptwithContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOptwith(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::OptwithContext* PostgreSQLParser::optwith() {
  OptwithContext *_localctx = _tracker.createInstance<OptwithContext>(_ctx, getState());
  enterRule(_localctx, 246, PostgreSQLParser::RuleOptwith);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3081);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::WITH: {
        enterOuterAlt(_localctx, 1);
        setState(3077);
        match(PostgreSQLParser::WITH);
        setState(3078);
        reloptions();
        break;
      }

      case PostgreSQLParser::WITHOUT: {
        enterOuterAlt(_localctx, 2);
        setState(3079);
        match(PostgreSQLParser::WITHOUT);
        setState(3080);
        match(PostgreSQLParser::OIDS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OncommitoptionContext ------------------------------------------------------------------

PostgreSQLParser::OncommitoptionContext::OncommitoptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::OncommitoptionContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

tree::TerminalNode* PostgreSQLParser::OncommitoptionContext::COMMIT() {
  return getToken(PostgreSQLParser::COMMIT, 0);
}

tree::TerminalNode* PostgreSQLParser::OncommitoptionContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

tree::TerminalNode* PostgreSQLParser::OncommitoptionContext::DELETE_P() {
  return getToken(PostgreSQLParser::DELETE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::OncommitoptionContext::ROWS() {
  return getToken(PostgreSQLParser::ROWS, 0);
}

tree::TerminalNode* PostgreSQLParser::OncommitoptionContext::PRESERVE() {
  return getToken(PostgreSQLParser::PRESERVE, 0);
}


size_t PostgreSQLParser::OncommitoptionContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOncommitoption;
}


std::any PostgreSQLParser::OncommitoptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOncommitoption(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::OncommitoptionContext* PostgreSQLParser::oncommitoption() {
  OncommitoptionContext *_localctx = _tracker.createInstance<OncommitoptionContext>(_ctx, getState());
  enterRule(_localctx, 248, PostgreSQLParser::RuleOncommitoption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3083);
    match(PostgreSQLParser::ON);
    setState(3084);
    match(PostgreSQLParser::COMMIT);
    setState(3090);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::DROP: {
        setState(3085);
        match(PostgreSQLParser::DROP);
        break;
      }

      case PostgreSQLParser::DELETE_P: {
        setState(3086);
        match(PostgreSQLParser::DELETE_P);
        setState(3087);
        match(PostgreSQLParser::ROWS);
        break;
      }

      case PostgreSQLParser::PRESERVE: {
        setState(3088);
        match(PostgreSQLParser::PRESERVE);
        setState(3089);
        match(PostgreSQLParser::ROWS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OpttablespaceContext ------------------------------------------------------------------

PostgreSQLParser::OpttablespaceContext::OpttablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::OpttablespaceContext::TABLESPACE() {
  return getToken(PostgreSQLParser::TABLESPACE, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::OpttablespaceContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}


size_t PostgreSQLParser::OpttablespaceContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOpttablespace;
}


std::any PostgreSQLParser::OpttablespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOpttablespace(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::OpttablespaceContext* PostgreSQLParser::opttablespace() {
  OpttablespaceContext *_localctx = _tracker.createInstance<OpttablespaceContext>(_ctx, getState());
  enterRule(_localctx, 250, PostgreSQLParser::RuleOpttablespace);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3092);
    match(PostgreSQLParser::TABLESPACE);
    setState(3093);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptconstablespaceContext ------------------------------------------------------------------

PostgreSQLParser::OptconstablespaceContext::OptconstablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::OptconstablespaceContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

tree::TerminalNode* PostgreSQLParser::OptconstablespaceContext::INDEX() {
  return getToken(PostgreSQLParser::INDEX, 0);
}

tree::TerminalNode* PostgreSQLParser::OptconstablespaceContext::TABLESPACE() {
  return getToken(PostgreSQLParser::TABLESPACE, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::OptconstablespaceContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}


size_t PostgreSQLParser::OptconstablespaceContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOptconstablespace;
}


std::any PostgreSQLParser::OptconstablespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOptconstablespace(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::OptconstablespaceContext* PostgreSQLParser::optconstablespace() {
  OptconstablespaceContext *_localctx = _tracker.createInstance<OptconstablespaceContext>(_ctx, getState());
  enterRule(_localctx, 252, PostgreSQLParser::RuleOptconstablespace);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3095);
    match(PostgreSQLParser::USING);
    setState(3096);
    match(PostgreSQLParser::INDEX);
    setState(3097);
    match(PostgreSQLParser::TABLESPACE);
    setState(3098);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExistingindexContext ------------------------------------------------------------------

PostgreSQLParser::ExistingindexContext::ExistingindexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::ExistingindexContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

tree::TerminalNode* PostgreSQLParser::ExistingindexContext::INDEX() {
  return getToken(PostgreSQLParser::INDEX, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::ExistingindexContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}


size_t PostgreSQLParser::ExistingindexContext::getRuleIndex() const {
  return PostgreSQLParser::RuleExistingindex;
}


std::any PostgreSQLParser::ExistingindexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitExistingindex(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ExistingindexContext* PostgreSQLParser::existingindex() {
  ExistingindexContext *_localctx = _tracker.createInstance<ExistingindexContext>(_ctx, getState());
  enterRule(_localctx, 254, PostgreSQLParser::RuleExistingindex);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3100);
    match(PostgreSQLParser::USING);
    setState(3101);
    match(PostgreSQLParser::INDEX);
    setState(3102);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreatestatsstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreatestatsstmtContext::CreatestatsstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreatestatsstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatestatsstmtContext::STATISTICS() {
  return getToken(PostgreSQLParser::STATISTICS, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::CreatestatsstmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatestatsstmtContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::CreatestatsstmtContext::expr_list() {
  return getRuleContext<PostgreSQLParser::Expr_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatestatsstmtContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

PostgreSQLParser::From_listContext* PostgreSQLParser::CreatestatsstmtContext::from_list() {
  return getRuleContext<PostgreSQLParser::From_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatestatsstmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatestatsstmtContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatestatsstmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

PostgreSQLParser::Name_list_Context* PostgreSQLParser::CreatestatsstmtContext::name_list_() {
  return getRuleContext<PostgreSQLParser::Name_list_Context>(0);
}


size_t PostgreSQLParser::CreatestatsstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatestatsstmt;
}


std::any PostgreSQLParser::CreatestatsstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatestatsstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreatestatsstmtContext* PostgreSQLParser::createstatsstmt() {
  CreatestatsstmtContext *_localctx = _tracker.createInstance<CreatestatsstmtContext>(_ctx, getState());
  enterRule(_localctx, 256, PostgreSQLParser::RuleCreatestatsstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3104);
    match(PostgreSQLParser::CREATE);
    setState(3105);
    match(PostgreSQLParser::STATISTICS);
    setState(3109);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, _ctx)) {
    case 1: {
      setState(3106);
      match(PostgreSQLParser::IF_P);
      setState(3107);
      match(PostgreSQLParser::NOT);
      setState(3108);
      match(PostgreSQLParser::EXISTS);
      break;
    }

    default:
      break;
    }
    setState(3111);
    any_name();
    setState(3113);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OPEN_PAREN) {
      setState(3112);
      name_list_();
    }
    setState(3115);
    match(PostgreSQLParser::ON);
    setState(3116);
    expr_list();
    setState(3117);
    match(PostgreSQLParser::FROM);
    setState(3118);
    from_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterstatsstmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterstatsstmtContext::AlterstatsstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterstatsstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::AlterstatsstmtContext::STATISTICS() {
  return getTokens(PostgreSQLParser::STATISTICS);
}

tree::TerminalNode* PostgreSQLParser::AlterstatsstmtContext::STATISTICS(size_t i) {
  return getToken(PostgreSQLParser::STATISTICS, i);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::AlterstatsstmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterstatsstmtContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

PostgreSQLParser::SignediconstContext* PostgreSQLParser::AlterstatsstmtContext::signediconst() {
  return getRuleContext<PostgreSQLParser::SignediconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterstatsstmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterstatsstmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}


size_t PostgreSQLParser::AlterstatsstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterstatsstmt;
}


std::any PostgreSQLParser::AlterstatsstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterstatsstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterstatsstmtContext* PostgreSQLParser::alterstatsstmt() {
  AlterstatsstmtContext *_localctx = _tracker.createInstance<AlterstatsstmtContext>(_ctx, getState());
  enterRule(_localctx, 258, PostgreSQLParser::RuleAlterstatsstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3120);
    match(PostgreSQLParser::ALTER);
    setState(3121);
    match(PostgreSQLParser::STATISTICS);
    setState(3124);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 208, _ctx)) {
    case 1: {
      setState(3122);
      match(PostgreSQLParser::IF_P);
      setState(3123);
      match(PostgreSQLParser::EXISTS);
      break;
    }

    default:
      break;
    }
    setState(3126);
    any_name();
    setState(3127);
    match(PostgreSQLParser::SET);
    setState(3128);
    match(PostgreSQLParser::STATISTICS);
    setState(3129);
    signediconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateasstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreateasstmtContext::CreateasstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreateasstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateasstmtContext::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}

PostgreSQLParser::Create_as_targetContext* PostgreSQLParser::CreateasstmtContext::create_as_target() {
  return getRuleContext<PostgreSQLParser::Create_as_targetContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateasstmtContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

PostgreSQLParser::SelectstmtContext* PostgreSQLParser::CreateasstmtContext::selectstmt() {
  return getRuleContext<PostgreSQLParser::SelectstmtContext>(0);
}

PostgreSQLParser::OpttempContext* PostgreSQLParser::CreateasstmtContext::opttemp() {
  return getRuleContext<PostgreSQLParser::OpttempContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateasstmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateasstmtContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateasstmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

PostgreSQLParser::With_data_Context* PostgreSQLParser::CreateasstmtContext::with_data_() {
  return getRuleContext<PostgreSQLParser::With_data_Context>(0);
}


size_t PostgreSQLParser::CreateasstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreateasstmt;
}


std::any PostgreSQLParser::CreateasstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateasstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreateasstmtContext* PostgreSQLParser::createasstmt() {
  CreateasstmtContext *_localctx = _tracker.createInstance<CreateasstmtContext>(_ctx, getState());
  enterRule(_localctx, 260, PostgreSQLParser::RuleCreateasstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3131);
    match(PostgreSQLParser::CREATE);
    setState(3133);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::GLOBAL

    || _la == PostgreSQLParser::LOCAL || ((((_la - 383) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 383)) & 32773) != 0)) {
      setState(3132);
      opttemp();
    }
    setState(3135);
    match(PostgreSQLParser::TABLE);
    setState(3139);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 210, _ctx)) {
    case 1: {
      setState(3136);
      match(PostgreSQLParser::IF_P);
      setState(3137);
      match(PostgreSQLParser::NOT);
      setState(3138);
      match(PostgreSQLParser::EXISTS);
      break;
    }

    default:
      break;
    }
    setState(3141);
    create_as_target();
    setState(3142);
    match(PostgreSQLParser::AS);
    setState(3143);
    selectstmt();
    setState(3145);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(3144);
      with_data_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_as_targetContext ------------------------------------------------------------------

PostgreSQLParser::Create_as_targetContext::Create_as_targetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::Create_as_targetContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

PostgreSQLParser::Column_list_Context* PostgreSQLParser::Create_as_targetContext::column_list_() {
  return getRuleContext<PostgreSQLParser::Column_list_Context>(0);
}

PostgreSQLParser::Table_access_method_clauseContext* PostgreSQLParser::Create_as_targetContext::table_access_method_clause() {
  return getRuleContext<PostgreSQLParser::Table_access_method_clauseContext>(0);
}

PostgreSQLParser::OptwithContext* PostgreSQLParser::Create_as_targetContext::optwith() {
  return getRuleContext<PostgreSQLParser::OptwithContext>(0);
}

PostgreSQLParser::OncommitoptionContext* PostgreSQLParser::Create_as_targetContext::oncommitoption() {
  return getRuleContext<PostgreSQLParser::OncommitoptionContext>(0);
}

PostgreSQLParser::OpttablespaceContext* PostgreSQLParser::Create_as_targetContext::opttablespace() {
  return getRuleContext<PostgreSQLParser::OpttablespaceContext>(0);
}


size_t PostgreSQLParser::Create_as_targetContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreate_as_target;
}


std::any PostgreSQLParser::Create_as_targetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreate_as_target(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Create_as_targetContext* PostgreSQLParser::create_as_target() {
  Create_as_targetContext *_localctx = _tracker.createInstance<Create_as_targetContext>(_ctx, getState());
  enterRule(_localctx, 262, PostgreSQLParser::RuleCreate_as_target);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3147);
    qualified_name();
    setState(3149);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OPEN_PAREN) {
      setState(3148);
      column_list_();
    }
    setState(3152);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::USING) {
      setState(3151);
      table_access_method_clause();
    }
    setState(3155);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH || _la == PostgreSQLParser::WITHOUT) {
      setState(3154);
      optwith();
    }
    setState(3158);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::ON) {
      setState(3157);
      oncommitoption();
    }
    setState(3161);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::TABLESPACE) {
      setState(3160);
      opttablespace();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_data_Context ------------------------------------------------------------------

PostgreSQLParser::With_data_Context::With_data_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::With_data_Context::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

tree::TerminalNode* PostgreSQLParser::With_data_Context::DATA_P() {
  return getToken(PostgreSQLParser::DATA_P, 0);
}

tree::TerminalNode* PostgreSQLParser::With_data_Context::NO() {
  return getToken(PostgreSQLParser::NO, 0);
}


size_t PostgreSQLParser::With_data_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleWith_data_;
}


std::any PostgreSQLParser::With_data_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitWith_data_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::With_data_Context* PostgreSQLParser::with_data_() {
  With_data_Context *_localctx = _tracker.createInstance<With_data_Context>(_ctx, getState());
  enterRule(_localctx, 264, PostgreSQLParser::RuleWith_data_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3163);
    match(PostgreSQLParser::WITH);
    setState(3167);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::DATA_P: {
        setState(3164);
        match(PostgreSQLParser::DATA_P);
        break;
      }

      case PostgreSQLParser::NO: {
        setState(3165);
        match(PostgreSQLParser::NO);
        setState(3166);
        match(PostgreSQLParser::DATA_P);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreatematviewstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreatematviewstmtContext::CreatematviewstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreatematviewstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatematviewstmtContext::MATERIALIZED() {
  return getToken(PostgreSQLParser::MATERIALIZED, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatematviewstmtContext::VIEW() {
  return getToken(PostgreSQLParser::VIEW, 0);
}

PostgreSQLParser::Create_mv_targetContext* PostgreSQLParser::CreatematviewstmtContext::create_mv_target() {
  return getRuleContext<PostgreSQLParser::Create_mv_targetContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatematviewstmtContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

PostgreSQLParser::SelectstmtContext* PostgreSQLParser::CreatematviewstmtContext::selectstmt() {
  return getRuleContext<PostgreSQLParser::SelectstmtContext>(0);
}

PostgreSQLParser::OptnologContext* PostgreSQLParser::CreatematviewstmtContext::optnolog() {
  return getRuleContext<PostgreSQLParser::OptnologContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatematviewstmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatematviewstmtContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatematviewstmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

PostgreSQLParser::With_data_Context* PostgreSQLParser::CreatematviewstmtContext::with_data_() {
  return getRuleContext<PostgreSQLParser::With_data_Context>(0);
}


size_t PostgreSQLParser::CreatematviewstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatematviewstmt;
}


std::any PostgreSQLParser::CreatematviewstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatematviewstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreatematviewstmtContext* PostgreSQLParser::creatematviewstmt() {
  CreatematviewstmtContext *_localctx = _tracker.createInstance<CreatematviewstmtContext>(_ctx, getState());
  enterRule(_localctx, 266, PostgreSQLParser::RuleCreatematviewstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3169);
    match(PostgreSQLParser::CREATE);
    setState(3171);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::UNLOGGED) {
      setState(3170);
      optnolog();
    }
    setState(3173);
    match(PostgreSQLParser::MATERIALIZED);
    setState(3174);
    match(PostgreSQLParser::VIEW);
    setState(3178);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx)) {
    case 1: {
      setState(3175);
      match(PostgreSQLParser::IF_P);
      setState(3176);
      match(PostgreSQLParser::NOT);
      setState(3177);
      match(PostgreSQLParser::EXISTS);
      break;
    }

    default:
      break;
    }
    setState(3180);
    create_mv_target();
    setState(3181);
    match(PostgreSQLParser::AS);
    setState(3182);
    selectstmt();
    setState(3184);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(3183);
      with_data_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_mv_targetContext ------------------------------------------------------------------

PostgreSQLParser::Create_mv_targetContext::Create_mv_targetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::Create_mv_targetContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

PostgreSQLParser::Column_list_Context* PostgreSQLParser::Create_mv_targetContext::column_list_() {
  return getRuleContext<PostgreSQLParser::Column_list_Context>(0);
}

PostgreSQLParser::Table_access_method_clauseContext* PostgreSQLParser::Create_mv_targetContext::table_access_method_clause() {
  return getRuleContext<PostgreSQLParser::Table_access_method_clauseContext>(0);
}

PostgreSQLParser::Reloptions_Context* PostgreSQLParser::Create_mv_targetContext::reloptions_() {
  return getRuleContext<PostgreSQLParser::Reloptions_Context>(0);
}

PostgreSQLParser::OpttablespaceContext* PostgreSQLParser::Create_mv_targetContext::opttablespace() {
  return getRuleContext<PostgreSQLParser::OpttablespaceContext>(0);
}


size_t PostgreSQLParser::Create_mv_targetContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreate_mv_target;
}


std::any PostgreSQLParser::Create_mv_targetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreate_mv_target(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Create_mv_targetContext* PostgreSQLParser::create_mv_target() {
  Create_mv_targetContext *_localctx = _tracker.createInstance<Create_mv_targetContext>(_ctx, getState());
  enterRule(_localctx, 268, PostgreSQLParser::RuleCreate_mv_target);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3186);
    qualified_name();
    setState(3188);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OPEN_PAREN) {
      setState(3187);
      column_list_();
    }
    setState(3191);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::USING) {
      setState(3190);
      table_access_method_clause();
    }
    setState(3194);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(3193);
      reloptions_();
    }
    setState(3197);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::TABLESPACE) {
      setState(3196);
      opttablespace();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptnologContext ------------------------------------------------------------------

PostgreSQLParser::OptnologContext::OptnologContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::OptnologContext::UNLOGGED() {
  return getToken(PostgreSQLParser::UNLOGGED, 0);
}


size_t PostgreSQLParser::OptnologContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOptnolog;
}


std::any PostgreSQLParser::OptnologContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOptnolog(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::OptnologContext* PostgreSQLParser::optnolog() {
  OptnologContext *_localctx = _tracker.createInstance<OptnologContext>(_ctx, getState());
  enterRule(_localctx, 270, PostgreSQLParser::RuleOptnolog);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3199);
    match(PostgreSQLParser::UNLOGGED);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RefreshmatviewstmtContext ------------------------------------------------------------------

PostgreSQLParser::RefreshmatviewstmtContext::RefreshmatviewstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::RefreshmatviewstmtContext::REFRESH() {
  return getToken(PostgreSQLParser::REFRESH, 0);
}

tree::TerminalNode* PostgreSQLParser::RefreshmatviewstmtContext::MATERIALIZED() {
  return getToken(PostgreSQLParser::MATERIALIZED, 0);
}

tree::TerminalNode* PostgreSQLParser::RefreshmatviewstmtContext::VIEW() {
  return getToken(PostgreSQLParser::VIEW, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::RefreshmatviewstmtContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

PostgreSQLParser::Concurrently_Context* PostgreSQLParser::RefreshmatviewstmtContext::concurrently_() {
  return getRuleContext<PostgreSQLParser::Concurrently_Context>(0);
}

PostgreSQLParser::With_data_Context* PostgreSQLParser::RefreshmatviewstmtContext::with_data_() {
  return getRuleContext<PostgreSQLParser::With_data_Context>(0);
}


size_t PostgreSQLParser::RefreshmatviewstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRefreshmatviewstmt;
}


std::any PostgreSQLParser::RefreshmatviewstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRefreshmatviewstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RefreshmatviewstmtContext* PostgreSQLParser::refreshmatviewstmt() {
  RefreshmatviewstmtContext *_localctx = _tracker.createInstance<RefreshmatviewstmtContext>(_ctx, getState());
  enterRule(_localctx, 272, PostgreSQLParser::RuleRefreshmatviewstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3201);
    match(PostgreSQLParser::REFRESH);
    setState(3202);
    match(PostgreSQLParser::MATERIALIZED);
    setState(3203);
    match(PostgreSQLParser::VIEW);
    setState(3205);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::CONCURRENTLY) {
      setState(3204);
      concurrently_();
    }
    setState(3207);
    qualified_name();
    setState(3209);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(3208);
      with_data_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateseqstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreateseqstmtContext::CreateseqstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreateseqstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateseqstmtContext::SEQUENCE() {
  return getToken(PostgreSQLParser::SEQUENCE, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::CreateseqstmtContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

PostgreSQLParser::OpttempContext* PostgreSQLParser::CreateseqstmtContext::opttemp() {
  return getRuleContext<PostgreSQLParser::OpttempContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateseqstmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateseqstmtContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateseqstmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

PostgreSQLParser::OptseqoptlistContext* PostgreSQLParser::CreateseqstmtContext::optseqoptlist() {
  return getRuleContext<PostgreSQLParser::OptseqoptlistContext>(0);
}


size_t PostgreSQLParser::CreateseqstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreateseqstmt;
}


std::any PostgreSQLParser::CreateseqstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateseqstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreateseqstmtContext* PostgreSQLParser::createseqstmt() {
  CreateseqstmtContext *_localctx = _tracker.createInstance<CreateseqstmtContext>(_ctx, getState());
  enterRule(_localctx, 274, PostgreSQLParser::RuleCreateseqstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3211);
    match(PostgreSQLParser::CREATE);
    setState(3213);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::GLOBAL

    || _la == PostgreSQLParser::LOCAL || ((((_la - 383) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 383)) & 32773) != 0)) {
      setState(3212);
      opttemp();
    }
    setState(3215);
    match(PostgreSQLParser::SEQUENCE);
    setState(3219);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 228, _ctx)) {
    case 1: {
      setState(3216);
      match(PostgreSQLParser::IF_P);
      setState(3217);
      match(PostgreSQLParser::NOT);
      setState(3218);
      match(PostgreSQLParser::EXISTS);
      break;
    }

    default:
      break;
    }
    setState(3221);
    qualified_name();
    setState(3223);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::AS || _la == PostgreSQLParser::CACHE

    || _la == PostgreSQLParser::CYCLE || ((((_la - 263) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 263)) & 563088600334337) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 345)) & 67125249) != 0)) {
      setState(3222);
      optseqoptlist();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterseqstmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterseqstmtContext::AlterseqstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterseqstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterseqstmtContext::SEQUENCE() {
  return getToken(PostgreSQLParser::SEQUENCE, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::AlterseqstmtContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

PostgreSQLParser::SeqoptlistContext* PostgreSQLParser::AlterseqstmtContext::seqoptlist() {
  return getRuleContext<PostgreSQLParser::SeqoptlistContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterseqstmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterseqstmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}


size_t PostgreSQLParser::AlterseqstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterseqstmt;
}


std::any PostgreSQLParser::AlterseqstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterseqstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterseqstmtContext* PostgreSQLParser::alterseqstmt() {
  AlterseqstmtContext *_localctx = _tracker.createInstance<AlterseqstmtContext>(_ctx, getState());
  enterRule(_localctx, 276, PostgreSQLParser::RuleAlterseqstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3225);
    match(PostgreSQLParser::ALTER);
    setState(3226);
    match(PostgreSQLParser::SEQUENCE);
    setState(3229);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 230, _ctx)) {
    case 1: {
      setState(3227);
      match(PostgreSQLParser::IF_P);
      setState(3228);
      match(PostgreSQLParser::EXISTS);
      break;
    }

    default:
      break;
    }
    setState(3231);
    qualified_name();
    setState(3232);
    seqoptlist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptseqoptlistContext ------------------------------------------------------------------

PostgreSQLParser::OptseqoptlistContext::OptseqoptlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::SeqoptlistContext* PostgreSQLParser::OptseqoptlistContext::seqoptlist() {
  return getRuleContext<PostgreSQLParser::SeqoptlistContext>(0);
}


size_t PostgreSQLParser::OptseqoptlistContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOptseqoptlist;
}


std::any PostgreSQLParser::OptseqoptlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOptseqoptlist(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::OptseqoptlistContext* PostgreSQLParser::optseqoptlist() {
  OptseqoptlistContext *_localctx = _tracker.createInstance<OptseqoptlistContext>(_ctx, getState());
  enterRule(_localctx, 278, PostgreSQLParser::RuleOptseqoptlist);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3234);
    seqoptlist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptparenthesizedseqoptlistContext ------------------------------------------------------------------

PostgreSQLParser::OptparenthesizedseqoptlistContext::OptparenthesizedseqoptlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::OptparenthesizedseqoptlistContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::SeqoptlistContext* PostgreSQLParser::OptparenthesizedseqoptlistContext::seqoptlist() {
  return getRuleContext<PostgreSQLParser::SeqoptlistContext>(0);
}

tree::TerminalNode* PostgreSQLParser::OptparenthesizedseqoptlistContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::OptparenthesizedseqoptlistContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOptparenthesizedseqoptlist;
}


std::any PostgreSQLParser::OptparenthesizedseqoptlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOptparenthesizedseqoptlist(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::OptparenthesizedseqoptlistContext* PostgreSQLParser::optparenthesizedseqoptlist() {
  OptparenthesizedseqoptlistContext *_localctx = _tracker.createInstance<OptparenthesizedseqoptlistContext>(_ctx, getState());
  enterRule(_localctx, 280, PostgreSQLParser::RuleOptparenthesizedseqoptlist);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3236);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(3237);
    seqoptlist();
    setState(3238);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SeqoptlistContext ------------------------------------------------------------------

PostgreSQLParser::SeqoptlistContext::SeqoptlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::SeqoptelemContext *> PostgreSQLParser::SeqoptlistContext::seqoptelem() {
  return getRuleContexts<PostgreSQLParser::SeqoptelemContext>();
}

PostgreSQLParser::SeqoptelemContext* PostgreSQLParser::SeqoptlistContext::seqoptelem(size_t i) {
  return getRuleContext<PostgreSQLParser::SeqoptelemContext>(i);
}


size_t PostgreSQLParser::SeqoptlistContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSeqoptlist;
}


std::any PostgreSQLParser::SeqoptlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSeqoptlist(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::SeqoptlistContext* PostgreSQLParser::seqoptlist() {
  SeqoptlistContext *_localctx = _tracker.createInstance<SeqoptlistContext>(_ctx, getState());
  enterRule(_localctx, 282, PostgreSQLParser::RuleSeqoptlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3241); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(3240);
      seqoptelem();
      setState(3243); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == PostgreSQLParser::AS || _la == PostgreSQLParser::CACHE

    || _la == PostgreSQLParser::CYCLE || ((((_la - 263) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 263)) & 563088600334337) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 345)) & 67125249) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SeqoptelemContext ------------------------------------------------------------------

PostgreSQLParser::SeqoptelemContext::SeqoptelemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::SeqoptelemContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

PostgreSQLParser::SimpletypenameContext* PostgreSQLParser::SeqoptelemContext::simpletypename() {
  return getRuleContext<PostgreSQLParser::SimpletypenameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::SeqoptelemContext::CACHE() {
  return getToken(PostgreSQLParser::CACHE, 0);
}

PostgreSQLParser::NumericonlyContext* PostgreSQLParser::SeqoptelemContext::numericonly() {
  return getRuleContext<PostgreSQLParser::NumericonlyContext>(0);
}

tree::TerminalNode* PostgreSQLParser::SeqoptelemContext::CYCLE() {
  return getToken(PostgreSQLParser::CYCLE, 0);
}

tree::TerminalNode* PostgreSQLParser::SeqoptelemContext::INCREMENT() {
  return getToken(PostgreSQLParser::INCREMENT, 0);
}

PostgreSQLParser::By_Context* PostgreSQLParser::SeqoptelemContext::by_() {
  return getRuleContext<PostgreSQLParser::By_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::SeqoptelemContext::MAXVALUE() {
  return getToken(PostgreSQLParser::MAXVALUE, 0);
}

tree::TerminalNode* PostgreSQLParser::SeqoptelemContext::MINVALUE() {
  return getToken(PostgreSQLParser::MINVALUE, 0);
}

tree::TerminalNode* PostgreSQLParser::SeqoptelemContext::NO() {
  return getToken(PostgreSQLParser::NO, 0);
}

tree::TerminalNode* PostgreSQLParser::SeqoptelemContext::OWNED() {
  return getToken(PostgreSQLParser::OWNED, 0);
}

tree::TerminalNode* PostgreSQLParser::SeqoptelemContext::BY() {
  return getToken(PostgreSQLParser::BY, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::SeqoptelemContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::SeqoptelemContext::SEQUENCE() {
  return getToken(PostgreSQLParser::SEQUENCE, 0);
}

tree::TerminalNode* PostgreSQLParser::SeqoptelemContext::NAME_P() {
  return getToken(PostgreSQLParser::NAME_P, 0);
}

tree::TerminalNode* PostgreSQLParser::SeqoptelemContext::START() {
  return getToken(PostgreSQLParser::START, 0);
}

PostgreSQLParser::With_Context* PostgreSQLParser::SeqoptelemContext::with_() {
  return getRuleContext<PostgreSQLParser::With_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::SeqoptelemContext::RESTART() {
  return getToken(PostgreSQLParser::RESTART, 0);
}


size_t PostgreSQLParser::SeqoptelemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSeqoptelem;
}


std::any PostgreSQLParser::SeqoptelemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSeqoptelem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::SeqoptelemContext* PostgreSQLParser::seqoptelem() {
  SeqoptelemContext *_localctx = _tracker.createInstance<SeqoptelemContext>(_ctx, getState());
  enterRule(_localctx, 284, PostgreSQLParser::RuleSeqoptelem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3279);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::AS: {
        enterOuterAlt(_localctx, 1);
        setState(3245);
        match(PostgreSQLParser::AS);
        setState(3246);
        simpletypename();
        break;
      }

      case PostgreSQLParser::CACHE: {
        enterOuterAlt(_localctx, 2);
        setState(3247);
        match(PostgreSQLParser::CACHE);
        setState(3248);
        numericonly();
        break;
      }

      case PostgreSQLParser::CYCLE: {
        enterOuterAlt(_localctx, 3);
        setState(3249);
        match(PostgreSQLParser::CYCLE);
        break;
      }

      case PostgreSQLParser::INCREMENT: {
        enterOuterAlt(_localctx, 4);
        setState(3250);
        match(PostgreSQLParser::INCREMENT);
        setState(3252);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::BY) {
          setState(3251);
          by_();
        }
        setState(3254);
        numericonly();
        break;
      }

      case PostgreSQLParser::MAXVALUE: {
        enterOuterAlt(_localctx, 5);
        setState(3255);
        match(PostgreSQLParser::MAXVALUE);
        setState(3256);
        numericonly();
        break;
      }

      case PostgreSQLParser::MINVALUE: {
        enterOuterAlt(_localctx, 6);
        setState(3257);
        match(PostgreSQLParser::MINVALUE);
        setState(3258);
        numericonly();
        break;
      }

      case PostgreSQLParser::NO: {
        enterOuterAlt(_localctx, 7);
        setState(3259);
        match(PostgreSQLParser::NO);
        setState(3260);
        _la = _input->LA(1);
        if (!(_la == PostgreSQLParser::CYCLE || _la == PostgreSQLParser::MAXVALUE

        || _la == PostgreSQLParser::MINVALUE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case PostgreSQLParser::OWNED: {
        enterOuterAlt(_localctx, 8);
        setState(3261);
        match(PostgreSQLParser::OWNED);
        setState(3262);
        match(PostgreSQLParser::BY);
        setState(3263);
        any_name();
        break;
      }

      case PostgreSQLParser::SEQUENCE: {
        enterOuterAlt(_localctx, 9);
        setState(3264);
        match(PostgreSQLParser::SEQUENCE);
        setState(3265);
        match(PostgreSQLParser::NAME_P);
        setState(3266);
        any_name();
        break;
      }

      case PostgreSQLParser::START: {
        enterOuterAlt(_localctx, 10);
        setState(3267);
        match(PostgreSQLParser::START);
        setState(3269);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::WITH) {
          setState(3268);
          with_();
        }
        setState(3271);
        numericonly();
        break;
      }

      case PostgreSQLParser::RESTART: {
        enterOuterAlt(_localctx, 11);
        setState(3272);
        match(PostgreSQLParser::RESTART);
        setState(3274);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::WITH) {
          setState(3273);
          with_();
        }
        setState(3277);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::PLUS

        || _la == PostgreSQLParser::MINUS || ((((_la - 576) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 576)) & 47) != 0)) {
          setState(3276);
          numericonly();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- By_Context ------------------------------------------------------------------

PostgreSQLParser::By_Context::By_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::By_Context::BY() {
  return getToken(PostgreSQLParser::BY, 0);
}


size_t PostgreSQLParser::By_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleBy_;
}


std::any PostgreSQLParser::By_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitBy_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::By_Context* PostgreSQLParser::by_() {
  By_Context *_localctx = _tracker.createInstance<By_Context>(_ctx, getState());
  enterRule(_localctx, 286, PostgreSQLParser::RuleBy_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3281);
    match(PostgreSQLParser::BY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericonlyContext ------------------------------------------------------------------

PostgreSQLParser::NumericonlyContext::NumericonlyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::FconstContext* PostgreSQLParser::NumericonlyContext::fconst() {
  return getRuleContext<PostgreSQLParser::FconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::NumericonlyContext::PLUS() {
  return getToken(PostgreSQLParser::PLUS, 0);
}

tree::TerminalNode* PostgreSQLParser::NumericonlyContext::MINUS() {
  return getToken(PostgreSQLParser::MINUS, 0);
}

PostgreSQLParser::SignediconstContext* PostgreSQLParser::NumericonlyContext::signediconst() {
  return getRuleContext<PostgreSQLParser::SignediconstContext>(0);
}


size_t PostgreSQLParser::NumericonlyContext::getRuleIndex() const {
  return PostgreSQLParser::RuleNumericonly;
}


std::any PostgreSQLParser::NumericonlyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitNumericonly(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::NumericonlyContext* PostgreSQLParser::numericonly() {
  NumericonlyContext *_localctx = _tracker.createInstance<NumericonlyContext>(_ctx, getState());
  enterRule(_localctx, 288, PostgreSQLParser::RuleNumericonly);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3289);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3283);
      fconst();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3284);
      match(PostgreSQLParser::PLUS);
      setState(3285);
      fconst();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3286);
      match(PostgreSQLParser::MINUS);
      setState(3287);
      fconst();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3288);
      signediconst();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Numericonly_listContext ------------------------------------------------------------------

PostgreSQLParser::Numericonly_listContext::Numericonly_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::NumericonlyContext *> PostgreSQLParser::Numericonly_listContext::numericonly() {
  return getRuleContexts<PostgreSQLParser::NumericonlyContext>();
}

PostgreSQLParser::NumericonlyContext* PostgreSQLParser::Numericonly_listContext::numericonly(size_t i) {
  return getRuleContext<PostgreSQLParser::NumericonlyContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Numericonly_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Numericonly_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Numericonly_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleNumericonly_list;
}


std::any PostgreSQLParser::Numericonly_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitNumericonly_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Numericonly_listContext* PostgreSQLParser::numericonly_list() {
  Numericonly_listContext *_localctx = _tracker.createInstance<Numericonly_listContext>(_ctx, getState());
  enterRule(_localctx, 290, PostgreSQLParser::RuleNumericonly_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3291);
    numericonly();
    setState(3296);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(3292);
      match(PostgreSQLParser::COMMA);
      setState(3293);
      numericonly();
      setState(3298);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateplangstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreateplangstmtContext::CreateplangstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreateplangstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateplangstmtContext::LANGUAGE() {
  return getToken(PostgreSQLParser::LANGUAGE, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::CreateplangstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::Or_replace_Context* PostgreSQLParser::CreateplangstmtContext::or_replace_() {
  return getRuleContext<PostgreSQLParser::Or_replace_Context>(0);
}

PostgreSQLParser::Trusted_Context* PostgreSQLParser::CreateplangstmtContext::trusted_() {
  return getRuleContext<PostgreSQLParser::Trusted_Context>(0);
}

PostgreSQLParser::Procedural_Context* PostgreSQLParser::CreateplangstmtContext::procedural_() {
  return getRuleContext<PostgreSQLParser::Procedural_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateplangstmtContext::HANDLER() {
  return getToken(PostgreSQLParser::HANDLER, 0);
}

PostgreSQLParser::Handler_nameContext* PostgreSQLParser::CreateplangstmtContext::handler_name() {
  return getRuleContext<PostgreSQLParser::Handler_nameContext>(0);
}

PostgreSQLParser::Inline_handler_Context* PostgreSQLParser::CreateplangstmtContext::inline_handler_() {
  return getRuleContext<PostgreSQLParser::Inline_handler_Context>(0);
}

PostgreSQLParser::Validator_Context* PostgreSQLParser::CreateplangstmtContext::validator_() {
  return getRuleContext<PostgreSQLParser::Validator_Context>(0);
}


size_t PostgreSQLParser::CreateplangstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreateplangstmt;
}


std::any PostgreSQLParser::CreateplangstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateplangstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreateplangstmtContext* PostgreSQLParser::createplangstmt() {
  CreateplangstmtContext *_localctx = _tracker.createInstance<CreateplangstmtContext>(_ctx, getState());
  enterRule(_localctx, 292, PostgreSQLParser::RuleCreateplangstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3299);
    match(PostgreSQLParser::CREATE);
    setState(3301);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OR) {
      setState(3300);
      or_replace_();
    }
    setState(3304);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::TRUSTED) {
      setState(3303);
      trusted_();
    }
    setState(3307);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::PROCEDURAL) {
      setState(3306);
      procedural_();
    }
    setState(3309);
    match(PostgreSQLParser::LANGUAGE);
    setState(3310);
    name();
    setState(3319);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::HANDLER) {
      setState(3311);
      match(PostgreSQLParser::HANDLER);
      setState(3312);
      handler_name();
      setState(3314);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::INLINE_P) {
        setState(3313);
        inline_handler_();
      }
      setState(3317);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::NO || _la == PostgreSQLParser::VALIDATOR) {
        setState(3316);
        validator_();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trusted_Context ------------------------------------------------------------------

PostgreSQLParser::Trusted_Context::Trusted_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Trusted_Context::TRUSTED() {
  return getToken(PostgreSQLParser::TRUSTED, 0);
}


size_t PostgreSQLParser::Trusted_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleTrusted_;
}


std::any PostgreSQLParser::Trusted_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTrusted_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Trusted_Context* PostgreSQLParser::trusted_() {
  Trusted_Context *_localctx = _tracker.createInstance<Trusted_Context>(_ctx, getState());
  enterRule(_localctx, 294, PostgreSQLParser::RuleTrusted_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3321);
    match(PostgreSQLParser::TRUSTED);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Handler_nameContext ------------------------------------------------------------------

PostgreSQLParser::Handler_nameContext::Handler_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::NameContext* PostgreSQLParser::Handler_nameContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::AttrsContext* PostgreSQLParser::Handler_nameContext::attrs() {
  return getRuleContext<PostgreSQLParser::AttrsContext>(0);
}


size_t PostgreSQLParser::Handler_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleHandler_name;
}


std::any PostgreSQLParser::Handler_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitHandler_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Handler_nameContext* PostgreSQLParser::handler_name() {
  Handler_nameContext *_localctx = _tracker.createInstance<Handler_nameContext>(_ctx, getState());
  enterRule(_localctx, 296, PostgreSQLParser::RuleHandler_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3323);
    name();
    setState(3325);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::DOT) {
      setState(3324);
      attrs();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inline_handler_Context ------------------------------------------------------------------

PostgreSQLParser::Inline_handler_Context::Inline_handler_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Inline_handler_Context::INLINE_P() {
  return getToken(PostgreSQLParser::INLINE_P, 0);
}

PostgreSQLParser::Handler_nameContext* PostgreSQLParser::Inline_handler_Context::handler_name() {
  return getRuleContext<PostgreSQLParser::Handler_nameContext>(0);
}


size_t PostgreSQLParser::Inline_handler_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleInline_handler_;
}


std::any PostgreSQLParser::Inline_handler_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitInline_handler_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Inline_handler_Context* PostgreSQLParser::inline_handler_() {
  Inline_handler_Context *_localctx = _tracker.createInstance<Inline_handler_Context>(_ctx, getState());
  enterRule(_localctx, 298, PostgreSQLParser::RuleInline_handler_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3327);
    match(PostgreSQLParser::INLINE_P);
    setState(3328);
    handler_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Validator_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Validator_clauseContext::Validator_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Validator_clauseContext::VALIDATOR() {
  return getToken(PostgreSQLParser::VALIDATOR, 0);
}

PostgreSQLParser::Handler_nameContext* PostgreSQLParser::Validator_clauseContext::handler_name() {
  return getRuleContext<PostgreSQLParser::Handler_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Validator_clauseContext::NO() {
  return getToken(PostgreSQLParser::NO, 0);
}


size_t PostgreSQLParser::Validator_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleValidator_clause;
}


std::any PostgreSQLParser::Validator_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitValidator_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Validator_clauseContext* PostgreSQLParser::validator_clause() {
  Validator_clauseContext *_localctx = _tracker.createInstance<Validator_clauseContext>(_ctx, getState());
  enterRule(_localctx, 300, PostgreSQLParser::RuleValidator_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3334);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::VALIDATOR: {
        enterOuterAlt(_localctx, 1);
        setState(3330);
        match(PostgreSQLParser::VALIDATOR);
        setState(3331);
        handler_name();
        break;
      }

      case PostgreSQLParser::NO: {
        enterOuterAlt(_localctx, 2);
        setState(3332);
        match(PostgreSQLParser::NO);
        setState(3333);
        match(PostgreSQLParser::VALIDATOR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Validator_Context ------------------------------------------------------------------

PostgreSQLParser::Validator_Context::Validator_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Validator_clauseContext* PostgreSQLParser::Validator_Context::validator_clause() {
  return getRuleContext<PostgreSQLParser::Validator_clauseContext>(0);
}


size_t PostgreSQLParser::Validator_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleValidator_;
}


std::any PostgreSQLParser::Validator_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitValidator_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Validator_Context* PostgreSQLParser::validator_() {
  Validator_Context *_localctx = _tracker.createInstance<Validator_Context>(_ctx, getState());
  enterRule(_localctx, 302, PostgreSQLParser::RuleValidator_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3336);
    validator_clause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Procedural_Context ------------------------------------------------------------------

PostgreSQLParser::Procedural_Context::Procedural_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Procedural_Context::PROCEDURAL() {
  return getToken(PostgreSQLParser::PROCEDURAL, 0);
}


size_t PostgreSQLParser::Procedural_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleProcedural_;
}


std::any PostgreSQLParser::Procedural_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitProcedural_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Procedural_Context* PostgreSQLParser::procedural_() {
  Procedural_Context *_localctx = _tracker.createInstance<Procedural_Context>(_ctx, getState());
  enterRule(_localctx, 304, PostgreSQLParser::RuleProcedural_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3338);
    match(PostgreSQLParser::PROCEDURAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreatetablespacestmtContext ------------------------------------------------------------------

PostgreSQLParser::CreatetablespacestmtContext::CreatetablespacestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreatetablespacestmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatetablespacestmtContext::TABLESPACE() {
  return getToken(PostgreSQLParser::TABLESPACE, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::CreatetablespacestmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatetablespacestmtContext::LOCATION() {
  return getToken(PostgreSQLParser::LOCATION, 0);
}

PostgreSQLParser::SconstContext* PostgreSQLParser::CreatetablespacestmtContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}

PostgreSQLParser::OpttablespaceownerContext* PostgreSQLParser::CreatetablespacestmtContext::opttablespaceowner() {
  return getRuleContext<PostgreSQLParser::OpttablespaceownerContext>(0);
}

PostgreSQLParser::Reloptions_Context* PostgreSQLParser::CreatetablespacestmtContext::reloptions_() {
  return getRuleContext<PostgreSQLParser::Reloptions_Context>(0);
}


size_t PostgreSQLParser::CreatetablespacestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatetablespacestmt;
}


std::any PostgreSQLParser::CreatetablespacestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatetablespacestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreatetablespacestmtContext* PostgreSQLParser::createtablespacestmt() {
  CreatetablespacestmtContext *_localctx = _tracker.createInstance<CreatetablespacestmtContext>(_ctx, getState());
  enterRule(_localctx, 306, PostgreSQLParser::RuleCreatetablespacestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3340);
    match(PostgreSQLParser::CREATE);
    setState(3341);
    match(PostgreSQLParser::TABLESPACE);
    setState(3342);
    name();
    setState(3344);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OWNER) {
      setState(3343);
      opttablespaceowner();
    }
    setState(3346);
    match(PostgreSQLParser::LOCATION);
    setState(3347);
    sconst();
    setState(3349);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(3348);
      reloptions_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OpttablespaceownerContext ------------------------------------------------------------------

PostgreSQLParser::OpttablespaceownerContext::OpttablespaceownerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::OpttablespaceownerContext::OWNER() {
  return getToken(PostgreSQLParser::OWNER, 0);
}

PostgreSQLParser::RolespecContext* PostgreSQLParser::OpttablespaceownerContext::rolespec() {
  return getRuleContext<PostgreSQLParser::RolespecContext>(0);
}


size_t PostgreSQLParser::OpttablespaceownerContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOpttablespaceowner;
}


std::any PostgreSQLParser::OpttablespaceownerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOpttablespaceowner(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::OpttablespaceownerContext* PostgreSQLParser::opttablespaceowner() {
  OpttablespaceownerContext *_localctx = _tracker.createInstance<OpttablespaceownerContext>(_ctx, getState());
  enterRule(_localctx, 308, PostgreSQLParser::RuleOpttablespaceowner);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3351);
    match(PostgreSQLParser::OWNER);
    setState(3352);
    rolespec();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DroptablespacestmtContext ------------------------------------------------------------------

PostgreSQLParser::DroptablespacestmtContext::DroptablespacestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DroptablespacestmtContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

tree::TerminalNode* PostgreSQLParser::DroptablespacestmtContext::TABLESPACE() {
  return getToken(PostgreSQLParser::TABLESPACE, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::DroptablespacestmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DroptablespacestmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::DroptablespacestmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}


size_t PostgreSQLParser::DroptablespacestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDroptablespacestmt;
}


std::any PostgreSQLParser::DroptablespacestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDroptablespacestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DroptablespacestmtContext* PostgreSQLParser::droptablespacestmt() {
  DroptablespacestmtContext *_localctx = _tracker.createInstance<DroptablespacestmtContext>(_ctx, getState());
  enterRule(_localctx, 310, PostgreSQLParser::RuleDroptablespacestmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3354);
    match(PostgreSQLParser::DROP);
    setState(3355);
    match(PostgreSQLParser::TABLESPACE);
    setState(3358);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 249, _ctx)) {
    case 1: {
      setState(3356);
      match(PostgreSQLParser::IF_P);
      setState(3357);
      match(PostgreSQLParser::EXISTS);
      break;
    }

    default:
      break;
    }
    setState(3360);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateextensionstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreateextensionstmtContext::CreateextensionstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreateextensionstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateextensionstmtContext::EXTENSION() {
  return getToken(PostgreSQLParser::EXTENSION, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::CreateextensionstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::Create_extension_opt_listContext* PostgreSQLParser::CreateextensionstmtContext::create_extension_opt_list() {
  return getRuleContext<PostgreSQLParser::Create_extension_opt_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateextensionstmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateextensionstmtContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateextensionstmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

PostgreSQLParser::With_Context* PostgreSQLParser::CreateextensionstmtContext::with_() {
  return getRuleContext<PostgreSQLParser::With_Context>(0);
}


size_t PostgreSQLParser::CreateextensionstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreateextensionstmt;
}


std::any PostgreSQLParser::CreateextensionstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateextensionstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreateextensionstmtContext* PostgreSQLParser::createextensionstmt() {
  CreateextensionstmtContext *_localctx = _tracker.createInstance<CreateextensionstmtContext>(_ctx, getState());
  enterRule(_localctx, 312, PostgreSQLParser::RuleCreateextensionstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3362);
    match(PostgreSQLParser::CREATE);
    setState(3363);
    match(PostgreSQLParser::EXTENSION);
    setState(3367);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 250, _ctx)) {
    case 1: {
      setState(3364);
      match(PostgreSQLParser::IF_P);
      setState(3365);
      match(PostgreSQLParser::NOT);
      setState(3366);
      match(PostgreSQLParser::EXISTS);
      break;
    }

    default:
      break;
    }
    setState(3369);
    name();
    setState(3371);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(3370);
      with_();
    }
    setState(3373);
    create_extension_opt_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_extension_opt_listContext ------------------------------------------------------------------

PostgreSQLParser::Create_extension_opt_listContext::Create_extension_opt_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Create_extension_opt_itemContext *> PostgreSQLParser::Create_extension_opt_listContext::create_extension_opt_item() {
  return getRuleContexts<PostgreSQLParser::Create_extension_opt_itemContext>();
}

PostgreSQLParser::Create_extension_opt_itemContext* PostgreSQLParser::Create_extension_opt_listContext::create_extension_opt_item(size_t i) {
  return getRuleContext<PostgreSQLParser::Create_extension_opt_itemContext>(i);
}


size_t PostgreSQLParser::Create_extension_opt_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreate_extension_opt_list;
}


std::any PostgreSQLParser::Create_extension_opt_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreate_extension_opt_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Create_extension_opt_listContext* PostgreSQLParser::create_extension_opt_list() {
  Create_extension_opt_listContext *_localctx = _tracker.createInstance<Create_extension_opt_listContext>(_ctx, getState());
  enterRule(_localctx, 314, PostgreSQLParser::RuleCreate_extension_opt_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3378);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::FROM || _la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::SCHEMA

    || _la == PostgreSQLParser::VERSION_P) {
      setState(3375);
      create_extension_opt_item();
      setState(3380);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_extension_opt_itemContext ------------------------------------------------------------------

PostgreSQLParser::Create_extension_opt_itemContext::Create_extension_opt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Create_extension_opt_itemContext::SCHEMA() {
  return getToken(PostgreSQLParser::SCHEMA, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::Create_extension_opt_itemContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Create_extension_opt_itemContext::VERSION_P() {
  return getToken(PostgreSQLParser::VERSION_P, 0);
}

PostgreSQLParser::Nonreservedword_or_sconstContext* PostgreSQLParser::Create_extension_opt_itemContext::nonreservedword_or_sconst() {
  return getRuleContext<PostgreSQLParser::Nonreservedword_or_sconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Create_extension_opt_itemContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

tree::TerminalNode* PostgreSQLParser::Create_extension_opt_itemContext::CASCADE() {
  return getToken(PostgreSQLParser::CASCADE, 0);
}


size_t PostgreSQLParser::Create_extension_opt_itemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreate_extension_opt_item;
}


std::any PostgreSQLParser::Create_extension_opt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreate_extension_opt_item(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Create_extension_opt_itemContext* PostgreSQLParser::create_extension_opt_item() {
  Create_extension_opt_itemContext *_localctx = _tracker.createInstance<Create_extension_opt_itemContext>(_ctx, getState());
  enterRule(_localctx, 316, PostgreSQLParser::RuleCreate_extension_opt_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3388);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::SCHEMA: {
        enterOuterAlt(_localctx, 1);
        setState(3381);
        match(PostgreSQLParser::SCHEMA);
        setState(3382);
        name();
        break;
      }

      case PostgreSQLParser::VERSION_P: {
        enterOuterAlt(_localctx, 2);
        setState(3383);
        match(PostgreSQLParser::VERSION_P);
        setState(3384);
        nonreservedword_or_sconst();
        break;
      }

      case PostgreSQLParser::FROM: {
        enterOuterAlt(_localctx, 3);
        setState(3385);
        match(PostgreSQLParser::FROM);
        setState(3386);
        nonreservedword_or_sconst();
        break;
      }

      case PostgreSQLParser::CASCADE: {
        enterOuterAlt(_localctx, 4);
        setState(3387);
        match(PostgreSQLParser::CASCADE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterextensionstmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterextensionstmtContext::AlterextensionstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterextensionstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterextensionstmtContext::EXTENSION() {
  return getToken(PostgreSQLParser::EXTENSION, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::AlterextensionstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterextensionstmtContext::UPDATE() {
  return getToken(PostgreSQLParser::UPDATE, 0);
}

PostgreSQLParser::Alter_extension_opt_listContext* PostgreSQLParser::AlterextensionstmtContext::alter_extension_opt_list() {
  return getRuleContext<PostgreSQLParser::Alter_extension_opt_listContext>(0);
}


size_t PostgreSQLParser::AlterextensionstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterextensionstmt;
}


std::any PostgreSQLParser::AlterextensionstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterextensionstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterextensionstmtContext* PostgreSQLParser::alterextensionstmt() {
  AlterextensionstmtContext *_localctx = _tracker.createInstance<AlterextensionstmtContext>(_ctx, getState());
  enterRule(_localctx, 318, PostgreSQLParser::RuleAlterextensionstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3390);
    match(PostgreSQLParser::ALTER);
    setState(3391);
    match(PostgreSQLParser::EXTENSION);
    setState(3392);
    name();
    setState(3393);
    match(PostgreSQLParser::UPDATE);
    setState(3394);
    alter_extension_opt_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_extension_opt_listContext ------------------------------------------------------------------

PostgreSQLParser::Alter_extension_opt_listContext::Alter_extension_opt_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Alter_extension_opt_itemContext *> PostgreSQLParser::Alter_extension_opt_listContext::alter_extension_opt_item() {
  return getRuleContexts<PostgreSQLParser::Alter_extension_opt_itemContext>();
}

PostgreSQLParser::Alter_extension_opt_itemContext* PostgreSQLParser::Alter_extension_opt_listContext::alter_extension_opt_item(size_t i) {
  return getRuleContext<PostgreSQLParser::Alter_extension_opt_itemContext>(i);
}


size_t PostgreSQLParser::Alter_extension_opt_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlter_extension_opt_list;
}


std::any PostgreSQLParser::Alter_extension_opt_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlter_extension_opt_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Alter_extension_opt_listContext* PostgreSQLParser::alter_extension_opt_list() {
  Alter_extension_opt_listContext *_localctx = _tracker.createInstance<Alter_extension_opt_listContext>(_ctx, getState());
  enterRule(_localctx, 320, PostgreSQLParser::RuleAlter_extension_opt_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3399);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::TO) {
      setState(3396);
      alter_extension_opt_item();
      setState(3401);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_extension_opt_itemContext ------------------------------------------------------------------

PostgreSQLParser::Alter_extension_opt_itemContext::Alter_extension_opt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Alter_extension_opt_itemContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}

PostgreSQLParser::Nonreservedword_or_sconstContext* PostgreSQLParser::Alter_extension_opt_itemContext::nonreservedword_or_sconst() {
  return getRuleContext<PostgreSQLParser::Nonreservedword_or_sconstContext>(0);
}


size_t PostgreSQLParser::Alter_extension_opt_itemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlter_extension_opt_item;
}


std::any PostgreSQLParser::Alter_extension_opt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlter_extension_opt_item(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Alter_extension_opt_itemContext* PostgreSQLParser::alter_extension_opt_item() {
  Alter_extension_opt_itemContext *_localctx = _tracker.createInstance<Alter_extension_opt_itemContext>(_ctx, getState());
  enterRule(_localctx, 322, PostgreSQLParser::RuleAlter_extension_opt_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3402);
    match(PostgreSQLParser::TO);
    setState(3403);
    nonreservedword_or_sconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterextensioncontentsstmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterextensioncontentsstmtContext::AlterextensioncontentsstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterextensioncontentsstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterextensioncontentsstmtContext::EXTENSION() {
  return getToken(PostgreSQLParser::EXTENSION, 0);
}

std::vector<PostgreSQLParser::NameContext *> PostgreSQLParser::AlterextensioncontentsstmtContext::name() {
  return getRuleContexts<PostgreSQLParser::NameContext>();
}

PostgreSQLParser::NameContext* PostgreSQLParser::AlterextensioncontentsstmtContext::name(size_t i) {
  return getRuleContext<PostgreSQLParser::NameContext>(i);
}

PostgreSQLParser::Add_dropContext* PostgreSQLParser::AlterextensioncontentsstmtContext::add_drop() {
  return getRuleContext<PostgreSQLParser::Add_dropContext>(0);
}

PostgreSQLParser::Object_type_nameContext* PostgreSQLParser::AlterextensioncontentsstmtContext::object_type_name() {
  return getRuleContext<PostgreSQLParser::Object_type_nameContext>(0);
}

PostgreSQLParser::Object_type_any_nameContext* PostgreSQLParser::AlterextensioncontentsstmtContext::object_type_any_name() {
  return getRuleContext<PostgreSQLParser::Object_type_any_nameContext>(0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::AlterextensioncontentsstmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterextensioncontentsstmtContext::AGGREGATE() {
  return getToken(PostgreSQLParser::AGGREGATE, 0);
}

PostgreSQLParser::Aggregate_with_argtypesContext* PostgreSQLParser::AlterextensioncontentsstmtContext::aggregate_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Aggregate_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterextensioncontentsstmtContext::CAST() {
  return getToken(PostgreSQLParser::CAST, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterextensioncontentsstmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

std::vector<PostgreSQLParser::TypenameContext *> PostgreSQLParser::AlterextensioncontentsstmtContext::typename_() {
  return getRuleContexts<PostgreSQLParser::TypenameContext>();
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::AlterextensioncontentsstmtContext::typename_(size_t i) {
  return getRuleContext<PostgreSQLParser::TypenameContext>(i);
}

tree::TerminalNode* PostgreSQLParser::AlterextensioncontentsstmtContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterextensioncontentsstmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterextensioncontentsstmtContext::DOMAIN_P() {
  return getToken(PostgreSQLParser::DOMAIN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterextensioncontentsstmtContext::FUNCTION() {
  return getToken(PostgreSQLParser::FUNCTION, 0);
}

PostgreSQLParser::Function_with_argtypesContext* PostgreSQLParser::AlterextensioncontentsstmtContext::function_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Function_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterextensioncontentsstmtContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

PostgreSQLParser::Operator_with_argtypesContext* PostgreSQLParser::AlterextensioncontentsstmtContext::operator_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Operator_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterextensioncontentsstmtContext::CLASS() {
  return getToken(PostgreSQLParser::CLASS, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterextensioncontentsstmtContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterextensioncontentsstmtContext::FAMILY() {
  return getToken(PostgreSQLParser::FAMILY, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterextensioncontentsstmtContext::PROCEDURE() {
  return getToken(PostgreSQLParser::PROCEDURE, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterextensioncontentsstmtContext::ROUTINE() {
  return getToken(PostgreSQLParser::ROUTINE, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterextensioncontentsstmtContext::TRANSFORM() {
  return getToken(PostgreSQLParser::TRANSFORM, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterextensioncontentsstmtContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterextensioncontentsstmtContext::LANGUAGE() {
  return getToken(PostgreSQLParser::LANGUAGE, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterextensioncontentsstmtContext::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}


size_t PostgreSQLParser::AlterextensioncontentsstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterextensioncontentsstmt;
}


std::any PostgreSQLParser::AlterextensioncontentsstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterextensioncontentsstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterextensioncontentsstmtContext* PostgreSQLParser::alterextensioncontentsstmt() {
  AlterextensioncontentsstmtContext *_localctx = _tracker.createInstance<AlterextensioncontentsstmtContext>(_ctx, getState());
  enterRule(_localctx, 324, PostgreSQLParser::RuleAlterextensioncontentsstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3509);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 255, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3405);
      match(PostgreSQLParser::ALTER);
      setState(3406);
      match(PostgreSQLParser::EXTENSION);
      setState(3407);
      name();
      setState(3408);
      add_drop();
      setState(3409);
      object_type_name();
      setState(3410);
      name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3412);
      match(PostgreSQLParser::ALTER);
      setState(3413);
      match(PostgreSQLParser::EXTENSION);
      setState(3414);
      name();
      setState(3415);
      add_drop();
      setState(3416);
      object_type_any_name();
      setState(3417);
      any_name();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3419);
      match(PostgreSQLParser::ALTER);
      setState(3420);
      match(PostgreSQLParser::EXTENSION);
      setState(3421);
      name();
      setState(3422);
      add_drop();
      setState(3423);
      match(PostgreSQLParser::AGGREGATE);
      setState(3424);
      aggregate_with_argtypes();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3426);
      match(PostgreSQLParser::ALTER);
      setState(3427);
      match(PostgreSQLParser::EXTENSION);
      setState(3428);
      name();
      setState(3429);
      add_drop();
      setState(3430);
      match(PostgreSQLParser::CAST);
      setState(3431);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(3432);
      typename_();
      setState(3433);
      match(PostgreSQLParser::AS);
      setState(3434);
      typename_();
      setState(3435);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3437);
      match(PostgreSQLParser::ALTER);
      setState(3438);
      match(PostgreSQLParser::EXTENSION);
      setState(3439);
      name();
      setState(3440);
      add_drop();
      setState(3441);
      match(PostgreSQLParser::DOMAIN_P);
      setState(3442);
      typename_();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3444);
      match(PostgreSQLParser::ALTER);
      setState(3445);
      match(PostgreSQLParser::EXTENSION);
      setState(3446);
      name();
      setState(3447);
      add_drop();
      setState(3448);
      match(PostgreSQLParser::FUNCTION);
      setState(3449);
      function_with_argtypes();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3451);
      match(PostgreSQLParser::ALTER);
      setState(3452);
      match(PostgreSQLParser::EXTENSION);
      setState(3453);
      name();
      setState(3454);
      add_drop();
      setState(3455);
      match(PostgreSQLParser::OPERATOR);
      setState(3456);
      operator_with_argtypes();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3458);
      match(PostgreSQLParser::ALTER);
      setState(3459);
      match(PostgreSQLParser::EXTENSION);
      setState(3460);
      name();
      setState(3461);
      add_drop();
      setState(3462);
      match(PostgreSQLParser::OPERATOR);
      setState(3463);
      match(PostgreSQLParser::CLASS);
      setState(3464);
      any_name();
      setState(3465);
      match(PostgreSQLParser::USING);
      setState(3466);
      name();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(3468);
      match(PostgreSQLParser::ALTER);
      setState(3469);
      match(PostgreSQLParser::EXTENSION);
      setState(3470);
      name();
      setState(3471);
      add_drop();
      setState(3472);
      match(PostgreSQLParser::OPERATOR);
      setState(3473);
      match(PostgreSQLParser::FAMILY);
      setState(3474);
      any_name();
      setState(3475);
      match(PostgreSQLParser::USING);
      setState(3476);
      name();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(3478);
      match(PostgreSQLParser::ALTER);
      setState(3479);
      match(PostgreSQLParser::EXTENSION);
      setState(3480);
      name();
      setState(3481);
      add_drop();
      setState(3482);
      match(PostgreSQLParser::PROCEDURE);
      setState(3483);
      function_with_argtypes();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(3485);
      match(PostgreSQLParser::ALTER);
      setState(3486);
      match(PostgreSQLParser::EXTENSION);
      setState(3487);
      name();
      setState(3488);
      add_drop();
      setState(3489);
      match(PostgreSQLParser::ROUTINE);
      setState(3490);
      function_with_argtypes();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(3492);
      match(PostgreSQLParser::ALTER);
      setState(3493);
      match(PostgreSQLParser::EXTENSION);
      setState(3494);
      name();
      setState(3495);
      add_drop();
      setState(3496);
      match(PostgreSQLParser::TRANSFORM);
      setState(3497);
      match(PostgreSQLParser::FOR);
      setState(3498);
      typename_();
      setState(3499);
      match(PostgreSQLParser::LANGUAGE);
      setState(3500);
      name();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(3502);
      match(PostgreSQLParser::ALTER);
      setState(3503);
      match(PostgreSQLParser::EXTENSION);
      setState(3504);
      name();
      setState(3505);
      add_drop();
      setState(3506);
      match(PostgreSQLParser::TYPE_P);
      setState(3507);
      typename_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreatefdwstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreatefdwstmtContext::CreatefdwstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreatefdwstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatefdwstmtContext::FOREIGN() {
  return getToken(PostgreSQLParser::FOREIGN, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatefdwstmtContext::DATA_P() {
  return getToken(PostgreSQLParser::DATA_P, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatefdwstmtContext::WRAPPER() {
  return getToken(PostgreSQLParser::WRAPPER, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::CreatefdwstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::Fdw_options_Context* PostgreSQLParser::CreatefdwstmtContext::fdw_options_() {
  return getRuleContext<PostgreSQLParser::Fdw_options_Context>(0);
}

PostgreSQLParser::Create_generic_optionsContext* PostgreSQLParser::CreatefdwstmtContext::create_generic_options() {
  return getRuleContext<PostgreSQLParser::Create_generic_optionsContext>(0);
}


size_t PostgreSQLParser::CreatefdwstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatefdwstmt;
}


std::any PostgreSQLParser::CreatefdwstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatefdwstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreatefdwstmtContext* PostgreSQLParser::createfdwstmt() {
  CreatefdwstmtContext *_localctx = _tracker.createInstance<CreatefdwstmtContext>(_ctx, getState());
  enterRule(_localctx, 326, PostgreSQLParser::RuleCreatefdwstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3511);
    match(PostgreSQLParser::CREATE);
    setState(3512);
    match(PostgreSQLParser::FOREIGN);
    setState(3513);
    match(PostgreSQLParser::DATA_P);
    setState(3514);
    match(PostgreSQLParser::WRAPPER);
    setState(3515);
    name();
    setState(3517);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::HANDLER

    || _la == PostgreSQLParser::NO || _la == PostgreSQLParser::VALIDATOR) {
      setState(3516);
      fdw_options_();
    }
    setState(3520);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OPTIONS) {
      setState(3519);
      create_generic_options();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fdw_optionContext ------------------------------------------------------------------

PostgreSQLParser::Fdw_optionContext::Fdw_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Fdw_optionContext::HANDLER() {
  return getToken(PostgreSQLParser::HANDLER, 0);
}

PostgreSQLParser::Handler_nameContext* PostgreSQLParser::Fdw_optionContext::handler_name() {
  return getRuleContext<PostgreSQLParser::Handler_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Fdw_optionContext::NO() {
  return getToken(PostgreSQLParser::NO, 0);
}

tree::TerminalNode* PostgreSQLParser::Fdw_optionContext::VALIDATOR() {
  return getToken(PostgreSQLParser::VALIDATOR, 0);
}


size_t PostgreSQLParser::Fdw_optionContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFdw_option;
}


std::any PostgreSQLParser::Fdw_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFdw_option(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Fdw_optionContext* PostgreSQLParser::fdw_option() {
  Fdw_optionContext *_localctx = _tracker.createInstance<Fdw_optionContext>(_ctx, getState());
  enterRule(_localctx, 328, PostgreSQLParser::RuleFdw_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3530);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 258, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3522);
      match(PostgreSQLParser::HANDLER);
      setState(3523);
      handler_name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3524);
      match(PostgreSQLParser::NO);
      setState(3525);
      match(PostgreSQLParser::HANDLER);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3526);
      match(PostgreSQLParser::VALIDATOR);
      setState(3527);
      handler_name();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3528);
      match(PostgreSQLParser::NO);
      setState(3529);
      match(PostgreSQLParser::VALIDATOR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fdw_optionsContext ------------------------------------------------------------------

PostgreSQLParser::Fdw_optionsContext::Fdw_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Fdw_optionContext *> PostgreSQLParser::Fdw_optionsContext::fdw_option() {
  return getRuleContexts<PostgreSQLParser::Fdw_optionContext>();
}

PostgreSQLParser::Fdw_optionContext* PostgreSQLParser::Fdw_optionsContext::fdw_option(size_t i) {
  return getRuleContext<PostgreSQLParser::Fdw_optionContext>(i);
}


size_t PostgreSQLParser::Fdw_optionsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFdw_options;
}


std::any PostgreSQLParser::Fdw_optionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFdw_options(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Fdw_optionsContext* PostgreSQLParser::fdw_options() {
  Fdw_optionsContext *_localctx = _tracker.createInstance<Fdw_optionsContext>(_ctx, getState());
  enterRule(_localctx, 330, PostgreSQLParser::RuleFdw_options);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3533); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(3532);
      fdw_option();
      setState(3535); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == PostgreSQLParser::HANDLER

    || _la == PostgreSQLParser::NO || _la == PostgreSQLParser::VALIDATOR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fdw_options_Context ------------------------------------------------------------------

PostgreSQLParser::Fdw_options_Context::Fdw_options_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Fdw_optionsContext* PostgreSQLParser::Fdw_options_Context::fdw_options() {
  return getRuleContext<PostgreSQLParser::Fdw_optionsContext>(0);
}


size_t PostgreSQLParser::Fdw_options_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleFdw_options_;
}


std::any PostgreSQLParser::Fdw_options_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFdw_options_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Fdw_options_Context* PostgreSQLParser::fdw_options_() {
  Fdw_options_Context *_localctx = _tracker.createInstance<Fdw_options_Context>(_ctx, getState());
  enterRule(_localctx, 332, PostgreSQLParser::RuleFdw_options_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3537);
    fdw_options();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterfdwstmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterfdwstmtContext::AlterfdwstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterfdwstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterfdwstmtContext::FOREIGN() {
  return getToken(PostgreSQLParser::FOREIGN, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterfdwstmtContext::DATA_P() {
  return getToken(PostgreSQLParser::DATA_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterfdwstmtContext::WRAPPER() {
  return getToken(PostgreSQLParser::WRAPPER, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::AlterfdwstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::Alter_generic_optionsContext* PostgreSQLParser::AlterfdwstmtContext::alter_generic_options() {
  return getRuleContext<PostgreSQLParser::Alter_generic_optionsContext>(0);
}

PostgreSQLParser::Fdw_options_Context* PostgreSQLParser::AlterfdwstmtContext::fdw_options_() {
  return getRuleContext<PostgreSQLParser::Fdw_options_Context>(0);
}

PostgreSQLParser::Fdw_optionsContext* PostgreSQLParser::AlterfdwstmtContext::fdw_options() {
  return getRuleContext<PostgreSQLParser::Fdw_optionsContext>(0);
}


size_t PostgreSQLParser::AlterfdwstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterfdwstmt;
}


std::any PostgreSQLParser::AlterfdwstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterfdwstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterfdwstmtContext* PostgreSQLParser::alterfdwstmt() {
  AlterfdwstmtContext *_localctx = _tracker.createInstance<AlterfdwstmtContext>(_ctx, getState());
  enterRule(_localctx, 334, PostgreSQLParser::RuleAlterfdwstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3556);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 261, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3539);
      match(PostgreSQLParser::ALTER);
      setState(3540);
      match(PostgreSQLParser::FOREIGN);
      setState(3541);
      match(PostgreSQLParser::DATA_P);
      setState(3542);
      match(PostgreSQLParser::WRAPPER);
      setState(3543);
      name();
      setState(3545);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::HANDLER

      || _la == PostgreSQLParser::NO || _la == PostgreSQLParser::VALIDATOR) {
        setState(3544);
        fdw_options_();
      }
      setState(3547);
      alter_generic_options();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3549);
      match(PostgreSQLParser::ALTER);
      setState(3550);
      match(PostgreSQLParser::FOREIGN);
      setState(3551);
      match(PostgreSQLParser::DATA_P);
      setState(3552);
      match(PostgreSQLParser::WRAPPER);
      setState(3553);
      name();
      setState(3554);
      fdw_options();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_generic_optionsContext ------------------------------------------------------------------

PostgreSQLParser::Create_generic_optionsContext::Create_generic_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Create_generic_optionsContext::OPTIONS() {
  return getToken(PostgreSQLParser::OPTIONS, 0);
}

tree::TerminalNode* PostgreSQLParser::Create_generic_optionsContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Generic_option_listContext* PostgreSQLParser::Create_generic_optionsContext::generic_option_list() {
  return getRuleContext<PostgreSQLParser::Generic_option_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Create_generic_optionsContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Create_generic_optionsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreate_generic_options;
}


std::any PostgreSQLParser::Create_generic_optionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreate_generic_options(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Create_generic_optionsContext* PostgreSQLParser::create_generic_options() {
  Create_generic_optionsContext *_localctx = _tracker.createInstance<Create_generic_optionsContext>(_ctx, getState());
  enterRule(_localctx, 336, PostgreSQLParser::RuleCreate_generic_options);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3558);
    match(PostgreSQLParser::OPTIONS);
    setState(3559);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(3560);
    generic_option_list();
    setState(3561);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generic_option_listContext ------------------------------------------------------------------

PostgreSQLParser::Generic_option_listContext::Generic_option_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Generic_option_elemContext *> PostgreSQLParser::Generic_option_listContext::generic_option_elem() {
  return getRuleContexts<PostgreSQLParser::Generic_option_elemContext>();
}

PostgreSQLParser::Generic_option_elemContext* PostgreSQLParser::Generic_option_listContext::generic_option_elem(size_t i) {
  return getRuleContext<PostgreSQLParser::Generic_option_elemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Generic_option_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Generic_option_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Generic_option_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleGeneric_option_list;
}


std::any PostgreSQLParser::Generic_option_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitGeneric_option_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Generic_option_listContext* PostgreSQLParser::generic_option_list() {
  Generic_option_listContext *_localctx = _tracker.createInstance<Generic_option_listContext>(_ctx, getState());
  enterRule(_localctx, 338, PostgreSQLParser::RuleGeneric_option_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3563);
    generic_option_elem();
    setState(3568);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(3564);
      match(PostgreSQLParser::COMMA);
      setState(3565);
      generic_option_elem();
      setState(3570);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_generic_optionsContext ------------------------------------------------------------------

PostgreSQLParser::Alter_generic_optionsContext::Alter_generic_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Alter_generic_optionsContext::OPTIONS() {
  return getToken(PostgreSQLParser::OPTIONS, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_generic_optionsContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Alter_generic_option_listContext* PostgreSQLParser::Alter_generic_optionsContext::alter_generic_option_list() {
  return getRuleContext<PostgreSQLParser::Alter_generic_option_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Alter_generic_optionsContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Alter_generic_optionsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlter_generic_options;
}


std::any PostgreSQLParser::Alter_generic_optionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlter_generic_options(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Alter_generic_optionsContext* PostgreSQLParser::alter_generic_options() {
  Alter_generic_optionsContext *_localctx = _tracker.createInstance<Alter_generic_optionsContext>(_ctx, getState());
  enterRule(_localctx, 340, PostgreSQLParser::RuleAlter_generic_options);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3571);
    match(PostgreSQLParser::OPTIONS);
    setState(3572);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(3573);
    alter_generic_option_list();
    setState(3574);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_generic_option_listContext ------------------------------------------------------------------

PostgreSQLParser::Alter_generic_option_listContext::Alter_generic_option_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Alter_generic_option_elemContext *> PostgreSQLParser::Alter_generic_option_listContext::alter_generic_option_elem() {
  return getRuleContexts<PostgreSQLParser::Alter_generic_option_elemContext>();
}

PostgreSQLParser::Alter_generic_option_elemContext* PostgreSQLParser::Alter_generic_option_listContext::alter_generic_option_elem(size_t i) {
  return getRuleContext<PostgreSQLParser::Alter_generic_option_elemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Alter_generic_option_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Alter_generic_option_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Alter_generic_option_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlter_generic_option_list;
}


std::any PostgreSQLParser::Alter_generic_option_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlter_generic_option_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Alter_generic_option_listContext* PostgreSQLParser::alter_generic_option_list() {
  Alter_generic_option_listContext *_localctx = _tracker.createInstance<Alter_generic_option_listContext>(_ctx, getState());
  enterRule(_localctx, 342, PostgreSQLParser::RuleAlter_generic_option_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3576);
    alter_generic_option_elem();
    setState(3581);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(3577);
      match(PostgreSQLParser::COMMA);
      setState(3578);
      alter_generic_option_elem();
      setState(3583);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_generic_option_elemContext ------------------------------------------------------------------

PostgreSQLParser::Alter_generic_option_elemContext::Alter_generic_option_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Generic_option_elemContext* PostgreSQLParser::Alter_generic_option_elemContext::generic_option_elem() {
  return getRuleContext<PostgreSQLParser::Generic_option_elemContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Alter_generic_option_elemContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_generic_option_elemContext::ADD_P() {
  return getToken(PostgreSQLParser::ADD_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Alter_generic_option_elemContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

PostgreSQLParser::Generic_option_nameContext* PostgreSQLParser::Alter_generic_option_elemContext::generic_option_name() {
  return getRuleContext<PostgreSQLParser::Generic_option_nameContext>(0);
}


size_t PostgreSQLParser::Alter_generic_option_elemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlter_generic_option_elem;
}


std::any PostgreSQLParser::Alter_generic_option_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlter_generic_option_elem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Alter_generic_option_elemContext* PostgreSQLParser::alter_generic_option_elem() {
  Alter_generic_option_elemContext *_localctx = _tracker.createInstance<Alter_generic_option_elemContext>(_ctx, getState());
  enterRule(_localctx, 344, PostgreSQLParser::RuleAlter_generic_option_elem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3591);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 264, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3584);
      generic_option_elem();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3585);
      match(PostgreSQLParser::SET);
      setState(3586);
      generic_option_elem();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3587);
      match(PostgreSQLParser::ADD_P);
      setState(3588);
      generic_option_elem();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3589);
      match(PostgreSQLParser::DROP);
      setState(3590);
      generic_option_name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generic_option_elemContext ------------------------------------------------------------------

PostgreSQLParser::Generic_option_elemContext::Generic_option_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Generic_option_nameContext* PostgreSQLParser::Generic_option_elemContext::generic_option_name() {
  return getRuleContext<PostgreSQLParser::Generic_option_nameContext>(0);
}

PostgreSQLParser::Generic_option_argContext* PostgreSQLParser::Generic_option_elemContext::generic_option_arg() {
  return getRuleContext<PostgreSQLParser::Generic_option_argContext>(0);
}


size_t PostgreSQLParser::Generic_option_elemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleGeneric_option_elem;
}


std::any PostgreSQLParser::Generic_option_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitGeneric_option_elem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Generic_option_elemContext* PostgreSQLParser::generic_option_elem() {
  Generic_option_elemContext *_localctx = _tracker.createInstance<Generic_option_elemContext>(_ctx, getState());
  enterRule(_localctx, 346, PostgreSQLParser::RuleGeneric_option_elem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3593);
    generic_option_name();
    setState(3594);
    generic_option_arg();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generic_option_nameContext ------------------------------------------------------------------

PostgreSQLParser::Generic_option_nameContext::Generic_option_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColLabelContext* PostgreSQLParser::Generic_option_nameContext::colLabel() {
  return getRuleContext<PostgreSQLParser::ColLabelContext>(0);
}


size_t PostgreSQLParser::Generic_option_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleGeneric_option_name;
}


std::any PostgreSQLParser::Generic_option_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitGeneric_option_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Generic_option_nameContext* PostgreSQLParser::generic_option_name() {
  Generic_option_nameContext *_localctx = _tracker.createInstance<Generic_option_nameContext>(_ctx, getState());
  enterRule(_localctx, 348, PostgreSQLParser::RuleGeneric_option_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3596);
    colLabel();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generic_option_argContext ------------------------------------------------------------------

PostgreSQLParser::Generic_option_argContext::Generic_option_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Generic_option_argContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}


size_t PostgreSQLParser::Generic_option_argContext::getRuleIndex() const {
  return PostgreSQLParser::RuleGeneric_option_arg;
}


std::any PostgreSQLParser::Generic_option_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitGeneric_option_arg(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Generic_option_argContext* PostgreSQLParser::generic_option_arg() {
  Generic_option_argContext *_localctx = _tracker.createInstance<Generic_option_argContext>(_ctx, getState());
  enterRule(_localctx, 350, PostgreSQLParser::RuleGeneric_option_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3598);
    sconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateforeignserverstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreateforeignserverstmtContext::CreateforeignserverstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreateforeignserverstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateforeignserverstmtContext::SERVER() {
  return getToken(PostgreSQLParser::SERVER, 0);
}

std::vector<PostgreSQLParser::NameContext *> PostgreSQLParser::CreateforeignserverstmtContext::name() {
  return getRuleContexts<PostgreSQLParser::NameContext>();
}

PostgreSQLParser::NameContext* PostgreSQLParser::CreateforeignserverstmtContext::name(size_t i) {
  return getRuleContext<PostgreSQLParser::NameContext>(i);
}

tree::TerminalNode* PostgreSQLParser::CreateforeignserverstmtContext::FOREIGN() {
  return getToken(PostgreSQLParser::FOREIGN, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateforeignserverstmtContext::DATA_P() {
  return getToken(PostgreSQLParser::DATA_P, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateforeignserverstmtContext::WRAPPER() {
  return getToken(PostgreSQLParser::WRAPPER, 0);
}

PostgreSQLParser::Type_Context* PostgreSQLParser::CreateforeignserverstmtContext::type_() {
  return getRuleContext<PostgreSQLParser::Type_Context>(0);
}

PostgreSQLParser::Foreign_server_version_Context* PostgreSQLParser::CreateforeignserverstmtContext::foreign_server_version_() {
  return getRuleContext<PostgreSQLParser::Foreign_server_version_Context>(0);
}

PostgreSQLParser::Create_generic_optionsContext* PostgreSQLParser::CreateforeignserverstmtContext::create_generic_options() {
  return getRuleContext<PostgreSQLParser::Create_generic_optionsContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateforeignserverstmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateforeignserverstmtContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateforeignserverstmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}


size_t PostgreSQLParser::CreateforeignserverstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreateforeignserverstmt;
}


std::any PostgreSQLParser::CreateforeignserverstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateforeignserverstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreateforeignserverstmtContext* PostgreSQLParser::createforeignserverstmt() {
  CreateforeignserverstmtContext *_localctx = _tracker.createInstance<CreateforeignserverstmtContext>(_ctx, getState());
  enterRule(_localctx, 352, PostgreSQLParser::RuleCreateforeignserverstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3635);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 271, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3600);
      match(PostgreSQLParser::CREATE);
      setState(3601);
      match(PostgreSQLParser::SERVER);
      setState(3602);
      name();
      setState(3604);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::TYPE_P) {
        setState(3603);
        type_();
      }
      setState(3607);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::VERSION_P) {
        setState(3606);
        foreign_server_version_();
      }
      setState(3609);
      match(PostgreSQLParser::FOREIGN);
      setState(3610);
      match(PostgreSQLParser::DATA_P);
      setState(3611);
      match(PostgreSQLParser::WRAPPER);
      setState(3612);
      name();
      setState(3614);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPTIONS) {
        setState(3613);
        create_generic_options();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3616);
      match(PostgreSQLParser::CREATE);
      setState(3617);
      match(PostgreSQLParser::SERVER);
      setState(3618);
      match(PostgreSQLParser::IF_P);
      setState(3619);
      match(PostgreSQLParser::NOT);
      setState(3620);
      match(PostgreSQLParser::EXISTS);
      setState(3621);
      name();
      setState(3623);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::TYPE_P) {
        setState(3622);
        type_();
      }
      setState(3626);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::VERSION_P) {
        setState(3625);
        foreign_server_version_();
      }
      setState(3628);
      match(PostgreSQLParser::FOREIGN);
      setState(3629);
      match(PostgreSQLParser::DATA_P);
      setState(3630);
      match(PostgreSQLParser::WRAPPER);
      setState(3631);
      name();
      setState(3633);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPTIONS) {
        setState(3632);
        create_generic_options();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_Context ------------------------------------------------------------------

PostgreSQLParser::Type_Context::Type_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Type_Context::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Type_Context::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}


size_t PostgreSQLParser::Type_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleType_;
}


std::any PostgreSQLParser::Type_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitType_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Type_Context* PostgreSQLParser::type_() {
  Type_Context *_localctx = _tracker.createInstance<Type_Context>(_ctx, getState());
  enterRule(_localctx, 354, PostgreSQLParser::RuleType_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3637);
    match(PostgreSQLParser::TYPE_P);
    setState(3638);
    sconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Foreign_server_versionContext ------------------------------------------------------------------

PostgreSQLParser::Foreign_server_versionContext::Foreign_server_versionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Foreign_server_versionContext::VERSION_P() {
  return getToken(PostgreSQLParser::VERSION_P, 0);
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Foreign_server_versionContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Foreign_server_versionContext::NULL_P() {
  return getToken(PostgreSQLParser::NULL_P, 0);
}


size_t PostgreSQLParser::Foreign_server_versionContext::getRuleIndex() const {
  return PostgreSQLParser::RuleForeign_server_version;
}


std::any PostgreSQLParser::Foreign_server_versionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitForeign_server_version(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Foreign_server_versionContext* PostgreSQLParser::foreign_server_version() {
  Foreign_server_versionContext *_localctx = _tracker.createInstance<Foreign_server_versionContext>(_ctx, getState());
  enterRule(_localctx, 356, PostgreSQLParser::RuleForeign_server_version);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3640);
    match(PostgreSQLParser::VERSION_P);
    setState(3643);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::EscapeStringConstant: {
        setState(3641);
        sconst();
        break;
      }

      case PostgreSQLParser::NULL_P: {
        setState(3642);
        match(PostgreSQLParser::NULL_P);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Foreign_server_version_Context ------------------------------------------------------------------

PostgreSQLParser::Foreign_server_version_Context::Foreign_server_version_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Foreign_server_versionContext* PostgreSQLParser::Foreign_server_version_Context::foreign_server_version() {
  return getRuleContext<PostgreSQLParser::Foreign_server_versionContext>(0);
}


size_t PostgreSQLParser::Foreign_server_version_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleForeign_server_version_;
}


std::any PostgreSQLParser::Foreign_server_version_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitForeign_server_version_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Foreign_server_version_Context* PostgreSQLParser::foreign_server_version_() {
  Foreign_server_version_Context *_localctx = _tracker.createInstance<Foreign_server_version_Context>(_ctx, getState());
  enterRule(_localctx, 358, PostgreSQLParser::RuleForeign_server_version_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3645);
    foreign_server_version();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterforeignserverstmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterforeignserverstmtContext::AlterforeignserverstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterforeignserverstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterforeignserverstmtContext::SERVER() {
  return getToken(PostgreSQLParser::SERVER, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::AlterforeignserverstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::Alter_generic_optionsContext* PostgreSQLParser::AlterforeignserverstmtContext::alter_generic_options() {
  return getRuleContext<PostgreSQLParser::Alter_generic_optionsContext>(0);
}

PostgreSQLParser::Foreign_server_versionContext* PostgreSQLParser::AlterforeignserverstmtContext::foreign_server_version() {
  return getRuleContext<PostgreSQLParser::Foreign_server_versionContext>(0);
}


size_t PostgreSQLParser::AlterforeignserverstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterforeignserverstmt;
}


std::any PostgreSQLParser::AlterforeignserverstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterforeignserverstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterforeignserverstmtContext* PostgreSQLParser::alterforeignserverstmt() {
  AlterforeignserverstmtContext *_localctx = _tracker.createInstance<AlterforeignserverstmtContext>(_ctx, getState());
  enterRule(_localctx, 360, PostgreSQLParser::RuleAlterforeignserverstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3647);
    match(PostgreSQLParser::ALTER);
    setState(3648);
    match(PostgreSQLParser::SERVER);
    setState(3649);
    name();
    setState(3655);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::OPTIONS: {
        setState(3650);
        alter_generic_options();
        break;
      }

      case PostgreSQLParser::VERSION_P: {
        setState(3651);
        foreign_server_version();
        setState(3653);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::OPTIONS) {
          setState(3652);
          alter_generic_options();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateforeigntablestmtContext ------------------------------------------------------------------

PostgreSQLParser::CreateforeigntablestmtContext::CreateforeigntablestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreateforeigntablestmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateforeigntablestmtContext::FOREIGN() {
  return getToken(PostgreSQLParser::FOREIGN, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateforeigntablestmtContext::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}

std::vector<PostgreSQLParser::Qualified_nameContext *> PostgreSQLParser::CreateforeigntablestmtContext::qualified_name() {
  return getRuleContexts<PostgreSQLParser::Qualified_nameContext>();
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::CreateforeigntablestmtContext::qualified_name(size_t i) {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(i);
}

tree::TerminalNode* PostgreSQLParser::CreateforeigntablestmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateforeigntablestmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateforeigntablestmtContext::SERVER() {
  return getToken(PostgreSQLParser::SERVER, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::CreateforeigntablestmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::OpttableelementlistContext* PostgreSQLParser::CreateforeigntablestmtContext::opttableelementlist() {
  return getRuleContext<PostgreSQLParser::OpttableelementlistContext>(0);
}

PostgreSQLParser::OptinheritContext* PostgreSQLParser::CreateforeigntablestmtContext::optinherit() {
  return getRuleContext<PostgreSQLParser::OptinheritContext>(0);
}

PostgreSQLParser::Create_generic_optionsContext* PostgreSQLParser::CreateforeigntablestmtContext::create_generic_options() {
  return getRuleContext<PostgreSQLParser::Create_generic_optionsContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateforeigntablestmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateforeigntablestmtContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateforeigntablestmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateforeigntablestmtContext::PARTITION() {
  return getToken(PostgreSQLParser::PARTITION, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateforeigntablestmtContext::OF() {
  return getToken(PostgreSQLParser::OF, 0);
}

PostgreSQLParser::PartitionboundspecContext* PostgreSQLParser::CreateforeigntablestmtContext::partitionboundspec() {
  return getRuleContext<PostgreSQLParser::PartitionboundspecContext>(0);
}

PostgreSQLParser::OpttypedtableelementlistContext* PostgreSQLParser::CreateforeigntablestmtContext::opttypedtableelementlist() {
  return getRuleContext<PostgreSQLParser::OpttypedtableelementlistContext>(0);
}


size_t PostgreSQLParser::CreateforeigntablestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreateforeigntablestmt;
}


std::any PostgreSQLParser::CreateforeigntablestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateforeigntablestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreateforeigntablestmtContext* PostgreSQLParser::createforeigntablestmt() {
  CreateforeigntablestmtContext *_localctx = _tracker.createInstance<CreateforeigntablestmtContext>(_ctx, getState());
  enterRule(_localctx, 362, PostgreSQLParser::RuleCreateforeigntablestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3729);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 285, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3657);
      match(PostgreSQLParser::CREATE);
      setState(3658);
      match(PostgreSQLParser::FOREIGN);
      setState(3659);
      match(PostgreSQLParser::TABLE);
      setState(3660);
      qualified_name();
      setState(3661);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(3663);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -4399120252928) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 576460889742966791) != 0) || ((((_la - 136) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 136)) & -2076180479) != 0) || ((((_la - 200) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 200)) & -1) != 0) || ((((_la - 264) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 264)) & -1) != 0) || ((((_la - 328) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 328)) & -33) != 0) || ((((_la - 392) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 392)) & -1) != 0) || ((((_la - 463) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 463)) & -4644337652596737) != 0) || ((((_la - 527) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 527)) & 36028801783726085) != 0)) {
        setState(3662);
        opttableelementlist();
      }
      setState(3665);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(3667);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::INHERITS) {
        setState(3666);
        optinherit();
      }
      setState(3669);
      match(PostgreSQLParser::SERVER);
      setState(3670);
      name();
      setState(3672);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPTIONS) {
        setState(3671);
        create_generic_options();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3674);
      match(PostgreSQLParser::CREATE);
      setState(3675);
      match(PostgreSQLParser::FOREIGN);
      setState(3676);
      match(PostgreSQLParser::TABLE);
      setState(3677);
      match(PostgreSQLParser::IF_P);
      setState(3678);
      match(PostgreSQLParser::NOT);
      setState(3679);
      match(PostgreSQLParser::EXISTS);
      setState(3680);
      qualified_name();
      setState(3681);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(3683);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & -4399120252928) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 576460889742966791) != 0) || ((((_la - 136) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 136)) & -2076180479) != 0) || ((((_la - 200) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 200)) & -1) != 0) || ((((_la - 264) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 264)) & -1) != 0) || ((((_la - 328) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 328)) & -33) != 0) || ((((_la - 392) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 392)) & -1) != 0) || ((((_la - 463) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 463)) & -4644337652596737) != 0) || ((((_la - 527) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 527)) & 36028801783726085) != 0)) {
        setState(3682);
        opttableelementlist();
      }
      setState(3685);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(3687);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::INHERITS) {
        setState(3686);
        optinherit();
      }
      setState(3689);
      match(PostgreSQLParser::SERVER);
      setState(3690);
      name();
      setState(3692);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPTIONS) {
        setState(3691);
        create_generic_options();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3694);
      match(PostgreSQLParser::CREATE);
      setState(3695);
      match(PostgreSQLParser::FOREIGN);
      setState(3696);
      match(PostgreSQLParser::TABLE);
      setState(3697);
      qualified_name();
      setState(3698);
      match(PostgreSQLParser::PARTITION);
      setState(3699);
      match(PostgreSQLParser::OF);
      setState(3700);
      qualified_name();
      setState(3702);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPEN_PAREN) {
        setState(3701);
        opttypedtableelementlist();
      }
      setState(3704);
      partitionboundspec();
      setState(3705);
      match(PostgreSQLParser::SERVER);
      setState(3706);
      name();
      setState(3708);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPTIONS) {
        setState(3707);
        create_generic_options();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3710);
      match(PostgreSQLParser::CREATE);
      setState(3711);
      match(PostgreSQLParser::FOREIGN);
      setState(3712);
      match(PostgreSQLParser::TABLE);
      setState(3713);
      match(PostgreSQLParser::IF_P);
      setState(3714);
      match(PostgreSQLParser::NOT);
      setState(3715);
      match(PostgreSQLParser::EXISTS);
      setState(3716);
      qualified_name();
      setState(3717);
      match(PostgreSQLParser::PARTITION);
      setState(3718);
      match(PostgreSQLParser::OF);
      setState(3719);
      qualified_name();
      setState(3721);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPEN_PAREN) {
        setState(3720);
        opttypedtableelementlist();
      }
      setState(3723);
      partitionboundspec();
      setState(3724);
      match(PostgreSQLParser::SERVER);
      setState(3725);
      name();
      setState(3727);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPTIONS) {
        setState(3726);
        create_generic_options();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportforeignschemastmtContext ------------------------------------------------------------------

PostgreSQLParser::ImportforeignschemastmtContext::ImportforeignschemastmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::ImportforeignschemastmtContext::IMPORT_P() {
  return getToken(PostgreSQLParser::IMPORT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::ImportforeignschemastmtContext::FOREIGN() {
  return getToken(PostgreSQLParser::FOREIGN, 0);
}

tree::TerminalNode* PostgreSQLParser::ImportforeignschemastmtContext::SCHEMA() {
  return getToken(PostgreSQLParser::SCHEMA, 0);
}

std::vector<PostgreSQLParser::NameContext *> PostgreSQLParser::ImportforeignschemastmtContext::name() {
  return getRuleContexts<PostgreSQLParser::NameContext>();
}

PostgreSQLParser::NameContext* PostgreSQLParser::ImportforeignschemastmtContext::name(size_t i) {
  return getRuleContext<PostgreSQLParser::NameContext>(i);
}

tree::TerminalNode* PostgreSQLParser::ImportforeignschemastmtContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

tree::TerminalNode* PostgreSQLParser::ImportforeignschemastmtContext::SERVER() {
  return getToken(PostgreSQLParser::SERVER, 0);
}

tree::TerminalNode* PostgreSQLParser::ImportforeignschemastmtContext::INTO() {
  return getToken(PostgreSQLParser::INTO, 0);
}

PostgreSQLParser::Import_qualificationContext* PostgreSQLParser::ImportforeignschemastmtContext::import_qualification() {
  return getRuleContext<PostgreSQLParser::Import_qualificationContext>(0);
}

PostgreSQLParser::Create_generic_optionsContext* PostgreSQLParser::ImportforeignschemastmtContext::create_generic_options() {
  return getRuleContext<PostgreSQLParser::Create_generic_optionsContext>(0);
}


size_t PostgreSQLParser::ImportforeignschemastmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleImportforeignschemastmt;
}


std::any PostgreSQLParser::ImportforeignschemastmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitImportforeignschemastmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ImportforeignschemastmtContext* PostgreSQLParser::importforeignschemastmt() {
  ImportforeignschemastmtContext *_localctx = _tracker.createInstance<ImportforeignschemastmtContext>(_ctx, getState());
  enterRule(_localctx, 364, PostgreSQLParser::RuleImportforeignschemastmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3731);
    match(PostgreSQLParser::IMPORT_P);
    setState(3732);
    match(PostgreSQLParser::FOREIGN);
    setState(3733);
    match(PostgreSQLParser::SCHEMA);
    setState(3734);
    name();
    setState(3736);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::EXCEPT

    || _la == PostgreSQLParser::LIMIT) {
      setState(3735);
      import_qualification();
    }
    setState(3738);
    match(PostgreSQLParser::FROM);
    setState(3739);
    match(PostgreSQLParser::SERVER);
    setState(3740);
    name();
    setState(3741);
    match(PostgreSQLParser::INTO);
    setState(3742);
    name();
    setState(3744);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OPTIONS) {
      setState(3743);
      create_generic_options();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_qualification_typeContext ------------------------------------------------------------------

PostgreSQLParser::Import_qualification_typeContext::Import_qualification_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Import_qualification_typeContext::LIMIT() {
  return getToken(PostgreSQLParser::LIMIT, 0);
}

tree::TerminalNode* PostgreSQLParser::Import_qualification_typeContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}

tree::TerminalNode* PostgreSQLParser::Import_qualification_typeContext::EXCEPT() {
  return getToken(PostgreSQLParser::EXCEPT, 0);
}


size_t PostgreSQLParser::Import_qualification_typeContext::getRuleIndex() const {
  return PostgreSQLParser::RuleImport_qualification_type;
}


std::any PostgreSQLParser::Import_qualification_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitImport_qualification_type(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Import_qualification_typeContext* PostgreSQLParser::import_qualification_type() {
  Import_qualification_typeContext *_localctx = _tracker.createInstance<Import_qualification_typeContext>(_ctx, getState());
  enterRule(_localctx, 366, PostgreSQLParser::RuleImport_qualification_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3749);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::LIMIT: {
        enterOuterAlt(_localctx, 1);
        setState(3746);
        match(PostgreSQLParser::LIMIT);
        setState(3747);
        match(PostgreSQLParser::TO);
        break;
      }

      case PostgreSQLParser::EXCEPT: {
        enterOuterAlt(_localctx, 2);
        setState(3748);
        match(PostgreSQLParser::EXCEPT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_qualificationContext ------------------------------------------------------------------

PostgreSQLParser::Import_qualificationContext::Import_qualificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Import_qualification_typeContext* PostgreSQLParser::Import_qualificationContext::import_qualification_type() {
  return getRuleContext<PostgreSQLParser::Import_qualification_typeContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Import_qualificationContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Relation_expr_listContext* PostgreSQLParser::Import_qualificationContext::relation_expr_list() {
  return getRuleContext<PostgreSQLParser::Relation_expr_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Import_qualificationContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Import_qualificationContext::getRuleIndex() const {
  return PostgreSQLParser::RuleImport_qualification;
}


std::any PostgreSQLParser::Import_qualificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitImport_qualification(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Import_qualificationContext* PostgreSQLParser::import_qualification() {
  Import_qualificationContext *_localctx = _tracker.createInstance<Import_qualificationContext>(_ctx, getState());
  enterRule(_localctx, 368, PostgreSQLParser::RuleImport_qualification);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3751);
    import_qualification_type();
    setState(3752);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(3753);
    relation_expr_list();
    setState(3754);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateusermappingstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreateusermappingstmtContext::CreateusermappingstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreateusermappingstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateusermappingstmtContext::USER() {
  return getToken(PostgreSQLParser::USER, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateusermappingstmtContext::MAPPING() {
  return getToken(PostgreSQLParser::MAPPING, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateusermappingstmtContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

PostgreSQLParser::Auth_identContext* PostgreSQLParser::CreateusermappingstmtContext::auth_ident() {
  return getRuleContext<PostgreSQLParser::Auth_identContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateusermappingstmtContext::SERVER() {
  return getToken(PostgreSQLParser::SERVER, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::CreateusermappingstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::Create_generic_optionsContext* PostgreSQLParser::CreateusermappingstmtContext::create_generic_options() {
  return getRuleContext<PostgreSQLParser::Create_generic_optionsContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateusermappingstmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateusermappingstmtContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateusermappingstmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}


size_t PostgreSQLParser::CreateusermappingstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreateusermappingstmt;
}


std::any PostgreSQLParser::CreateusermappingstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateusermappingstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreateusermappingstmtContext* PostgreSQLParser::createusermappingstmt() {
  CreateusermappingstmtContext *_localctx = _tracker.createInstance<CreateusermappingstmtContext>(_ctx, getState());
  enterRule(_localctx, 370, PostgreSQLParser::RuleCreateusermappingstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3779);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 291, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3756);
      match(PostgreSQLParser::CREATE);
      setState(3757);
      match(PostgreSQLParser::USER);
      setState(3758);
      match(PostgreSQLParser::MAPPING);
      setState(3759);
      match(PostgreSQLParser::FOR);
      setState(3760);
      auth_ident();
      setState(3761);
      match(PostgreSQLParser::SERVER);
      setState(3762);
      name();
      setState(3764);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPTIONS) {
        setState(3763);
        create_generic_options();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3766);
      match(PostgreSQLParser::CREATE);
      setState(3767);
      match(PostgreSQLParser::USER);
      setState(3768);
      match(PostgreSQLParser::MAPPING);
      setState(3769);
      match(PostgreSQLParser::IF_P);
      setState(3770);
      match(PostgreSQLParser::NOT);
      setState(3771);
      match(PostgreSQLParser::EXISTS);
      setState(3772);
      match(PostgreSQLParser::FOR);
      setState(3773);
      auth_ident();
      setState(3774);
      match(PostgreSQLParser::SERVER);
      setState(3775);
      name();
      setState(3777);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPTIONS) {
        setState(3776);
        create_generic_options();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Auth_identContext ------------------------------------------------------------------

PostgreSQLParser::Auth_identContext::Auth_identContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::RolespecContext* PostgreSQLParser::Auth_identContext::rolespec() {
  return getRuleContext<PostgreSQLParser::RolespecContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Auth_identContext::USER() {
  return getToken(PostgreSQLParser::USER, 0);
}


size_t PostgreSQLParser::Auth_identContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAuth_ident;
}


std::any PostgreSQLParser::Auth_identContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAuth_ident(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Auth_identContext* PostgreSQLParser::auth_ident() {
  Auth_identContext *_localctx = _tracker.createInstance<Auth_identContext>(_ctx, getState());
  enterRule(_localctx, 372, PostgreSQLParser::RuleAuth_ident);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3783);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::CURRENT_USER:
      case PostgreSQLParser::SESSION_USER:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 1);
        setState(3781);
        rolespec();
        break;
      }

      case PostgreSQLParser::USER: {
        enterOuterAlt(_localctx, 2);
        setState(3782);
        match(PostgreSQLParser::USER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropusermappingstmtContext ------------------------------------------------------------------

PostgreSQLParser::DropusermappingstmtContext::DropusermappingstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DropusermappingstmtContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

tree::TerminalNode* PostgreSQLParser::DropusermappingstmtContext::USER() {
  return getToken(PostgreSQLParser::USER, 0);
}

tree::TerminalNode* PostgreSQLParser::DropusermappingstmtContext::MAPPING() {
  return getToken(PostgreSQLParser::MAPPING, 0);
}

tree::TerminalNode* PostgreSQLParser::DropusermappingstmtContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

PostgreSQLParser::Auth_identContext* PostgreSQLParser::DropusermappingstmtContext::auth_ident() {
  return getRuleContext<PostgreSQLParser::Auth_identContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DropusermappingstmtContext::SERVER() {
  return getToken(PostgreSQLParser::SERVER, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::DropusermappingstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DropusermappingstmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::DropusermappingstmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}


size_t PostgreSQLParser::DropusermappingstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDropusermappingstmt;
}


std::any PostgreSQLParser::DropusermappingstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDropusermappingstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DropusermappingstmtContext* PostgreSQLParser::dropusermappingstmt() {
  DropusermappingstmtContext *_localctx = _tracker.createInstance<DropusermappingstmtContext>(_ctx, getState());
  enterRule(_localctx, 374, PostgreSQLParser::RuleDropusermappingstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3803);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 293, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3785);
      match(PostgreSQLParser::DROP);
      setState(3786);
      match(PostgreSQLParser::USER);
      setState(3787);
      match(PostgreSQLParser::MAPPING);
      setState(3788);
      match(PostgreSQLParser::FOR);
      setState(3789);
      auth_ident();
      setState(3790);
      match(PostgreSQLParser::SERVER);
      setState(3791);
      name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3793);
      match(PostgreSQLParser::DROP);
      setState(3794);
      match(PostgreSQLParser::USER);
      setState(3795);
      match(PostgreSQLParser::MAPPING);
      setState(3796);
      match(PostgreSQLParser::IF_P);
      setState(3797);
      match(PostgreSQLParser::EXISTS);
      setState(3798);
      match(PostgreSQLParser::FOR);
      setState(3799);
      auth_ident();
      setState(3800);
      match(PostgreSQLParser::SERVER);
      setState(3801);
      name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterusermappingstmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterusermappingstmtContext::AlterusermappingstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterusermappingstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterusermappingstmtContext::USER() {
  return getToken(PostgreSQLParser::USER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterusermappingstmtContext::MAPPING() {
  return getToken(PostgreSQLParser::MAPPING, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterusermappingstmtContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

PostgreSQLParser::Auth_identContext* PostgreSQLParser::AlterusermappingstmtContext::auth_ident() {
  return getRuleContext<PostgreSQLParser::Auth_identContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterusermappingstmtContext::SERVER() {
  return getToken(PostgreSQLParser::SERVER, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::AlterusermappingstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::Alter_generic_optionsContext* PostgreSQLParser::AlterusermappingstmtContext::alter_generic_options() {
  return getRuleContext<PostgreSQLParser::Alter_generic_optionsContext>(0);
}


size_t PostgreSQLParser::AlterusermappingstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterusermappingstmt;
}


std::any PostgreSQLParser::AlterusermappingstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterusermappingstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterusermappingstmtContext* PostgreSQLParser::alterusermappingstmt() {
  AlterusermappingstmtContext *_localctx = _tracker.createInstance<AlterusermappingstmtContext>(_ctx, getState());
  enterRule(_localctx, 376, PostgreSQLParser::RuleAlterusermappingstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3805);
    match(PostgreSQLParser::ALTER);
    setState(3806);
    match(PostgreSQLParser::USER);
    setState(3807);
    match(PostgreSQLParser::MAPPING);
    setState(3808);
    match(PostgreSQLParser::FOR);
    setState(3809);
    auth_ident();
    setState(3810);
    match(PostgreSQLParser::SERVER);
    setState(3811);
    name();
    setState(3812);
    alter_generic_options();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreatepolicystmtContext ------------------------------------------------------------------

PostgreSQLParser::CreatepolicystmtContext::CreatepolicystmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreatepolicystmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatepolicystmtContext::POLICY() {
  return getToken(PostgreSQLParser::POLICY, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::CreatepolicystmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatepolicystmtContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::CreatepolicystmtContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

PostgreSQLParser::RowsecuritydefaultpermissiveContext* PostgreSQLParser::CreatepolicystmtContext::rowsecuritydefaultpermissive() {
  return getRuleContext<PostgreSQLParser::RowsecuritydefaultpermissiveContext>(0);
}

PostgreSQLParser::RowsecuritydefaultforcmdContext* PostgreSQLParser::CreatepolicystmtContext::rowsecuritydefaultforcmd() {
  return getRuleContext<PostgreSQLParser::RowsecuritydefaultforcmdContext>(0);
}

PostgreSQLParser::RowsecuritydefaulttoroleContext* PostgreSQLParser::CreatepolicystmtContext::rowsecuritydefaulttorole() {
  return getRuleContext<PostgreSQLParser::RowsecuritydefaulttoroleContext>(0);
}

PostgreSQLParser::RowsecurityoptionalexprContext* PostgreSQLParser::CreatepolicystmtContext::rowsecurityoptionalexpr() {
  return getRuleContext<PostgreSQLParser::RowsecurityoptionalexprContext>(0);
}

PostgreSQLParser::RowsecurityoptionalwithcheckContext* PostgreSQLParser::CreatepolicystmtContext::rowsecurityoptionalwithcheck() {
  return getRuleContext<PostgreSQLParser::RowsecurityoptionalwithcheckContext>(0);
}


size_t PostgreSQLParser::CreatepolicystmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatepolicystmt;
}


std::any PostgreSQLParser::CreatepolicystmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatepolicystmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreatepolicystmtContext* PostgreSQLParser::createpolicystmt() {
  CreatepolicystmtContext *_localctx = _tracker.createInstance<CreatepolicystmtContext>(_ctx, getState());
  enterRule(_localctx, 378, PostgreSQLParser::RuleCreatepolicystmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3814);
    match(PostgreSQLParser::CREATE);
    setState(3815);
    match(PostgreSQLParser::POLICY);
    setState(3816);
    name();
    setState(3817);
    match(PostgreSQLParser::ON);
    setState(3818);
    qualified_name();
    setState(3820);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::AS) {
      setState(3819);
      rowsecuritydefaultpermissive();
    }
    setState(3823);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::FOR) {
      setState(3822);
      rowsecuritydefaultforcmd();
    }
    setState(3826);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::TO) {
      setState(3825);
      rowsecuritydefaulttorole();
    }
    setState(3829);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::USING) {
      setState(3828);
      rowsecurityoptionalexpr();
    }
    setState(3832);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(3831);
      rowsecurityoptionalwithcheck();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterpolicystmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterpolicystmtContext::AlterpolicystmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterpolicystmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterpolicystmtContext::POLICY() {
  return getToken(PostgreSQLParser::POLICY, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::AlterpolicystmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterpolicystmtContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::AlterpolicystmtContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

PostgreSQLParser::RowsecurityoptionaltoroleContext* PostgreSQLParser::AlterpolicystmtContext::rowsecurityoptionaltorole() {
  return getRuleContext<PostgreSQLParser::RowsecurityoptionaltoroleContext>(0);
}

PostgreSQLParser::RowsecurityoptionalexprContext* PostgreSQLParser::AlterpolicystmtContext::rowsecurityoptionalexpr() {
  return getRuleContext<PostgreSQLParser::RowsecurityoptionalexprContext>(0);
}

PostgreSQLParser::RowsecurityoptionalwithcheckContext* PostgreSQLParser::AlterpolicystmtContext::rowsecurityoptionalwithcheck() {
  return getRuleContext<PostgreSQLParser::RowsecurityoptionalwithcheckContext>(0);
}


size_t PostgreSQLParser::AlterpolicystmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterpolicystmt;
}


std::any PostgreSQLParser::AlterpolicystmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterpolicystmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterpolicystmtContext* PostgreSQLParser::alterpolicystmt() {
  AlterpolicystmtContext *_localctx = _tracker.createInstance<AlterpolicystmtContext>(_ctx, getState());
  enterRule(_localctx, 380, PostgreSQLParser::RuleAlterpolicystmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3834);
    match(PostgreSQLParser::ALTER);
    setState(3835);
    match(PostgreSQLParser::POLICY);
    setState(3836);
    name();
    setState(3837);
    match(PostgreSQLParser::ON);
    setState(3838);
    qualified_name();
    setState(3840);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::TO) {
      setState(3839);
      rowsecurityoptionaltorole();
    }
    setState(3843);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::USING) {
      setState(3842);
      rowsecurityoptionalexpr();
    }
    setState(3846);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(3845);
      rowsecurityoptionalwithcheck();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RowsecurityoptionalexprContext ------------------------------------------------------------------

PostgreSQLParser::RowsecurityoptionalexprContext::RowsecurityoptionalexprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::RowsecurityoptionalexprContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

tree::TerminalNode* PostgreSQLParser::RowsecurityoptionalexprContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::RowsecurityoptionalexprContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::RowsecurityoptionalexprContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::RowsecurityoptionalexprContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRowsecurityoptionalexpr;
}


std::any PostgreSQLParser::RowsecurityoptionalexprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRowsecurityoptionalexpr(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RowsecurityoptionalexprContext* PostgreSQLParser::rowsecurityoptionalexpr() {
  RowsecurityoptionalexprContext *_localctx = _tracker.createInstance<RowsecurityoptionalexprContext>(_ctx, getState());
  enterRule(_localctx, 382, PostgreSQLParser::RuleRowsecurityoptionalexpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3848);
    match(PostgreSQLParser::USING);
    setState(3849);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(3850);
    a_expr();
    setState(3851);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RowsecurityoptionalwithcheckContext ------------------------------------------------------------------

PostgreSQLParser::RowsecurityoptionalwithcheckContext::RowsecurityoptionalwithcheckContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::RowsecurityoptionalwithcheckContext::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

tree::TerminalNode* PostgreSQLParser::RowsecurityoptionalwithcheckContext::CHECK() {
  return getToken(PostgreSQLParser::CHECK, 0);
}

tree::TerminalNode* PostgreSQLParser::RowsecurityoptionalwithcheckContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::RowsecurityoptionalwithcheckContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::RowsecurityoptionalwithcheckContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::RowsecurityoptionalwithcheckContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRowsecurityoptionalwithcheck;
}


std::any PostgreSQLParser::RowsecurityoptionalwithcheckContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRowsecurityoptionalwithcheck(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RowsecurityoptionalwithcheckContext* PostgreSQLParser::rowsecurityoptionalwithcheck() {
  RowsecurityoptionalwithcheckContext *_localctx = _tracker.createInstance<RowsecurityoptionalwithcheckContext>(_ctx, getState());
  enterRule(_localctx, 384, PostgreSQLParser::RuleRowsecurityoptionalwithcheck);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3853);
    match(PostgreSQLParser::WITH);
    setState(3854);
    match(PostgreSQLParser::CHECK);
    setState(3855);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(3856);
    a_expr();
    setState(3857);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RowsecuritydefaulttoroleContext ------------------------------------------------------------------

PostgreSQLParser::RowsecuritydefaulttoroleContext::RowsecuritydefaulttoroleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::RowsecuritydefaulttoroleContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}

PostgreSQLParser::Role_listContext* PostgreSQLParser::RowsecuritydefaulttoroleContext::role_list() {
  return getRuleContext<PostgreSQLParser::Role_listContext>(0);
}


size_t PostgreSQLParser::RowsecuritydefaulttoroleContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRowsecuritydefaulttorole;
}


std::any PostgreSQLParser::RowsecuritydefaulttoroleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRowsecuritydefaulttorole(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RowsecuritydefaulttoroleContext* PostgreSQLParser::rowsecuritydefaulttorole() {
  RowsecuritydefaulttoroleContext *_localctx = _tracker.createInstance<RowsecuritydefaulttoroleContext>(_ctx, getState());
  enterRule(_localctx, 386, PostgreSQLParser::RuleRowsecuritydefaulttorole);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3859);
    match(PostgreSQLParser::TO);
    setState(3860);
    role_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RowsecurityoptionaltoroleContext ------------------------------------------------------------------

PostgreSQLParser::RowsecurityoptionaltoroleContext::RowsecurityoptionaltoroleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::RowsecurityoptionaltoroleContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}

PostgreSQLParser::Role_listContext* PostgreSQLParser::RowsecurityoptionaltoroleContext::role_list() {
  return getRuleContext<PostgreSQLParser::Role_listContext>(0);
}


size_t PostgreSQLParser::RowsecurityoptionaltoroleContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRowsecurityoptionaltorole;
}


std::any PostgreSQLParser::RowsecurityoptionaltoroleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRowsecurityoptionaltorole(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RowsecurityoptionaltoroleContext* PostgreSQLParser::rowsecurityoptionaltorole() {
  RowsecurityoptionaltoroleContext *_localctx = _tracker.createInstance<RowsecurityoptionaltoroleContext>(_ctx, getState());
  enterRule(_localctx, 388, PostgreSQLParser::RuleRowsecurityoptionaltorole);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3862);
    match(PostgreSQLParser::TO);
    setState(3863);
    role_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RowsecuritydefaultpermissiveContext ------------------------------------------------------------------

PostgreSQLParser::RowsecuritydefaultpermissiveContext::RowsecuritydefaultpermissiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::RowsecuritydefaultpermissiveContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

PostgreSQLParser::IdentifierContext* PostgreSQLParser::RowsecuritydefaultpermissiveContext::identifier() {
  return getRuleContext<PostgreSQLParser::IdentifierContext>(0);
}


size_t PostgreSQLParser::RowsecuritydefaultpermissiveContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRowsecuritydefaultpermissive;
}


std::any PostgreSQLParser::RowsecuritydefaultpermissiveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRowsecuritydefaultpermissive(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RowsecuritydefaultpermissiveContext* PostgreSQLParser::rowsecuritydefaultpermissive() {
  RowsecuritydefaultpermissiveContext *_localctx = _tracker.createInstance<RowsecuritydefaultpermissiveContext>(_ctx, getState());
  enterRule(_localctx, 390, PostgreSQLParser::RuleRowsecuritydefaultpermissive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3865);
    match(PostgreSQLParser::AS);
    setState(3866);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RowsecuritydefaultforcmdContext ------------------------------------------------------------------

PostgreSQLParser::RowsecuritydefaultforcmdContext::RowsecuritydefaultforcmdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::RowsecuritydefaultforcmdContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

PostgreSQLParser::Row_security_cmdContext* PostgreSQLParser::RowsecuritydefaultforcmdContext::row_security_cmd() {
  return getRuleContext<PostgreSQLParser::Row_security_cmdContext>(0);
}


size_t PostgreSQLParser::RowsecuritydefaultforcmdContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRowsecuritydefaultforcmd;
}


std::any PostgreSQLParser::RowsecuritydefaultforcmdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRowsecuritydefaultforcmd(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RowsecuritydefaultforcmdContext* PostgreSQLParser::rowsecuritydefaultforcmd() {
  RowsecuritydefaultforcmdContext *_localctx = _tracker.createInstance<RowsecuritydefaultforcmdContext>(_ctx, getState());
  enterRule(_localctx, 392, PostgreSQLParser::RuleRowsecuritydefaultforcmd);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3868);
    match(PostgreSQLParser::FOR);
    setState(3869);
    row_security_cmd();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Row_security_cmdContext ------------------------------------------------------------------

PostgreSQLParser::Row_security_cmdContext::Row_security_cmdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Row_security_cmdContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}

tree::TerminalNode* PostgreSQLParser::Row_security_cmdContext::SELECT() {
  return getToken(PostgreSQLParser::SELECT, 0);
}

tree::TerminalNode* PostgreSQLParser::Row_security_cmdContext::INSERT() {
  return getToken(PostgreSQLParser::INSERT, 0);
}

tree::TerminalNode* PostgreSQLParser::Row_security_cmdContext::UPDATE() {
  return getToken(PostgreSQLParser::UPDATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Row_security_cmdContext::DELETE_P() {
  return getToken(PostgreSQLParser::DELETE_P, 0);
}


size_t PostgreSQLParser::Row_security_cmdContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRow_security_cmd;
}


std::any PostgreSQLParser::Row_security_cmdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRow_security_cmd(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Row_security_cmdContext* PostgreSQLParser::row_security_cmd() {
  Row_security_cmdContext *_localctx = _tracker.createInstance<Row_security_cmdContext>(_ctx, getState());
  enterRule(_localctx, 394, PostgreSQLParser::RuleRow_security_cmd);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3871);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::ALL

    || _la == PostgreSQLParser::SELECT || _la == PostgreSQLParser::DELETE_P

    || _la == PostgreSQLParser::INSERT || _la == PostgreSQLParser::UPDATE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateamstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreateamstmtContext::CreateamstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreateamstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateamstmtContext::ACCESS() {
  return getToken(PostgreSQLParser::ACCESS, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateamstmtContext::METHOD() {
  return getToken(PostgreSQLParser::METHOD, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::CreateamstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateamstmtContext::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}

PostgreSQLParser::Am_typeContext* PostgreSQLParser::CreateamstmtContext::am_type() {
  return getRuleContext<PostgreSQLParser::Am_typeContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateamstmtContext::HANDLER() {
  return getToken(PostgreSQLParser::HANDLER, 0);
}

PostgreSQLParser::Handler_nameContext* PostgreSQLParser::CreateamstmtContext::handler_name() {
  return getRuleContext<PostgreSQLParser::Handler_nameContext>(0);
}


size_t PostgreSQLParser::CreateamstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreateamstmt;
}


std::any PostgreSQLParser::CreateamstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateamstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreateamstmtContext* PostgreSQLParser::createamstmt() {
  CreateamstmtContext *_localctx = _tracker.createInstance<CreateamstmtContext>(_ctx, getState());
  enterRule(_localctx, 396, PostgreSQLParser::RuleCreateamstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3873);
    match(PostgreSQLParser::CREATE);
    setState(3874);
    match(PostgreSQLParser::ACCESS);
    setState(3875);
    match(PostgreSQLParser::METHOD);
    setState(3876);
    name();
    setState(3877);
    match(PostgreSQLParser::TYPE_P);
    setState(3878);
    am_type();
    setState(3879);
    match(PostgreSQLParser::HANDLER);
    setState(3880);
    handler_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Am_typeContext ------------------------------------------------------------------

PostgreSQLParser::Am_typeContext::Am_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Am_typeContext::INDEX() {
  return getToken(PostgreSQLParser::INDEX, 0);
}

tree::TerminalNode* PostgreSQLParser::Am_typeContext::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}


size_t PostgreSQLParser::Am_typeContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAm_type;
}


std::any PostgreSQLParser::Am_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAm_type(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Am_typeContext* PostgreSQLParser::am_type() {
  Am_typeContext *_localctx = _tracker.createInstance<Am_typeContext>(_ctx, getState());
  enterRule(_localctx, 398, PostgreSQLParser::RuleAm_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3882);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::TABLE || _la == PostgreSQLParser::INDEX)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreatetrigstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreatetrigstmtContext::CreatetrigstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreatetrigstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatetrigstmtContext::TRIGGER() {
  return getToken(PostgreSQLParser::TRIGGER, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::CreatetrigstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::TriggeractiontimeContext* PostgreSQLParser::CreatetrigstmtContext::triggeractiontime() {
  return getRuleContext<PostgreSQLParser::TriggeractiontimeContext>(0);
}

PostgreSQLParser::TriggereventsContext* PostgreSQLParser::CreatetrigstmtContext::triggerevents() {
  return getRuleContext<PostgreSQLParser::TriggereventsContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatetrigstmtContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::CreatetrigstmtContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatetrigstmtContext::EXECUTE() {
  return getToken(PostgreSQLParser::EXECUTE, 0);
}

PostgreSQLParser::Function_or_procedureContext* PostgreSQLParser::CreatetrigstmtContext::function_or_procedure() {
  return getRuleContext<PostgreSQLParser::Function_or_procedureContext>(0);
}

PostgreSQLParser::Func_nameContext* PostgreSQLParser::CreatetrigstmtContext::func_name() {
  return getRuleContext<PostgreSQLParser::Func_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatetrigstmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::TriggerfuncargsContext* PostgreSQLParser::CreatetrigstmtContext::triggerfuncargs() {
  return getRuleContext<PostgreSQLParser::TriggerfuncargsContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatetrigstmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::TriggerreferencingContext* PostgreSQLParser::CreatetrigstmtContext::triggerreferencing() {
  return getRuleContext<PostgreSQLParser::TriggerreferencingContext>(0);
}

PostgreSQLParser::TriggerforspecContext* PostgreSQLParser::CreatetrigstmtContext::triggerforspec() {
  return getRuleContext<PostgreSQLParser::TriggerforspecContext>(0);
}

PostgreSQLParser::TriggerwhenContext* PostgreSQLParser::CreatetrigstmtContext::triggerwhen() {
  return getRuleContext<PostgreSQLParser::TriggerwhenContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatetrigstmtContext::CONSTRAINT() {
  return getToken(PostgreSQLParser::CONSTRAINT, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatetrigstmtContext::AFTER() {
  return getToken(PostgreSQLParser::AFTER, 0);
}

PostgreSQLParser::ConstraintattributespecContext* PostgreSQLParser::CreatetrigstmtContext::constraintattributespec() {
  return getRuleContext<PostgreSQLParser::ConstraintattributespecContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatetrigstmtContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatetrigstmtContext::EACH() {
  return getToken(PostgreSQLParser::EACH, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatetrigstmtContext::ROW() {
  return getToken(PostgreSQLParser::ROW, 0);
}

PostgreSQLParser::OptconstrfromtableContext* PostgreSQLParser::CreatetrigstmtContext::optconstrfromtable() {
  return getRuleContext<PostgreSQLParser::OptconstrfromtableContext>(0);
}


size_t PostgreSQLParser::CreatetrigstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatetrigstmt;
}


std::any PostgreSQLParser::CreatetrigstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatetrigstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreatetrigstmtContext* PostgreSQLParser::createtrigstmt() {
  CreatetrigstmtContext *_localctx = _tracker.createInstance<CreatetrigstmtContext>(_ctx, getState());
  enterRule(_localctx, 400, PostgreSQLParser::RuleCreatetrigstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3932);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 307, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3884);
      match(PostgreSQLParser::CREATE);
      setState(3885);
      match(PostgreSQLParser::TRIGGER);
      setState(3886);
      name();
      setState(3887);
      triggeractiontime();
      setState(3888);
      triggerevents();
      setState(3889);
      match(PostgreSQLParser::ON);
      setState(3890);
      qualified_name();
      setState(3892);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::REFERENCING) {
        setState(3891);
        triggerreferencing();
      }
      setState(3895);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FOR) {
        setState(3894);
        triggerforspec();
      }
      setState(3898);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::WHEN) {
        setState(3897);
        triggerwhen();
      }
      setState(3900);
      match(PostgreSQLParser::EXECUTE);
      setState(3901);
      function_or_procedure();
      setState(3902);
      func_name();
      setState(3903);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(3904);
      triggerfuncargs();
      setState(3905);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3907);
      match(PostgreSQLParser::CREATE);
      setState(3908);
      match(PostgreSQLParser::CONSTRAINT);
      setState(3909);
      match(PostgreSQLParser::TRIGGER);
      setState(3910);
      name();
      setState(3911);
      match(PostgreSQLParser::AFTER);
      setState(3912);
      triggerevents();
      setState(3913);
      match(PostgreSQLParser::ON);
      setState(3914);
      qualified_name();
      setState(3916);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FROM) {
        setState(3915);
        optconstrfromtable();
      }
      setState(3918);
      constraintattributespec();
      setState(3919);
      match(PostgreSQLParser::FOR);
      setState(3920);
      match(PostgreSQLParser::EACH);
      setState(3921);
      match(PostgreSQLParser::ROW);
      setState(3923);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::WHEN) {
        setState(3922);
        triggerwhen();
      }
      setState(3925);
      match(PostgreSQLParser::EXECUTE);
      setState(3926);
      function_or_procedure();
      setState(3927);
      func_name();
      setState(3928);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(3929);
      triggerfuncargs();
      setState(3930);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggeractiontimeContext ------------------------------------------------------------------

PostgreSQLParser::TriggeractiontimeContext::TriggeractiontimeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::TriggeractiontimeContext::BEFORE() {
  return getToken(PostgreSQLParser::BEFORE, 0);
}

tree::TerminalNode* PostgreSQLParser::TriggeractiontimeContext::AFTER() {
  return getToken(PostgreSQLParser::AFTER, 0);
}

tree::TerminalNode* PostgreSQLParser::TriggeractiontimeContext::INSTEAD() {
  return getToken(PostgreSQLParser::INSTEAD, 0);
}

tree::TerminalNode* PostgreSQLParser::TriggeractiontimeContext::OF() {
  return getToken(PostgreSQLParser::OF, 0);
}


size_t PostgreSQLParser::TriggeractiontimeContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTriggeractiontime;
}


std::any PostgreSQLParser::TriggeractiontimeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTriggeractiontime(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TriggeractiontimeContext* PostgreSQLParser::triggeractiontime() {
  TriggeractiontimeContext *_localctx = _tracker.createInstance<TriggeractiontimeContext>(_ctx, getState());
  enterRule(_localctx, 402, PostgreSQLParser::RuleTriggeractiontime);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3938);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::BEFORE: {
        enterOuterAlt(_localctx, 1);
        setState(3934);
        match(PostgreSQLParser::BEFORE);
        break;
      }

      case PostgreSQLParser::AFTER: {
        enterOuterAlt(_localctx, 2);
        setState(3935);
        match(PostgreSQLParser::AFTER);
        break;
      }

      case PostgreSQLParser::INSTEAD: {
        enterOuterAlt(_localctx, 3);
        setState(3936);
        match(PostgreSQLParser::INSTEAD);
        setState(3937);
        match(PostgreSQLParser::OF);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggereventsContext ------------------------------------------------------------------

PostgreSQLParser::TriggereventsContext::TriggereventsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::TriggeroneeventContext *> PostgreSQLParser::TriggereventsContext::triggeroneevent() {
  return getRuleContexts<PostgreSQLParser::TriggeroneeventContext>();
}

PostgreSQLParser::TriggeroneeventContext* PostgreSQLParser::TriggereventsContext::triggeroneevent(size_t i) {
  return getRuleContext<PostgreSQLParser::TriggeroneeventContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::TriggereventsContext::OR() {
  return getTokens(PostgreSQLParser::OR);
}

tree::TerminalNode* PostgreSQLParser::TriggereventsContext::OR(size_t i) {
  return getToken(PostgreSQLParser::OR, i);
}


size_t PostgreSQLParser::TriggereventsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTriggerevents;
}


std::any PostgreSQLParser::TriggereventsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTriggerevents(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TriggereventsContext* PostgreSQLParser::triggerevents() {
  TriggereventsContext *_localctx = _tracker.createInstance<TriggereventsContext>(_ctx, getState());
  enterRule(_localctx, 404, PostgreSQLParser::RuleTriggerevents);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3940);
    triggeroneevent();
    setState(3945);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::OR) {
      setState(3941);
      match(PostgreSQLParser::OR);
      setState(3942);
      triggeroneevent();
      setState(3947);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggeroneeventContext ------------------------------------------------------------------

PostgreSQLParser::TriggeroneeventContext::TriggeroneeventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::TriggeroneeventContext::INSERT() {
  return getToken(PostgreSQLParser::INSERT, 0);
}

tree::TerminalNode* PostgreSQLParser::TriggeroneeventContext::DELETE_P() {
  return getToken(PostgreSQLParser::DELETE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::TriggeroneeventContext::UPDATE() {
  return getToken(PostgreSQLParser::UPDATE, 0);
}

tree::TerminalNode* PostgreSQLParser::TriggeroneeventContext::OF() {
  return getToken(PostgreSQLParser::OF, 0);
}

PostgreSQLParser::ColumnlistContext* PostgreSQLParser::TriggeroneeventContext::columnlist() {
  return getRuleContext<PostgreSQLParser::ColumnlistContext>(0);
}

tree::TerminalNode* PostgreSQLParser::TriggeroneeventContext::TRUNCATE() {
  return getToken(PostgreSQLParser::TRUNCATE, 0);
}


size_t PostgreSQLParser::TriggeroneeventContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTriggeroneevent;
}


std::any PostgreSQLParser::TriggeroneeventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTriggeroneevent(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TriggeroneeventContext* PostgreSQLParser::triggeroneevent() {
  TriggeroneeventContext *_localctx = _tracker.createInstance<TriggeroneeventContext>(_ctx, getState());
  enterRule(_localctx, 406, PostgreSQLParser::RuleTriggeroneevent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3955);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 310, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3948);
      match(PostgreSQLParser::INSERT);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3949);
      match(PostgreSQLParser::DELETE_P);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3950);
      match(PostgreSQLParser::UPDATE);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3951);
      match(PostgreSQLParser::UPDATE);
      setState(3952);
      match(PostgreSQLParser::OF);
      setState(3953);
      columnlist();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3954);
      match(PostgreSQLParser::TRUNCATE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerreferencingContext ------------------------------------------------------------------

PostgreSQLParser::TriggerreferencingContext::TriggerreferencingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::TriggerreferencingContext::REFERENCING() {
  return getToken(PostgreSQLParser::REFERENCING, 0);
}

PostgreSQLParser::TriggertransitionsContext* PostgreSQLParser::TriggerreferencingContext::triggertransitions() {
  return getRuleContext<PostgreSQLParser::TriggertransitionsContext>(0);
}


size_t PostgreSQLParser::TriggerreferencingContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTriggerreferencing;
}


std::any PostgreSQLParser::TriggerreferencingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTriggerreferencing(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TriggerreferencingContext* PostgreSQLParser::triggerreferencing() {
  TriggerreferencingContext *_localctx = _tracker.createInstance<TriggerreferencingContext>(_ctx, getState());
  enterRule(_localctx, 408, PostgreSQLParser::RuleTriggerreferencing);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3957);
    match(PostgreSQLParser::REFERENCING);
    setState(3958);
    triggertransitions();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggertransitionsContext ------------------------------------------------------------------

PostgreSQLParser::TriggertransitionsContext::TriggertransitionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::TriggertransitionContext *> PostgreSQLParser::TriggertransitionsContext::triggertransition() {
  return getRuleContexts<PostgreSQLParser::TriggertransitionContext>();
}

PostgreSQLParser::TriggertransitionContext* PostgreSQLParser::TriggertransitionsContext::triggertransition(size_t i) {
  return getRuleContext<PostgreSQLParser::TriggertransitionContext>(i);
}


size_t PostgreSQLParser::TriggertransitionsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTriggertransitions;
}


std::any PostgreSQLParser::TriggertransitionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTriggertransitions(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TriggertransitionsContext* PostgreSQLParser::triggertransitions() {
  TriggertransitionsContext *_localctx = _tracker.createInstance<TriggertransitionsContext>(_ctx, getState());
  enterRule(_localctx, 410, PostgreSQLParser::RuleTriggertransitions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3961); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(3960);
      triggertransition();
      setState(3963); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == PostgreSQLParser::NEW

    || _la == PostgreSQLParser::OLD);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggertransitionContext ------------------------------------------------------------------

PostgreSQLParser::TriggertransitionContext::TriggertransitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::TransitionoldornewContext* PostgreSQLParser::TriggertransitionContext::transitionoldornew() {
  return getRuleContext<PostgreSQLParser::TransitionoldornewContext>(0);
}

PostgreSQLParser::TransitionrowortableContext* PostgreSQLParser::TriggertransitionContext::transitionrowortable() {
  return getRuleContext<PostgreSQLParser::TransitionrowortableContext>(0);
}

PostgreSQLParser::TransitionrelnameContext* PostgreSQLParser::TriggertransitionContext::transitionrelname() {
  return getRuleContext<PostgreSQLParser::TransitionrelnameContext>(0);
}

PostgreSQLParser::As_Context* PostgreSQLParser::TriggertransitionContext::as_() {
  return getRuleContext<PostgreSQLParser::As_Context>(0);
}


size_t PostgreSQLParser::TriggertransitionContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTriggertransition;
}


std::any PostgreSQLParser::TriggertransitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTriggertransition(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TriggertransitionContext* PostgreSQLParser::triggertransition() {
  TriggertransitionContext *_localctx = _tracker.createInstance<TriggertransitionContext>(_ctx, getState());
  enterRule(_localctx, 412, PostgreSQLParser::RuleTriggertransition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3965);
    transitionoldornew();
    setState(3966);
    transitionrowortable();
    setState(3968);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::AS) {
      setState(3967);
      as_();
    }
    setState(3970);
    transitionrelname();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransitionoldornewContext ------------------------------------------------------------------

PostgreSQLParser::TransitionoldornewContext::TransitionoldornewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::TransitionoldornewContext::NEW() {
  return getToken(PostgreSQLParser::NEW, 0);
}

tree::TerminalNode* PostgreSQLParser::TransitionoldornewContext::OLD() {
  return getToken(PostgreSQLParser::OLD, 0);
}


size_t PostgreSQLParser::TransitionoldornewContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTransitionoldornew;
}


std::any PostgreSQLParser::TransitionoldornewContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTransitionoldornew(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TransitionoldornewContext* PostgreSQLParser::transitionoldornew() {
  TransitionoldornewContext *_localctx = _tracker.createInstance<TransitionoldornewContext>(_ctx, getState());
  enterRule(_localctx, 414, PostgreSQLParser::RuleTransitionoldornew);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3972);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::NEW

    || _la == PostgreSQLParser::OLD)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransitionrowortableContext ------------------------------------------------------------------

PostgreSQLParser::TransitionrowortableContext::TransitionrowortableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::TransitionrowortableContext::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::TransitionrowortableContext::ROW() {
  return getToken(PostgreSQLParser::ROW, 0);
}


size_t PostgreSQLParser::TransitionrowortableContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTransitionrowortable;
}


std::any PostgreSQLParser::TransitionrowortableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTransitionrowortable(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TransitionrowortableContext* PostgreSQLParser::transitionrowortable() {
  TransitionrowortableContext *_localctx = _tracker.createInstance<TransitionrowortableContext>(_ctx, getState());
  enterRule(_localctx, 416, PostgreSQLParser::RuleTransitionrowortable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3974);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::TABLE || _la == PostgreSQLParser::ROW)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransitionrelnameContext ------------------------------------------------------------------

PostgreSQLParser::TransitionrelnameContext::TransitionrelnameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::TransitionrelnameContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}


size_t PostgreSQLParser::TransitionrelnameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTransitionrelname;
}


std::any PostgreSQLParser::TransitionrelnameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTransitionrelname(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TransitionrelnameContext* PostgreSQLParser::transitionrelname() {
  TransitionrelnameContext *_localctx = _tracker.createInstance<TransitionrelnameContext>(_ctx, getState());
  enterRule(_localctx, 418, PostgreSQLParser::RuleTransitionrelname);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3976);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerforspecContext ------------------------------------------------------------------

PostgreSQLParser::TriggerforspecContext::TriggerforspecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::TriggerforspecContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

PostgreSQLParser::TriggerfortypeContext* PostgreSQLParser::TriggerforspecContext::triggerfortype() {
  return getRuleContext<PostgreSQLParser::TriggerfortypeContext>(0);
}

PostgreSQLParser::TriggerforopteachContext* PostgreSQLParser::TriggerforspecContext::triggerforopteach() {
  return getRuleContext<PostgreSQLParser::TriggerforopteachContext>(0);
}


size_t PostgreSQLParser::TriggerforspecContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTriggerforspec;
}


std::any PostgreSQLParser::TriggerforspecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTriggerforspec(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TriggerforspecContext* PostgreSQLParser::triggerforspec() {
  TriggerforspecContext *_localctx = _tracker.createInstance<TriggerforspecContext>(_ctx, getState());
  enterRule(_localctx, 420, PostgreSQLParser::RuleTriggerforspec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3978);
    match(PostgreSQLParser::FOR);
    setState(3980);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::EACH) {
      setState(3979);
      triggerforopteach();
    }
    setState(3982);
    triggerfortype();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerforopteachContext ------------------------------------------------------------------

PostgreSQLParser::TriggerforopteachContext::TriggerforopteachContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::TriggerforopteachContext::EACH() {
  return getToken(PostgreSQLParser::EACH, 0);
}


size_t PostgreSQLParser::TriggerforopteachContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTriggerforopteach;
}


std::any PostgreSQLParser::TriggerforopteachContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTriggerforopteach(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TriggerforopteachContext* PostgreSQLParser::triggerforopteach() {
  TriggerforopteachContext *_localctx = _tracker.createInstance<TriggerforopteachContext>(_ctx, getState());
  enterRule(_localctx, 422, PostgreSQLParser::RuleTriggerforopteach);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3984);
    match(PostgreSQLParser::EACH);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerfortypeContext ------------------------------------------------------------------

PostgreSQLParser::TriggerfortypeContext::TriggerfortypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::TriggerfortypeContext::ROW() {
  return getToken(PostgreSQLParser::ROW, 0);
}

tree::TerminalNode* PostgreSQLParser::TriggerfortypeContext::STATEMENT() {
  return getToken(PostgreSQLParser::STATEMENT, 0);
}


size_t PostgreSQLParser::TriggerfortypeContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTriggerfortype;
}


std::any PostgreSQLParser::TriggerfortypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTriggerfortype(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TriggerfortypeContext* PostgreSQLParser::triggerfortype() {
  TriggerfortypeContext *_localctx = _tracker.createInstance<TriggerfortypeContext>(_ctx, getState());
  enterRule(_localctx, 424, PostgreSQLParser::RuleTriggerfortype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3986);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::STATEMENT || _la == PostgreSQLParser::ROW)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerwhenContext ------------------------------------------------------------------

PostgreSQLParser::TriggerwhenContext::TriggerwhenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::TriggerwhenContext::WHEN() {
  return getToken(PostgreSQLParser::WHEN, 0);
}

tree::TerminalNode* PostgreSQLParser::TriggerwhenContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::TriggerwhenContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::TriggerwhenContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::TriggerwhenContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTriggerwhen;
}


std::any PostgreSQLParser::TriggerwhenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTriggerwhen(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TriggerwhenContext* PostgreSQLParser::triggerwhen() {
  TriggerwhenContext *_localctx = _tracker.createInstance<TriggerwhenContext>(_ctx, getState());
  enterRule(_localctx, 426, PostgreSQLParser::RuleTriggerwhen);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3988);
    match(PostgreSQLParser::WHEN);
    setState(3989);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(3990);
    a_expr();
    setState(3991);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_or_procedureContext ------------------------------------------------------------------

PostgreSQLParser::Function_or_procedureContext::Function_or_procedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Function_or_procedureContext::FUNCTION() {
  return getToken(PostgreSQLParser::FUNCTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Function_or_procedureContext::PROCEDURE() {
  return getToken(PostgreSQLParser::PROCEDURE, 0);
}


size_t PostgreSQLParser::Function_or_procedureContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunction_or_procedure;
}


std::any PostgreSQLParser::Function_or_procedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunction_or_procedure(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Function_or_procedureContext* PostgreSQLParser::function_or_procedure() {
  Function_or_procedureContext *_localctx = _tracker.createInstance<Function_or_procedureContext>(_ctx, getState());
  enterRule(_localctx, 428, PostgreSQLParser::RuleFunction_or_procedure);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3993);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::FUNCTION || _la == PostgreSQLParser::PROCEDURE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerfuncargsContext ------------------------------------------------------------------

PostgreSQLParser::TriggerfuncargsContext::TriggerfuncargsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::TriggerfuncargContext *> PostgreSQLParser::TriggerfuncargsContext::triggerfuncarg() {
  return getRuleContexts<PostgreSQLParser::TriggerfuncargContext>();
}

PostgreSQLParser::TriggerfuncargContext* PostgreSQLParser::TriggerfuncargsContext::triggerfuncarg(size_t i) {
  return getRuleContext<PostgreSQLParser::TriggerfuncargContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::TriggerfuncargsContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::TriggerfuncargsContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::TriggerfuncargsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTriggerfuncargs;
}


std::any PostgreSQLParser::TriggerfuncargsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTriggerfuncargs(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TriggerfuncargsContext* PostgreSQLParser::triggerfuncargs() {
  TriggerfuncargsContext *_localctx = _tracker.createInstance<TriggerfuncargsContext>(_ctx, getState());
  enterRule(_localctx, 430, PostgreSQLParser::RuleTriggerfuncargs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3997);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::SYSTEM_USER:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::ALL:
      case PostgreSQLParser::ANALYSE:
      case PostgreSQLParser::ANALYZE:
      case PostgreSQLParser::AND:
      case PostgreSQLParser::ANY:
      case PostgreSQLParser::ARRAY:
      case PostgreSQLParser::AS:
      case PostgreSQLParser::ASC:
      case PostgreSQLParser::ASYMMETRIC:
      case PostgreSQLParser::BOTH:
      case PostgreSQLParser::CASE:
      case PostgreSQLParser::CAST:
      case PostgreSQLParser::CHECK:
      case PostgreSQLParser::COLLATE:
      case PostgreSQLParser::COLUMN:
      case PostgreSQLParser::CONSTRAINT:
      case PostgreSQLParser::CREATE:
      case PostgreSQLParser::CURRENT_CATALOG:
      case PostgreSQLParser::CURRENT_DATE:
      case PostgreSQLParser::CURRENT_ROLE:
      case PostgreSQLParser::CURRENT_TIME:
      case PostgreSQLParser::CURRENT_TIMESTAMP:
      case PostgreSQLParser::CURRENT_USER:
      case PostgreSQLParser::DEFAULT:
      case PostgreSQLParser::DEFERRABLE:
      case PostgreSQLParser::DESC:
      case PostgreSQLParser::DISTINCT:
      case PostgreSQLParser::DO:
      case PostgreSQLParser::ELSE:
      case PostgreSQLParser::EXCEPT:
      case PostgreSQLParser::FALSE_P:
      case PostgreSQLParser::FETCH:
      case PostgreSQLParser::FOR:
      case PostgreSQLParser::FOREIGN:
      case PostgreSQLParser::FROM:
      case PostgreSQLParser::GRANT:
      case PostgreSQLParser::GROUP_P:
      case PostgreSQLParser::HAVING:
      case PostgreSQLParser::IN_P:
      case PostgreSQLParser::INITIALLY:
      case PostgreSQLParser::INTERSECT:
      case PostgreSQLParser::INTO:
      case PostgreSQLParser::LATERAL_P:
      case PostgreSQLParser::LEADING:
      case PostgreSQLParser::LIMIT:
      case PostgreSQLParser::LOCALTIME:
      case PostgreSQLParser::LOCALTIMESTAMP:
      case PostgreSQLParser::NOT:
      case PostgreSQLParser::NULL_P:
      case PostgreSQLParser::OFFSET:
      case PostgreSQLParser::ON:
      case PostgreSQLParser::ONLY:
      case PostgreSQLParser::OR:
      case PostgreSQLParser::ORDER:
      case PostgreSQLParser::PLACING:
      case PostgreSQLParser::PRIMARY:
      case PostgreSQLParser::REFERENCES:
      case PostgreSQLParser::RETURNING:
      case PostgreSQLParser::SELECT:
      case PostgreSQLParser::SESSION_USER:
      case PostgreSQLParser::SOME:
      case PostgreSQLParser::SYMMETRIC:
      case PostgreSQLParser::TABLE:
      case PostgreSQLParser::THEN:
      case PostgreSQLParser::TO:
      case PostgreSQLParser::TRAILING:
      case PostgreSQLParser::TRUE_P:
      case PostgreSQLParser::UNION:
      case PostgreSQLParser::UNIQUE:
      case PostgreSQLParser::USER:
      case PostgreSQLParser::USING:
      case PostgreSQLParser::VARIADIC:
      case PostgreSQLParser::WHEN:
      case PostgreSQLParser::WHERE:
      case PostgreSQLParser::WINDOW:
      case PostgreSQLParser::WITH:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::END_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::EXIT:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::Integral:
      case PostgreSQLParser::BinaryIntegral:
      case PostgreSQLParser::OctalIntegral:
      case PostgreSQLParser::HexadecimalIntegral:
      case PostgreSQLParser::Numeric:
      case PostgreSQLParser::PLSQLVARIABLENAME:
      case PostgreSQLParser::EscapeStringConstant: {
        setState(3995);
        triggerfuncarg();
        break;
      }

      case PostgreSQLParser::CLOSE_PAREN:
      case PostgreSQLParser::COMMA: {
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(4003);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(3999);
      match(PostgreSQLParser::COMMA);
      setState(4000);
      triggerfuncarg();
      setState(4005);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerfuncargContext ------------------------------------------------------------------

PostgreSQLParser::TriggerfuncargContext::TriggerfuncargContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::IconstContext* PostgreSQLParser::TriggerfuncargContext::iconst() {
  return getRuleContext<PostgreSQLParser::IconstContext>(0);
}

PostgreSQLParser::FconstContext* PostgreSQLParser::TriggerfuncargContext::fconst() {
  return getRuleContext<PostgreSQLParser::FconstContext>(0);
}

PostgreSQLParser::SconstContext* PostgreSQLParser::TriggerfuncargContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}

PostgreSQLParser::ColLabelContext* PostgreSQLParser::TriggerfuncargContext::colLabel() {
  return getRuleContext<PostgreSQLParser::ColLabelContext>(0);
}


size_t PostgreSQLParser::TriggerfuncargContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTriggerfuncarg;
}


std::any PostgreSQLParser::TriggerfuncargContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTriggerfuncarg(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TriggerfuncargContext* PostgreSQLParser::triggerfuncarg() {
  TriggerfuncargContext *_localctx = _tracker.createInstance<TriggerfuncargContext>(_ctx, getState());
  enterRule(_localctx, 432, PostgreSQLParser::RuleTriggerfuncarg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4010);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::Integral:
      case PostgreSQLParser::BinaryIntegral:
      case PostgreSQLParser::OctalIntegral:
      case PostgreSQLParser::HexadecimalIntegral: {
        enterOuterAlt(_localctx, 1);
        setState(4006);
        iconst();
        break;
      }

      case PostgreSQLParser::Numeric: {
        enterOuterAlt(_localctx, 2);
        setState(4007);
        fconst();
        break;
      }

      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::EscapeStringConstant: {
        enterOuterAlt(_localctx, 3);
        setState(4008);
        sconst();
        break;
      }

      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::SYSTEM_USER:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::ALL:
      case PostgreSQLParser::ANALYSE:
      case PostgreSQLParser::ANALYZE:
      case PostgreSQLParser::AND:
      case PostgreSQLParser::ANY:
      case PostgreSQLParser::ARRAY:
      case PostgreSQLParser::AS:
      case PostgreSQLParser::ASC:
      case PostgreSQLParser::ASYMMETRIC:
      case PostgreSQLParser::BOTH:
      case PostgreSQLParser::CASE:
      case PostgreSQLParser::CAST:
      case PostgreSQLParser::CHECK:
      case PostgreSQLParser::COLLATE:
      case PostgreSQLParser::COLUMN:
      case PostgreSQLParser::CONSTRAINT:
      case PostgreSQLParser::CREATE:
      case PostgreSQLParser::CURRENT_CATALOG:
      case PostgreSQLParser::CURRENT_DATE:
      case PostgreSQLParser::CURRENT_ROLE:
      case PostgreSQLParser::CURRENT_TIME:
      case PostgreSQLParser::CURRENT_TIMESTAMP:
      case PostgreSQLParser::CURRENT_USER:
      case PostgreSQLParser::DEFAULT:
      case PostgreSQLParser::DEFERRABLE:
      case PostgreSQLParser::DESC:
      case PostgreSQLParser::DISTINCT:
      case PostgreSQLParser::DO:
      case PostgreSQLParser::ELSE:
      case PostgreSQLParser::EXCEPT:
      case PostgreSQLParser::FALSE_P:
      case PostgreSQLParser::FETCH:
      case PostgreSQLParser::FOR:
      case PostgreSQLParser::FOREIGN:
      case PostgreSQLParser::FROM:
      case PostgreSQLParser::GRANT:
      case PostgreSQLParser::GROUP_P:
      case PostgreSQLParser::HAVING:
      case PostgreSQLParser::IN_P:
      case PostgreSQLParser::INITIALLY:
      case PostgreSQLParser::INTERSECT:
      case PostgreSQLParser::INTO:
      case PostgreSQLParser::LATERAL_P:
      case PostgreSQLParser::LEADING:
      case PostgreSQLParser::LIMIT:
      case PostgreSQLParser::LOCALTIME:
      case PostgreSQLParser::LOCALTIMESTAMP:
      case PostgreSQLParser::NOT:
      case PostgreSQLParser::NULL_P:
      case PostgreSQLParser::OFFSET:
      case PostgreSQLParser::ON:
      case PostgreSQLParser::ONLY:
      case PostgreSQLParser::OR:
      case PostgreSQLParser::ORDER:
      case PostgreSQLParser::PLACING:
      case PostgreSQLParser::PRIMARY:
      case PostgreSQLParser::REFERENCES:
      case PostgreSQLParser::RETURNING:
      case PostgreSQLParser::SELECT:
      case PostgreSQLParser::SESSION_USER:
      case PostgreSQLParser::SOME:
      case PostgreSQLParser::SYMMETRIC:
      case PostgreSQLParser::TABLE:
      case PostgreSQLParser::THEN:
      case PostgreSQLParser::TO:
      case PostgreSQLParser::TRAILING:
      case PostgreSQLParser::TRUE_P:
      case PostgreSQLParser::UNION:
      case PostgreSQLParser::UNIQUE:
      case PostgreSQLParser::USER:
      case PostgreSQLParser::USING:
      case PostgreSQLParser::VARIADIC:
      case PostgreSQLParser::WHEN:
      case PostgreSQLParser::WHERE:
      case PostgreSQLParser::WINDOW:
      case PostgreSQLParser::WITH:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::END_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::EXIT:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 4);
        setState(4009);
        colLabel();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptconstrfromtableContext ------------------------------------------------------------------

PostgreSQLParser::OptconstrfromtableContext::OptconstrfromtableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::OptconstrfromtableContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::OptconstrfromtableContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}


size_t PostgreSQLParser::OptconstrfromtableContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOptconstrfromtable;
}


std::any PostgreSQLParser::OptconstrfromtableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOptconstrfromtable(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::OptconstrfromtableContext* PostgreSQLParser::optconstrfromtable() {
  OptconstrfromtableContext *_localctx = _tracker.createInstance<OptconstrfromtableContext>(_ctx, getState());
  enterRule(_localctx, 434, PostgreSQLParser::RuleOptconstrfromtable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4012);
    match(PostgreSQLParser::FROM);
    setState(4013);
    qualified_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintattributespecContext ------------------------------------------------------------------

PostgreSQLParser::ConstraintattributespecContext::ConstraintattributespecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::ConstraintattributeElemContext *> PostgreSQLParser::ConstraintattributespecContext::constraintattributeElem() {
  return getRuleContexts<PostgreSQLParser::ConstraintattributeElemContext>();
}

PostgreSQLParser::ConstraintattributeElemContext* PostgreSQLParser::ConstraintattributespecContext::constraintattributeElem(size_t i) {
  return getRuleContext<PostgreSQLParser::ConstraintattributeElemContext>(i);
}


size_t PostgreSQLParser::ConstraintattributespecContext::getRuleIndex() const {
  return PostgreSQLParser::RuleConstraintattributespec;
}


std::any PostgreSQLParser::ConstraintattributespecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitConstraintattributespec(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ConstraintattributespecContext* PostgreSQLParser::constraintattributespec() {
  ConstraintattributespecContext *_localctx = _tracker.createInstance<ConstraintattributespecContext>(_ctx, getState());
  enterRule(_localctx, 436, PostgreSQLParser::RuleConstraintattributespec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4018);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 92) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 92)) & 8421377) != 0) || _la == PostgreSQLParser::NO) {
      setState(4015);
      constraintattributeElem();
      setState(4020);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintattributeElemContext ------------------------------------------------------------------

PostgreSQLParser::ConstraintattributeElemContext::ConstraintattributeElemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::ConstraintattributeElemContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintattributeElemContext::DEFERRABLE() {
  return getToken(PostgreSQLParser::DEFERRABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintattributeElemContext::INITIALLY() {
  return getToken(PostgreSQLParser::INITIALLY, 0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintattributeElemContext::IMMEDIATE() {
  return getToken(PostgreSQLParser::IMMEDIATE, 0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintattributeElemContext::DEFERRED() {
  return getToken(PostgreSQLParser::DEFERRED, 0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintattributeElemContext::VALID() {
  return getToken(PostgreSQLParser::VALID, 0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintattributeElemContext::NO() {
  return getToken(PostgreSQLParser::NO, 0);
}

tree::TerminalNode* PostgreSQLParser::ConstraintattributeElemContext::INHERIT() {
  return getToken(PostgreSQLParser::INHERIT, 0);
}


size_t PostgreSQLParser::ConstraintattributeElemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleConstraintattributeElem;
}


std::any PostgreSQLParser::ConstraintattributeElemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitConstraintattributeElem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ConstraintattributeElemContext* PostgreSQLParser::constraintattributeElem() {
  ConstraintattributeElemContext *_localctx = _tracker.createInstance<ConstraintattributeElemContext>(_ctx, getState());
  enterRule(_localctx, 438, PostgreSQLParser::RuleConstraintattributeElem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4032);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 318, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4021);
      match(PostgreSQLParser::NOT);
      setState(4022);
      match(PostgreSQLParser::DEFERRABLE);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4023);
      match(PostgreSQLParser::DEFERRABLE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4024);
      match(PostgreSQLParser::INITIALLY);
      setState(4025);
      match(PostgreSQLParser::IMMEDIATE);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4026);
      match(PostgreSQLParser::INITIALLY);
      setState(4027);
      match(PostgreSQLParser::DEFERRED);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4028);
      match(PostgreSQLParser::NOT);
      setState(4029);
      match(PostgreSQLParser::VALID);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4030);
      match(PostgreSQLParser::NO);
      setState(4031);
      match(PostgreSQLParser::INHERIT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateeventtrigstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreateeventtrigstmtContext::CreateeventtrigstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreateeventtrigstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateeventtrigstmtContext::EVENT() {
  return getToken(PostgreSQLParser::EVENT, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateeventtrigstmtContext::TRIGGER() {
  return getToken(PostgreSQLParser::TRIGGER, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::CreateeventtrigstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateeventtrigstmtContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

PostgreSQLParser::ColLabelContext* PostgreSQLParser::CreateeventtrigstmtContext::colLabel() {
  return getRuleContext<PostgreSQLParser::ColLabelContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateeventtrigstmtContext::EXECUTE() {
  return getToken(PostgreSQLParser::EXECUTE, 0);
}

PostgreSQLParser::Function_or_procedureContext* PostgreSQLParser::CreateeventtrigstmtContext::function_or_procedure() {
  return getRuleContext<PostgreSQLParser::Function_or_procedureContext>(0);
}

PostgreSQLParser::Func_nameContext* PostgreSQLParser::CreateeventtrigstmtContext::func_name() {
  return getRuleContext<PostgreSQLParser::Func_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateeventtrigstmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateeventtrigstmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateeventtrigstmtContext::WHEN() {
  return getToken(PostgreSQLParser::WHEN, 0);
}

PostgreSQLParser::Event_trigger_when_listContext* PostgreSQLParser::CreateeventtrigstmtContext::event_trigger_when_list() {
  return getRuleContext<PostgreSQLParser::Event_trigger_when_listContext>(0);
}


size_t PostgreSQLParser::CreateeventtrigstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreateeventtrigstmt;
}


std::any PostgreSQLParser::CreateeventtrigstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateeventtrigstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreateeventtrigstmtContext* PostgreSQLParser::createeventtrigstmt() {
  CreateeventtrigstmtContext *_localctx = _tracker.createInstance<CreateeventtrigstmtContext>(_ctx, getState());
  enterRule(_localctx, 440, PostgreSQLParser::RuleCreateeventtrigstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4060);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 319, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4034);
      match(PostgreSQLParser::CREATE);
      setState(4035);
      match(PostgreSQLParser::EVENT);
      setState(4036);
      match(PostgreSQLParser::TRIGGER);
      setState(4037);
      name();
      setState(4038);
      match(PostgreSQLParser::ON);
      setState(4039);
      colLabel();
      setState(4040);
      match(PostgreSQLParser::EXECUTE);
      setState(4041);
      function_or_procedure();
      setState(4042);
      func_name();
      setState(4043);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(4044);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4046);
      match(PostgreSQLParser::CREATE);
      setState(4047);
      match(PostgreSQLParser::EVENT);
      setState(4048);
      match(PostgreSQLParser::TRIGGER);
      setState(4049);
      name();
      setState(4050);
      match(PostgreSQLParser::ON);
      setState(4051);
      colLabel();
      setState(4052);
      match(PostgreSQLParser::WHEN);
      setState(4053);
      event_trigger_when_list();
      setState(4054);
      match(PostgreSQLParser::EXECUTE);
      setState(4055);
      function_or_procedure();
      setState(4056);
      func_name();
      setState(4057);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(4058);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_trigger_when_listContext ------------------------------------------------------------------

PostgreSQLParser::Event_trigger_when_listContext::Event_trigger_when_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Event_trigger_when_itemContext *> PostgreSQLParser::Event_trigger_when_listContext::event_trigger_when_item() {
  return getRuleContexts<PostgreSQLParser::Event_trigger_when_itemContext>();
}

PostgreSQLParser::Event_trigger_when_itemContext* PostgreSQLParser::Event_trigger_when_listContext::event_trigger_when_item(size_t i) {
  return getRuleContext<PostgreSQLParser::Event_trigger_when_itemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Event_trigger_when_listContext::AND() {
  return getTokens(PostgreSQLParser::AND);
}

tree::TerminalNode* PostgreSQLParser::Event_trigger_when_listContext::AND(size_t i) {
  return getToken(PostgreSQLParser::AND, i);
}


size_t PostgreSQLParser::Event_trigger_when_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleEvent_trigger_when_list;
}


std::any PostgreSQLParser::Event_trigger_when_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitEvent_trigger_when_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Event_trigger_when_listContext* PostgreSQLParser::event_trigger_when_list() {
  Event_trigger_when_listContext *_localctx = _tracker.createInstance<Event_trigger_when_listContext>(_ctx, getState());
  enterRule(_localctx, 442, PostgreSQLParser::RuleEvent_trigger_when_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4062);
    event_trigger_when_item();
    setState(4067);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::AND) {
      setState(4063);
      match(PostgreSQLParser::AND);
      setState(4064);
      event_trigger_when_item();
      setState(4069);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_trigger_when_itemContext ------------------------------------------------------------------

PostgreSQLParser::Event_trigger_when_itemContext::Event_trigger_when_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Event_trigger_when_itemContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Event_trigger_when_itemContext::IN_P() {
  return getToken(PostgreSQLParser::IN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Event_trigger_when_itemContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Event_trigger_value_listContext* PostgreSQLParser::Event_trigger_when_itemContext::event_trigger_value_list() {
  return getRuleContext<PostgreSQLParser::Event_trigger_value_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Event_trigger_when_itemContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Event_trigger_when_itemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleEvent_trigger_when_item;
}


std::any PostgreSQLParser::Event_trigger_when_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitEvent_trigger_when_item(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Event_trigger_when_itemContext* PostgreSQLParser::event_trigger_when_item() {
  Event_trigger_when_itemContext *_localctx = _tracker.createInstance<Event_trigger_when_itemContext>(_ctx, getState());
  enterRule(_localctx, 444, PostgreSQLParser::RuleEvent_trigger_when_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4070);
    colid();
    setState(4071);
    match(PostgreSQLParser::IN_P);
    setState(4072);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(4073);
    event_trigger_value_list();
    setState(4074);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_trigger_value_listContext ------------------------------------------------------------------

PostgreSQLParser::Event_trigger_value_listContext::Event_trigger_value_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::SconstContext *> PostgreSQLParser::Event_trigger_value_listContext::sconst() {
  return getRuleContexts<PostgreSQLParser::SconstContext>();
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Event_trigger_value_listContext::sconst(size_t i) {
  return getRuleContext<PostgreSQLParser::SconstContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Event_trigger_value_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Event_trigger_value_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Event_trigger_value_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleEvent_trigger_value_list;
}


std::any PostgreSQLParser::Event_trigger_value_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitEvent_trigger_value_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Event_trigger_value_listContext* PostgreSQLParser::event_trigger_value_list() {
  Event_trigger_value_listContext *_localctx = _tracker.createInstance<Event_trigger_value_listContext>(_ctx, getState());
  enterRule(_localctx, 446, PostgreSQLParser::RuleEvent_trigger_value_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4076);
    sconst();
    setState(4081);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(4077);
      match(PostgreSQLParser::COMMA);
      setState(4078);
      sconst();
      setState(4083);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AltereventtrigstmtContext ------------------------------------------------------------------

PostgreSQLParser::AltereventtrigstmtContext::AltereventtrigstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AltereventtrigstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AltereventtrigstmtContext::EVENT() {
  return getToken(PostgreSQLParser::EVENT, 0);
}

tree::TerminalNode* PostgreSQLParser::AltereventtrigstmtContext::TRIGGER() {
  return getToken(PostgreSQLParser::TRIGGER, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::AltereventtrigstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::Enable_triggerContext* PostgreSQLParser::AltereventtrigstmtContext::enable_trigger() {
  return getRuleContext<PostgreSQLParser::Enable_triggerContext>(0);
}


size_t PostgreSQLParser::AltereventtrigstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAltereventtrigstmt;
}


std::any PostgreSQLParser::AltereventtrigstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAltereventtrigstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AltereventtrigstmtContext* PostgreSQLParser::altereventtrigstmt() {
  AltereventtrigstmtContext *_localctx = _tracker.createInstance<AltereventtrigstmtContext>(_ctx, getState());
  enterRule(_localctx, 448, PostgreSQLParser::RuleAltereventtrigstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4084);
    match(PostgreSQLParser::ALTER);
    setState(4085);
    match(PostgreSQLParser::EVENT);
    setState(4086);
    match(PostgreSQLParser::TRIGGER);
    setState(4087);
    name();
    setState(4088);
    enable_trigger();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enable_triggerContext ------------------------------------------------------------------

PostgreSQLParser::Enable_triggerContext::Enable_triggerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Enable_triggerContext::ENABLE_P() {
  return getToken(PostgreSQLParser::ENABLE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Enable_triggerContext::REPLICA() {
  return getToken(PostgreSQLParser::REPLICA, 0);
}

tree::TerminalNode* PostgreSQLParser::Enable_triggerContext::ALWAYS() {
  return getToken(PostgreSQLParser::ALWAYS, 0);
}

tree::TerminalNode* PostgreSQLParser::Enable_triggerContext::DISABLE_P() {
  return getToken(PostgreSQLParser::DISABLE_P, 0);
}


size_t PostgreSQLParser::Enable_triggerContext::getRuleIndex() const {
  return PostgreSQLParser::RuleEnable_trigger;
}


std::any PostgreSQLParser::Enable_triggerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitEnable_trigger(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Enable_triggerContext* PostgreSQLParser::enable_trigger() {
  Enable_triggerContext *_localctx = _tracker.createInstance<Enable_triggerContext>(_ctx, getState());
  enterRule(_localctx, 450, PostgreSQLParser::RuleEnable_trigger);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4096);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 322, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4090);
      match(PostgreSQLParser::ENABLE_P);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4091);
      match(PostgreSQLParser::ENABLE_P);
      setState(4092);
      match(PostgreSQLParser::REPLICA);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4093);
      match(PostgreSQLParser::ENABLE_P);
      setState(4094);
      match(PostgreSQLParser::ALWAYS);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4095);
      match(PostgreSQLParser::DISABLE_P);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateassertionstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreateassertionstmtContext::CreateassertionstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreateassertionstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateassertionstmtContext::ASSERTION() {
  return getToken(PostgreSQLParser::ASSERTION, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::CreateassertionstmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateassertionstmtContext::CHECK() {
  return getToken(PostgreSQLParser::CHECK, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateassertionstmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::CreateassertionstmtContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateassertionstmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::ConstraintattributespecContext* PostgreSQLParser::CreateassertionstmtContext::constraintattributespec() {
  return getRuleContext<PostgreSQLParser::ConstraintattributespecContext>(0);
}


size_t PostgreSQLParser::CreateassertionstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreateassertionstmt;
}


std::any PostgreSQLParser::CreateassertionstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateassertionstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreateassertionstmtContext* PostgreSQLParser::createassertionstmt() {
  CreateassertionstmtContext *_localctx = _tracker.createInstance<CreateassertionstmtContext>(_ctx, getState());
  enterRule(_localctx, 452, PostgreSQLParser::RuleCreateassertionstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4098);
    match(PostgreSQLParser::CREATE);
    setState(4099);
    match(PostgreSQLParser::ASSERTION);
    setState(4100);
    any_name();
    setState(4101);
    match(PostgreSQLParser::CHECK);
    setState(4102);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(4103);
    a_expr();
    setState(4104);
    match(PostgreSQLParser::CLOSE_PAREN);
    setState(4105);
    constraintattributespec();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefinestmtContext ------------------------------------------------------------------

PostgreSQLParser::DefinestmtContext::DefinestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::AGGREGATE() {
  return getToken(PostgreSQLParser::AGGREGATE, 0);
}

PostgreSQLParser::Func_nameContext* PostgreSQLParser::DefinestmtContext::func_name() {
  return getRuleContext<PostgreSQLParser::Func_nameContext>(0);
}

PostgreSQLParser::Aggr_argsContext* PostgreSQLParser::DefinestmtContext::aggr_args() {
  return getRuleContext<PostgreSQLParser::Aggr_argsContext>(0);
}

PostgreSQLParser::DefinitionContext* PostgreSQLParser::DefinestmtContext::definition() {
  return getRuleContext<PostgreSQLParser::DefinitionContext>(0);
}

PostgreSQLParser::Or_replace_Context* PostgreSQLParser::DefinestmtContext::or_replace_() {
  return getRuleContext<PostgreSQLParser::Or_replace_Context>(0);
}

PostgreSQLParser::Old_aggr_definitionContext* PostgreSQLParser::DefinestmtContext::old_aggr_definition() {
  return getRuleContext<PostgreSQLParser::Old_aggr_definitionContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

PostgreSQLParser::Any_operatorContext* PostgreSQLParser::DefinestmtContext::any_operator() {
  return getRuleContext<PostgreSQLParser::Any_operatorContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}

std::vector<PostgreSQLParser::Any_nameContext *> PostgreSQLParser::DefinestmtContext::any_name() {
  return getRuleContexts<PostgreSQLParser::Any_nameContext>();
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::DefinestmtContext::any_name(size_t i) {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(i);
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::OpttablefuncelementlistContext* PostgreSQLParser::DefinestmtContext::opttablefuncelementlist() {
  return getRuleContext<PostgreSQLParser::OpttablefuncelementlistContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::ENUM_P() {
  return getToken(PostgreSQLParser::ENUM_P, 0);
}

PostgreSQLParser::Enum_val_list_Context* PostgreSQLParser::DefinestmtContext::enum_val_list_() {
  return getRuleContext<PostgreSQLParser::Enum_val_list_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::RANGE() {
  return getToken(PostgreSQLParser::RANGE, 0);
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::TEXT_P() {
  return getToken(PostgreSQLParser::TEXT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::SEARCH() {
  return getToken(PostgreSQLParser::SEARCH, 0);
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::PARSER() {
  return getToken(PostgreSQLParser::PARSER, 0);
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::DICTIONARY() {
  return getToken(PostgreSQLParser::DICTIONARY, 0);
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::TEMPLATE() {
  return getToken(PostgreSQLParser::TEMPLATE, 0);
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::CONFIGURATION() {
  return getToken(PostgreSQLParser::CONFIGURATION, 0);
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::COLLATION() {
  return getToken(PostgreSQLParser::COLLATION, 0);
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

tree::TerminalNode* PostgreSQLParser::DefinestmtContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}


size_t PostgreSQLParser::DefinestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDefinestmt;
}


std::any PostgreSQLParser::DefinestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDefinestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DefinestmtContext* PostgreSQLParser::definestmt() {
  DefinestmtContext *_localctx = _tracker.createInstance<DefinestmtContext>(_ctx, getState());
  enterRule(_localctx, 454, PostgreSQLParser::RuleDefinestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4221);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 327, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4107);
      match(PostgreSQLParser::CREATE);
      setState(4109);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OR) {
        setState(4108);
        or_replace_();
      }
      setState(4111);
      match(PostgreSQLParser::AGGREGATE);
      setState(4112);
      func_name();
      setState(4113);
      aggr_args();
      setState(4114);
      definition();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4116);
      match(PostgreSQLParser::CREATE);
      setState(4118);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OR) {
        setState(4117);
        or_replace_();
      }
      setState(4120);
      match(PostgreSQLParser::AGGREGATE);
      setState(4121);
      func_name();
      setState(4122);
      old_aggr_definition();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4124);
      match(PostgreSQLParser::CREATE);
      setState(4125);
      match(PostgreSQLParser::OPERATOR);
      setState(4126);
      any_operator();
      setState(4127);
      definition();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4129);
      match(PostgreSQLParser::CREATE);
      setState(4130);
      match(PostgreSQLParser::TYPE_P);
      setState(4131);
      any_name();
      setState(4132);
      definition();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4134);
      match(PostgreSQLParser::CREATE);
      setState(4135);
      match(PostgreSQLParser::TYPE_P);
      setState(4136);
      any_name();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4137);
      match(PostgreSQLParser::CREATE);
      setState(4138);
      match(PostgreSQLParser::TYPE_P);
      setState(4139);
      any_name();
      setState(4140);
      match(PostgreSQLParser::AS);
      setState(4141);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(4143);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 30) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 30)) & 137438949375) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 553)) & 536870983) != 0)) {
        setState(4142);
        opttablefuncelementlist();
      }
      setState(4145);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4147);
      match(PostgreSQLParser::CREATE);
      setState(4148);
      match(PostgreSQLParser::TYPE_P);
      setState(4149);
      any_name();
      setState(4150);
      match(PostgreSQLParser::AS);
      setState(4151);
      match(PostgreSQLParser::ENUM_P);
      setState(4152);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(4154);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 563) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 563)) & 134217749) != 0)) {
        setState(4153);
        enum_val_list_();
      }
      setState(4156);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4158);
      match(PostgreSQLParser::CREATE);
      setState(4159);
      match(PostgreSQLParser::TYPE_P);
      setState(4160);
      any_name();
      setState(4161);
      match(PostgreSQLParser::AS);
      setState(4162);
      match(PostgreSQLParser::RANGE);
      setState(4163);
      definition();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(4165);
      match(PostgreSQLParser::CREATE);
      setState(4166);
      match(PostgreSQLParser::TEXT_P);
      setState(4167);
      match(PostgreSQLParser::SEARCH);
      setState(4168);
      match(PostgreSQLParser::PARSER);
      setState(4169);
      any_name();
      setState(4170);
      definition();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(4172);
      match(PostgreSQLParser::CREATE);
      setState(4173);
      match(PostgreSQLParser::TEXT_P);
      setState(4174);
      match(PostgreSQLParser::SEARCH);
      setState(4175);
      match(PostgreSQLParser::DICTIONARY);
      setState(4176);
      any_name();
      setState(4177);
      definition();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(4179);
      match(PostgreSQLParser::CREATE);
      setState(4180);
      match(PostgreSQLParser::TEXT_P);
      setState(4181);
      match(PostgreSQLParser::SEARCH);
      setState(4182);
      match(PostgreSQLParser::TEMPLATE);
      setState(4183);
      any_name();
      setState(4184);
      definition();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(4186);
      match(PostgreSQLParser::CREATE);
      setState(4187);
      match(PostgreSQLParser::TEXT_P);
      setState(4188);
      match(PostgreSQLParser::SEARCH);
      setState(4189);
      match(PostgreSQLParser::CONFIGURATION);
      setState(4190);
      any_name();
      setState(4191);
      definition();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(4193);
      match(PostgreSQLParser::CREATE);
      setState(4194);
      match(PostgreSQLParser::COLLATION);
      setState(4195);
      any_name();
      setState(4196);
      definition();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(4198);
      match(PostgreSQLParser::CREATE);
      setState(4199);
      match(PostgreSQLParser::COLLATION);
      setState(4200);
      match(PostgreSQLParser::IF_P);
      setState(4201);
      match(PostgreSQLParser::NOT);
      setState(4202);
      match(PostgreSQLParser::EXISTS);
      setState(4203);
      any_name();
      setState(4204);
      definition();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(4206);
      match(PostgreSQLParser::CREATE);
      setState(4207);
      match(PostgreSQLParser::COLLATION);
      setState(4208);
      any_name();
      setState(4209);
      match(PostgreSQLParser::FROM);
      setState(4210);
      any_name();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(4212);
      match(PostgreSQLParser::CREATE);
      setState(4213);
      match(PostgreSQLParser::COLLATION);
      setState(4214);
      match(PostgreSQLParser::IF_P);
      setState(4215);
      match(PostgreSQLParser::NOT);
      setState(4216);
      match(PostgreSQLParser::EXISTS);
      setState(4217);
      any_name();
      setState(4218);
      match(PostgreSQLParser::FROM);
      setState(4219);
      any_name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefinitionContext ------------------------------------------------------------------

PostgreSQLParser::DefinitionContext::DefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DefinitionContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Def_listContext* PostgreSQLParser::DefinitionContext::def_list() {
  return getRuleContext<PostgreSQLParser::Def_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DefinitionContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::DefinitionContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDefinition;
}


std::any PostgreSQLParser::DefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDefinition(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DefinitionContext* PostgreSQLParser::definition() {
  DefinitionContext *_localctx = _tracker.createInstance<DefinitionContext>(_ctx, getState());
  enterRule(_localctx, 456, PostgreSQLParser::RuleDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4223);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(4224);
    def_list();
    setState(4225);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Def_listContext ------------------------------------------------------------------

PostgreSQLParser::Def_listContext::Def_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Def_elemContext *> PostgreSQLParser::Def_listContext::def_elem() {
  return getRuleContexts<PostgreSQLParser::Def_elemContext>();
}

PostgreSQLParser::Def_elemContext* PostgreSQLParser::Def_listContext::def_elem(size_t i) {
  return getRuleContext<PostgreSQLParser::Def_elemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Def_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Def_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Def_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDef_list;
}


std::any PostgreSQLParser::Def_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDef_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Def_listContext* PostgreSQLParser::def_list() {
  Def_listContext *_localctx = _tracker.createInstance<Def_listContext>(_ctx, getState());
  enterRule(_localctx, 458, PostgreSQLParser::RuleDef_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4227);
    def_elem();
    setState(4232);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(4228);
      match(PostgreSQLParser::COMMA);
      setState(4229);
      def_elem();
      setState(4234);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Def_elemContext ------------------------------------------------------------------

PostgreSQLParser::Def_elemContext::Def_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColLabelContext* PostgreSQLParser::Def_elemContext::colLabel() {
  return getRuleContext<PostgreSQLParser::ColLabelContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Def_elemContext::EQUAL() {
  return getToken(PostgreSQLParser::EQUAL, 0);
}

PostgreSQLParser::Def_argContext* PostgreSQLParser::Def_elemContext::def_arg() {
  return getRuleContext<PostgreSQLParser::Def_argContext>(0);
}


size_t PostgreSQLParser::Def_elemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDef_elem;
}


std::any PostgreSQLParser::Def_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDef_elem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Def_elemContext* PostgreSQLParser::def_elem() {
  Def_elemContext *_localctx = _tracker.createInstance<Def_elemContext>(_ctx, getState());
  enterRule(_localctx, 460, PostgreSQLParser::RuleDef_elem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4235);
    colLabel();
    setState(4238);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::EQUAL) {
      setState(4236);
      match(PostgreSQLParser::EQUAL);
      setState(4237);
      def_arg();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Def_argContext ------------------------------------------------------------------

PostgreSQLParser::Def_argContext::Def_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Func_typeContext* PostgreSQLParser::Def_argContext::func_type() {
  return getRuleContext<PostgreSQLParser::Func_typeContext>(0);
}

PostgreSQLParser::Reserved_keywordContext* PostgreSQLParser::Def_argContext::reserved_keyword() {
  return getRuleContext<PostgreSQLParser::Reserved_keywordContext>(0);
}

PostgreSQLParser::Qual_all_opContext* PostgreSQLParser::Def_argContext::qual_all_op() {
  return getRuleContext<PostgreSQLParser::Qual_all_opContext>(0);
}

PostgreSQLParser::NumericonlyContext* PostgreSQLParser::Def_argContext::numericonly() {
  return getRuleContext<PostgreSQLParser::NumericonlyContext>(0);
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Def_argContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Def_argContext::NONE() {
  return getToken(PostgreSQLParser::NONE, 0);
}


size_t PostgreSQLParser::Def_argContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDef_arg;
}


std::any PostgreSQLParser::Def_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDef_arg(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Def_argContext* PostgreSQLParser::def_arg() {
  Def_argContext *_localctx = _tracker.createInstance<Def_argContext>(_ctx, getState());
  enterRule(_localctx, 462, PostgreSQLParser::RuleDef_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4246);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 330, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4240);
      func_type();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4241);
      reserved_keyword();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4242);
      qual_all_op();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4243);
      numericonly();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4244);
      sconst();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4245);
      match(PostgreSQLParser::NONE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Old_aggr_definitionContext ------------------------------------------------------------------

PostgreSQLParser::Old_aggr_definitionContext::Old_aggr_definitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Old_aggr_definitionContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Old_aggr_listContext* PostgreSQLParser::Old_aggr_definitionContext::old_aggr_list() {
  return getRuleContext<PostgreSQLParser::Old_aggr_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Old_aggr_definitionContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Old_aggr_definitionContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOld_aggr_definition;
}


std::any PostgreSQLParser::Old_aggr_definitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOld_aggr_definition(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Old_aggr_definitionContext* PostgreSQLParser::old_aggr_definition() {
  Old_aggr_definitionContext *_localctx = _tracker.createInstance<Old_aggr_definitionContext>(_ctx, getState());
  enterRule(_localctx, 464, PostgreSQLParser::RuleOld_aggr_definition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4248);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(4249);
    old_aggr_list();
    setState(4250);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Old_aggr_listContext ------------------------------------------------------------------

PostgreSQLParser::Old_aggr_listContext::Old_aggr_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Old_aggr_elemContext *> PostgreSQLParser::Old_aggr_listContext::old_aggr_elem() {
  return getRuleContexts<PostgreSQLParser::Old_aggr_elemContext>();
}

PostgreSQLParser::Old_aggr_elemContext* PostgreSQLParser::Old_aggr_listContext::old_aggr_elem(size_t i) {
  return getRuleContext<PostgreSQLParser::Old_aggr_elemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Old_aggr_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Old_aggr_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Old_aggr_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOld_aggr_list;
}


std::any PostgreSQLParser::Old_aggr_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOld_aggr_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Old_aggr_listContext* PostgreSQLParser::old_aggr_list() {
  Old_aggr_listContext *_localctx = _tracker.createInstance<Old_aggr_listContext>(_ctx, getState());
  enterRule(_localctx, 466, PostgreSQLParser::RuleOld_aggr_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4252);
    old_aggr_elem();
    setState(4257);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(4253);
      match(PostgreSQLParser::COMMA);
      setState(4254);
      old_aggr_elem();
      setState(4259);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Old_aggr_elemContext ------------------------------------------------------------------

PostgreSQLParser::Old_aggr_elemContext::Old_aggr_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::IdentifierContext* PostgreSQLParser::Old_aggr_elemContext::identifier() {
  return getRuleContext<PostgreSQLParser::IdentifierContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Old_aggr_elemContext::EQUAL() {
  return getToken(PostgreSQLParser::EQUAL, 0);
}

PostgreSQLParser::Def_argContext* PostgreSQLParser::Old_aggr_elemContext::def_arg() {
  return getRuleContext<PostgreSQLParser::Def_argContext>(0);
}


size_t PostgreSQLParser::Old_aggr_elemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOld_aggr_elem;
}


std::any PostgreSQLParser::Old_aggr_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOld_aggr_elem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Old_aggr_elemContext* PostgreSQLParser::old_aggr_elem() {
  Old_aggr_elemContext *_localctx = _tracker.createInstance<Old_aggr_elemContext>(_ctx, getState());
  enterRule(_localctx, 468, PostgreSQLParser::RuleOld_aggr_elem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4260);
    identifier();
    setState(4261);
    match(PostgreSQLParser::EQUAL);
    setState(4262);
    def_arg();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enum_val_list_Context ------------------------------------------------------------------

PostgreSQLParser::Enum_val_list_Context::Enum_val_list_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Enum_val_listContext* PostgreSQLParser::Enum_val_list_Context::enum_val_list() {
  return getRuleContext<PostgreSQLParser::Enum_val_listContext>(0);
}


size_t PostgreSQLParser::Enum_val_list_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleEnum_val_list_;
}


std::any PostgreSQLParser::Enum_val_list_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitEnum_val_list_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Enum_val_list_Context* PostgreSQLParser::enum_val_list_() {
  Enum_val_list_Context *_localctx = _tracker.createInstance<Enum_val_list_Context>(_ctx, getState());
  enterRule(_localctx, 470, PostgreSQLParser::RuleEnum_val_list_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4264);
    enum_val_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enum_val_listContext ------------------------------------------------------------------

PostgreSQLParser::Enum_val_listContext::Enum_val_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::SconstContext *> PostgreSQLParser::Enum_val_listContext::sconst() {
  return getRuleContexts<PostgreSQLParser::SconstContext>();
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Enum_val_listContext::sconst(size_t i) {
  return getRuleContext<PostgreSQLParser::SconstContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Enum_val_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Enum_val_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Enum_val_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleEnum_val_list;
}


std::any PostgreSQLParser::Enum_val_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitEnum_val_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Enum_val_listContext* PostgreSQLParser::enum_val_list() {
  Enum_val_listContext *_localctx = _tracker.createInstance<Enum_val_listContext>(_ctx, getState());
  enterRule(_localctx, 472, PostgreSQLParser::RuleEnum_val_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4266);
    sconst();
    setState(4271);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(4267);
      match(PostgreSQLParser::COMMA);
      setState(4268);
      sconst();
      setState(4273);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterenumstmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterenumstmtContext::AlterenumstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterenumstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterenumstmtContext::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::AlterenumstmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterenumstmtContext::ADD_P() {
  return getToken(PostgreSQLParser::ADD_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterenumstmtContext::VALUE_P() {
  return getToken(PostgreSQLParser::VALUE_P, 0);
}

std::vector<PostgreSQLParser::SconstContext *> PostgreSQLParser::AlterenumstmtContext::sconst() {
  return getRuleContexts<PostgreSQLParser::SconstContext>();
}

PostgreSQLParser::SconstContext* PostgreSQLParser::AlterenumstmtContext::sconst(size_t i) {
  return getRuleContext<PostgreSQLParser::SconstContext>(i);
}

PostgreSQLParser::If_not_exists_Context* PostgreSQLParser::AlterenumstmtContext::if_not_exists_() {
  return getRuleContext<PostgreSQLParser::If_not_exists_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterenumstmtContext::BEFORE() {
  return getToken(PostgreSQLParser::BEFORE, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterenumstmtContext::AFTER() {
  return getToken(PostgreSQLParser::AFTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterenumstmtContext::RENAME() {
  return getToken(PostgreSQLParser::RENAME, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterenumstmtContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}


size_t PostgreSQLParser::AlterenumstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterenumstmt;
}


std::any PostgreSQLParser::AlterenumstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterenumstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterenumstmtContext* PostgreSQLParser::alterenumstmt() {
  AlterenumstmtContext *_localctx = _tracker.createInstance<AlterenumstmtContext>(_ctx, getState());
  enterRule(_localctx, 474, PostgreSQLParser::RuleAlterenumstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4317);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 336, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4274);
      match(PostgreSQLParser::ALTER);
      setState(4275);
      match(PostgreSQLParser::TYPE_P);
      setState(4276);
      any_name();
      setState(4277);
      match(PostgreSQLParser::ADD_P);
      setState(4278);
      match(PostgreSQLParser::VALUE_P);
      setState(4280);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::IF_P) {
        setState(4279);
        if_not_exists_();
      }
      setState(4282);
      sconst();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4284);
      match(PostgreSQLParser::ALTER);
      setState(4285);
      match(PostgreSQLParser::TYPE_P);
      setState(4286);
      any_name();
      setState(4287);
      match(PostgreSQLParser::ADD_P);
      setState(4288);
      match(PostgreSQLParser::VALUE_P);
      setState(4290);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::IF_P) {
        setState(4289);
        if_not_exists_();
      }
      setState(4292);
      sconst();
      setState(4293);
      match(PostgreSQLParser::BEFORE);
      setState(4294);
      sconst();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4296);
      match(PostgreSQLParser::ALTER);
      setState(4297);
      match(PostgreSQLParser::TYPE_P);
      setState(4298);
      any_name();
      setState(4299);
      match(PostgreSQLParser::ADD_P);
      setState(4300);
      match(PostgreSQLParser::VALUE_P);
      setState(4302);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::IF_P) {
        setState(4301);
        if_not_exists_();
      }
      setState(4304);
      sconst();
      setState(4305);
      match(PostgreSQLParser::AFTER);
      setState(4306);
      sconst();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4308);
      match(PostgreSQLParser::ALTER);
      setState(4309);
      match(PostgreSQLParser::TYPE_P);
      setState(4310);
      any_name();
      setState(4311);
      match(PostgreSQLParser::RENAME);
      setState(4312);
      match(PostgreSQLParser::VALUE_P);
      setState(4313);
      sconst();
      setState(4314);
      match(PostgreSQLParser::TO);
      setState(4315);
      sconst();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_not_exists_Context ------------------------------------------------------------------

PostgreSQLParser::If_not_exists_Context::If_not_exists_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::If_not_exists_Context::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::If_not_exists_Context::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::If_not_exists_Context::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}


size_t PostgreSQLParser::If_not_exists_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleIf_not_exists_;
}


std::any PostgreSQLParser::If_not_exists_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitIf_not_exists_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::If_not_exists_Context* PostgreSQLParser::if_not_exists_() {
  If_not_exists_Context *_localctx = _tracker.createInstance<If_not_exists_Context>(_ctx, getState());
  enterRule(_localctx, 476, PostgreSQLParser::RuleIf_not_exists_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4319);
    match(PostgreSQLParser::IF_P);
    setState(4320);
    match(PostgreSQLParser::NOT);
    setState(4321);
    match(PostgreSQLParser::EXISTS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateopclassstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreateopclassstmtContext::CreateopclassstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreateopclassstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateopclassstmtContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateopclassstmtContext::CLASS() {
  return getToken(PostgreSQLParser::CLASS, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::CreateopclassstmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateopclassstmtContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateopclassstmtContext::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::CreateopclassstmtContext::typename_() {
  return getRuleContext<PostgreSQLParser::TypenameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateopclassstmtContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::CreateopclassstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateopclassstmtContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

PostgreSQLParser::Opclass_item_listContext* PostgreSQLParser::CreateopclassstmtContext::opclass_item_list() {
  return getRuleContext<PostgreSQLParser::Opclass_item_listContext>(0);
}

PostgreSQLParser::Default_Context* PostgreSQLParser::CreateopclassstmtContext::default_() {
  return getRuleContext<PostgreSQLParser::Default_Context>(0);
}

PostgreSQLParser::Opfamily_Context* PostgreSQLParser::CreateopclassstmtContext::opfamily_() {
  return getRuleContext<PostgreSQLParser::Opfamily_Context>(0);
}


size_t PostgreSQLParser::CreateopclassstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreateopclassstmt;
}


std::any PostgreSQLParser::CreateopclassstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateopclassstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreateopclassstmtContext* PostgreSQLParser::createopclassstmt() {
  CreateopclassstmtContext *_localctx = _tracker.createInstance<CreateopclassstmtContext>(_ctx, getState());
  enterRule(_localctx, 478, PostgreSQLParser::RuleCreateopclassstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4323);
    match(PostgreSQLParser::CREATE);
    setState(4324);
    match(PostgreSQLParser::OPERATOR);
    setState(4325);
    match(PostgreSQLParser::CLASS);
    setState(4326);
    any_name();
    setState(4328);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::DEFAULT) {
      setState(4327);
      default_();
    }
    setState(4330);
    match(PostgreSQLParser::FOR);
    setState(4331);
    match(PostgreSQLParser::TYPE_P);
    setState(4332);
    typename_();
    setState(4333);
    match(PostgreSQLParser::USING);
    setState(4334);
    name();
    setState(4336);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::FAMILY) {
      setState(4335);
      opfamily_();
    }
    setState(4338);
    match(PostgreSQLParser::AS);
    setState(4339);
    opclass_item_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opclass_item_listContext ------------------------------------------------------------------

PostgreSQLParser::Opclass_item_listContext::Opclass_item_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Opclass_itemContext *> PostgreSQLParser::Opclass_item_listContext::opclass_item() {
  return getRuleContexts<PostgreSQLParser::Opclass_itemContext>();
}

PostgreSQLParser::Opclass_itemContext* PostgreSQLParser::Opclass_item_listContext::opclass_item(size_t i) {
  return getRuleContext<PostgreSQLParser::Opclass_itemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Opclass_item_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Opclass_item_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Opclass_item_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOpclass_item_list;
}


std::any PostgreSQLParser::Opclass_item_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOpclass_item_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Opclass_item_listContext* PostgreSQLParser::opclass_item_list() {
  Opclass_item_listContext *_localctx = _tracker.createInstance<Opclass_item_listContext>(_ctx, getState());
  enterRule(_localctx, 480, PostgreSQLParser::RuleOpclass_item_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4341);
    opclass_item();
    setState(4346);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(4342);
      match(PostgreSQLParser::COMMA);
      setState(4343);
      opclass_item();
      setState(4348);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opclass_itemContext ------------------------------------------------------------------

PostgreSQLParser::Opclass_itemContext::Opclass_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Opclass_itemContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

PostgreSQLParser::IconstContext* PostgreSQLParser::Opclass_itemContext::iconst() {
  return getRuleContext<PostgreSQLParser::IconstContext>(0);
}

PostgreSQLParser::Any_operatorContext* PostgreSQLParser::Opclass_itemContext::any_operator() {
  return getRuleContext<PostgreSQLParser::Any_operatorContext>(0);
}

PostgreSQLParser::Opclass_purposeContext* PostgreSQLParser::Opclass_itemContext::opclass_purpose() {
  return getRuleContext<PostgreSQLParser::Opclass_purposeContext>(0);
}

PostgreSQLParser::Recheck_Context* PostgreSQLParser::Opclass_itemContext::recheck_() {
  return getRuleContext<PostgreSQLParser::Recheck_Context>(0);
}

PostgreSQLParser::Operator_with_argtypesContext* PostgreSQLParser::Opclass_itemContext::operator_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Operator_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Opclass_itemContext::FUNCTION() {
  return getToken(PostgreSQLParser::FUNCTION, 0);
}

PostgreSQLParser::Function_with_argtypesContext* PostgreSQLParser::Opclass_itemContext::function_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Function_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Opclass_itemContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Type_listContext* PostgreSQLParser::Opclass_itemContext::type_list() {
  return getRuleContext<PostgreSQLParser::Type_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Opclass_itemContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::Opclass_itemContext::STORAGE() {
  return getToken(PostgreSQLParser::STORAGE, 0);
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::Opclass_itemContext::typename_() {
  return getRuleContext<PostgreSQLParser::TypenameContext>(0);
}


size_t PostgreSQLParser::Opclass_itemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOpclass_item;
}


std::any PostgreSQLParser::Opclass_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOpclass_item(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Opclass_itemContext* PostgreSQLParser::opclass_item() {
  Opclass_itemContext *_localctx = _tracker.createInstance<Opclass_itemContext>(_ctx, getState());
  enterRule(_localctx, 482, PostgreSQLParser::RuleOpclass_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4380);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 344, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4349);
      match(PostgreSQLParser::OPERATOR);
      setState(4350);
      iconst();
      setState(4351);
      any_operator();
      setState(4353);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FOR) {
        setState(4352);
        opclass_purpose();
      }
      setState(4356);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::RECHECK) {
        setState(4355);
        recheck_();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4358);
      match(PostgreSQLParser::OPERATOR);
      setState(4359);
      iconst();
      setState(4360);
      operator_with_argtypes();
      setState(4362);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FOR) {
        setState(4361);
        opclass_purpose();
      }
      setState(4365);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::RECHECK) {
        setState(4364);
        recheck_();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4367);
      match(PostgreSQLParser::FUNCTION);
      setState(4368);
      iconst();
      setState(4369);
      function_with_argtypes();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4371);
      match(PostgreSQLParser::FUNCTION);
      setState(4372);
      iconst();
      setState(4373);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(4374);
      type_list();
      setState(4375);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(4376);
      function_with_argtypes();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4378);
      match(PostgreSQLParser::STORAGE);
      setState(4379);
      typename_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Default_Context ------------------------------------------------------------------

PostgreSQLParser::Default_Context::Default_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Default_Context::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}


size_t PostgreSQLParser::Default_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleDefault_;
}


std::any PostgreSQLParser::Default_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDefault_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Default_Context* PostgreSQLParser::default_() {
  Default_Context *_localctx = _tracker.createInstance<Default_Context>(_ctx, getState());
  enterRule(_localctx, 484, PostgreSQLParser::RuleDefault_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4382);
    match(PostgreSQLParser::DEFAULT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opfamily_Context ------------------------------------------------------------------

PostgreSQLParser::Opfamily_Context::Opfamily_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Opfamily_Context::FAMILY() {
  return getToken(PostgreSQLParser::FAMILY, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::Opfamily_Context::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}


size_t PostgreSQLParser::Opfamily_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleOpfamily_;
}


std::any PostgreSQLParser::Opfamily_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOpfamily_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Opfamily_Context* PostgreSQLParser::opfamily_() {
  Opfamily_Context *_localctx = _tracker.createInstance<Opfamily_Context>(_ctx, getState());
  enterRule(_localctx, 486, PostgreSQLParser::RuleOpfamily_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4384);
    match(PostgreSQLParser::FAMILY);
    setState(4385);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opclass_purposeContext ------------------------------------------------------------------

PostgreSQLParser::Opclass_purposeContext::Opclass_purposeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Opclass_purposeContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

tree::TerminalNode* PostgreSQLParser::Opclass_purposeContext::SEARCH() {
  return getToken(PostgreSQLParser::SEARCH, 0);
}

tree::TerminalNode* PostgreSQLParser::Opclass_purposeContext::ORDER() {
  return getToken(PostgreSQLParser::ORDER, 0);
}

tree::TerminalNode* PostgreSQLParser::Opclass_purposeContext::BY() {
  return getToken(PostgreSQLParser::BY, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::Opclass_purposeContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}


size_t PostgreSQLParser::Opclass_purposeContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOpclass_purpose;
}


std::any PostgreSQLParser::Opclass_purposeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOpclass_purpose(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Opclass_purposeContext* PostgreSQLParser::opclass_purpose() {
  Opclass_purposeContext *_localctx = _tracker.createInstance<Opclass_purposeContext>(_ctx, getState());
  enterRule(_localctx, 488, PostgreSQLParser::RuleOpclass_purpose);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4393);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 345, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4387);
      match(PostgreSQLParser::FOR);
      setState(4388);
      match(PostgreSQLParser::SEARCH);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4389);
      match(PostgreSQLParser::FOR);
      setState(4390);
      match(PostgreSQLParser::ORDER);
      setState(4391);
      match(PostgreSQLParser::BY);
      setState(4392);
      any_name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Recheck_Context ------------------------------------------------------------------

PostgreSQLParser::Recheck_Context::Recheck_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Recheck_Context::RECHECK() {
  return getToken(PostgreSQLParser::RECHECK, 0);
}


size_t PostgreSQLParser::Recheck_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleRecheck_;
}


std::any PostgreSQLParser::Recheck_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRecheck_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Recheck_Context* PostgreSQLParser::recheck_() {
  Recheck_Context *_localctx = _tracker.createInstance<Recheck_Context>(_ctx, getState());
  enterRule(_localctx, 490, PostgreSQLParser::RuleRecheck_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4395);
    match(PostgreSQLParser::RECHECK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateopfamilystmtContext ------------------------------------------------------------------

PostgreSQLParser::CreateopfamilystmtContext::CreateopfamilystmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreateopfamilystmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateopfamilystmtContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateopfamilystmtContext::FAMILY() {
  return getToken(PostgreSQLParser::FAMILY, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::CreateopfamilystmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreateopfamilystmtContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::CreateopfamilystmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}


size_t PostgreSQLParser::CreateopfamilystmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreateopfamilystmt;
}


std::any PostgreSQLParser::CreateopfamilystmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateopfamilystmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreateopfamilystmtContext* PostgreSQLParser::createopfamilystmt() {
  CreateopfamilystmtContext *_localctx = _tracker.createInstance<CreateopfamilystmtContext>(_ctx, getState());
  enterRule(_localctx, 492, PostgreSQLParser::RuleCreateopfamilystmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4397);
    match(PostgreSQLParser::CREATE);
    setState(4398);
    match(PostgreSQLParser::OPERATOR);
    setState(4399);
    match(PostgreSQLParser::FAMILY);
    setState(4400);
    any_name();
    setState(4401);
    match(PostgreSQLParser::USING);
    setState(4402);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlteropfamilystmtContext ------------------------------------------------------------------

PostgreSQLParser::AlteropfamilystmtContext::AlteropfamilystmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlteropfamilystmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlteropfamilystmtContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

tree::TerminalNode* PostgreSQLParser::AlteropfamilystmtContext::FAMILY() {
  return getToken(PostgreSQLParser::FAMILY, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::AlteropfamilystmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlteropfamilystmtContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::AlteropfamilystmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlteropfamilystmtContext::ADD_P() {
  return getToken(PostgreSQLParser::ADD_P, 0);
}

PostgreSQLParser::Opclass_item_listContext* PostgreSQLParser::AlteropfamilystmtContext::opclass_item_list() {
  return getRuleContext<PostgreSQLParser::Opclass_item_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlteropfamilystmtContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

PostgreSQLParser::Opclass_drop_listContext* PostgreSQLParser::AlteropfamilystmtContext::opclass_drop_list() {
  return getRuleContext<PostgreSQLParser::Opclass_drop_listContext>(0);
}


size_t PostgreSQLParser::AlteropfamilystmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlteropfamilystmt;
}


std::any PostgreSQLParser::AlteropfamilystmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlteropfamilystmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlteropfamilystmtContext* PostgreSQLParser::alteropfamilystmt() {
  AlteropfamilystmtContext *_localctx = _tracker.createInstance<AlteropfamilystmtContext>(_ctx, getState());
  enterRule(_localctx, 494, PostgreSQLParser::RuleAlteropfamilystmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4422);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 346, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4404);
      match(PostgreSQLParser::ALTER);
      setState(4405);
      match(PostgreSQLParser::OPERATOR);
      setState(4406);
      match(PostgreSQLParser::FAMILY);
      setState(4407);
      any_name();
      setState(4408);
      match(PostgreSQLParser::USING);
      setState(4409);
      name();
      setState(4410);
      match(PostgreSQLParser::ADD_P);
      setState(4411);
      opclass_item_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4413);
      match(PostgreSQLParser::ALTER);
      setState(4414);
      match(PostgreSQLParser::OPERATOR);
      setState(4415);
      match(PostgreSQLParser::FAMILY);
      setState(4416);
      any_name();
      setState(4417);
      match(PostgreSQLParser::USING);
      setState(4418);
      name();
      setState(4419);
      match(PostgreSQLParser::DROP);
      setState(4420);
      opclass_drop_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opclass_drop_listContext ------------------------------------------------------------------

PostgreSQLParser::Opclass_drop_listContext::Opclass_drop_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Opclass_dropContext *> PostgreSQLParser::Opclass_drop_listContext::opclass_drop() {
  return getRuleContexts<PostgreSQLParser::Opclass_dropContext>();
}

PostgreSQLParser::Opclass_dropContext* PostgreSQLParser::Opclass_drop_listContext::opclass_drop(size_t i) {
  return getRuleContext<PostgreSQLParser::Opclass_dropContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Opclass_drop_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Opclass_drop_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Opclass_drop_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOpclass_drop_list;
}


std::any PostgreSQLParser::Opclass_drop_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOpclass_drop_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Opclass_drop_listContext* PostgreSQLParser::opclass_drop_list() {
  Opclass_drop_listContext *_localctx = _tracker.createInstance<Opclass_drop_listContext>(_ctx, getState());
  enterRule(_localctx, 496, PostgreSQLParser::RuleOpclass_drop_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4424);
    opclass_drop();
    setState(4429);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(4425);
      match(PostgreSQLParser::COMMA);
      setState(4426);
      opclass_drop();
      setState(4431);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opclass_dropContext ------------------------------------------------------------------

PostgreSQLParser::Opclass_dropContext::Opclass_dropContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Opclass_dropContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

PostgreSQLParser::IconstContext* PostgreSQLParser::Opclass_dropContext::iconst() {
  return getRuleContext<PostgreSQLParser::IconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Opclass_dropContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Type_listContext* PostgreSQLParser::Opclass_dropContext::type_list() {
  return getRuleContext<PostgreSQLParser::Type_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Opclass_dropContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::Opclass_dropContext::FUNCTION() {
  return getToken(PostgreSQLParser::FUNCTION, 0);
}


size_t PostgreSQLParser::Opclass_dropContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOpclass_drop;
}


std::any PostgreSQLParser::Opclass_dropContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOpclass_drop(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Opclass_dropContext* PostgreSQLParser::opclass_drop() {
  Opclass_dropContext *_localctx = _tracker.createInstance<Opclass_dropContext>(_ctx, getState());
  enterRule(_localctx, 498, PostgreSQLParser::RuleOpclass_drop);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4444);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::OPERATOR: {
        enterOuterAlt(_localctx, 1);
        setState(4432);
        match(PostgreSQLParser::OPERATOR);
        setState(4433);
        iconst();
        setState(4434);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(4435);
        type_list();
        setState(4436);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::FUNCTION: {
        enterOuterAlt(_localctx, 2);
        setState(4438);
        match(PostgreSQLParser::FUNCTION);
        setState(4439);
        iconst();
        setState(4440);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(4441);
        type_list();
        setState(4442);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropopclassstmtContext ------------------------------------------------------------------

PostgreSQLParser::DropopclassstmtContext::DropopclassstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DropopclassstmtContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

tree::TerminalNode* PostgreSQLParser::DropopclassstmtContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

tree::TerminalNode* PostgreSQLParser::DropopclassstmtContext::CLASS() {
  return getToken(PostgreSQLParser::CLASS, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::DropopclassstmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DropopclassstmtContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::DropopclassstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::Drop_behavior_Context* PostgreSQLParser::DropopclassstmtContext::drop_behavior_() {
  return getRuleContext<PostgreSQLParser::Drop_behavior_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::DropopclassstmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::DropopclassstmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}


size_t PostgreSQLParser::DropopclassstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDropopclassstmt;
}


std::any PostgreSQLParser::DropopclassstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDropopclassstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DropopclassstmtContext* PostgreSQLParser::dropopclassstmt() {
  DropopclassstmtContext *_localctx = _tracker.createInstance<DropopclassstmtContext>(_ctx, getState());
  enterRule(_localctx, 500, PostgreSQLParser::RuleDropopclassstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4466);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 351, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4446);
      match(PostgreSQLParser::DROP);
      setState(4447);
      match(PostgreSQLParser::OPERATOR);
      setState(4448);
      match(PostgreSQLParser::CLASS);
      setState(4449);
      any_name();
      setState(4450);
      match(PostgreSQLParser::USING);
      setState(4451);
      name();
      setState(4453);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(4452);
        drop_behavior_();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4455);
      match(PostgreSQLParser::DROP);
      setState(4456);
      match(PostgreSQLParser::OPERATOR);
      setState(4457);
      match(PostgreSQLParser::CLASS);
      setState(4458);
      match(PostgreSQLParser::IF_P);
      setState(4459);
      match(PostgreSQLParser::EXISTS);
      setState(4460);
      any_name();
      setState(4461);
      match(PostgreSQLParser::USING);
      setState(4462);
      name();
      setState(4464);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(4463);
        drop_behavior_();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropopfamilystmtContext ------------------------------------------------------------------

PostgreSQLParser::DropopfamilystmtContext::DropopfamilystmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DropopfamilystmtContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

tree::TerminalNode* PostgreSQLParser::DropopfamilystmtContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

tree::TerminalNode* PostgreSQLParser::DropopfamilystmtContext::FAMILY() {
  return getToken(PostgreSQLParser::FAMILY, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::DropopfamilystmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DropopfamilystmtContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::DropopfamilystmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::Drop_behavior_Context* PostgreSQLParser::DropopfamilystmtContext::drop_behavior_() {
  return getRuleContext<PostgreSQLParser::Drop_behavior_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::DropopfamilystmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::DropopfamilystmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}


size_t PostgreSQLParser::DropopfamilystmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDropopfamilystmt;
}


std::any PostgreSQLParser::DropopfamilystmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDropopfamilystmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DropopfamilystmtContext* PostgreSQLParser::dropopfamilystmt() {
  DropopfamilystmtContext *_localctx = _tracker.createInstance<DropopfamilystmtContext>(_ctx, getState());
  enterRule(_localctx, 502, PostgreSQLParser::RuleDropopfamilystmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4488);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 354, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4468);
      match(PostgreSQLParser::DROP);
      setState(4469);
      match(PostgreSQLParser::OPERATOR);
      setState(4470);
      match(PostgreSQLParser::FAMILY);
      setState(4471);
      any_name();
      setState(4472);
      match(PostgreSQLParser::USING);
      setState(4473);
      name();
      setState(4475);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(4474);
        drop_behavior_();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4477);
      match(PostgreSQLParser::DROP);
      setState(4478);
      match(PostgreSQLParser::OPERATOR);
      setState(4479);
      match(PostgreSQLParser::FAMILY);
      setState(4480);
      match(PostgreSQLParser::IF_P);
      setState(4481);
      match(PostgreSQLParser::EXISTS);
      setState(4482);
      any_name();
      setState(4483);
      match(PostgreSQLParser::USING);
      setState(4484);
      name();
      setState(4486);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(4485);
        drop_behavior_();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropownedstmtContext ------------------------------------------------------------------

PostgreSQLParser::DropownedstmtContext::DropownedstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DropownedstmtContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

tree::TerminalNode* PostgreSQLParser::DropownedstmtContext::OWNED() {
  return getToken(PostgreSQLParser::OWNED, 0);
}

tree::TerminalNode* PostgreSQLParser::DropownedstmtContext::BY() {
  return getToken(PostgreSQLParser::BY, 0);
}

PostgreSQLParser::Role_listContext* PostgreSQLParser::DropownedstmtContext::role_list() {
  return getRuleContext<PostgreSQLParser::Role_listContext>(0);
}

PostgreSQLParser::Drop_behavior_Context* PostgreSQLParser::DropownedstmtContext::drop_behavior_() {
  return getRuleContext<PostgreSQLParser::Drop_behavior_Context>(0);
}


size_t PostgreSQLParser::DropownedstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDropownedstmt;
}


std::any PostgreSQLParser::DropownedstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDropownedstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DropownedstmtContext* PostgreSQLParser::dropownedstmt() {
  DropownedstmtContext *_localctx = _tracker.createInstance<DropownedstmtContext>(_ctx, getState());
  enterRule(_localctx, 504, PostgreSQLParser::RuleDropownedstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4490);
    match(PostgreSQLParser::DROP);
    setState(4491);
    match(PostgreSQLParser::OWNED);
    setState(4492);
    match(PostgreSQLParser::BY);
    setState(4493);
    role_list();
    setState(4495);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
      setState(4494);
      drop_behavior_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReassignownedstmtContext ------------------------------------------------------------------

PostgreSQLParser::ReassignownedstmtContext::ReassignownedstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::ReassignownedstmtContext::REASSIGN() {
  return getToken(PostgreSQLParser::REASSIGN, 0);
}

tree::TerminalNode* PostgreSQLParser::ReassignownedstmtContext::OWNED() {
  return getToken(PostgreSQLParser::OWNED, 0);
}

tree::TerminalNode* PostgreSQLParser::ReassignownedstmtContext::BY() {
  return getToken(PostgreSQLParser::BY, 0);
}

PostgreSQLParser::Role_listContext* PostgreSQLParser::ReassignownedstmtContext::role_list() {
  return getRuleContext<PostgreSQLParser::Role_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ReassignownedstmtContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}

PostgreSQLParser::RolespecContext* PostgreSQLParser::ReassignownedstmtContext::rolespec() {
  return getRuleContext<PostgreSQLParser::RolespecContext>(0);
}


size_t PostgreSQLParser::ReassignownedstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleReassignownedstmt;
}


std::any PostgreSQLParser::ReassignownedstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitReassignownedstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ReassignownedstmtContext* PostgreSQLParser::reassignownedstmt() {
  ReassignownedstmtContext *_localctx = _tracker.createInstance<ReassignownedstmtContext>(_ctx, getState());
  enterRule(_localctx, 506, PostgreSQLParser::RuleReassignownedstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4497);
    match(PostgreSQLParser::REASSIGN);
    setState(4498);
    match(PostgreSQLParser::OWNED);
    setState(4499);
    match(PostgreSQLParser::BY);
    setState(4500);
    role_list();
    setState(4501);
    match(PostgreSQLParser::TO);
    setState(4502);
    rolespec();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropstmtContext ------------------------------------------------------------------

PostgreSQLParser::DropstmtContext::DropstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DropstmtContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

PostgreSQLParser::Object_type_any_nameContext* PostgreSQLParser::DropstmtContext::object_type_any_name() {
  return getRuleContext<PostgreSQLParser::Object_type_any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DropstmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::DropstmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

PostgreSQLParser::Any_name_list_Context* PostgreSQLParser::DropstmtContext::any_name_list_() {
  return getRuleContext<PostgreSQLParser::Any_name_list_Context>(0);
}

PostgreSQLParser::Drop_behavior_Context* PostgreSQLParser::DropstmtContext::drop_behavior_() {
  return getRuleContext<PostgreSQLParser::Drop_behavior_Context>(0);
}

PostgreSQLParser::Drop_type_nameContext* PostgreSQLParser::DropstmtContext::drop_type_name() {
  return getRuleContext<PostgreSQLParser::Drop_type_nameContext>(0);
}

PostgreSQLParser::Name_listContext* PostgreSQLParser::DropstmtContext::name_list() {
  return getRuleContext<PostgreSQLParser::Name_listContext>(0);
}

PostgreSQLParser::Object_type_name_on_any_nameContext* PostgreSQLParser::DropstmtContext::object_type_name_on_any_name() {
  return getRuleContext<PostgreSQLParser::Object_type_name_on_any_nameContext>(0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::DropstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DropstmtContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::DropstmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DropstmtContext::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}

PostgreSQLParser::Type_name_listContext* PostgreSQLParser::DropstmtContext::type_name_list() {
  return getRuleContext<PostgreSQLParser::Type_name_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DropstmtContext::DOMAIN_P() {
  return getToken(PostgreSQLParser::DOMAIN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::DropstmtContext::INDEX() {
  return getToken(PostgreSQLParser::INDEX, 0);
}

tree::TerminalNode* PostgreSQLParser::DropstmtContext::CONCURRENTLY() {
  return getToken(PostgreSQLParser::CONCURRENTLY, 0);
}


size_t PostgreSQLParser::DropstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDropstmt;
}


std::any PostgreSQLParser::DropstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDropstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DropstmtContext* PostgreSQLParser::dropstmt() {
  DropstmtContext *_localctx = _tracker.createInstance<DropstmtContext>(_ctx, getState());
  enterRule(_localctx, 508, PostgreSQLParser::RuleDropstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4594);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 368, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4504);
      match(PostgreSQLParser::DROP);
      setState(4505);
      object_type_any_name();
      setState(4506);
      match(PostgreSQLParser::IF_P);
      setState(4507);
      match(PostgreSQLParser::EXISTS);
      setState(4508);
      any_name_list_();
      setState(4510);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(4509);
        drop_behavior_();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4512);
      match(PostgreSQLParser::DROP);
      setState(4513);
      object_type_any_name();
      setState(4514);
      any_name_list_();
      setState(4516);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(4515);
        drop_behavior_();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4518);
      match(PostgreSQLParser::DROP);
      setState(4519);
      drop_type_name();
      setState(4520);
      match(PostgreSQLParser::IF_P);
      setState(4521);
      match(PostgreSQLParser::EXISTS);
      setState(4522);
      name_list();
      setState(4524);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(4523);
        drop_behavior_();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4526);
      match(PostgreSQLParser::DROP);
      setState(4527);
      drop_type_name();
      setState(4528);
      name_list();
      setState(4530);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(4529);
        drop_behavior_();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4532);
      match(PostgreSQLParser::DROP);
      setState(4533);
      object_type_name_on_any_name();
      setState(4534);
      name();
      setState(4535);
      match(PostgreSQLParser::ON);
      setState(4536);
      any_name();
      setState(4538);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(4537);
        drop_behavior_();
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4540);
      match(PostgreSQLParser::DROP);
      setState(4541);
      object_type_name_on_any_name();
      setState(4542);
      match(PostgreSQLParser::IF_P);
      setState(4543);
      match(PostgreSQLParser::EXISTS);
      setState(4544);
      name();
      setState(4545);
      match(PostgreSQLParser::ON);
      setState(4546);
      any_name();
      setState(4548);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(4547);
        drop_behavior_();
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4550);
      match(PostgreSQLParser::DROP);
      setState(4551);
      match(PostgreSQLParser::TYPE_P);
      setState(4552);
      type_name_list();
      setState(4554);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(4553);
        drop_behavior_();
      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4556);
      match(PostgreSQLParser::DROP);
      setState(4557);
      match(PostgreSQLParser::TYPE_P);
      setState(4558);
      match(PostgreSQLParser::IF_P);
      setState(4559);
      match(PostgreSQLParser::EXISTS);
      setState(4560);
      type_name_list();
      setState(4562);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(4561);
        drop_behavior_();
      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(4564);
      match(PostgreSQLParser::DROP);
      setState(4565);
      match(PostgreSQLParser::DOMAIN_P);
      setState(4566);
      type_name_list();
      setState(4568);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(4567);
        drop_behavior_();
      }
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(4570);
      match(PostgreSQLParser::DROP);
      setState(4571);
      match(PostgreSQLParser::DOMAIN_P);
      setState(4572);
      match(PostgreSQLParser::IF_P);
      setState(4573);
      match(PostgreSQLParser::EXISTS);
      setState(4574);
      type_name_list();
      setState(4576);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(4575);
        drop_behavior_();
      }
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(4578);
      match(PostgreSQLParser::DROP);
      setState(4579);
      match(PostgreSQLParser::INDEX);
      setState(4580);
      match(PostgreSQLParser::CONCURRENTLY);
      setState(4581);
      any_name_list_();
      setState(4583);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(4582);
        drop_behavior_();
      }
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(4585);
      match(PostgreSQLParser::DROP);
      setState(4586);
      match(PostgreSQLParser::INDEX);
      setState(4587);
      match(PostgreSQLParser::CONCURRENTLY);
      setState(4588);
      match(PostgreSQLParser::IF_P);
      setState(4589);
      match(PostgreSQLParser::EXISTS);
      setState(4590);
      any_name_list_();
      setState(4592);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(4591);
        drop_behavior_();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Object_type_any_nameContext ------------------------------------------------------------------

PostgreSQLParser::Object_type_any_nameContext::Object_type_any_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Object_type_any_nameContext::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_any_nameContext::SEQUENCE() {
  return getToken(PostgreSQLParser::SEQUENCE, 0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_any_nameContext::VIEW() {
  return getToken(PostgreSQLParser::VIEW, 0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_any_nameContext::MATERIALIZED() {
  return getToken(PostgreSQLParser::MATERIALIZED, 0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_any_nameContext::INDEX() {
  return getToken(PostgreSQLParser::INDEX, 0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_any_nameContext::FOREIGN() {
  return getToken(PostgreSQLParser::FOREIGN, 0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_any_nameContext::COLLATION() {
  return getToken(PostgreSQLParser::COLLATION, 0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_any_nameContext::CONVERSION_P() {
  return getToken(PostgreSQLParser::CONVERSION_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_any_nameContext::STATISTICS() {
  return getToken(PostgreSQLParser::STATISTICS, 0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_any_nameContext::TEXT_P() {
  return getToken(PostgreSQLParser::TEXT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_any_nameContext::SEARCH() {
  return getToken(PostgreSQLParser::SEARCH, 0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_any_nameContext::PARSER() {
  return getToken(PostgreSQLParser::PARSER, 0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_any_nameContext::DICTIONARY() {
  return getToken(PostgreSQLParser::DICTIONARY, 0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_any_nameContext::TEMPLATE() {
  return getToken(PostgreSQLParser::TEMPLATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_any_nameContext::CONFIGURATION() {
  return getToken(PostgreSQLParser::CONFIGURATION, 0);
}


size_t PostgreSQLParser::Object_type_any_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleObject_type_any_name;
}


std::any PostgreSQLParser::Object_type_any_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitObject_type_any_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Object_type_any_nameContext* PostgreSQLParser::object_type_any_name() {
  Object_type_any_nameContext *_localctx = _tracker.createInstance<Object_type_any_nameContext>(_ctx, getState());
  enterRule(_localctx, 510, PostgreSQLParser::RuleObject_type_any_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4619);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 369, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4596);
      match(PostgreSQLParser::TABLE);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4597);
      match(PostgreSQLParser::SEQUENCE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4598);
      match(PostgreSQLParser::VIEW);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4599);
      match(PostgreSQLParser::MATERIALIZED);
      setState(4600);
      match(PostgreSQLParser::VIEW);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4601);
      match(PostgreSQLParser::INDEX);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4602);
      match(PostgreSQLParser::FOREIGN);
      setState(4603);
      match(PostgreSQLParser::TABLE);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4604);
      match(PostgreSQLParser::COLLATION);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4605);
      match(PostgreSQLParser::CONVERSION_P);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(4606);
      match(PostgreSQLParser::STATISTICS);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(4607);
      match(PostgreSQLParser::TEXT_P);
      setState(4608);
      match(PostgreSQLParser::SEARCH);
      setState(4609);
      match(PostgreSQLParser::PARSER);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(4610);
      match(PostgreSQLParser::TEXT_P);
      setState(4611);
      match(PostgreSQLParser::SEARCH);
      setState(4612);
      match(PostgreSQLParser::DICTIONARY);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(4613);
      match(PostgreSQLParser::TEXT_P);
      setState(4614);
      match(PostgreSQLParser::SEARCH);
      setState(4615);
      match(PostgreSQLParser::TEMPLATE);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(4616);
      match(PostgreSQLParser::TEXT_P);
      setState(4617);
      match(PostgreSQLParser::SEARCH);
      setState(4618);
      match(PostgreSQLParser::CONFIGURATION);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Object_type_nameContext ------------------------------------------------------------------

PostgreSQLParser::Object_type_nameContext::Object_type_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Drop_type_nameContext* PostgreSQLParser::Object_type_nameContext::drop_type_name() {
  return getRuleContext<PostgreSQLParser::Drop_type_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_nameContext::DATABASE() {
  return getToken(PostgreSQLParser::DATABASE, 0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_nameContext::ROLE() {
  return getToken(PostgreSQLParser::ROLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_nameContext::SUBSCRIPTION() {
  return getToken(PostgreSQLParser::SUBSCRIPTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_nameContext::TABLESPACE() {
  return getToken(PostgreSQLParser::TABLESPACE, 0);
}


size_t PostgreSQLParser::Object_type_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleObject_type_name;
}


std::any PostgreSQLParser::Object_type_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitObject_type_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Object_type_nameContext* PostgreSQLParser::object_type_name() {
  Object_type_nameContext *_localctx = _tracker.createInstance<Object_type_nameContext>(_ctx, getState());
  enterRule(_localctx, 512, PostgreSQLParser::RuleObject_type_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4626);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::FOREIGN:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::PUBLICATION: {
        enterOuterAlt(_localctx, 1);
        setState(4621);
        drop_type_name();
        break;
      }

      case PostgreSQLParser::DATABASE: {
        enterOuterAlt(_localctx, 2);
        setState(4622);
        match(PostgreSQLParser::DATABASE);
        break;
      }

      case PostgreSQLParser::ROLE: {
        enterOuterAlt(_localctx, 3);
        setState(4623);
        match(PostgreSQLParser::ROLE);
        break;
      }

      case PostgreSQLParser::SUBSCRIPTION: {
        enterOuterAlt(_localctx, 4);
        setState(4624);
        match(PostgreSQLParser::SUBSCRIPTION);
        break;
      }

      case PostgreSQLParser::TABLESPACE: {
        enterOuterAlt(_localctx, 5);
        setState(4625);
        match(PostgreSQLParser::TABLESPACE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_type_nameContext ------------------------------------------------------------------

PostgreSQLParser::Drop_type_nameContext::Drop_type_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Drop_type_nameContext::ACCESS() {
  return getToken(PostgreSQLParser::ACCESS, 0);
}

tree::TerminalNode* PostgreSQLParser::Drop_type_nameContext::METHOD() {
  return getToken(PostgreSQLParser::METHOD, 0);
}

tree::TerminalNode* PostgreSQLParser::Drop_type_nameContext::EVENT() {
  return getToken(PostgreSQLParser::EVENT, 0);
}

tree::TerminalNode* PostgreSQLParser::Drop_type_nameContext::TRIGGER() {
  return getToken(PostgreSQLParser::TRIGGER, 0);
}

tree::TerminalNode* PostgreSQLParser::Drop_type_nameContext::EXTENSION() {
  return getToken(PostgreSQLParser::EXTENSION, 0);
}

tree::TerminalNode* PostgreSQLParser::Drop_type_nameContext::FOREIGN() {
  return getToken(PostgreSQLParser::FOREIGN, 0);
}

tree::TerminalNode* PostgreSQLParser::Drop_type_nameContext::DATA_P() {
  return getToken(PostgreSQLParser::DATA_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Drop_type_nameContext::WRAPPER() {
  return getToken(PostgreSQLParser::WRAPPER, 0);
}

tree::TerminalNode* PostgreSQLParser::Drop_type_nameContext::LANGUAGE() {
  return getToken(PostgreSQLParser::LANGUAGE, 0);
}

PostgreSQLParser::Procedural_Context* PostgreSQLParser::Drop_type_nameContext::procedural_() {
  return getRuleContext<PostgreSQLParser::Procedural_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::Drop_type_nameContext::PUBLICATION() {
  return getToken(PostgreSQLParser::PUBLICATION, 0);
}

tree::TerminalNode* PostgreSQLParser::Drop_type_nameContext::SCHEMA() {
  return getToken(PostgreSQLParser::SCHEMA, 0);
}

tree::TerminalNode* PostgreSQLParser::Drop_type_nameContext::SERVER() {
  return getToken(PostgreSQLParser::SERVER, 0);
}


size_t PostgreSQLParser::Drop_type_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDrop_type_name;
}


std::any PostgreSQLParser::Drop_type_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDrop_type_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Drop_type_nameContext* PostgreSQLParser::drop_type_name() {
  Drop_type_nameContext *_localctx = _tracker.createInstance<Drop_type_nameContext>(_ctx, getState());
  enterRule(_localctx, 514, PostgreSQLParser::RuleDrop_type_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4643);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::ACCESS: {
        enterOuterAlt(_localctx, 1);
        setState(4628);
        match(PostgreSQLParser::ACCESS);
        setState(4629);
        match(PostgreSQLParser::METHOD);
        break;
      }

      case PostgreSQLParser::EVENT: {
        enterOuterAlt(_localctx, 2);
        setState(4630);
        match(PostgreSQLParser::EVENT);
        setState(4631);
        match(PostgreSQLParser::TRIGGER);
        break;
      }

      case PostgreSQLParser::EXTENSION: {
        enterOuterAlt(_localctx, 3);
        setState(4632);
        match(PostgreSQLParser::EXTENSION);
        break;
      }

      case PostgreSQLParser::FOREIGN: {
        enterOuterAlt(_localctx, 4);
        setState(4633);
        match(PostgreSQLParser::FOREIGN);
        setState(4634);
        match(PostgreSQLParser::DATA_P);
        setState(4635);
        match(PostgreSQLParser::WRAPPER);
        break;
      }

      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::PROCEDURAL: {
        enterOuterAlt(_localctx, 5);
        setState(4637);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::PROCEDURAL) {
          setState(4636);
          procedural_();
        }
        setState(4639);
        match(PostgreSQLParser::LANGUAGE);
        break;
      }

      case PostgreSQLParser::PUBLICATION: {
        enterOuterAlt(_localctx, 6);
        setState(4640);
        match(PostgreSQLParser::PUBLICATION);
        break;
      }

      case PostgreSQLParser::SCHEMA: {
        enterOuterAlt(_localctx, 7);
        setState(4641);
        match(PostgreSQLParser::SCHEMA);
        break;
      }

      case PostgreSQLParser::SERVER: {
        enterOuterAlt(_localctx, 8);
        setState(4642);
        match(PostgreSQLParser::SERVER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Object_type_name_on_any_nameContext ------------------------------------------------------------------

PostgreSQLParser::Object_type_name_on_any_nameContext::Object_type_name_on_any_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Object_type_name_on_any_nameContext::POLICY() {
  return getToken(PostgreSQLParser::POLICY, 0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_name_on_any_nameContext::RULE() {
  return getToken(PostgreSQLParser::RULE, 0);
}

tree::TerminalNode* PostgreSQLParser::Object_type_name_on_any_nameContext::TRIGGER() {
  return getToken(PostgreSQLParser::TRIGGER, 0);
}


size_t PostgreSQLParser::Object_type_name_on_any_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleObject_type_name_on_any_name;
}


std::any PostgreSQLParser::Object_type_name_on_any_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitObject_type_name_on_any_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Object_type_name_on_any_nameContext* PostgreSQLParser::object_type_name_on_any_name() {
  Object_type_name_on_any_nameContext *_localctx = _tracker.createInstance<Object_type_name_on_any_nameContext>(_ctx, getState());
  enterRule(_localctx, 516, PostgreSQLParser::RuleObject_type_name_on_any_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4645);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::RULE

    || _la == PostgreSQLParser::TRIGGER || _la == PostgreSQLParser::POLICY)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Any_name_list_Context ------------------------------------------------------------------

PostgreSQLParser::Any_name_list_Context::Any_name_list_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Any_nameContext *> PostgreSQLParser::Any_name_list_Context::any_name() {
  return getRuleContexts<PostgreSQLParser::Any_nameContext>();
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::Any_name_list_Context::any_name(size_t i) {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Any_name_list_Context::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Any_name_list_Context::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Any_name_list_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleAny_name_list_;
}


std::any PostgreSQLParser::Any_name_list_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAny_name_list_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Any_name_list_Context* PostgreSQLParser::any_name_list_() {
  Any_name_list_Context *_localctx = _tracker.createInstance<Any_name_list_Context>(_ctx, getState());
  enterRule(_localctx, 518, PostgreSQLParser::RuleAny_name_list_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4647);
    any_name();
    setState(4652);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(4648);
      match(PostgreSQLParser::COMMA);
      setState(4649);
      any_name();
      setState(4654);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Any_nameContext ------------------------------------------------------------------

PostgreSQLParser::Any_nameContext::Any_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Any_nameContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

PostgreSQLParser::AttrsContext* PostgreSQLParser::Any_nameContext::attrs() {
  return getRuleContext<PostgreSQLParser::AttrsContext>(0);
}


size_t PostgreSQLParser::Any_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAny_name;
}


std::any PostgreSQLParser::Any_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAny_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::any_name() {
  Any_nameContext *_localctx = _tracker.createInstance<Any_nameContext>(_ctx, getState());
  enterRule(_localctx, 520, PostgreSQLParser::RuleAny_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4655);
    colid();
    setState(4657);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 374, _ctx)) {
    case 1: {
      setState(4656);
      attrs();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttrsContext ------------------------------------------------------------------

PostgreSQLParser::AttrsContext::AttrsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> PostgreSQLParser::AttrsContext::DOT() {
  return getTokens(PostgreSQLParser::DOT);
}

tree::TerminalNode* PostgreSQLParser::AttrsContext::DOT(size_t i) {
  return getToken(PostgreSQLParser::DOT, i);
}

std::vector<PostgreSQLParser::Attr_nameContext *> PostgreSQLParser::AttrsContext::attr_name() {
  return getRuleContexts<PostgreSQLParser::Attr_nameContext>();
}

PostgreSQLParser::Attr_nameContext* PostgreSQLParser::AttrsContext::attr_name(size_t i) {
  return getRuleContext<PostgreSQLParser::Attr_nameContext>(i);
}


size_t PostgreSQLParser::AttrsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAttrs;
}


std::any PostgreSQLParser::AttrsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAttrs(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AttrsContext* PostgreSQLParser::attrs() {
  AttrsContext *_localctx = _tracker.createInstance<AttrsContext>(_ctx, getState());
  enterRule(_localctx, 522, PostgreSQLParser::RuleAttrs);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4661); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(4659);
              match(PostgreSQLParser::DOT);
              setState(4660);
              attr_name();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(4663); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 375, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_name_listContext ------------------------------------------------------------------

PostgreSQLParser::Type_name_listContext::Type_name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::TypenameContext *> PostgreSQLParser::Type_name_listContext::typename_() {
  return getRuleContexts<PostgreSQLParser::TypenameContext>();
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::Type_name_listContext::typename_(size_t i) {
  return getRuleContext<PostgreSQLParser::TypenameContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Type_name_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Type_name_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Type_name_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleType_name_list;
}


std::any PostgreSQLParser::Type_name_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitType_name_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Type_name_listContext* PostgreSQLParser::type_name_list() {
  Type_name_listContext *_localctx = _tracker.createInstance<Type_name_listContext>(_ctx, getState());
  enterRule(_localctx, 524, PostgreSQLParser::RuleType_name_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4665);
    typename_();
    setState(4670);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(4666);
      match(PostgreSQLParser::COMMA);
      setState(4667);
      typename_();
      setState(4672);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TruncatestmtContext ------------------------------------------------------------------

PostgreSQLParser::TruncatestmtContext::TruncatestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::TruncatestmtContext::TRUNCATE() {
  return getToken(PostgreSQLParser::TRUNCATE, 0);
}

PostgreSQLParser::Relation_expr_listContext* PostgreSQLParser::TruncatestmtContext::relation_expr_list() {
  return getRuleContext<PostgreSQLParser::Relation_expr_listContext>(0);
}

PostgreSQLParser::Table_Context* PostgreSQLParser::TruncatestmtContext::table_() {
  return getRuleContext<PostgreSQLParser::Table_Context>(0);
}

PostgreSQLParser::Restart_seqs_Context* PostgreSQLParser::TruncatestmtContext::restart_seqs_() {
  return getRuleContext<PostgreSQLParser::Restart_seqs_Context>(0);
}

PostgreSQLParser::Drop_behavior_Context* PostgreSQLParser::TruncatestmtContext::drop_behavior_() {
  return getRuleContext<PostgreSQLParser::Drop_behavior_Context>(0);
}


size_t PostgreSQLParser::TruncatestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTruncatestmt;
}


std::any PostgreSQLParser::TruncatestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTruncatestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TruncatestmtContext* PostgreSQLParser::truncatestmt() {
  TruncatestmtContext *_localctx = _tracker.createInstance<TruncatestmtContext>(_ctx, getState());
  enterRule(_localctx, 526, PostgreSQLParser::RuleTruncatestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4673);
    match(PostgreSQLParser::TRUNCATE);
    setState(4675);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::TABLE) {
      setState(4674);
      table_();
    }
    setState(4677);
    relation_expr_list();
    setState(4679);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::CONTINUE_P || _la == PostgreSQLParser::RESTART) {
      setState(4678);
      restart_seqs_();
    }
    setState(4682);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
      setState(4681);
      drop_behavior_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Restart_seqs_Context ------------------------------------------------------------------

PostgreSQLParser::Restart_seqs_Context::Restart_seqs_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Restart_seqs_Context::CONTINUE_P() {
  return getToken(PostgreSQLParser::CONTINUE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Restart_seqs_Context::IDENTITY_P() {
  return getToken(PostgreSQLParser::IDENTITY_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Restart_seqs_Context::RESTART() {
  return getToken(PostgreSQLParser::RESTART, 0);
}


size_t PostgreSQLParser::Restart_seqs_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleRestart_seqs_;
}


std::any PostgreSQLParser::Restart_seqs_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRestart_seqs_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Restart_seqs_Context* PostgreSQLParser::restart_seqs_() {
  Restart_seqs_Context *_localctx = _tracker.createInstance<Restart_seqs_Context>(_ctx, getState());
  enterRule(_localctx, 528, PostgreSQLParser::RuleRestart_seqs_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4688);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::CONTINUE_P: {
        enterOuterAlt(_localctx, 1);
        setState(4684);
        match(PostgreSQLParser::CONTINUE_P);
        setState(4685);
        match(PostgreSQLParser::IDENTITY_P);
        break;
      }

      case PostgreSQLParser::RESTART: {
        enterOuterAlt(_localctx, 2);
        setState(4686);
        match(PostgreSQLParser::RESTART);
        setState(4687);
        match(PostgreSQLParser::IDENTITY_P);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommentstmtContext ------------------------------------------------------------------

PostgreSQLParser::CommentstmtContext::CommentstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::COMMENT() {
  return getToken(PostgreSQLParser::COMMENT, 0);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::CommentstmtContext::ON() {
  return getTokens(PostgreSQLParser::ON);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::ON(size_t i) {
  return getToken(PostgreSQLParser::ON, i);
}

PostgreSQLParser::Object_type_any_nameContext* PostgreSQLParser::CommentstmtContext::object_type_any_name() {
  return getRuleContext<PostgreSQLParser::Object_type_any_nameContext>(0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::CommentstmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::IS() {
  return getToken(PostgreSQLParser::IS, 0);
}

PostgreSQLParser::Comment_textContext* PostgreSQLParser::CommentstmtContext::comment_text() {
  return getRuleContext<PostgreSQLParser::Comment_textContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::COLUMN() {
  return getToken(PostgreSQLParser::COLUMN, 0);
}

PostgreSQLParser::Object_type_nameContext* PostgreSQLParser::CommentstmtContext::object_type_name() {
  return getRuleContext<PostgreSQLParser::Object_type_nameContext>(0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::CommentstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}

std::vector<PostgreSQLParser::TypenameContext *> PostgreSQLParser::CommentstmtContext::typename_() {
  return getRuleContexts<PostgreSQLParser::TypenameContext>();
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::CommentstmtContext::typename_(size_t i) {
  return getRuleContext<PostgreSQLParser::TypenameContext>(i);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::DOMAIN_P() {
  return getToken(PostgreSQLParser::DOMAIN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::AGGREGATE() {
  return getToken(PostgreSQLParser::AGGREGATE, 0);
}

PostgreSQLParser::Aggregate_with_argtypesContext* PostgreSQLParser::CommentstmtContext::aggregate_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Aggregate_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::FUNCTION() {
  return getToken(PostgreSQLParser::FUNCTION, 0);
}

PostgreSQLParser::Function_with_argtypesContext* PostgreSQLParser::CommentstmtContext::function_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Function_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

PostgreSQLParser::Operator_with_argtypesContext* PostgreSQLParser::CommentstmtContext::operator_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Operator_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::CONSTRAINT() {
  return getToken(PostgreSQLParser::CONSTRAINT, 0);
}

PostgreSQLParser::Object_type_name_on_any_nameContext* PostgreSQLParser::CommentstmtContext::object_type_name_on_any_name() {
  return getRuleContext<PostgreSQLParser::Object_type_name_on_any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::PROCEDURE() {
  return getToken(PostgreSQLParser::PROCEDURE, 0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::ROUTINE() {
  return getToken(PostgreSQLParser::ROUTINE, 0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::TRANSFORM() {
  return getToken(PostgreSQLParser::TRANSFORM, 0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::LANGUAGE() {
  return getToken(PostgreSQLParser::LANGUAGE, 0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::CLASS() {
  return getToken(PostgreSQLParser::CLASS, 0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::FAMILY() {
  return getToken(PostgreSQLParser::FAMILY, 0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::LARGE_P() {
  return getToken(PostgreSQLParser::LARGE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::OBJECT_P() {
  return getToken(PostgreSQLParser::OBJECT_P, 0);
}

PostgreSQLParser::NumericonlyContext* PostgreSQLParser::CommentstmtContext::numericonly() {
  return getRuleContext<PostgreSQLParser::NumericonlyContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::CAST() {
  return getToken(PostgreSQLParser::CAST, 0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

tree::TerminalNode* PostgreSQLParser::CommentstmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::CommentstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCommentstmt;
}


std::any PostgreSQLParser::CommentstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCommentstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CommentstmtContext* PostgreSQLParser::commentstmt() {
  CommentstmtContext *_localctx = _tracker.createInstance<CommentstmtContext>(_ctx, getState());
  enterRule(_localctx, 530, PostgreSQLParser::RuleCommentstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4837);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 381, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4690);
      match(PostgreSQLParser::COMMENT);
      setState(4691);
      match(PostgreSQLParser::ON);
      setState(4692);
      object_type_any_name();
      setState(4693);
      any_name();
      setState(4694);
      match(PostgreSQLParser::IS);
      setState(4695);
      comment_text();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4697);
      match(PostgreSQLParser::COMMENT);
      setState(4698);
      match(PostgreSQLParser::ON);
      setState(4699);
      match(PostgreSQLParser::COLUMN);
      setState(4700);
      any_name();
      setState(4701);
      match(PostgreSQLParser::IS);
      setState(4702);
      comment_text();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4704);
      match(PostgreSQLParser::COMMENT);
      setState(4705);
      match(PostgreSQLParser::ON);
      setState(4706);
      object_type_name();
      setState(4707);
      name();
      setState(4708);
      match(PostgreSQLParser::IS);
      setState(4709);
      comment_text();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4711);
      match(PostgreSQLParser::COMMENT);
      setState(4712);
      match(PostgreSQLParser::ON);
      setState(4713);
      match(PostgreSQLParser::TYPE_P);
      setState(4714);
      typename_();
      setState(4715);
      match(PostgreSQLParser::IS);
      setState(4716);
      comment_text();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4718);
      match(PostgreSQLParser::COMMENT);
      setState(4719);
      match(PostgreSQLParser::ON);
      setState(4720);
      match(PostgreSQLParser::DOMAIN_P);
      setState(4721);
      typename_();
      setState(4722);
      match(PostgreSQLParser::IS);
      setState(4723);
      comment_text();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4725);
      match(PostgreSQLParser::COMMENT);
      setState(4726);
      match(PostgreSQLParser::ON);
      setState(4727);
      match(PostgreSQLParser::AGGREGATE);
      setState(4728);
      aggregate_with_argtypes();
      setState(4729);
      match(PostgreSQLParser::IS);
      setState(4730);
      comment_text();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4732);
      match(PostgreSQLParser::COMMENT);
      setState(4733);
      match(PostgreSQLParser::ON);
      setState(4734);
      match(PostgreSQLParser::FUNCTION);
      setState(4735);
      function_with_argtypes();
      setState(4736);
      match(PostgreSQLParser::IS);
      setState(4737);
      comment_text();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4739);
      match(PostgreSQLParser::COMMENT);
      setState(4740);
      match(PostgreSQLParser::ON);
      setState(4741);
      match(PostgreSQLParser::OPERATOR);
      setState(4742);
      operator_with_argtypes();
      setState(4743);
      match(PostgreSQLParser::IS);
      setState(4744);
      comment_text();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(4746);
      match(PostgreSQLParser::COMMENT);
      setState(4747);
      match(PostgreSQLParser::ON);
      setState(4748);
      match(PostgreSQLParser::CONSTRAINT);
      setState(4749);
      name();
      setState(4750);
      match(PostgreSQLParser::ON);
      setState(4751);
      any_name();
      setState(4752);
      match(PostgreSQLParser::IS);
      setState(4753);
      comment_text();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(4755);
      match(PostgreSQLParser::COMMENT);
      setState(4756);
      match(PostgreSQLParser::ON);
      setState(4757);
      match(PostgreSQLParser::CONSTRAINT);
      setState(4758);
      name();
      setState(4759);
      match(PostgreSQLParser::ON);
      setState(4760);
      match(PostgreSQLParser::DOMAIN_P);
      setState(4761);
      any_name();
      setState(4762);
      match(PostgreSQLParser::IS);
      setState(4763);
      comment_text();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(4765);
      match(PostgreSQLParser::COMMENT);
      setState(4766);
      match(PostgreSQLParser::ON);
      setState(4767);
      object_type_name_on_any_name();
      setState(4768);
      name();
      setState(4769);
      match(PostgreSQLParser::ON);
      setState(4770);
      any_name();
      setState(4771);
      match(PostgreSQLParser::IS);
      setState(4772);
      comment_text();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(4774);
      match(PostgreSQLParser::COMMENT);
      setState(4775);
      match(PostgreSQLParser::ON);
      setState(4776);
      match(PostgreSQLParser::PROCEDURE);
      setState(4777);
      function_with_argtypes();
      setState(4778);
      match(PostgreSQLParser::IS);
      setState(4779);
      comment_text();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(4781);
      match(PostgreSQLParser::COMMENT);
      setState(4782);
      match(PostgreSQLParser::ON);
      setState(4783);
      match(PostgreSQLParser::ROUTINE);
      setState(4784);
      function_with_argtypes();
      setState(4785);
      match(PostgreSQLParser::IS);
      setState(4786);
      comment_text();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(4788);
      match(PostgreSQLParser::COMMENT);
      setState(4789);
      match(PostgreSQLParser::ON);
      setState(4790);
      match(PostgreSQLParser::TRANSFORM);
      setState(4791);
      match(PostgreSQLParser::FOR);
      setState(4792);
      typename_();
      setState(4793);
      match(PostgreSQLParser::LANGUAGE);
      setState(4794);
      name();
      setState(4795);
      match(PostgreSQLParser::IS);
      setState(4796);
      comment_text();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(4798);
      match(PostgreSQLParser::COMMENT);
      setState(4799);
      match(PostgreSQLParser::ON);
      setState(4800);
      match(PostgreSQLParser::OPERATOR);
      setState(4801);
      match(PostgreSQLParser::CLASS);
      setState(4802);
      any_name();
      setState(4803);
      match(PostgreSQLParser::USING);
      setState(4804);
      name();
      setState(4805);
      match(PostgreSQLParser::IS);
      setState(4806);
      comment_text();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(4808);
      match(PostgreSQLParser::COMMENT);
      setState(4809);
      match(PostgreSQLParser::ON);
      setState(4810);
      match(PostgreSQLParser::OPERATOR);
      setState(4811);
      match(PostgreSQLParser::FAMILY);
      setState(4812);
      any_name();
      setState(4813);
      match(PostgreSQLParser::USING);
      setState(4814);
      name();
      setState(4815);
      match(PostgreSQLParser::IS);
      setState(4816);
      comment_text();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(4818);
      match(PostgreSQLParser::COMMENT);
      setState(4819);
      match(PostgreSQLParser::ON);
      setState(4820);
      match(PostgreSQLParser::LARGE_P);
      setState(4821);
      match(PostgreSQLParser::OBJECT_P);
      setState(4822);
      numericonly();
      setState(4823);
      match(PostgreSQLParser::IS);
      setState(4824);
      comment_text();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(4826);
      match(PostgreSQLParser::COMMENT);
      setState(4827);
      match(PostgreSQLParser::ON);
      setState(4828);
      match(PostgreSQLParser::CAST);
      setState(4829);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(4830);
      typename_();
      setState(4831);
      match(PostgreSQLParser::AS);
      setState(4832);
      typename_();
      setState(4833);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(4834);
      match(PostgreSQLParser::IS);
      setState(4835);
      comment_text();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comment_textContext ------------------------------------------------------------------

PostgreSQLParser::Comment_textContext::Comment_textContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Comment_textContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Comment_textContext::NULL_P() {
  return getToken(PostgreSQLParser::NULL_P, 0);
}


size_t PostgreSQLParser::Comment_textContext::getRuleIndex() const {
  return PostgreSQLParser::RuleComment_text;
}


std::any PostgreSQLParser::Comment_textContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitComment_text(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Comment_textContext* PostgreSQLParser::comment_text() {
  Comment_textContext *_localctx = _tracker.createInstance<Comment_textContext>(_ctx, getState());
  enterRule(_localctx, 532, PostgreSQLParser::RuleComment_text);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4841);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::EscapeStringConstant: {
        enterOuterAlt(_localctx, 1);
        setState(4839);
        sconst();
        break;
      }

      case PostgreSQLParser::NULL_P: {
        enterOuterAlt(_localctx, 2);
        setState(4840);
        match(PostgreSQLParser::NULL_P);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SeclabelstmtContext ------------------------------------------------------------------

PostgreSQLParser::SeclabelstmtContext::SeclabelstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::SeclabelstmtContext::SECURITY() {
  return getToken(PostgreSQLParser::SECURITY, 0);
}

tree::TerminalNode* PostgreSQLParser::SeclabelstmtContext::LABEL() {
  return getToken(PostgreSQLParser::LABEL, 0);
}

tree::TerminalNode* PostgreSQLParser::SeclabelstmtContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

PostgreSQLParser::Object_type_any_nameContext* PostgreSQLParser::SeclabelstmtContext::object_type_any_name() {
  return getRuleContext<PostgreSQLParser::Object_type_any_nameContext>(0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::SeclabelstmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::SeclabelstmtContext::IS() {
  return getToken(PostgreSQLParser::IS, 0);
}

PostgreSQLParser::Security_labelContext* PostgreSQLParser::SeclabelstmtContext::security_label() {
  return getRuleContext<PostgreSQLParser::Security_labelContext>(0);
}

PostgreSQLParser::Provider_Context* PostgreSQLParser::SeclabelstmtContext::provider_() {
  return getRuleContext<PostgreSQLParser::Provider_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::SeclabelstmtContext::COLUMN() {
  return getToken(PostgreSQLParser::COLUMN, 0);
}

PostgreSQLParser::Object_type_nameContext* PostgreSQLParser::SeclabelstmtContext::object_type_name() {
  return getRuleContext<PostgreSQLParser::Object_type_nameContext>(0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::SeclabelstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::SeclabelstmtContext::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::SeclabelstmtContext::typename_() {
  return getRuleContext<PostgreSQLParser::TypenameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::SeclabelstmtContext::DOMAIN_P() {
  return getToken(PostgreSQLParser::DOMAIN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::SeclabelstmtContext::AGGREGATE() {
  return getToken(PostgreSQLParser::AGGREGATE, 0);
}

PostgreSQLParser::Aggregate_with_argtypesContext* PostgreSQLParser::SeclabelstmtContext::aggregate_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Aggregate_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::SeclabelstmtContext::FUNCTION() {
  return getToken(PostgreSQLParser::FUNCTION, 0);
}

PostgreSQLParser::Function_with_argtypesContext* PostgreSQLParser::SeclabelstmtContext::function_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Function_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::SeclabelstmtContext::LARGE_P() {
  return getToken(PostgreSQLParser::LARGE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::SeclabelstmtContext::OBJECT_P() {
  return getToken(PostgreSQLParser::OBJECT_P, 0);
}

PostgreSQLParser::NumericonlyContext* PostgreSQLParser::SeclabelstmtContext::numericonly() {
  return getRuleContext<PostgreSQLParser::NumericonlyContext>(0);
}

tree::TerminalNode* PostgreSQLParser::SeclabelstmtContext::PROCEDURE() {
  return getToken(PostgreSQLParser::PROCEDURE, 0);
}

tree::TerminalNode* PostgreSQLParser::SeclabelstmtContext::ROUTINE() {
  return getToken(PostgreSQLParser::ROUTINE, 0);
}


size_t PostgreSQLParser::SeclabelstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSeclabelstmt;
}


std::any PostgreSQLParser::SeclabelstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSeclabelstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::SeclabelstmtContext* PostgreSQLParser::seclabelstmt() {
  SeclabelstmtContext *_localctx = _tracker.createInstance<SeclabelstmtContext>(_ctx, getState());
  enterRule(_localctx, 534, PostgreSQLParser::RuleSeclabelstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4954);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 393, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4843);
      match(PostgreSQLParser::SECURITY);
      setState(4844);
      match(PostgreSQLParser::LABEL);
      setState(4846);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FOR) {
        setState(4845);
        provider_();
      }
      setState(4848);
      match(PostgreSQLParser::ON);
      setState(4849);
      object_type_any_name();
      setState(4850);
      any_name();
      setState(4851);
      match(PostgreSQLParser::IS);
      setState(4852);
      security_label();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4854);
      match(PostgreSQLParser::SECURITY);
      setState(4855);
      match(PostgreSQLParser::LABEL);
      setState(4857);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FOR) {
        setState(4856);
        provider_();
      }
      setState(4859);
      match(PostgreSQLParser::ON);
      setState(4860);
      match(PostgreSQLParser::COLUMN);
      setState(4861);
      any_name();
      setState(4862);
      match(PostgreSQLParser::IS);
      setState(4863);
      security_label();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4865);
      match(PostgreSQLParser::SECURITY);
      setState(4866);
      match(PostgreSQLParser::LABEL);
      setState(4868);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FOR) {
        setState(4867);
        provider_();
      }
      setState(4870);
      match(PostgreSQLParser::ON);
      setState(4871);
      object_type_name();
      setState(4872);
      name();
      setState(4873);
      match(PostgreSQLParser::IS);
      setState(4874);
      security_label();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4876);
      match(PostgreSQLParser::SECURITY);
      setState(4877);
      match(PostgreSQLParser::LABEL);
      setState(4879);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FOR) {
        setState(4878);
        provider_();
      }
      setState(4881);
      match(PostgreSQLParser::ON);
      setState(4882);
      match(PostgreSQLParser::TYPE_P);
      setState(4883);
      typename_();
      setState(4884);
      match(PostgreSQLParser::IS);
      setState(4885);
      security_label();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4887);
      match(PostgreSQLParser::SECURITY);
      setState(4888);
      match(PostgreSQLParser::LABEL);
      setState(4890);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FOR) {
        setState(4889);
        provider_();
      }
      setState(4892);
      match(PostgreSQLParser::ON);
      setState(4893);
      match(PostgreSQLParser::DOMAIN_P);
      setState(4894);
      typename_();
      setState(4895);
      match(PostgreSQLParser::IS);
      setState(4896);
      security_label();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4898);
      match(PostgreSQLParser::SECURITY);
      setState(4899);
      match(PostgreSQLParser::LABEL);
      setState(4901);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FOR) {
        setState(4900);
        provider_();
      }
      setState(4903);
      match(PostgreSQLParser::ON);
      setState(4904);
      match(PostgreSQLParser::AGGREGATE);
      setState(4905);
      aggregate_with_argtypes();
      setState(4906);
      match(PostgreSQLParser::IS);
      setState(4907);
      security_label();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4909);
      match(PostgreSQLParser::SECURITY);
      setState(4910);
      match(PostgreSQLParser::LABEL);
      setState(4912);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FOR) {
        setState(4911);
        provider_();
      }
      setState(4914);
      match(PostgreSQLParser::ON);
      setState(4915);
      match(PostgreSQLParser::FUNCTION);
      setState(4916);
      function_with_argtypes();
      setState(4917);
      match(PostgreSQLParser::IS);
      setState(4918);
      security_label();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4920);
      match(PostgreSQLParser::SECURITY);
      setState(4921);
      match(PostgreSQLParser::LABEL);
      setState(4923);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FOR) {
        setState(4922);
        provider_();
      }
      setState(4925);
      match(PostgreSQLParser::ON);
      setState(4926);
      match(PostgreSQLParser::LARGE_P);
      setState(4927);
      match(PostgreSQLParser::OBJECT_P);
      setState(4928);
      numericonly();
      setState(4929);
      match(PostgreSQLParser::IS);
      setState(4930);
      security_label();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(4932);
      match(PostgreSQLParser::SECURITY);
      setState(4933);
      match(PostgreSQLParser::LABEL);
      setState(4935);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FOR) {
        setState(4934);
        provider_();
      }
      setState(4937);
      match(PostgreSQLParser::ON);
      setState(4938);
      match(PostgreSQLParser::PROCEDURE);
      setState(4939);
      function_with_argtypes();
      setState(4940);
      match(PostgreSQLParser::IS);
      setState(4941);
      security_label();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(4943);
      match(PostgreSQLParser::SECURITY);
      setState(4944);
      match(PostgreSQLParser::LABEL);
      setState(4946);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FOR) {
        setState(4945);
        provider_();
      }
      setState(4948);
      match(PostgreSQLParser::ON);
      setState(4949);
      match(PostgreSQLParser::ROUTINE);
      setState(4950);
      function_with_argtypes();
      setState(4951);
      match(PostgreSQLParser::IS);
      setState(4952);
      security_label();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Provider_Context ------------------------------------------------------------------

PostgreSQLParser::Provider_Context::Provider_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Provider_Context::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

PostgreSQLParser::Nonreservedword_or_sconstContext* PostgreSQLParser::Provider_Context::nonreservedword_or_sconst() {
  return getRuleContext<PostgreSQLParser::Nonreservedword_or_sconstContext>(0);
}


size_t PostgreSQLParser::Provider_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleProvider_;
}


std::any PostgreSQLParser::Provider_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitProvider_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Provider_Context* PostgreSQLParser::provider_() {
  Provider_Context *_localctx = _tracker.createInstance<Provider_Context>(_ctx, getState());
  enterRule(_localctx, 536, PostgreSQLParser::RuleProvider_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4956);
    match(PostgreSQLParser::FOR);
    setState(4957);
    nonreservedword_or_sconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Security_labelContext ------------------------------------------------------------------

PostgreSQLParser::Security_labelContext::Security_labelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Security_labelContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Security_labelContext::NULL_P() {
  return getToken(PostgreSQLParser::NULL_P, 0);
}


size_t PostgreSQLParser::Security_labelContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSecurity_label;
}


std::any PostgreSQLParser::Security_labelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSecurity_label(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Security_labelContext* PostgreSQLParser::security_label() {
  Security_labelContext *_localctx = _tracker.createInstance<Security_labelContext>(_ctx, getState());
  enterRule(_localctx, 538, PostgreSQLParser::RuleSecurity_label);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4961);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::EscapeStringConstant: {
        enterOuterAlt(_localctx, 1);
        setState(4959);
        sconst();
        break;
      }

      case PostgreSQLParser::NULL_P: {
        enterOuterAlt(_localctx, 2);
        setState(4960);
        match(PostgreSQLParser::NULL_P);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FetchstmtContext ------------------------------------------------------------------

PostgreSQLParser::FetchstmtContext::FetchstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::FetchstmtContext::FETCH() {
  return getToken(PostgreSQLParser::FETCH, 0);
}

PostgreSQLParser::Fetch_argsContext* PostgreSQLParser::FetchstmtContext::fetch_args() {
  return getRuleContext<PostgreSQLParser::Fetch_argsContext>(0);
}

tree::TerminalNode* PostgreSQLParser::FetchstmtContext::MOVE() {
  return getToken(PostgreSQLParser::MOVE, 0);
}


size_t PostgreSQLParser::FetchstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFetchstmt;
}


std::any PostgreSQLParser::FetchstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFetchstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::FetchstmtContext* PostgreSQLParser::fetchstmt() {
  FetchstmtContext *_localctx = _tracker.createInstance<FetchstmtContext>(_ctx, getState());
  enterRule(_localctx, 540, PostgreSQLParser::RuleFetchstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4967);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::FETCH: {
        enterOuterAlt(_localctx, 1);
        setState(4963);
        match(PostgreSQLParser::FETCH);
        setState(4964);
        fetch_args();
        break;
      }

      case PostgreSQLParser::MOVE: {
        enterOuterAlt(_localctx, 2);
        setState(4965);
        match(PostgreSQLParser::MOVE);
        setState(4966);
        fetch_args();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fetch_argsContext ------------------------------------------------------------------

PostgreSQLParser::Fetch_argsContext::Fetch_argsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Cursor_nameContext* PostgreSQLParser::Fetch_argsContext::cursor_name() {
  return getRuleContext<PostgreSQLParser::Cursor_nameContext>(0);
}

PostgreSQLParser::From_inContext* PostgreSQLParser::Fetch_argsContext::from_in() {
  return getRuleContext<PostgreSQLParser::From_inContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Fetch_argsContext::NEXT() {
  return getToken(PostgreSQLParser::NEXT, 0);
}

PostgreSQLParser::From_in_Context* PostgreSQLParser::Fetch_argsContext::from_in_() {
  return getRuleContext<PostgreSQLParser::From_in_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::Fetch_argsContext::PRIOR() {
  return getToken(PostgreSQLParser::PRIOR, 0);
}

tree::TerminalNode* PostgreSQLParser::Fetch_argsContext::FIRST_P() {
  return getToken(PostgreSQLParser::FIRST_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Fetch_argsContext::LAST_P() {
  return getToken(PostgreSQLParser::LAST_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Fetch_argsContext::ABSOLUTE_P() {
  return getToken(PostgreSQLParser::ABSOLUTE_P, 0);
}

PostgreSQLParser::SignediconstContext* PostgreSQLParser::Fetch_argsContext::signediconst() {
  return getRuleContext<PostgreSQLParser::SignediconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Fetch_argsContext::RELATIVE_P() {
  return getToken(PostgreSQLParser::RELATIVE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Fetch_argsContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}

tree::TerminalNode* PostgreSQLParser::Fetch_argsContext::FORWARD() {
  return getToken(PostgreSQLParser::FORWARD, 0);
}

tree::TerminalNode* PostgreSQLParser::Fetch_argsContext::BACKWARD() {
  return getToken(PostgreSQLParser::BACKWARD, 0);
}


size_t PostgreSQLParser::Fetch_argsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFetch_args;
}


std::any PostgreSQLParser::Fetch_argsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFetch_args(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Fetch_argsContext* PostgreSQLParser::fetch_args() {
  Fetch_argsContext *_localctx = _tracker.createInstance<Fetch_argsContext>(_ctx, getState());
  enterRule(_localctx, 542, PostgreSQLParser::RuleFetch_args);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5054);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 410, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4969);
      cursor_name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4970);
      from_in();
      setState(4971);
      cursor_name();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4973);
      match(PostgreSQLParser::NEXT);
      setState(4975);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FROM

      || _la == PostgreSQLParser::IN_P) {
        setState(4974);
        from_in_();
      }
      setState(4977);
      cursor_name();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4978);
      match(PostgreSQLParser::PRIOR);
      setState(4980);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FROM

      || _la == PostgreSQLParser::IN_P) {
        setState(4979);
        from_in_();
      }
      setState(4982);
      cursor_name();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4983);
      match(PostgreSQLParser::FIRST_P);
      setState(4985);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FROM

      || _la == PostgreSQLParser::IN_P) {
        setState(4984);
        from_in_();
      }
      setState(4987);
      cursor_name();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4988);
      match(PostgreSQLParser::LAST_P);
      setState(4990);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FROM

      || _la == PostgreSQLParser::IN_P) {
        setState(4989);
        from_in_();
      }
      setState(4992);
      cursor_name();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4993);
      match(PostgreSQLParser::ABSOLUTE_P);
      setState(4994);
      signediconst();
      setState(4996);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FROM

      || _la == PostgreSQLParser::IN_P) {
        setState(4995);
        from_in_();
      }
      setState(4998);
      cursor_name();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(5000);
      match(PostgreSQLParser::RELATIVE_P);
      setState(5001);
      signediconst();
      setState(5003);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FROM

      || _la == PostgreSQLParser::IN_P) {
        setState(5002);
        from_in_();
      }
      setState(5005);
      cursor_name();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(5007);
      signediconst();
      setState(5009);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FROM

      || _la == PostgreSQLParser::IN_P) {
        setState(5008);
        from_in_();
      }
      setState(5011);
      cursor_name();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(5013);
      match(PostgreSQLParser::ALL);
      setState(5015);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FROM

      || _la == PostgreSQLParser::IN_P) {
        setState(5014);
        from_in_();
      }
      setState(5017);
      cursor_name();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(5018);
      match(PostgreSQLParser::FORWARD);
      setState(5020);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FROM

      || _la == PostgreSQLParser::IN_P) {
        setState(5019);
        from_in_();
      }
      setState(5022);
      cursor_name();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(5023);
      match(PostgreSQLParser::FORWARD);
      setState(5024);
      signediconst();
      setState(5026);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FROM

      || _la == PostgreSQLParser::IN_P) {
        setState(5025);
        from_in_();
      }
      setState(5028);
      cursor_name();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(5030);
      match(PostgreSQLParser::FORWARD);
      setState(5031);
      match(PostgreSQLParser::ALL);
      setState(5033);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FROM

      || _la == PostgreSQLParser::IN_P) {
        setState(5032);
        from_in_();
      }
      setState(5035);
      cursor_name();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(5036);
      match(PostgreSQLParser::BACKWARD);
      setState(5038);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FROM

      || _la == PostgreSQLParser::IN_P) {
        setState(5037);
        from_in_();
      }
      setState(5040);
      cursor_name();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(5041);
      match(PostgreSQLParser::BACKWARD);
      setState(5042);
      signediconst();
      setState(5044);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FROM

      || _la == PostgreSQLParser::IN_P) {
        setState(5043);
        from_in_();
      }
      setState(5046);
      cursor_name();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(5048);
      match(PostgreSQLParser::BACKWARD);
      setState(5049);
      match(PostgreSQLParser::ALL);
      setState(5051);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FROM

      || _la == PostgreSQLParser::IN_P) {
        setState(5050);
        from_in_();
      }
      setState(5053);
      cursor_name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- From_inContext ------------------------------------------------------------------

PostgreSQLParser::From_inContext::From_inContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::From_inContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

tree::TerminalNode* PostgreSQLParser::From_inContext::IN_P() {
  return getToken(PostgreSQLParser::IN_P, 0);
}


size_t PostgreSQLParser::From_inContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFrom_in;
}


std::any PostgreSQLParser::From_inContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFrom_in(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::From_inContext* PostgreSQLParser::from_in() {
  From_inContext *_localctx = _tracker.createInstance<From_inContext>(_ctx, getState());
  enterRule(_localctx, 544, PostgreSQLParser::RuleFrom_in);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5056);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::FROM

    || _la == PostgreSQLParser::IN_P)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- From_in_Context ------------------------------------------------------------------

PostgreSQLParser::From_in_Context::From_in_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::From_inContext* PostgreSQLParser::From_in_Context::from_in() {
  return getRuleContext<PostgreSQLParser::From_inContext>(0);
}


size_t PostgreSQLParser::From_in_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleFrom_in_;
}


std::any PostgreSQLParser::From_in_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFrom_in_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::From_in_Context* PostgreSQLParser::from_in_() {
  From_in_Context *_localctx = _tracker.createInstance<From_in_Context>(_ctx, getState());
  enterRule(_localctx, 546, PostgreSQLParser::RuleFrom_in_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5058);
    from_in();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantstmtContext ------------------------------------------------------------------

PostgreSQLParser::GrantstmtContext::GrantstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::GrantstmtContext::GRANT() {
  return getToken(PostgreSQLParser::GRANT, 0);
}

PostgreSQLParser::PrivilegesContext* PostgreSQLParser::GrantstmtContext::privileges() {
  return getRuleContext<PostgreSQLParser::PrivilegesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::GrantstmtContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

PostgreSQLParser::Privilege_targetContext* PostgreSQLParser::GrantstmtContext::privilege_target() {
  return getRuleContext<PostgreSQLParser::Privilege_targetContext>(0);
}

tree::TerminalNode* PostgreSQLParser::GrantstmtContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}

PostgreSQLParser::Grantee_listContext* PostgreSQLParser::GrantstmtContext::grantee_list() {
  return getRuleContext<PostgreSQLParser::Grantee_listContext>(0);
}

PostgreSQLParser::Grant_grant_option_Context* PostgreSQLParser::GrantstmtContext::grant_grant_option_() {
  return getRuleContext<PostgreSQLParser::Grant_grant_option_Context>(0);
}


size_t PostgreSQLParser::GrantstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleGrantstmt;
}


std::any PostgreSQLParser::GrantstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitGrantstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::GrantstmtContext* PostgreSQLParser::grantstmt() {
  GrantstmtContext *_localctx = _tracker.createInstance<GrantstmtContext>(_ctx, getState());
  enterRule(_localctx, 548, PostgreSQLParser::RuleGrantstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5060);
    match(PostgreSQLParser::GRANT);
    setState(5061);
    privileges();
    setState(5062);
    match(PostgreSQLParser::ON);
    setState(5063);
    privilege_target();
    setState(5064);
    match(PostgreSQLParser::TO);
    setState(5065);
    grantee_list();
    setState(5067);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(5066);
      grant_grant_option_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RevokestmtContext ------------------------------------------------------------------

PostgreSQLParser::RevokestmtContext::RevokestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::RevokestmtContext::REVOKE() {
  return getToken(PostgreSQLParser::REVOKE, 0);
}

PostgreSQLParser::PrivilegesContext* PostgreSQLParser::RevokestmtContext::privileges() {
  return getRuleContext<PostgreSQLParser::PrivilegesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::RevokestmtContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

PostgreSQLParser::Privilege_targetContext* PostgreSQLParser::RevokestmtContext::privilege_target() {
  return getRuleContext<PostgreSQLParser::Privilege_targetContext>(0);
}

tree::TerminalNode* PostgreSQLParser::RevokestmtContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

PostgreSQLParser::Grantee_listContext* PostgreSQLParser::RevokestmtContext::grantee_list() {
  return getRuleContext<PostgreSQLParser::Grantee_listContext>(0);
}

PostgreSQLParser::Drop_behavior_Context* PostgreSQLParser::RevokestmtContext::drop_behavior_() {
  return getRuleContext<PostgreSQLParser::Drop_behavior_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::RevokestmtContext::GRANT() {
  return getToken(PostgreSQLParser::GRANT, 0);
}

tree::TerminalNode* PostgreSQLParser::RevokestmtContext::OPTION() {
  return getToken(PostgreSQLParser::OPTION, 0);
}

tree::TerminalNode* PostgreSQLParser::RevokestmtContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}


size_t PostgreSQLParser::RevokestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRevokestmt;
}


std::any PostgreSQLParser::RevokestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRevokestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RevokestmtContext* PostgreSQLParser::revokestmt() {
  RevokestmtContext *_localctx = _tracker.createInstance<RevokestmtContext>(_ctx, getState());
  enterRule(_localctx, 550, PostgreSQLParser::RuleRevokestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5090);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 414, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5069);
      match(PostgreSQLParser::REVOKE);
      setState(5070);
      privileges();
      setState(5071);
      match(PostgreSQLParser::ON);
      setState(5072);
      privilege_target();
      setState(5073);
      match(PostgreSQLParser::FROM);
      setState(5074);
      grantee_list();
      setState(5076);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(5075);
        drop_behavior_();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5078);
      match(PostgreSQLParser::REVOKE);
      setState(5079);
      match(PostgreSQLParser::GRANT);
      setState(5080);
      match(PostgreSQLParser::OPTION);
      setState(5081);
      match(PostgreSQLParser::FOR);
      setState(5082);
      privileges();
      setState(5083);
      match(PostgreSQLParser::ON);
      setState(5084);
      privilege_target();
      setState(5085);
      match(PostgreSQLParser::FROM);
      setState(5086);
      grantee_list();
      setState(5088);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(5087);
        drop_behavior_();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrivilegesContext ------------------------------------------------------------------

PostgreSQLParser::PrivilegesContext::PrivilegesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Privilege_listContext* PostgreSQLParser::PrivilegesContext::privilege_list() {
  return getRuleContext<PostgreSQLParser::Privilege_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::PrivilegesContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}

tree::TerminalNode* PostgreSQLParser::PrivilegesContext::PRIVILEGES() {
  return getToken(PostgreSQLParser::PRIVILEGES, 0);
}

tree::TerminalNode* PostgreSQLParser::PrivilegesContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::ColumnlistContext* PostgreSQLParser::PrivilegesContext::columnlist() {
  return getRuleContext<PostgreSQLParser::ColumnlistContext>(0);
}

tree::TerminalNode* PostgreSQLParser::PrivilegesContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::PrivilegesContext::getRuleIndex() const {
  return PostgreSQLParser::RulePrivileges;
}


std::any PostgreSQLParser::PrivilegesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitPrivileges(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::PrivilegesContext* PostgreSQLParser::privileges() {
  PrivilegesContext *_localctx = _tracker.createInstance<PrivilegesContext>(_ctx, getState());
  enterRule(_localctx, 552, PostgreSQLParser::RulePrivileges);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5107);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 415, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5092);
      privilege_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5093);
      match(PostgreSQLParser::ALL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5094);
      match(PostgreSQLParser::ALL);
      setState(5095);
      match(PostgreSQLParser::PRIVILEGES);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5096);
      match(PostgreSQLParser::ALL);
      setState(5097);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(5098);
      columnlist();
      setState(5099);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5101);
      match(PostgreSQLParser::ALL);
      setState(5102);
      match(PostgreSQLParser::PRIVILEGES);
      setState(5103);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(5104);
      columnlist();
      setState(5105);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Privilege_listContext ------------------------------------------------------------------

PostgreSQLParser::Privilege_listContext::Privilege_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::PrivilegeContext *> PostgreSQLParser::Privilege_listContext::privilege() {
  return getRuleContexts<PostgreSQLParser::PrivilegeContext>();
}

PostgreSQLParser::PrivilegeContext* PostgreSQLParser::Privilege_listContext::privilege(size_t i) {
  return getRuleContext<PostgreSQLParser::PrivilegeContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Privilege_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Privilege_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Privilege_listContext::getRuleIndex() const {
  return PostgreSQLParser::RulePrivilege_list;
}


std::any PostgreSQLParser::Privilege_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitPrivilege_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Privilege_listContext* PostgreSQLParser::privilege_list() {
  Privilege_listContext *_localctx = _tracker.createInstance<Privilege_listContext>(_ctx, getState());
  enterRule(_localctx, 554, PostgreSQLParser::RulePrivilege_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5109);
    privilege();
    setState(5114);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(5110);
      match(PostgreSQLParser::COMMA);
      setState(5111);
      privilege();
      setState(5116);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrivilegeContext ------------------------------------------------------------------

PostgreSQLParser::PrivilegeContext::PrivilegeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::PrivilegeContext::SELECT() {
  return getToken(PostgreSQLParser::SELECT, 0);
}

PostgreSQLParser::Column_list_Context* PostgreSQLParser::PrivilegeContext::column_list_() {
  return getRuleContext<PostgreSQLParser::Column_list_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::PrivilegeContext::REFERENCES() {
  return getToken(PostgreSQLParser::REFERENCES, 0);
}

tree::TerminalNode* PostgreSQLParser::PrivilegeContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

PostgreSQLParser::ColidContext* PostgreSQLParser::PrivilegeContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}


size_t PostgreSQLParser::PrivilegeContext::getRuleIndex() const {
  return PostgreSQLParser::RulePrivilege;
}


std::any PostgreSQLParser::PrivilegeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitPrivilege(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::PrivilegeContext* PostgreSQLParser::privilege() {
  PrivilegeContext *_localctx = _tracker.createInstance<PrivilegeContext>(_ctx, getState());
  enterRule(_localctx, 556, PostgreSQLParser::RulePrivilege);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5133);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::SELECT: {
        enterOuterAlt(_localctx, 1);
        setState(5117);
        match(PostgreSQLParser::SELECT);
        setState(5119);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::OPEN_PAREN) {
          setState(5118);
          column_list_();
        }
        break;
      }

      case PostgreSQLParser::REFERENCES: {
        enterOuterAlt(_localctx, 2);
        setState(5121);
        match(PostgreSQLParser::REFERENCES);
        setState(5123);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::OPEN_PAREN) {
          setState(5122);
          column_list_();
        }
        break;
      }

      case PostgreSQLParser::CREATE: {
        enterOuterAlt(_localctx, 3);
        setState(5125);
        match(PostgreSQLParser::CREATE);
        setState(5127);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::OPEN_PAREN) {
          setState(5126);
          column_list_();
        }
        break;
      }

      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 4);
        setState(5129);
        colid();
        setState(5131);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::OPEN_PAREN) {
          setState(5130);
          column_list_();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Privilege_targetContext ------------------------------------------------------------------

PostgreSQLParser::Privilege_targetContext::Privilege_targetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Qualified_name_listContext* PostgreSQLParser::Privilege_targetContext::qualified_name_list() {
  return getRuleContext<PostgreSQLParser::Qualified_name_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::SEQUENCE() {
  return getToken(PostgreSQLParser::SEQUENCE, 0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::FOREIGN() {
  return getToken(PostgreSQLParser::FOREIGN, 0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::DATA_P() {
  return getToken(PostgreSQLParser::DATA_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::WRAPPER() {
  return getToken(PostgreSQLParser::WRAPPER, 0);
}

PostgreSQLParser::Name_listContext* PostgreSQLParser::Privilege_targetContext::name_list() {
  return getRuleContext<PostgreSQLParser::Name_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::SERVER() {
  return getToken(PostgreSQLParser::SERVER, 0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::FUNCTION() {
  return getToken(PostgreSQLParser::FUNCTION, 0);
}

PostgreSQLParser::Function_with_argtypes_listContext* PostgreSQLParser::Privilege_targetContext::function_with_argtypes_list() {
  return getRuleContext<PostgreSQLParser::Function_with_argtypes_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::PROCEDURE() {
  return getToken(PostgreSQLParser::PROCEDURE, 0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::ROUTINE() {
  return getToken(PostgreSQLParser::ROUTINE, 0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::DATABASE() {
  return getToken(PostgreSQLParser::DATABASE, 0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::DOMAIN_P() {
  return getToken(PostgreSQLParser::DOMAIN_P, 0);
}

PostgreSQLParser::Any_name_list_Context* PostgreSQLParser::Privilege_targetContext::any_name_list_() {
  return getRuleContext<PostgreSQLParser::Any_name_list_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::LANGUAGE() {
  return getToken(PostgreSQLParser::LANGUAGE, 0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::LARGE_P() {
  return getToken(PostgreSQLParser::LARGE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::OBJECT_P() {
  return getToken(PostgreSQLParser::OBJECT_P, 0);
}

PostgreSQLParser::Numericonly_listContext* PostgreSQLParser::Privilege_targetContext::numericonly_list() {
  return getRuleContext<PostgreSQLParser::Numericonly_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::SCHEMA() {
  return getToken(PostgreSQLParser::SCHEMA, 0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::TABLESPACE() {
  return getToken(PostgreSQLParser::TABLESPACE, 0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::TABLES() {
  return getToken(PostgreSQLParser::TABLES, 0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::IN_P() {
  return getToken(PostgreSQLParser::IN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::SEQUENCES() {
  return getToken(PostgreSQLParser::SEQUENCES, 0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::FUNCTIONS() {
  return getToken(PostgreSQLParser::FUNCTIONS, 0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::PROCEDURES() {
  return getToken(PostgreSQLParser::PROCEDURES, 0);
}

tree::TerminalNode* PostgreSQLParser::Privilege_targetContext::ROUTINES() {
  return getToken(PostgreSQLParser::ROUTINES, 0);
}


size_t PostgreSQLParser::Privilege_targetContext::getRuleIndex() const {
  return PostgreSQLParser::RulePrivilege_target;
}


std::any PostgreSQLParser::Privilege_targetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitPrivilege_target(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Privilege_targetContext* PostgreSQLParser::privilege_target() {
  Privilege_targetContext *_localctx = _tracker.createInstance<Privilege_targetContext>(_ctx, getState());
  enterRule(_localctx, 558, PostgreSQLParser::RulePrivilege_target);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5193);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 422, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5135);
      qualified_name_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5136);
      match(PostgreSQLParser::TABLE);
      setState(5137);
      qualified_name_list();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5138);
      match(PostgreSQLParser::SEQUENCE);
      setState(5139);
      qualified_name_list();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5140);
      match(PostgreSQLParser::FOREIGN);
      setState(5141);
      match(PostgreSQLParser::DATA_P);
      setState(5142);
      match(PostgreSQLParser::WRAPPER);
      setState(5143);
      name_list();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5144);
      match(PostgreSQLParser::FOREIGN);
      setState(5145);
      match(PostgreSQLParser::SERVER);
      setState(5146);
      name_list();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(5147);
      match(PostgreSQLParser::FUNCTION);
      setState(5148);
      function_with_argtypes_list();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(5149);
      match(PostgreSQLParser::PROCEDURE);
      setState(5150);
      function_with_argtypes_list();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(5151);
      match(PostgreSQLParser::ROUTINE);
      setState(5152);
      function_with_argtypes_list();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(5153);
      match(PostgreSQLParser::DATABASE);
      setState(5154);
      name_list();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(5155);
      match(PostgreSQLParser::DOMAIN_P);
      setState(5156);
      any_name_list_();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(5157);
      match(PostgreSQLParser::LANGUAGE);
      setState(5158);
      name_list();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(5159);
      match(PostgreSQLParser::LARGE_P);
      setState(5160);
      match(PostgreSQLParser::OBJECT_P);
      setState(5161);
      numericonly_list();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(5162);
      match(PostgreSQLParser::SCHEMA);
      setState(5163);
      name_list();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(5164);
      match(PostgreSQLParser::TABLESPACE);
      setState(5165);
      name_list();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(5166);
      match(PostgreSQLParser::TYPE_P);
      setState(5167);
      any_name_list_();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(5168);
      match(PostgreSQLParser::ALL);
      setState(5169);
      match(PostgreSQLParser::TABLES);
      setState(5170);
      match(PostgreSQLParser::IN_P);
      setState(5171);
      match(PostgreSQLParser::SCHEMA);
      setState(5172);
      name_list();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(5173);
      match(PostgreSQLParser::ALL);
      setState(5174);
      match(PostgreSQLParser::SEQUENCES);
      setState(5175);
      match(PostgreSQLParser::IN_P);
      setState(5176);
      match(PostgreSQLParser::SCHEMA);
      setState(5177);
      name_list();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(5178);
      match(PostgreSQLParser::ALL);
      setState(5179);
      match(PostgreSQLParser::FUNCTIONS);
      setState(5180);
      match(PostgreSQLParser::IN_P);
      setState(5181);
      match(PostgreSQLParser::SCHEMA);
      setState(5182);
      name_list();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(5183);
      match(PostgreSQLParser::ALL);
      setState(5184);
      match(PostgreSQLParser::PROCEDURES);
      setState(5185);
      match(PostgreSQLParser::IN_P);
      setState(5186);
      match(PostgreSQLParser::SCHEMA);
      setState(5187);
      name_list();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(5188);
      match(PostgreSQLParser::ALL);
      setState(5189);
      match(PostgreSQLParser::ROUTINES);
      setState(5190);
      match(PostgreSQLParser::IN_P);
      setState(5191);
      match(PostgreSQLParser::SCHEMA);
      setState(5192);
      name_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Grantee_listContext ------------------------------------------------------------------

PostgreSQLParser::Grantee_listContext::Grantee_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::GranteeContext *> PostgreSQLParser::Grantee_listContext::grantee() {
  return getRuleContexts<PostgreSQLParser::GranteeContext>();
}

PostgreSQLParser::GranteeContext* PostgreSQLParser::Grantee_listContext::grantee(size_t i) {
  return getRuleContext<PostgreSQLParser::GranteeContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Grantee_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Grantee_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Grantee_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleGrantee_list;
}


std::any PostgreSQLParser::Grantee_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitGrantee_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Grantee_listContext* PostgreSQLParser::grantee_list() {
  Grantee_listContext *_localctx = _tracker.createInstance<Grantee_listContext>(_ctx, getState());
  enterRule(_localctx, 560, PostgreSQLParser::RuleGrantee_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5195);
    grantee();
    setState(5200);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(5196);
      match(PostgreSQLParser::COMMA);
      setState(5197);
      grantee();
      setState(5202);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GranteeContext ------------------------------------------------------------------

PostgreSQLParser::GranteeContext::GranteeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::RolespecContext* PostgreSQLParser::GranteeContext::rolespec() {
  return getRuleContext<PostgreSQLParser::RolespecContext>(0);
}

tree::TerminalNode* PostgreSQLParser::GranteeContext::GROUP_P() {
  return getToken(PostgreSQLParser::GROUP_P, 0);
}


size_t PostgreSQLParser::GranteeContext::getRuleIndex() const {
  return PostgreSQLParser::RuleGrantee;
}


std::any PostgreSQLParser::GranteeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitGrantee(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::GranteeContext* PostgreSQLParser::grantee() {
  GranteeContext *_localctx = _tracker.createInstance<GranteeContext>(_ctx, getState());
  enterRule(_localctx, 562, PostgreSQLParser::RuleGrantee);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5206);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::CURRENT_USER:
      case PostgreSQLParser::SESSION_USER:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 1);
        setState(5203);
        rolespec();
        break;
      }

      case PostgreSQLParser::GROUP_P: {
        enterOuterAlt(_localctx, 2);
        setState(5204);
        match(PostgreSQLParser::GROUP_P);
        setState(5205);
        rolespec();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Grant_grant_option_Context ------------------------------------------------------------------

PostgreSQLParser::Grant_grant_option_Context::Grant_grant_option_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Grant_grant_option_Context::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

tree::TerminalNode* PostgreSQLParser::Grant_grant_option_Context::GRANT() {
  return getToken(PostgreSQLParser::GRANT, 0);
}

tree::TerminalNode* PostgreSQLParser::Grant_grant_option_Context::OPTION() {
  return getToken(PostgreSQLParser::OPTION, 0);
}


size_t PostgreSQLParser::Grant_grant_option_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleGrant_grant_option_;
}


std::any PostgreSQLParser::Grant_grant_option_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitGrant_grant_option_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Grant_grant_option_Context* PostgreSQLParser::grant_grant_option_() {
  Grant_grant_option_Context *_localctx = _tracker.createInstance<Grant_grant_option_Context>(_ctx, getState());
  enterRule(_localctx, 564, PostgreSQLParser::RuleGrant_grant_option_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5208);
    match(PostgreSQLParser::WITH);
    setState(5209);
    match(PostgreSQLParser::GRANT);
    setState(5210);
    match(PostgreSQLParser::OPTION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantrolestmtContext ------------------------------------------------------------------

PostgreSQLParser::GrantrolestmtContext::GrantrolestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::GrantrolestmtContext::GRANT() {
  return getToken(PostgreSQLParser::GRANT, 0);
}

PostgreSQLParser::Privilege_listContext* PostgreSQLParser::GrantrolestmtContext::privilege_list() {
  return getRuleContext<PostgreSQLParser::Privilege_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::GrantrolestmtContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}

PostgreSQLParser::Role_listContext* PostgreSQLParser::GrantrolestmtContext::role_list() {
  return getRuleContext<PostgreSQLParser::Role_listContext>(0);
}

PostgreSQLParser::Grant_admin_option_Context* PostgreSQLParser::GrantrolestmtContext::grant_admin_option_() {
  return getRuleContext<PostgreSQLParser::Grant_admin_option_Context>(0);
}

PostgreSQLParser::Granted_by_Context* PostgreSQLParser::GrantrolestmtContext::granted_by_() {
  return getRuleContext<PostgreSQLParser::Granted_by_Context>(0);
}


size_t PostgreSQLParser::GrantrolestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleGrantrolestmt;
}


std::any PostgreSQLParser::GrantrolestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitGrantrolestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::GrantrolestmtContext* PostgreSQLParser::grantrolestmt() {
  GrantrolestmtContext *_localctx = _tracker.createInstance<GrantrolestmtContext>(_ctx, getState());
  enterRule(_localctx, 566, PostgreSQLParser::RuleGrantrolestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5212);
    match(PostgreSQLParser::GRANT);
    setState(5213);
    privilege_list();
    setState(5214);
    match(PostgreSQLParser::TO);
    setState(5215);
    role_list();
    setState(5217);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(5216);
      grant_admin_option_();
    }
    setState(5220);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::GRANTED) {
      setState(5219);
      granted_by_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RevokerolestmtContext ------------------------------------------------------------------

PostgreSQLParser::RevokerolestmtContext::RevokerolestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::RevokerolestmtContext::REVOKE() {
  return getToken(PostgreSQLParser::REVOKE, 0);
}

PostgreSQLParser::Privilege_listContext* PostgreSQLParser::RevokerolestmtContext::privilege_list() {
  return getRuleContext<PostgreSQLParser::Privilege_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::RevokerolestmtContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

PostgreSQLParser::Role_listContext* PostgreSQLParser::RevokerolestmtContext::role_list() {
  return getRuleContext<PostgreSQLParser::Role_listContext>(0);
}

PostgreSQLParser::Granted_by_Context* PostgreSQLParser::RevokerolestmtContext::granted_by_() {
  return getRuleContext<PostgreSQLParser::Granted_by_Context>(0);
}

PostgreSQLParser::Drop_behavior_Context* PostgreSQLParser::RevokerolestmtContext::drop_behavior_() {
  return getRuleContext<PostgreSQLParser::Drop_behavior_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::RevokerolestmtContext::ADMIN() {
  return getToken(PostgreSQLParser::ADMIN, 0);
}

tree::TerminalNode* PostgreSQLParser::RevokerolestmtContext::OPTION() {
  return getToken(PostgreSQLParser::OPTION, 0);
}

tree::TerminalNode* PostgreSQLParser::RevokerolestmtContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}


size_t PostgreSQLParser::RevokerolestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRevokerolestmt;
}


std::any PostgreSQLParser::RevokerolestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRevokerolestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RevokerolestmtContext* PostgreSQLParser::revokerolestmt() {
  RevokerolestmtContext *_localctx = _tracker.createInstance<RevokerolestmtContext>(_ctx, getState());
  enterRule(_localctx, 568, PostgreSQLParser::RuleRevokerolestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5245);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 431, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5222);
      match(PostgreSQLParser::REVOKE);
      setState(5223);
      privilege_list();
      setState(5224);
      match(PostgreSQLParser::FROM);
      setState(5225);
      role_list();
      setState(5227);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::GRANTED) {
        setState(5226);
        granted_by_();
      }
      setState(5230);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(5229);
        drop_behavior_();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5232);
      match(PostgreSQLParser::REVOKE);
      setState(5233);
      match(PostgreSQLParser::ADMIN);
      setState(5234);
      match(PostgreSQLParser::OPTION);
      setState(5235);
      match(PostgreSQLParser::FOR);
      setState(5236);
      privilege_list();
      setState(5237);
      match(PostgreSQLParser::FROM);
      setState(5238);
      role_list();
      setState(5240);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::GRANTED) {
        setState(5239);
        granted_by_();
      }
      setState(5243);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(5242);
        drop_behavior_();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Grant_admin_option_Context ------------------------------------------------------------------

PostgreSQLParser::Grant_admin_option_Context::Grant_admin_option_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Grant_admin_option_Context::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

tree::TerminalNode* PostgreSQLParser::Grant_admin_option_Context::ADMIN() {
  return getToken(PostgreSQLParser::ADMIN, 0);
}

tree::TerminalNode* PostgreSQLParser::Grant_admin_option_Context::OPTION() {
  return getToken(PostgreSQLParser::OPTION, 0);
}


size_t PostgreSQLParser::Grant_admin_option_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleGrant_admin_option_;
}


std::any PostgreSQLParser::Grant_admin_option_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitGrant_admin_option_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Grant_admin_option_Context* PostgreSQLParser::grant_admin_option_() {
  Grant_admin_option_Context *_localctx = _tracker.createInstance<Grant_admin_option_Context>(_ctx, getState());
  enterRule(_localctx, 570, PostgreSQLParser::RuleGrant_admin_option_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5247);
    match(PostgreSQLParser::WITH);
    setState(5248);
    match(PostgreSQLParser::ADMIN);
    setState(5249);
    match(PostgreSQLParser::OPTION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Granted_by_Context ------------------------------------------------------------------

PostgreSQLParser::Granted_by_Context::Granted_by_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Granted_by_Context::GRANTED() {
  return getToken(PostgreSQLParser::GRANTED, 0);
}

tree::TerminalNode* PostgreSQLParser::Granted_by_Context::BY() {
  return getToken(PostgreSQLParser::BY, 0);
}

PostgreSQLParser::RolespecContext* PostgreSQLParser::Granted_by_Context::rolespec() {
  return getRuleContext<PostgreSQLParser::RolespecContext>(0);
}


size_t PostgreSQLParser::Granted_by_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleGranted_by_;
}


std::any PostgreSQLParser::Granted_by_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitGranted_by_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Granted_by_Context* PostgreSQLParser::granted_by_() {
  Granted_by_Context *_localctx = _tracker.createInstance<Granted_by_Context>(_ctx, getState());
  enterRule(_localctx, 572, PostgreSQLParser::RuleGranted_by_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5251);
    match(PostgreSQLParser::GRANTED);
    setState(5252);
    match(PostgreSQLParser::BY);
    setState(5253);
    rolespec();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterdefaultprivilegesstmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterdefaultprivilegesstmtContext::AlterdefaultprivilegesstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterdefaultprivilegesstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterdefaultprivilegesstmtContext::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterdefaultprivilegesstmtContext::PRIVILEGES() {
  return getToken(PostgreSQLParser::PRIVILEGES, 0);
}

PostgreSQLParser::DefacloptionlistContext* PostgreSQLParser::AlterdefaultprivilegesstmtContext::defacloptionlist() {
  return getRuleContext<PostgreSQLParser::DefacloptionlistContext>(0);
}

PostgreSQLParser::DefaclactionContext* PostgreSQLParser::AlterdefaultprivilegesstmtContext::defaclaction() {
  return getRuleContext<PostgreSQLParser::DefaclactionContext>(0);
}


size_t PostgreSQLParser::AlterdefaultprivilegesstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterdefaultprivilegesstmt;
}


std::any PostgreSQLParser::AlterdefaultprivilegesstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterdefaultprivilegesstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterdefaultprivilegesstmtContext* PostgreSQLParser::alterdefaultprivilegesstmt() {
  AlterdefaultprivilegesstmtContext *_localctx = _tracker.createInstance<AlterdefaultprivilegesstmtContext>(_ctx, getState());
  enterRule(_localctx, 574, PostgreSQLParser::RuleAlterdefaultprivilegesstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5255);
    match(PostgreSQLParser::ALTER);
    setState(5256);
    match(PostgreSQLParser::DEFAULT);
    setState(5257);
    match(PostgreSQLParser::PRIVILEGES);
    setState(5258);
    defacloptionlist();
    setState(5259);
    defaclaction();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefacloptionlistContext ------------------------------------------------------------------

PostgreSQLParser::DefacloptionlistContext::DefacloptionlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::DefacloptionContext *> PostgreSQLParser::DefacloptionlistContext::defacloption() {
  return getRuleContexts<PostgreSQLParser::DefacloptionContext>();
}

PostgreSQLParser::DefacloptionContext* PostgreSQLParser::DefacloptionlistContext::defacloption(size_t i) {
  return getRuleContext<PostgreSQLParser::DefacloptionContext>(i);
}


size_t PostgreSQLParser::DefacloptionlistContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDefacloptionlist;
}


std::any PostgreSQLParser::DefacloptionlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDefacloptionlist(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DefacloptionlistContext* PostgreSQLParser::defacloptionlist() {
  DefacloptionlistContext *_localctx = _tracker.createInstance<DefacloptionlistContext>(_ctx, getState());
  enterRule(_localctx, 576, PostgreSQLParser::RuleDefacloptionlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5264);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::FOR

    || _la == PostgreSQLParser::IN_P) {
      setState(5261);
      defacloption();
      setState(5266);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefacloptionContext ------------------------------------------------------------------

PostgreSQLParser::DefacloptionContext::DefacloptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DefacloptionContext::IN_P() {
  return getToken(PostgreSQLParser::IN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::DefacloptionContext::SCHEMA() {
  return getToken(PostgreSQLParser::SCHEMA, 0);
}

PostgreSQLParser::Name_listContext* PostgreSQLParser::DefacloptionContext::name_list() {
  return getRuleContext<PostgreSQLParser::Name_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DefacloptionContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

tree::TerminalNode* PostgreSQLParser::DefacloptionContext::ROLE() {
  return getToken(PostgreSQLParser::ROLE, 0);
}

PostgreSQLParser::Role_listContext* PostgreSQLParser::DefacloptionContext::role_list() {
  return getRuleContext<PostgreSQLParser::Role_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DefacloptionContext::USER() {
  return getToken(PostgreSQLParser::USER, 0);
}


size_t PostgreSQLParser::DefacloptionContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDefacloption;
}


std::any PostgreSQLParser::DefacloptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDefacloption(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DefacloptionContext* PostgreSQLParser::defacloption() {
  DefacloptionContext *_localctx = _tracker.createInstance<DefacloptionContext>(_ctx, getState());
  enterRule(_localctx, 578, PostgreSQLParser::RuleDefacloption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5276);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 433, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5267);
      match(PostgreSQLParser::IN_P);
      setState(5268);
      match(PostgreSQLParser::SCHEMA);
      setState(5269);
      name_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5270);
      match(PostgreSQLParser::FOR);
      setState(5271);
      match(PostgreSQLParser::ROLE);
      setState(5272);
      role_list();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5273);
      match(PostgreSQLParser::FOR);
      setState(5274);
      match(PostgreSQLParser::USER);
      setState(5275);
      role_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaclactionContext ------------------------------------------------------------------

PostgreSQLParser::DefaclactionContext::DefaclactionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DefaclactionContext::GRANT() {
  return getToken(PostgreSQLParser::GRANT, 0);
}

PostgreSQLParser::PrivilegesContext* PostgreSQLParser::DefaclactionContext::privileges() {
  return getRuleContext<PostgreSQLParser::PrivilegesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DefaclactionContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

PostgreSQLParser::Defacl_privilege_targetContext* PostgreSQLParser::DefaclactionContext::defacl_privilege_target() {
  return getRuleContext<PostgreSQLParser::Defacl_privilege_targetContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DefaclactionContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}

PostgreSQLParser::Grantee_listContext* PostgreSQLParser::DefaclactionContext::grantee_list() {
  return getRuleContext<PostgreSQLParser::Grantee_listContext>(0);
}

PostgreSQLParser::Grant_grant_option_Context* PostgreSQLParser::DefaclactionContext::grant_grant_option_() {
  return getRuleContext<PostgreSQLParser::Grant_grant_option_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::DefaclactionContext::REVOKE() {
  return getToken(PostgreSQLParser::REVOKE, 0);
}

tree::TerminalNode* PostgreSQLParser::DefaclactionContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

PostgreSQLParser::Drop_behavior_Context* PostgreSQLParser::DefaclactionContext::drop_behavior_() {
  return getRuleContext<PostgreSQLParser::Drop_behavior_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::DefaclactionContext::OPTION() {
  return getToken(PostgreSQLParser::OPTION, 0);
}

tree::TerminalNode* PostgreSQLParser::DefaclactionContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}


size_t PostgreSQLParser::DefaclactionContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDefaclaction;
}


std::any PostgreSQLParser::DefaclactionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDefaclaction(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DefaclactionContext* PostgreSQLParser::defaclaction() {
  DefaclactionContext *_localctx = _tracker.createInstance<DefaclactionContext>(_ctx, getState());
  enterRule(_localctx, 580, PostgreSQLParser::RuleDefaclaction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5308);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 437, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5278);
      match(PostgreSQLParser::GRANT);
      setState(5279);
      privileges();
      setState(5280);
      match(PostgreSQLParser::ON);
      setState(5281);
      defacl_privilege_target();
      setState(5282);
      match(PostgreSQLParser::TO);
      setState(5283);
      grantee_list();
      setState(5285);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::WITH) {
        setState(5284);
        grant_grant_option_();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5287);
      match(PostgreSQLParser::REVOKE);
      setState(5288);
      privileges();
      setState(5289);
      match(PostgreSQLParser::ON);
      setState(5290);
      defacl_privilege_target();
      setState(5291);
      match(PostgreSQLParser::FROM);
      setState(5292);
      grantee_list();
      setState(5294);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(5293);
        drop_behavior_();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5296);
      match(PostgreSQLParser::REVOKE);
      setState(5297);
      match(PostgreSQLParser::GRANT);
      setState(5298);
      match(PostgreSQLParser::OPTION);
      setState(5299);
      match(PostgreSQLParser::FOR);
      setState(5300);
      privileges();
      setState(5301);
      match(PostgreSQLParser::ON);
      setState(5302);
      defacl_privilege_target();
      setState(5303);
      match(PostgreSQLParser::FROM);
      setState(5304);
      grantee_list();
      setState(5306);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(5305);
        drop_behavior_();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Defacl_privilege_targetContext ------------------------------------------------------------------

PostgreSQLParser::Defacl_privilege_targetContext::Defacl_privilege_targetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Defacl_privilege_targetContext::TABLES() {
  return getToken(PostgreSQLParser::TABLES, 0);
}

tree::TerminalNode* PostgreSQLParser::Defacl_privilege_targetContext::FUNCTIONS() {
  return getToken(PostgreSQLParser::FUNCTIONS, 0);
}

tree::TerminalNode* PostgreSQLParser::Defacl_privilege_targetContext::ROUTINES() {
  return getToken(PostgreSQLParser::ROUTINES, 0);
}

tree::TerminalNode* PostgreSQLParser::Defacl_privilege_targetContext::SEQUENCES() {
  return getToken(PostgreSQLParser::SEQUENCES, 0);
}

tree::TerminalNode* PostgreSQLParser::Defacl_privilege_targetContext::TYPES_P() {
  return getToken(PostgreSQLParser::TYPES_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Defacl_privilege_targetContext::SCHEMAS() {
  return getToken(PostgreSQLParser::SCHEMAS, 0);
}


size_t PostgreSQLParser::Defacl_privilege_targetContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDefacl_privilege_target;
}


std::any PostgreSQLParser::Defacl_privilege_targetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDefacl_privilege_target(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Defacl_privilege_targetContext* PostgreSQLParser::defacl_privilege_target() {
  Defacl_privilege_targetContext *_localctx = _tracker.createInstance<Defacl_privilege_targetContext>(_ctx, getState());
  enterRule(_localctx, 582, PostgreSQLParser::RuleDefacl_privilege_target);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5310);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::FUNCTIONS || ((((_la - 360) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 360)) & 4297064449) != 0) || _la == PostgreSQLParser::ROUTINES

    || _la == PostgreSQLParser::SCHEMAS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexstmtContext ------------------------------------------------------------------

PostgreSQLParser::IndexstmtContext::IndexstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::IndexstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::IndexstmtContext::INDEX() {
  return getToken(PostgreSQLParser::INDEX, 0);
}

tree::TerminalNode* PostgreSQLParser::IndexstmtContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

PostgreSQLParser::Relation_exprContext* PostgreSQLParser::IndexstmtContext::relation_expr() {
  return getRuleContext<PostgreSQLParser::Relation_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::IndexstmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Index_paramsContext* PostgreSQLParser::IndexstmtContext::index_params() {
  return getRuleContext<PostgreSQLParser::Index_paramsContext>(0);
}

tree::TerminalNode* PostgreSQLParser::IndexstmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::Unique_Context* PostgreSQLParser::IndexstmtContext::unique_() {
  return getRuleContext<PostgreSQLParser::Unique_Context>(0);
}

PostgreSQLParser::Concurrently_Context* PostgreSQLParser::IndexstmtContext::concurrently_() {
  return getRuleContext<PostgreSQLParser::Concurrently_Context>(0);
}

PostgreSQLParser::Index_name_Context* PostgreSQLParser::IndexstmtContext::index_name_() {
  return getRuleContext<PostgreSQLParser::Index_name_Context>(0);
}

PostgreSQLParser::Access_method_clauseContext* PostgreSQLParser::IndexstmtContext::access_method_clause() {
  return getRuleContext<PostgreSQLParser::Access_method_clauseContext>(0);
}

PostgreSQLParser::Include_Context* PostgreSQLParser::IndexstmtContext::include_() {
  return getRuleContext<PostgreSQLParser::Include_Context>(0);
}

PostgreSQLParser::Nulls_distinctContext* PostgreSQLParser::IndexstmtContext::nulls_distinct() {
  return getRuleContext<PostgreSQLParser::Nulls_distinctContext>(0);
}

PostgreSQLParser::Reloptions_Context* PostgreSQLParser::IndexstmtContext::reloptions_() {
  return getRuleContext<PostgreSQLParser::Reloptions_Context>(0);
}

PostgreSQLParser::OpttablespaceContext* PostgreSQLParser::IndexstmtContext::opttablespace() {
  return getRuleContext<PostgreSQLParser::OpttablespaceContext>(0);
}

PostgreSQLParser::Where_clauseContext* PostgreSQLParser::IndexstmtContext::where_clause() {
  return getRuleContext<PostgreSQLParser::Where_clauseContext>(0);
}

PostgreSQLParser::If_not_exists_Context* PostgreSQLParser::IndexstmtContext::if_not_exists_() {
  return getRuleContext<PostgreSQLParser::If_not_exists_Context>(0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::IndexstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}


size_t PostgreSQLParser::IndexstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleIndexstmt;
}


std::any PostgreSQLParser::IndexstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitIndexstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::IndexstmtContext* PostgreSQLParser::indexstmt() {
  IndexstmtContext *_localctx = _tracker.createInstance<IndexstmtContext>(_ctx, getState());
  enterRule(_localctx, 584, PostgreSQLParser::RuleIndexstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5384);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 457, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5312);
      match(PostgreSQLParser::CREATE);
      setState(5314);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::UNIQUE) {
        setState(5313);
        unique_();
      }
      setState(5316);
      match(PostgreSQLParser::INDEX);
      setState(5318);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CONCURRENTLY) {
        setState(5317);
        concurrently_();
      }
      setState(5324);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 30) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 30)) & 137438949375) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 553)) & 536870983) != 0)) {
        setState(5321);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 440, _ctx)) {
        case 1: {
          setState(5320);
          if_not_exists_();
          break;
        }

        default:
          break;
        }
        setState(5323);
        index_name_();
      }
      setState(5326);
      match(PostgreSQLParser::ON);
      setState(5327);
      relation_expr();
      setState(5329);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::USING) {
        setState(5328);
        access_method_clause();
      }
      setState(5331);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(5332);
      index_params();
      setState(5333);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(5335);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::INCLUDE) {
        setState(5334);
        include_();
      }
      setState(5338);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::NULLS_P) {
        setState(5337);
        nulls_distinct();
      }
      setState(5341);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::WITH) {
        setState(5340);
        reloptions_();
      }
      setState(5344);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::TABLESPACE) {
        setState(5343);
        opttablespace();
      }
      setState(5347);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::WHERE) {
        setState(5346);
        where_clause();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5349);
      match(PostgreSQLParser::CREATE);
      setState(5351);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::UNIQUE) {
        setState(5350);
        unique_();
      }
      setState(5353);
      match(PostgreSQLParser::INDEX);
      setState(5355);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CONCURRENTLY) {
        setState(5354);
        concurrently_();
      }
      setState(5358);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 450, _ctx)) {
      case 1: {
        setState(5357);
        if_not_exists_();
        break;
      }

      default:
        break;
      }
      setState(5360);
      name();
      setState(5361);
      match(PostgreSQLParser::ON);
      setState(5362);
      relation_expr();
      setState(5364);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::USING) {
        setState(5363);
        access_method_clause();
      }
      setState(5366);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(5367);
      index_params();
      setState(5368);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(5370);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::INCLUDE) {
        setState(5369);
        include_();
      }
      setState(5373);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::NULLS_P) {
        setState(5372);
        nulls_distinct();
      }
      setState(5376);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::WITH) {
        setState(5375);
        reloptions_();
      }
      setState(5379);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::TABLESPACE) {
        setState(5378);
        opttablespace();
      }
      setState(5382);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::WHERE) {
        setState(5381);
        where_clause();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unique_Context ------------------------------------------------------------------

PostgreSQLParser::Unique_Context::Unique_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Unique_Context::UNIQUE() {
  return getToken(PostgreSQLParser::UNIQUE, 0);
}


size_t PostgreSQLParser::Unique_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleUnique_;
}


std::any PostgreSQLParser::Unique_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitUnique_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Unique_Context* PostgreSQLParser::unique_() {
  Unique_Context *_localctx = _tracker.createInstance<Unique_Context>(_ctx, getState());
  enterRule(_localctx, 586, PostgreSQLParser::RuleUnique_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5386);
    match(PostgreSQLParser::UNIQUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nulls_distinctContext ------------------------------------------------------------------

PostgreSQLParser::Nulls_distinctContext::Nulls_distinctContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Nulls_distinctContext::NULLS_P() {
  return getToken(PostgreSQLParser::NULLS_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Nulls_distinctContext::DISTINCT() {
  return getToken(PostgreSQLParser::DISTINCT, 0);
}

tree::TerminalNode* PostgreSQLParser::Nulls_distinctContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}


size_t PostgreSQLParser::Nulls_distinctContext::getRuleIndex() const {
  return PostgreSQLParser::RuleNulls_distinct;
}


std::any PostgreSQLParser::Nulls_distinctContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitNulls_distinct(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Nulls_distinctContext* PostgreSQLParser::nulls_distinct() {
  Nulls_distinctContext *_localctx = _tracker.createInstance<Nulls_distinctContext>(_ctx, getState());
  enterRule(_localctx, 588, PostgreSQLParser::RuleNulls_distinct);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5388);
    match(PostgreSQLParser::NULLS_P);
    setState(5390);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::NOT) {
      setState(5389);
      match(PostgreSQLParser::NOT);
    }
    setState(5392);
    match(PostgreSQLParser::DISTINCT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Single_name_Context ------------------------------------------------------------------

PostgreSQLParser::Single_name_Context::Single_name_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Single_name_Context::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}


size_t PostgreSQLParser::Single_name_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleSingle_name_;
}


std::any PostgreSQLParser::Single_name_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSingle_name_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Single_name_Context* PostgreSQLParser::single_name_() {
  Single_name_Context *_localctx = _tracker.createInstance<Single_name_Context>(_ctx, getState());
  enterRule(_localctx, 590, PostgreSQLParser::RuleSingle_name_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5394);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Concurrently_Context ------------------------------------------------------------------

PostgreSQLParser::Concurrently_Context::Concurrently_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Concurrently_Context::CONCURRENTLY() {
  return getToken(PostgreSQLParser::CONCURRENTLY, 0);
}


size_t PostgreSQLParser::Concurrently_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleConcurrently_;
}


std::any PostgreSQLParser::Concurrently_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitConcurrently_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Concurrently_Context* PostgreSQLParser::concurrently_() {
  Concurrently_Context *_localctx = _tracker.createInstance<Concurrently_Context>(_ctx, getState());
  enterRule(_localctx, 592, PostgreSQLParser::RuleConcurrently_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5396);
    match(PostgreSQLParser::CONCURRENTLY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_name_Context ------------------------------------------------------------------

PostgreSQLParser::Index_name_Context::Index_name_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::NameContext* PostgreSQLParser::Index_name_Context::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}


size_t PostgreSQLParser::Index_name_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleIndex_name_;
}


std::any PostgreSQLParser::Index_name_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitIndex_name_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Index_name_Context* PostgreSQLParser::index_name_() {
  Index_name_Context *_localctx = _tracker.createInstance<Index_name_Context>(_ctx, getState());
  enterRule(_localctx, 594, PostgreSQLParser::RuleIndex_name_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5398);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Access_method_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Access_method_clauseContext::Access_method_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Access_method_clauseContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::Access_method_clauseContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}


size_t PostgreSQLParser::Access_method_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAccess_method_clause;
}


std::any PostgreSQLParser::Access_method_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAccess_method_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Access_method_clauseContext* PostgreSQLParser::access_method_clause() {
  Access_method_clauseContext *_localctx = _tracker.createInstance<Access_method_clauseContext>(_ctx, getState());
  enterRule(_localctx, 596, PostgreSQLParser::RuleAccess_method_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5400);
    match(PostgreSQLParser::USING);
    setState(5401);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_paramsContext ------------------------------------------------------------------

PostgreSQLParser::Index_paramsContext::Index_paramsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Index_elemContext *> PostgreSQLParser::Index_paramsContext::index_elem() {
  return getRuleContexts<PostgreSQLParser::Index_elemContext>();
}

PostgreSQLParser::Index_elemContext* PostgreSQLParser::Index_paramsContext::index_elem(size_t i) {
  return getRuleContext<PostgreSQLParser::Index_elemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Index_paramsContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Index_paramsContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Index_paramsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleIndex_params;
}


std::any PostgreSQLParser::Index_paramsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitIndex_params(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Index_paramsContext* PostgreSQLParser::index_params() {
  Index_paramsContext *_localctx = _tracker.createInstance<Index_paramsContext>(_ctx, getState());
  enterRule(_localctx, 598, PostgreSQLParser::RuleIndex_params);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5403);
    index_elem();
    setState(5408);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(5404);
      match(PostgreSQLParser::COMMA);
      setState(5405);
      index_elem();
      setState(5410);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_elem_optionsContext ------------------------------------------------------------------

PostgreSQLParser::Index_elem_optionsContext::Index_elem_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Collate_Context* PostgreSQLParser::Index_elem_optionsContext::collate_() {
  return getRuleContext<PostgreSQLParser::Collate_Context>(0);
}

PostgreSQLParser::Class_Context* PostgreSQLParser::Index_elem_optionsContext::class_() {
  return getRuleContext<PostgreSQLParser::Class_Context>(0);
}

PostgreSQLParser::Asc_desc_Context* PostgreSQLParser::Index_elem_optionsContext::asc_desc_() {
  return getRuleContext<PostgreSQLParser::Asc_desc_Context>(0);
}

PostgreSQLParser::Nulls_order_Context* PostgreSQLParser::Index_elem_optionsContext::nulls_order_() {
  return getRuleContext<PostgreSQLParser::Nulls_order_Context>(0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::Index_elem_optionsContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

PostgreSQLParser::ReloptionsContext* PostgreSQLParser::Index_elem_optionsContext::reloptions() {
  return getRuleContext<PostgreSQLParser::ReloptionsContext>(0);
}


size_t PostgreSQLParser::Index_elem_optionsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleIndex_elem_options;
}


std::any PostgreSQLParser::Index_elem_optionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitIndex_elem_options(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Index_elem_optionsContext* PostgreSQLParser::index_elem_options() {
  Index_elem_optionsContext *_localctx = _tracker.createInstance<Index_elem_optionsContext>(_ctx, getState());
  enterRule(_localctx, 600, PostgreSQLParser::RuleIndex_elem_options);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5434);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 467, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5412);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLLATE) {
        setState(5411);
        collate_();
      }
      setState(5415);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 461, _ctx)) {
      case 1: {
        setState(5414);
        class_();
        break;
      }

      default:
        break;
      }
      setState(5418);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::ASC

      || _la == PostgreSQLParser::DESC) {
        setState(5417);
        asc_desc_();
      }
      setState(5421);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::NULLS_P) {
        setState(5420);
        nulls_order_();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5424);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLLATE) {
        setState(5423);
        collate_();
      }
      setState(5426);
      any_name();
      setState(5427);
      reloptions();
      setState(5429);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::ASC

      || _la == PostgreSQLParser::DESC) {
        setState(5428);
        asc_desc_();
      }
      setState(5432);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::NULLS_P) {
        setState(5431);
        nulls_order_();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_elemContext ------------------------------------------------------------------

PostgreSQLParser::Index_elemContext::Index_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Index_elemContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

PostgreSQLParser::Index_elem_optionsContext* PostgreSQLParser::Index_elemContext::index_elem_options() {
  return getRuleContext<PostgreSQLParser::Index_elem_optionsContext>(0);
}

PostgreSQLParser::Func_expr_windowlessContext* PostgreSQLParser::Index_elemContext::func_expr_windowless() {
  return getRuleContext<PostgreSQLParser::Func_expr_windowlessContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Index_elemContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Index_elemContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Index_elemContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Index_elemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleIndex_elem;
}


std::any PostgreSQLParser::Index_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitIndex_elem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Index_elemContext* PostgreSQLParser::index_elem() {
  Index_elemContext *_localctx = _tracker.createInstance<Index_elemContext>(_ctx, getState());
  enterRule(_localctx, 602, PostgreSQLParser::RuleIndex_elem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5447);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 468, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5436);
      colid();
      setState(5437);
      index_elem_options();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5439);
      func_expr_windowless();
      setState(5440);
      index_elem_options();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5442);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(5443);
      a_expr();
      setState(5444);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(5445);
      index_elem_options();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Include_Context ------------------------------------------------------------------

PostgreSQLParser::Include_Context::Include_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Include_Context::INCLUDE() {
  return getToken(PostgreSQLParser::INCLUDE, 0);
}

tree::TerminalNode* PostgreSQLParser::Include_Context::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Index_including_paramsContext* PostgreSQLParser::Include_Context::index_including_params() {
  return getRuleContext<PostgreSQLParser::Index_including_paramsContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Include_Context::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Include_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleInclude_;
}


std::any PostgreSQLParser::Include_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitInclude_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Include_Context* PostgreSQLParser::include_() {
  Include_Context *_localctx = _tracker.createInstance<Include_Context>(_ctx, getState());
  enterRule(_localctx, 604, PostgreSQLParser::RuleInclude_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5449);
    match(PostgreSQLParser::INCLUDE);
    setState(5450);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(5451);
    index_including_params();
    setState(5452);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_including_paramsContext ------------------------------------------------------------------

PostgreSQLParser::Index_including_paramsContext::Index_including_paramsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Index_elemContext *> PostgreSQLParser::Index_including_paramsContext::index_elem() {
  return getRuleContexts<PostgreSQLParser::Index_elemContext>();
}

PostgreSQLParser::Index_elemContext* PostgreSQLParser::Index_including_paramsContext::index_elem(size_t i) {
  return getRuleContext<PostgreSQLParser::Index_elemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Index_including_paramsContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Index_including_paramsContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Index_including_paramsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleIndex_including_params;
}


std::any PostgreSQLParser::Index_including_paramsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitIndex_including_params(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Index_including_paramsContext* PostgreSQLParser::index_including_params() {
  Index_including_paramsContext *_localctx = _tracker.createInstance<Index_including_paramsContext>(_ctx, getState());
  enterRule(_localctx, 606, PostgreSQLParser::RuleIndex_including_params);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5454);
    index_elem();
    setState(5459);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(5455);
      match(PostgreSQLParser::COMMA);
      setState(5456);
      index_elem();
      setState(5461);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Collate_Context ------------------------------------------------------------------

PostgreSQLParser::Collate_Context::Collate_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Collate_Context::COLLATE() {
  return getToken(PostgreSQLParser::COLLATE, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::Collate_Context::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}


size_t PostgreSQLParser::Collate_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleCollate_;
}


std::any PostgreSQLParser::Collate_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCollate_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Collate_Context* PostgreSQLParser::collate_() {
  Collate_Context *_localctx = _tracker.createInstance<Collate_Context>(_ctx, getState());
  enterRule(_localctx, 608, PostgreSQLParser::RuleCollate_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5462);
    match(PostgreSQLParser::COLLATE);
    setState(5463);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_Context ------------------------------------------------------------------

PostgreSQLParser::Class_Context::Class_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::Class_Context::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}


size_t PostgreSQLParser::Class_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleClass_;
}


std::any PostgreSQLParser::Class_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitClass_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Class_Context* PostgreSQLParser::class_() {
  Class_Context *_localctx = _tracker.createInstance<Class_Context>(_ctx, getState());
  enterRule(_localctx, 610, PostgreSQLParser::RuleClass_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5465);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Asc_desc_Context ------------------------------------------------------------------

PostgreSQLParser::Asc_desc_Context::Asc_desc_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Asc_desc_Context::ASC() {
  return getToken(PostgreSQLParser::ASC, 0);
}

tree::TerminalNode* PostgreSQLParser::Asc_desc_Context::DESC() {
  return getToken(PostgreSQLParser::DESC, 0);
}


size_t PostgreSQLParser::Asc_desc_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleAsc_desc_;
}


std::any PostgreSQLParser::Asc_desc_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAsc_desc_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Asc_desc_Context* PostgreSQLParser::asc_desc_() {
  Asc_desc_Context *_localctx = _tracker.createInstance<Asc_desc_Context>(_ctx, getState());
  enterRule(_localctx, 612, PostgreSQLParser::RuleAsc_desc_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5467);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::ASC

    || _la == PostgreSQLParser::DESC)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nulls_order_Context ------------------------------------------------------------------

PostgreSQLParser::Nulls_order_Context::Nulls_order_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Nulls_order_Context::NULLS_P() {
  return getToken(PostgreSQLParser::NULLS_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Nulls_order_Context::FIRST_P() {
  return getToken(PostgreSQLParser::FIRST_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Nulls_order_Context::LAST_P() {
  return getToken(PostgreSQLParser::LAST_P, 0);
}


size_t PostgreSQLParser::Nulls_order_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleNulls_order_;
}


std::any PostgreSQLParser::Nulls_order_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitNulls_order_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Nulls_order_Context* PostgreSQLParser::nulls_order_() {
  Nulls_order_Context *_localctx = _tracker.createInstance<Nulls_order_Context>(_ctx, getState());
  enterRule(_localctx, 614, PostgreSQLParser::RuleNulls_order_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5473);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 470, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5469);
      match(PostgreSQLParser::NULLS_P);
      setState(5470);
      match(PostgreSQLParser::FIRST_P);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5471);
      match(PostgreSQLParser::NULLS_P);
      setState(5472);
      match(PostgreSQLParser::LAST_P);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreatefunctionstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreatefunctionstmtContext::CreatefunctionstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreatefunctionstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

PostgreSQLParser::Func_nameContext* PostgreSQLParser::CreatefunctionstmtContext::func_name() {
  return getRuleContext<PostgreSQLParser::Func_nameContext>(0);
}

PostgreSQLParser::Func_args_with_defaultsContext* PostgreSQLParser::CreatefunctionstmtContext::func_args_with_defaults() {
  return getRuleContext<PostgreSQLParser::Func_args_with_defaultsContext>(0);
}

PostgreSQLParser::Createfunc_opt_listContext* PostgreSQLParser::CreatefunctionstmtContext::createfunc_opt_list() {
  return getRuleContext<PostgreSQLParser::Createfunc_opt_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatefunctionstmtContext::FUNCTION() {
  return getToken(PostgreSQLParser::FUNCTION, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatefunctionstmtContext::PROCEDURE() {
  return getToken(PostgreSQLParser::PROCEDURE, 0);
}

PostgreSQLParser::Or_replace_Context* PostgreSQLParser::CreatefunctionstmtContext::or_replace_() {
  return getRuleContext<PostgreSQLParser::Or_replace_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatefunctionstmtContext::RETURNS() {
  return getToken(PostgreSQLParser::RETURNS, 0);
}

PostgreSQLParser::Func_returnContext* PostgreSQLParser::CreatefunctionstmtContext::func_return() {
  return getRuleContext<PostgreSQLParser::Func_returnContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatefunctionstmtContext::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatefunctionstmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Table_func_column_listContext* PostgreSQLParser::CreatefunctionstmtContext::table_func_column_list() {
  return getRuleContext<PostgreSQLParser::Table_func_column_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatefunctionstmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::CreatefunctionstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatefunctionstmt;
}


std::any PostgreSQLParser::CreatefunctionstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatefunctionstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreatefunctionstmtContext* PostgreSQLParser::createfunctionstmt() {
  CreatefunctionstmtContext *_localctx = _tracker.createInstance<CreatefunctionstmtContext>(_ctx, getState());
  enterRule(_localctx, 616, PostgreSQLParser::RuleCreatefunctionstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5475);
    match(PostgreSQLParser::CREATE);
    setState(5477);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OR) {
      setState(5476);
      or_replace_();
    }
    setState(5479);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::FUNCTION || _la == PostgreSQLParser::PROCEDURE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5480);
    func_name();
    setState(5481);
    func_args_with_defaults();
    setState(5491);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 473, _ctx)) {
    case 1: {
      setState(5482);
      match(PostgreSQLParser::RETURNS);
      setState(5489);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case PostgreSQLParser::JSON:
        case PostgreSQLParser::ABSENT:
        case PostgreSQLParser::ASENSITIVE:
        case PostgreSQLParser::ATOMIC:
        case PostgreSQLParser::BREADTH:
        case PostgreSQLParser::COMPRESSION:
        case PostgreSQLParser::CONDITIONAL:
        case PostgreSQLParser::DEPTH:
        case PostgreSQLParser::EMPTY_P:
        case PostgreSQLParser::FINALIZE:
        case PostgreSQLParser::INDENT:
        case PostgreSQLParser::KEEP:
        case PostgreSQLParser::KEYS:
        case PostgreSQLParser::NESTED:
        case PostgreSQLParser::OMIT:
        case PostgreSQLParser::PARAMETER:
        case PostgreSQLParser::PATH:
        case PostgreSQLParser::PLAN:
        case PostgreSQLParser::QUOTES:
        case PostgreSQLParser::SCALAR:
        case PostgreSQLParser::SOURCE:
        case PostgreSQLParser::STRING_P:
        case PostgreSQLParser::TARGET:
        case PostgreSQLParser::UNCONDITIONAL:
        case PostgreSQLParser::PERIOD:
        case PostgreSQLParser::AUTHORIZATION:
        case PostgreSQLParser::BINARY:
        case PostgreSQLParser::COLLATION:
        case PostgreSQLParser::CONCURRENTLY:
        case PostgreSQLParser::CROSS:
        case PostgreSQLParser::CURRENT_SCHEMA:
        case PostgreSQLParser::FREEZE:
        case PostgreSQLParser::FULL:
        case PostgreSQLParser::ILIKE:
        case PostgreSQLParser::INNER_P:
        case PostgreSQLParser::IS:
        case PostgreSQLParser::ISNULL:
        case PostgreSQLParser::JOIN:
        case PostgreSQLParser::LEFT:
        case PostgreSQLParser::LIKE:
        case PostgreSQLParser::NATURAL:
        case PostgreSQLParser::NOTNULL:
        case PostgreSQLParser::OUTER_P:
        case PostgreSQLParser::OVER:
        case PostgreSQLParser::OVERLAPS:
        case PostgreSQLParser::RIGHT:
        case PostgreSQLParser::SIMILAR:
        case PostgreSQLParser::VERBOSE:
        case PostgreSQLParser::ABORT_P:
        case PostgreSQLParser::ABSOLUTE_P:
        case PostgreSQLParser::ACCESS:
        case PostgreSQLParser::ACTION:
        case PostgreSQLParser::ADD_P:
        case PostgreSQLParser::ADMIN:
        case PostgreSQLParser::AFTER:
        case PostgreSQLParser::AGGREGATE:
        case PostgreSQLParser::ALSO:
        case PostgreSQLParser::ALTER:
        case PostgreSQLParser::ALWAYS:
        case PostgreSQLParser::ASSERTION:
        case PostgreSQLParser::ASSIGNMENT:
        case PostgreSQLParser::AT:
        case PostgreSQLParser::ATTRIBUTE:
        case PostgreSQLParser::BACKWARD:
        case PostgreSQLParser::BEFORE:
        case PostgreSQLParser::BEGIN_P:
        case PostgreSQLParser::BY:
        case PostgreSQLParser::CACHE:
        case PostgreSQLParser::CALLED:
        case PostgreSQLParser::CASCADE:
        case PostgreSQLParser::CASCADED:
        case PostgreSQLParser::CATALOG:
        case PostgreSQLParser::CHAIN:
        case PostgreSQLParser::CHARACTERISTICS:
        case PostgreSQLParser::CHECKPOINT:
        case PostgreSQLParser::CLASS:
        case PostgreSQLParser::CLOSE:
        case PostgreSQLParser::CLUSTER:
        case PostgreSQLParser::COMMENT:
        case PostgreSQLParser::COMMENTS:
        case PostgreSQLParser::COMMIT:
        case PostgreSQLParser::COMMITTED:
        case PostgreSQLParser::CONFIGURATION:
        case PostgreSQLParser::CONNECTION:
        case PostgreSQLParser::CONSTRAINTS:
        case PostgreSQLParser::CONTENT_P:
        case PostgreSQLParser::CONTINUE_P:
        case PostgreSQLParser::CONVERSION_P:
        case PostgreSQLParser::COPY:
        case PostgreSQLParser::COST:
        case PostgreSQLParser::CSV:
        case PostgreSQLParser::CURSOR:
        case PostgreSQLParser::CYCLE:
        case PostgreSQLParser::DATA_P:
        case PostgreSQLParser::DATABASE:
        case PostgreSQLParser::DAY_P:
        case PostgreSQLParser::DEALLOCATE:
        case PostgreSQLParser::DECLARE:
        case PostgreSQLParser::DEFAULTS:
        case PostgreSQLParser::DEFERRED:
        case PostgreSQLParser::DEFINER:
        case PostgreSQLParser::DELETE_P:
        case PostgreSQLParser::DELIMITER:
        case PostgreSQLParser::DELIMITERS:
        case PostgreSQLParser::DICTIONARY:
        case PostgreSQLParser::DISABLE_P:
        case PostgreSQLParser::DISCARD:
        case PostgreSQLParser::DOCUMENT_P:
        case PostgreSQLParser::DOMAIN_P:
        case PostgreSQLParser::DOUBLE_P:
        case PostgreSQLParser::DROP:
        case PostgreSQLParser::EACH:
        case PostgreSQLParser::ENABLE_P:
        case PostgreSQLParser::ENCODING:
        case PostgreSQLParser::ENCRYPTED:
        case PostgreSQLParser::ENUM_P:
        case PostgreSQLParser::ESCAPE:
        case PostgreSQLParser::EVENT:
        case PostgreSQLParser::EXCLUDE:
        case PostgreSQLParser::EXCLUDING:
        case PostgreSQLParser::EXCLUSIVE:
        case PostgreSQLParser::EXECUTE:
        case PostgreSQLParser::EXPLAIN:
        case PostgreSQLParser::EXTENSION:
        case PostgreSQLParser::EXTERNAL:
        case PostgreSQLParser::FAMILY:
        case PostgreSQLParser::FIRST_P:
        case PostgreSQLParser::FOLLOWING:
        case PostgreSQLParser::FORCE:
        case PostgreSQLParser::FORWARD:
        case PostgreSQLParser::FUNCTION:
        case PostgreSQLParser::FUNCTIONS:
        case PostgreSQLParser::GLOBAL:
        case PostgreSQLParser::GRANTED:
        case PostgreSQLParser::HANDLER:
        case PostgreSQLParser::HEADER_P:
        case PostgreSQLParser::HOLD:
        case PostgreSQLParser::HOUR_P:
        case PostgreSQLParser::IDENTITY_P:
        case PostgreSQLParser::IF_P:
        case PostgreSQLParser::IMMEDIATE:
        case PostgreSQLParser::IMMUTABLE:
        case PostgreSQLParser::IMPLICIT_P:
        case PostgreSQLParser::INCLUDING:
        case PostgreSQLParser::INCREMENT:
        case PostgreSQLParser::INDEX:
        case PostgreSQLParser::INDEXES:
        case PostgreSQLParser::INHERIT:
        case PostgreSQLParser::INHERITS:
        case PostgreSQLParser::INLINE_P:
        case PostgreSQLParser::INSENSITIVE:
        case PostgreSQLParser::INSERT:
        case PostgreSQLParser::INSTEAD:
        case PostgreSQLParser::INVOKER:
        case PostgreSQLParser::ISOLATION:
        case PostgreSQLParser::KEY:
        case PostgreSQLParser::LABEL:
        case PostgreSQLParser::LANGUAGE:
        case PostgreSQLParser::LARGE_P:
        case PostgreSQLParser::LAST_P:
        case PostgreSQLParser::LEAKPROOF:
        case PostgreSQLParser::LEVEL:
        case PostgreSQLParser::LISTEN:
        case PostgreSQLParser::LOAD:
        case PostgreSQLParser::LOCAL:
        case PostgreSQLParser::LOCATION:
        case PostgreSQLParser::LOCK_P:
        case PostgreSQLParser::MAPPING:
        case PostgreSQLParser::MATCH:
        case PostgreSQLParser::MATCHED:
        case PostgreSQLParser::MATERIALIZED:
        case PostgreSQLParser::MAXVALUE:
        case PostgreSQLParser::MERGE:
        case PostgreSQLParser::MINUTE_P:
        case PostgreSQLParser::MINVALUE:
        case PostgreSQLParser::MODE:
        case PostgreSQLParser::MONTH_P:
        case PostgreSQLParser::MOVE:
        case PostgreSQLParser::NAME_P:
        case PostgreSQLParser::NAMES:
        case PostgreSQLParser::NEXT:
        case PostgreSQLParser::NO:
        case PostgreSQLParser::NOTHING:
        case PostgreSQLParser::NOTIFY:
        case PostgreSQLParser::NOWAIT:
        case PostgreSQLParser::NULLS_P:
        case PostgreSQLParser::OBJECT_P:
        case PostgreSQLParser::OF:
        case PostgreSQLParser::OFF:
        case PostgreSQLParser::OIDS:
        case PostgreSQLParser::OPERATOR:
        case PostgreSQLParser::OPTION:
        case PostgreSQLParser::OPTIONS:
        case PostgreSQLParser::OWNED:
        case PostgreSQLParser::OWNER:
        case PostgreSQLParser::PARSER:
        case PostgreSQLParser::PARTIAL:
        case PostgreSQLParser::PARTITION:
        case PostgreSQLParser::PASSING:
        case PostgreSQLParser::PASSWORD:
        case PostgreSQLParser::PLANS:
        case PostgreSQLParser::PRECEDING:
        case PostgreSQLParser::PREPARE:
        case PostgreSQLParser::PREPARED:
        case PostgreSQLParser::PRESERVE:
        case PostgreSQLParser::PRIOR:
        case PostgreSQLParser::PRIVILEGES:
        case PostgreSQLParser::PROCEDURAL:
        case PostgreSQLParser::PROCEDURE:
        case PostgreSQLParser::PROGRAM:
        case PostgreSQLParser::QUOTE:
        case PostgreSQLParser::RANGE:
        case PostgreSQLParser::READ:
        case PostgreSQLParser::REASSIGN:
        case PostgreSQLParser::RECURSIVE:
        case PostgreSQLParser::REF:
        case PostgreSQLParser::REFRESH:
        case PostgreSQLParser::REINDEX:
        case PostgreSQLParser::RELATIVE_P:
        case PostgreSQLParser::RELEASE:
        case PostgreSQLParser::RENAME:
        case PostgreSQLParser::REPEATABLE:
        case PostgreSQLParser::REPLACE:
        case PostgreSQLParser::REPLICA:
        case PostgreSQLParser::RESET:
        case PostgreSQLParser::RESTART:
        case PostgreSQLParser::RESTRICT:
        case PostgreSQLParser::RETURNS:
        case PostgreSQLParser::REVOKE:
        case PostgreSQLParser::ROLE:
        case PostgreSQLParser::ROLLBACK:
        case PostgreSQLParser::ROWS:
        case PostgreSQLParser::RULE:
        case PostgreSQLParser::SAVEPOINT:
        case PostgreSQLParser::SCHEMA:
        case PostgreSQLParser::SCROLL:
        case PostgreSQLParser::SEARCH:
        case PostgreSQLParser::SECOND_P:
        case PostgreSQLParser::SECURITY:
        case PostgreSQLParser::SEQUENCE:
        case PostgreSQLParser::SEQUENCES:
        case PostgreSQLParser::SERIALIZABLE:
        case PostgreSQLParser::SERVER:
        case PostgreSQLParser::SESSION:
        case PostgreSQLParser::SET:
        case PostgreSQLParser::SHARE:
        case PostgreSQLParser::SHOW:
        case PostgreSQLParser::SIMPLE:
        case PostgreSQLParser::SNAPSHOT:
        case PostgreSQLParser::STABLE:
        case PostgreSQLParser::STANDALONE_P:
        case PostgreSQLParser::START:
        case PostgreSQLParser::STATEMENT:
        case PostgreSQLParser::STATISTICS:
        case PostgreSQLParser::STDIN:
        case PostgreSQLParser::STDOUT:
        case PostgreSQLParser::STORAGE:
        case PostgreSQLParser::STRICT_P:
        case PostgreSQLParser::STRIP_P:
        case PostgreSQLParser::SYSID:
        case PostgreSQLParser::SYSTEM_P:
        case PostgreSQLParser::TABLES:
        case PostgreSQLParser::TABLESPACE:
        case PostgreSQLParser::TEMP:
        case PostgreSQLParser::TEMPLATE:
        case PostgreSQLParser::TEMPORARY:
        case PostgreSQLParser::TEXT_P:
        case PostgreSQLParser::TRANSACTION:
        case PostgreSQLParser::TRIGGER:
        case PostgreSQLParser::TRUNCATE:
        case PostgreSQLParser::TRUSTED:
        case PostgreSQLParser::TYPE_P:
        case PostgreSQLParser::TYPES_P:
        case PostgreSQLParser::UNBOUNDED:
        case PostgreSQLParser::UNCOMMITTED:
        case PostgreSQLParser::UNENCRYPTED:
        case PostgreSQLParser::UNKNOWN:
        case PostgreSQLParser::UNLISTEN:
        case PostgreSQLParser::UNLOGGED:
        case PostgreSQLParser::UNTIL:
        case PostgreSQLParser::UPDATE:
        case PostgreSQLParser::VACUUM:
        case PostgreSQLParser::VALID:
        case PostgreSQLParser::VALIDATE:
        case PostgreSQLParser::VALIDATOR:
        case PostgreSQLParser::VARYING:
        case PostgreSQLParser::VERSION_P:
        case PostgreSQLParser::VIEW:
        case PostgreSQLParser::VOLATILE:
        case PostgreSQLParser::WHITESPACE_P:
        case PostgreSQLParser::WITHOUT:
        case PostgreSQLParser::WORK:
        case PostgreSQLParser::WRAPPER:
        case PostgreSQLParser::WRITE:
        case PostgreSQLParser::XML_P:
        case PostgreSQLParser::YEAR_P:
        case PostgreSQLParser::YES_P:
        case PostgreSQLParser::ZONE:
        case PostgreSQLParser::BIGINT:
        case PostgreSQLParser::BIT:
        case PostgreSQLParser::BOOLEAN_P:
        case PostgreSQLParser::CHAR_P:
        case PostgreSQLParser::CHARACTER:
        case PostgreSQLParser::DEC:
        case PostgreSQLParser::DECIMAL_P:
        case PostgreSQLParser::FLOAT_P:
        case PostgreSQLParser::INT_P:
        case PostgreSQLParser::INTEGER:
        case PostgreSQLParser::INTERVAL:
        case PostgreSQLParser::NATIONAL:
        case PostgreSQLParser::NCHAR:
        case PostgreSQLParser::NUMERIC:
        case PostgreSQLParser::REAL:
        case PostgreSQLParser::SETOF:
        case PostgreSQLParser::SMALLINT:
        case PostgreSQLParser::TIME:
        case PostgreSQLParser::TIMESTAMP:
        case PostgreSQLParser::VARCHAR:
        case PostgreSQLParser::CALL:
        case PostgreSQLParser::CURRENT_P:
        case PostgreSQLParser::ATTACH:
        case PostgreSQLParser::DETACH:
        case PostgreSQLParser::EXPRESSION:
        case PostgreSQLParser::GENERATED:
        case PostgreSQLParser::LOGGED:
        case PostgreSQLParser::STORED:
        case PostgreSQLParser::INCLUDE:
        case PostgreSQLParser::ROUTINE:
        case PostgreSQLParser::TRANSFORM:
        case PostgreSQLParser::IMPORT_P:
        case PostgreSQLParser::POLICY:
        case PostgreSQLParser::METHOD:
        case PostgreSQLParser::REFERENCING:
        case PostgreSQLParser::NEW:
        case PostgreSQLParser::OLD:
        case PostgreSQLParser::VALUE_P:
        case PostgreSQLParser::SUBSCRIPTION:
        case PostgreSQLParser::PUBLICATION:
        case PostgreSQLParser::ROUTINES:
        case PostgreSQLParser::SCHEMAS:
        case PostgreSQLParser::PROCEDURES:
        case PostgreSQLParser::INPUT_P:
        case PostgreSQLParser::SUPPORT:
        case PostgreSQLParser::PARALLEL:
        case PostgreSQLParser::SQL_P:
        case PostgreSQLParser::DEPENDS:
        case PostgreSQLParser::OVERRIDING:
        case PostgreSQLParser::CONFLICT:
        case PostgreSQLParser::SKIP_P:
        case PostgreSQLParser::LOCKED:
        case PostgreSQLParser::TIES:
        case PostgreSQLParser::ROLLUP:
        case PostgreSQLParser::CUBE:
        case PostgreSQLParser::SETS:
        case PostgreSQLParser::TABLESAMPLE:
        case PostgreSQLParser::ORDINALITY:
        case PostgreSQLParser::COLUMNS:
        case PostgreSQLParser::NORMALIZED:
        case PostgreSQLParser::WITHIN:
        case PostgreSQLParser::FILTER:
        case PostgreSQLParser::GROUPS:
        case PostgreSQLParser::OTHERS:
        case PostgreSQLParser::NFC:
        case PostgreSQLParser::NFD:
        case PostgreSQLParser::NFKC:
        case PostgreSQLParser::NFKD:
        case PostgreSQLParser::UESCAPE:
        case PostgreSQLParser::VIEWS:
        case PostgreSQLParser::ERROR:
        case PostgreSQLParser::RETURN:
        case PostgreSQLParser::FORMAT:
        case PostgreSQLParser::Identifier:
        case PostgreSQLParser::QuotedIdentifier:
        case PostgreSQLParser::UnicodeQuotedIdentifier:
        case PostgreSQLParser::PLSQLVARIABLENAME: {
          setState(5483);
          func_return();
          break;
        }

        case PostgreSQLParser::TABLE: {
          setState(5484);
          match(PostgreSQLParser::TABLE);
          setState(5485);
          match(PostgreSQLParser::OPEN_PAREN);
          setState(5486);
          table_func_column_list();
          setState(5487);
          match(PostgreSQLParser::CLOSE_PAREN);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    default:
      break;
    }
    setState(5493);
    createfunc_opt_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Or_replace_Context ------------------------------------------------------------------

PostgreSQLParser::Or_replace_Context::Or_replace_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Or_replace_Context::OR() {
  return getToken(PostgreSQLParser::OR, 0);
}

tree::TerminalNode* PostgreSQLParser::Or_replace_Context::REPLACE() {
  return getToken(PostgreSQLParser::REPLACE, 0);
}


size_t PostgreSQLParser::Or_replace_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleOr_replace_;
}


std::any PostgreSQLParser::Or_replace_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOr_replace_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Or_replace_Context* PostgreSQLParser::or_replace_() {
  Or_replace_Context *_localctx = _tracker.createInstance<Or_replace_Context>(_ctx, getState());
  enterRule(_localctx, 618, PostgreSQLParser::RuleOr_replace_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5495);
    match(PostgreSQLParser::OR);
    setState(5496);
    match(PostgreSQLParser::REPLACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_argsContext ------------------------------------------------------------------

PostgreSQLParser::Func_argsContext::Func_argsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Func_argsContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_argsContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::Func_args_listContext* PostgreSQLParser::Func_argsContext::func_args_list() {
  return getRuleContext<PostgreSQLParser::Func_args_listContext>(0);
}


size_t PostgreSQLParser::Func_argsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunc_args;
}


std::any PostgreSQLParser::Func_argsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunc_args(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Func_argsContext* PostgreSQLParser::func_args() {
  Func_argsContext *_localctx = _tracker.createInstance<Func_argsContext>(_ctx, getState());
  enterRule(_localctx, 620, PostgreSQLParser::RuleFunc_args);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5498);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(5500);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -8795019280384) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 4398046511111) != 0) || ((((_la - 139) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 139)) & -31) != 0) || ((((_la - 203) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 203)) & -1) != 0) || ((((_la - 267) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 267)) & -1) != 0) || ((((_la - 331) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 331)) & -5) != 0) || ((((_la - 395) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 395)) & 637865130389929983) != 0) || ((((_la - 471) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 471)) & 360259245446266879) != 0) || ((((_la - 542) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 542)) & 1099511773185) != 0)) {
      setState(5499);
      func_args_list();
    }
    setState(5502);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_args_listContext ------------------------------------------------------------------

PostgreSQLParser::Func_args_listContext::Func_args_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Func_argContext *> PostgreSQLParser::Func_args_listContext::func_arg() {
  return getRuleContexts<PostgreSQLParser::Func_argContext>();
}

PostgreSQLParser::Func_argContext* PostgreSQLParser::Func_args_listContext::func_arg(size_t i) {
  return getRuleContext<PostgreSQLParser::Func_argContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Func_args_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Func_args_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Func_args_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunc_args_list;
}


std::any PostgreSQLParser::Func_args_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunc_args_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Func_args_listContext* PostgreSQLParser::func_args_list() {
  Func_args_listContext *_localctx = _tracker.createInstance<Func_args_listContext>(_ctx, getState());
  enterRule(_localctx, 622, PostgreSQLParser::RuleFunc_args_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5504);
    func_arg();
    setState(5509);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(5505);
      match(PostgreSQLParser::COMMA);
      setState(5506);
      func_arg();
      setState(5511);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_with_argtypes_listContext ------------------------------------------------------------------

PostgreSQLParser::Function_with_argtypes_listContext::Function_with_argtypes_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Function_with_argtypesContext *> PostgreSQLParser::Function_with_argtypes_listContext::function_with_argtypes() {
  return getRuleContexts<PostgreSQLParser::Function_with_argtypesContext>();
}

PostgreSQLParser::Function_with_argtypesContext* PostgreSQLParser::Function_with_argtypes_listContext::function_with_argtypes(size_t i) {
  return getRuleContext<PostgreSQLParser::Function_with_argtypesContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Function_with_argtypes_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Function_with_argtypes_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Function_with_argtypes_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunction_with_argtypes_list;
}


std::any PostgreSQLParser::Function_with_argtypes_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunction_with_argtypes_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Function_with_argtypes_listContext* PostgreSQLParser::function_with_argtypes_list() {
  Function_with_argtypes_listContext *_localctx = _tracker.createInstance<Function_with_argtypes_listContext>(_ctx, getState());
  enterRule(_localctx, 624, PostgreSQLParser::RuleFunction_with_argtypes_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5512);
    function_with_argtypes();
    setState(5517);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(5513);
      match(PostgreSQLParser::COMMA);
      setState(5514);
      function_with_argtypes();
      setState(5519);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_with_argtypesContext ------------------------------------------------------------------

PostgreSQLParser::Function_with_argtypesContext::Function_with_argtypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Func_nameContext* PostgreSQLParser::Function_with_argtypesContext::func_name() {
  return getRuleContext<PostgreSQLParser::Func_nameContext>(0);
}

PostgreSQLParser::Func_argsContext* PostgreSQLParser::Function_with_argtypesContext::func_args() {
  return getRuleContext<PostgreSQLParser::Func_argsContext>(0);
}

PostgreSQLParser::Type_func_name_keywordContext* PostgreSQLParser::Function_with_argtypesContext::type_func_name_keyword() {
  return getRuleContext<PostgreSQLParser::Type_func_name_keywordContext>(0);
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Function_with_argtypesContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

PostgreSQLParser::IndirectionContext* PostgreSQLParser::Function_with_argtypesContext::indirection() {
  return getRuleContext<PostgreSQLParser::IndirectionContext>(0);
}


size_t PostgreSQLParser::Function_with_argtypesContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunction_with_argtypes;
}


std::any PostgreSQLParser::Function_with_argtypesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunction_with_argtypes(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Function_with_argtypesContext* PostgreSQLParser::function_with_argtypes() {
  Function_with_argtypesContext *_localctx = _tracker.createInstance<Function_with_argtypesContext>(_ctx, getState());
  enterRule(_localctx, 626, PostgreSQLParser::RuleFunction_with_argtypes);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5528);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 478, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5520);
      func_name();
      setState(5521);
      func_args();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5523);
      type_func_name_keyword();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5524);
      colid();
      setState(5526);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPEN_BRACKET

      || _la == PostgreSQLParser::DOT) {
        setState(5525);
        indirection();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_args_with_defaultsContext ------------------------------------------------------------------

PostgreSQLParser::Func_args_with_defaultsContext::Func_args_with_defaultsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Func_args_with_defaultsContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_args_with_defaultsContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::Func_args_with_defaults_listContext* PostgreSQLParser::Func_args_with_defaultsContext::func_args_with_defaults_list() {
  return getRuleContext<PostgreSQLParser::Func_args_with_defaults_listContext>(0);
}


size_t PostgreSQLParser::Func_args_with_defaultsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunc_args_with_defaults;
}


std::any PostgreSQLParser::Func_args_with_defaultsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunc_args_with_defaults(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Func_args_with_defaultsContext* PostgreSQLParser::func_args_with_defaults() {
  Func_args_with_defaultsContext *_localctx = _tracker.createInstance<Func_args_with_defaultsContext>(_ctx, getState());
  enterRule(_localctx, 628, PostgreSQLParser::RuleFunc_args_with_defaults);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5530);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(5532);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -8795019280384) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 4398046511111) != 0) || ((((_la - 139) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 139)) & -31) != 0) || ((((_la - 203) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 203)) & -1) != 0) || ((((_la - 267) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 267)) & -1) != 0) || ((((_la - 331) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 331)) & -5) != 0) || ((((_la - 395) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 395)) & 637865130389929983) != 0) || ((((_la - 471) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 471)) & 360259245446266879) != 0) || ((((_la - 542) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 542)) & 1099511773185) != 0)) {
      setState(5531);
      func_args_with_defaults_list();
    }
    setState(5534);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_args_with_defaults_listContext ------------------------------------------------------------------

PostgreSQLParser::Func_args_with_defaults_listContext::Func_args_with_defaults_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Func_arg_with_defaultContext *> PostgreSQLParser::Func_args_with_defaults_listContext::func_arg_with_default() {
  return getRuleContexts<PostgreSQLParser::Func_arg_with_defaultContext>();
}

PostgreSQLParser::Func_arg_with_defaultContext* PostgreSQLParser::Func_args_with_defaults_listContext::func_arg_with_default(size_t i) {
  return getRuleContext<PostgreSQLParser::Func_arg_with_defaultContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Func_args_with_defaults_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Func_args_with_defaults_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Func_args_with_defaults_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunc_args_with_defaults_list;
}


std::any PostgreSQLParser::Func_args_with_defaults_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunc_args_with_defaults_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Func_args_with_defaults_listContext* PostgreSQLParser::func_args_with_defaults_list() {
  Func_args_with_defaults_listContext *_localctx = _tracker.createInstance<Func_args_with_defaults_listContext>(_ctx, getState());
  enterRule(_localctx, 630, PostgreSQLParser::RuleFunc_args_with_defaults_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5536);
    func_arg_with_default();
    setState(5541);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(5537);
      match(PostgreSQLParser::COMMA);
      setState(5538);
      func_arg_with_default();
      setState(5543);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_argContext ------------------------------------------------------------------

PostgreSQLParser::Func_argContext::Func_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Arg_classContext* PostgreSQLParser::Func_argContext::arg_class() {
  return getRuleContext<PostgreSQLParser::Arg_classContext>(0);
}

PostgreSQLParser::Func_typeContext* PostgreSQLParser::Func_argContext::func_type() {
  return getRuleContext<PostgreSQLParser::Func_typeContext>(0);
}

PostgreSQLParser::Param_nameContext* PostgreSQLParser::Func_argContext::param_name() {
  return getRuleContext<PostgreSQLParser::Param_nameContext>(0);
}


size_t PostgreSQLParser::Func_argContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunc_arg;
}


std::any PostgreSQLParser::Func_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunc_arg(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Func_argContext* PostgreSQLParser::func_arg() {
  Func_argContext *_localctx = _tracker.createInstance<Func_argContext>(_ctx, getState());
  enterRule(_localctx, 632, PostgreSQLParser::RuleFunc_arg);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5557);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 483, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5544);
      arg_class();
      setState(5546);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 481, _ctx)) {
      case 1: {
        setState(5545);
        param_name();
        break;
      }

      default:
        break;
      }
      setState(5548);
      func_type();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5550);
      param_name();
      setState(5552);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::IN_P

      || _la == PostgreSQLParser::VARIADIC || _la == PostgreSQLParser::INOUT

      || _la == PostgreSQLParser::OUT_P) {
        setState(5551);
        arg_class();
      }
      setState(5554);
      func_type();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5556);
      func_type();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Arg_classContext ------------------------------------------------------------------

PostgreSQLParser::Arg_classContext::Arg_classContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Arg_classContext::IN_P() {
  return getToken(PostgreSQLParser::IN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Arg_classContext::OUT_P() {
  return getToken(PostgreSQLParser::OUT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Arg_classContext::INOUT() {
  return getToken(PostgreSQLParser::INOUT, 0);
}

tree::TerminalNode* PostgreSQLParser::Arg_classContext::VARIADIC() {
  return getToken(PostgreSQLParser::VARIADIC, 0);
}


size_t PostgreSQLParser::Arg_classContext::getRuleIndex() const {
  return PostgreSQLParser::RuleArg_class;
}


std::any PostgreSQLParser::Arg_classContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitArg_class(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Arg_classContext* PostgreSQLParser::arg_class() {
  Arg_classContext *_localctx = _tracker.createInstance<Arg_classContext>(_ctx, getState());
  enterRule(_localctx, 634, PostgreSQLParser::RuleArg_class);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5566);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::IN_P: {
        enterOuterAlt(_localctx, 1);
        setState(5559);
        match(PostgreSQLParser::IN_P);
        setState(5561);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::OUT_P) {
          setState(5560);
          match(PostgreSQLParser::OUT_P);
        }
        break;
      }

      case PostgreSQLParser::OUT_P: {
        enterOuterAlt(_localctx, 2);
        setState(5563);
        match(PostgreSQLParser::OUT_P);
        break;
      }

      case PostgreSQLParser::INOUT: {
        enterOuterAlt(_localctx, 3);
        setState(5564);
        match(PostgreSQLParser::INOUT);
        break;
      }

      case PostgreSQLParser::VARIADIC: {
        enterOuterAlt(_localctx, 4);
        setState(5565);
        match(PostgreSQLParser::VARIADIC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Param_nameContext ------------------------------------------------------------------

PostgreSQLParser::Param_nameContext::Param_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Type_function_nameContext* PostgreSQLParser::Param_nameContext::type_function_name() {
  return getRuleContext<PostgreSQLParser::Type_function_nameContext>(0);
}


size_t PostgreSQLParser::Param_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleParam_name;
}


std::any PostgreSQLParser::Param_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitParam_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Param_nameContext* PostgreSQLParser::param_name() {
  Param_nameContext *_localctx = _tracker.createInstance<Param_nameContext>(_ctx, getState());
  enterRule(_localctx, 636, PostgreSQLParser::RuleParam_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5568);
    type_function_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_returnContext ------------------------------------------------------------------

PostgreSQLParser::Func_returnContext::Func_returnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Func_typeContext* PostgreSQLParser::Func_returnContext::func_type() {
  return getRuleContext<PostgreSQLParser::Func_typeContext>(0);
}


size_t PostgreSQLParser::Func_returnContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunc_return;
}


std::any PostgreSQLParser::Func_returnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunc_return(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Func_returnContext* PostgreSQLParser::func_return() {
  Func_returnContext *_localctx = _tracker.createInstance<Func_returnContext>(_ctx, getState());
  enterRule(_localctx, 638, PostgreSQLParser::RuleFunc_return);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5570);
    func_type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_typeContext ------------------------------------------------------------------

PostgreSQLParser::Func_typeContext::Func_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::Func_typeContext::typename_() {
  return getRuleContext<PostgreSQLParser::TypenameContext>(0);
}

PostgreSQLParser::Type_function_nameContext* PostgreSQLParser::Func_typeContext::type_function_name() {
  return getRuleContext<PostgreSQLParser::Type_function_nameContext>(0);
}

PostgreSQLParser::AttrsContext* PostgreSQLParser::Func_typeContext::attrs() {
  return getRuleContext<PostgreSQLParser::AttrsContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_typeContext::PERCENT() {
  return getToken(PostgreSQLParser::PERCENT, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_typeContext::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_typeContext::SETOF() {
  return getToken(PostgreSQLParser::SETOF, 0);
}


size_t PostgreSQLParser::Func_typeContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunc_type;
}


std::any PostgreSQLParser::Func_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunc_type(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Func_typeContext* PostgreSQLParser::func_type() {
  Func_typeContext *_localctx = _tracker.createInstance<Func_typeContext>(_ctx, getState());
  enterRule(_localctx, 640, PostgreSQLParser::RuleFunc_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5581);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 487, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5572);
      typename_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5574);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::SETOF) {
        setState(5573);
        match(PostgreSQLParser::SETOF);
      }
      setState(5576);
      type_function_name();
      setState(5577);
      attrs();
      setState(5578);
      match(PostgreSQLParser::PERCENT);
      setState(5579);
      match(PostgreSQLParser::TYPE_P);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_arg_with_defaultContext ------------------------------------------------------------------

PostgreSQLParser::Func_arg_with_defaultContext::Func_arg_with_defaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Func_argContext* PostgreSQLParser::Func_arg_with_defaultContext::func_arg() {
  return getRuleContext<PostgreSQLParser::Func_argContext>(0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Func_arg_with_defaultContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_arg_with_defaultContext::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_arg_with_defaultContext::EQUAL() {
  return getToken(PostgreSQLParser::EQUAL, 0);
}


size_t PostgreSQLParser::Func_arg_with_defaultContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunc_arg_with_default;
}


std::any PostgreSQLParser::Func_arg_with_defaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunc_arg_with_default(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Func_arg_with_defaultContext* PostgreSQLParser::func_arg_with_default() {
  Func_arg_with_defaultContext *_localctx = _tracker.createInstance<Func_arg_with_defaultContext>(_ctx, getState());
  enterRule(_localctx, 642, PostgreSQLParser::RuleFunc_arg_with_default);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5583);
    func_arg();
    setState(5586);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::EQUAL || _la == PostgreSQLParser::DEFAULT) {
      setState(5584);
      _la = _input->LA(1);
      if (!(_la == PostgreSQLParser::EQUAL || _la == PostgreSQLParser::DEFAULT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5585);
      a_expr();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Aggr_argContext ------------------------------------------------------------------

PostgreSQLParser::Aggr_argContext::Aggr_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Func_argContext* PostgreSQLParser::Aggr_argContext::func_arg() {
  return getRuleContext<PostgreSQLParser::Func_argContext>(0);
}


size_t PostgreSQLParser::Aggr_argContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAggr_arg;
}


std::any PostgreSQLParser::Aggr_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAggr_arg(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Aggr_argContext* PostgreSQLParser::aggr_arg() {
  Aggr_argContext *_localctx = _tracker.createInstance<Aggr_argContext>(_ctx, getState());
  enterRule(_localctx, 644, PostgreSQLParser::RuleAggr_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5588);
    func_arg();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Aggr_argsContext ------------------------------------------------------------------

PostgreSQLParser::Aggr_argsContext::Aggr_argsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Aggr_argsContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::Aggr_argsContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::Aggr_argsContext::STAR() {
  return getToken(PostgreSQLParser::STAR, 0);
}

std::vector<PostgreSQLParser::Aggr_args_listContext *> PostgreSQLParser::Aggr_argsContext::aggr_args_list() {
  return getRuleContexts<PostgreSQLParser::Aggr_args_listContext>();
}

PostgreSQLParser::Aggr_args_listContext* PostgreSQLParser::Aggr_argsContext::aggr_args_list(size_t i) {
  return getRuleContext<PostgreSQLParser::Aggr_args_listContext>(i);
}

tree::TerminalNode* PostgreSQLParser::Aggr_argsContext::ORDER() {
  return getToken(PostgreSQLParser::ORDER, 0);
}

tree::TerminalNode* PostgreSQLParser::Aggr_argsContext::BY() {
  return getToken(PostgreSQLParser::BY, 0);
}


size_t PostgreSQLParser::Aggr_argsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAggr_args;
}


std::any PostgreSQLParser::Aggr_argsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAggr_args(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Aggr_argsContext* PostgreSQLParser::aggr_args() {
  Aggr_argsContext *_localctx = _tracker.createInstance<Aggr_argsContext>(_ctx, getState());
  enterRule(_localctx, 646, PostgreSQLParser::RuleAggr_args);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5590);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(5601);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 489, _ctx)) {
    case 1: {
      setState(5591);
      match(PostgreSQLParser::STAR);
      break;
    }

    case 2: {
      setState(5592);
      aggr_args_list();
      break;
    }

    case 3: {
      setState(5593);
      match(PostgreSQLParser::ORDER);
      setState(5594);
      match(PostgreSQLParser::BY);
      setState(5595);
      aggr_args_list();
      break;
    }

    case 4: {
      setState(5596);
      aggr_args_list();
      setState(5597);
      match(PostgreSQLParser::ORDER);
      setState(5598);
      match(PostgreSQLParser::BY);
      setState(5599);
      aggr_args_list();
      break;
    }

    default:
      break;
    }
    setState(5603);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Aggr_args_listContext ------------------------------------------------------------------

PostgreSQLParser::Aggr_args_listContext::Aggr_args_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Aggr_argContext *> PostgreSQLParser::Aggr_args_listContext::aggr_arg() {
  return getRuleContexts<PostgreSQLParser::Aggr_argContext>();
}

PostgreSQLParser::Aggr_argContext* PostgreSQLParser::Aggr_args_listContext::aggr_arg(size_t i) {
  return getRuleContext<PostgreSQLParser::Aggr_argContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Aggr_args_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Aggr_args_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Aggr_args_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAggr_args_list;
}


std::any PostgreSQLParser::Aggr_args_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAggr_args_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Aggr_args_listContext* PostgreSQLParser::aggr_args_list() {
  Aggr_args_listContext *_localctx = _tracker.createInstance<Aggr_args_listContext>(_ctx, getState());
  enterRule(_localctx, 648, PostgreSQLParser::RuleAggr_args_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5605);
    aggr_arg();
    setState(5610);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(5606);
      match(PostgreSQLParser::COMMA);
      setState(5607);
      aggr_arg();
      setState(5612);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Aggregate_with_argtypesContext ------------------------------------------------------------------

PostgreSQLParser::Aggregate_with_argtypesContext::Aggregate_with_argtypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Func_nameContext* PostgreSQLParser::Aggregate_with_argtypesContext::func_name() {
  return getRuleContext<PostgreSQLParser::Func_nameContext>(0);
}

PostgreSQLParser::Aggr_argsContext* PostgreSQLParser::Aggregate_with_argtypesContext::aggr_args() {
  return getRuleContext<PostgreSQLParser::Aggr_argsContext>(0);
}


size_t PostgreSQLParser::Aggregate_with_argtypesContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAggregate_with_argtypes;
}


std::any PostgreSQLParser::Aggregate_with_argtypesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAggregate_with_argtypes(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Aggregate_with_argtypesContext* PostgreSQLParser::aggregate_with_argtypes() {
  Aggregate_with_argtypesContext *_localctx = _tracker.createInstance<Aggregate_with_argtypesContext>(_ctx, getState());
  enterRule(_localctx, 650, PostgreSQLParser::RuleAggregate_with_argtypes);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5613);
    func_name();
    setState(5614);
    aggr_args();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Aggregate_with_argtypes_listContext ------------------------------------------------------------------

PostgreSQLParser::Aggregate_with_argtypes_listContext::Aggregate_with_argtypes_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Aggregate_with_argtypesContext *> PostgreSQLParser::Aggregate_with_argtypes_listContext::aggregate_with_argtypes() {
  return getRuleContexts<PostgreSQLParser::Aggregate_with_argtypesContext>();
}

PostgreSQLParser::Aggregate_with_argtypesContext* PostgreSQLParser::Aggregate_with_argtypes_listContext::aggregate_with_argtypes(size_t i) {
  return getRuleContext<PostgreSQLParser::Aggregate_with_argtypesContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Aggregate_with_argtypes_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Aggregate_with_argtypes_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Aggregate_with_argtypes_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAggregate_with_argtypes_list;
}


std::any PostgreSQLParser::Aggregate_with_argtypes_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAggregate_with_argtypes_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Aggregate_with_argtypes_listContext* PostgreSQLParser::aggregate_with_argtypes_list() {
  Aggregate_with_argtypes_listContext *_localctx = _tracker.createInstance<Aggregate_with_argtypes_listContext>(_ctx, getState());
  enterRule(_localctx, 652, PostgreSQLParser::RuleAggregate_with_argtypes_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5616);
    aggregate_with_argtypes();
    setState(5621);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(5617);
      match(PostgreSQLParser::COMMA);
      setState(5618);
      aggregate_with_argtypes();
      setState(5623);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Createfunc_opt_listContext ------------------------------------------------------------------

PostgreSQLParser::Createfunc_opt_listContext::Createfunc_opt_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Createfunc_opt_itemContext *> PostgreSQLParser::Createfunc_opt_listContext::createfunc_opt_item() {
  return getRuleContexts<PostgreSQLParser::Createfunc_opt_itemContext>();
}

PostgreSQLParser::Createfunc_opt_itemContext* PostgreSQLParser::Createfunc_opt_listContext::createfunc_opt_item(size_t i) {
  return getRuleContext<PostgreSQLParser::Createfunc_opt_itemContext>(i);
}


size_t PostgreSQLParser::Createfunc_opt_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatefunc_opt_list;
}


std::any PostgreSQLParser::Createfunc_opt_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatefunc_opt_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Createfunc_opt_listContext* PostgreSQLParser::createfunc_opt_list() {
  Createfunc_opt_listContext *_localctx = _tracker.createInstance<Createfunc_opt_listContext>(_ctx, getState());
  enterRule(_localctx, 654, PostgreSQLParser::RuleCreatefunc_opt_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5625); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(5624);
      createfunc_opt_item();
      setState(5627); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == PostgreSQLParser::AS

    || _la == PostgreSQLParser::NOT || _la == PostgreSQLParser::WINDOW

    || _la == PostgreSQLParser::CALLED || ((((_la - 208) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 208)) & 4503633987108865) != 0) || _la == PostgreSQLParser::LANGUAGE

    || _la == PostgreSQLParser::LEAKPROOF || ((((_la - 344) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 344)) & 8624554121) != 0) || _la == PostgreSQLParser::VOLATILE || ((((_la - 481) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 481)) & 196609) != 0));
    this->ParseRoutineBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Common_func_opt_itemContext ------------------------------------------------------------------

PostgreSQLParser::Common_func_opt_itemContext::Common_func_opt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Common_func_opt_itemContext::CALLED() {
  return getToken(PostgreSQLParser::CALLED, 0);
}

tree::TerminalNode* PostgreSQLParser::Common_func_opt_itemContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Common_func_opt_itemContext::NULL_P() {
  return getTokens(PostgreSQLParser::NULL_P);
}

tree::TerminalNode* PostgreSQLParser::Common_func_opt_itemContext::NULL_P(size_t i) {
  return getToken(PostgreSQLParser::NULL_P, i);
}

tree::TerminalNode* PostgreSQLParser::Common_func_opt_itemContext::INPUT_P() {
  return getToken(PostgreSQLParser::INPUT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Common_func_opt_itemContext::RETURNS() {
  return getToken(PostgreSQLParser::RETURNS, 0);
}

tree::TerminalNode* PostgreSQLParser::Common_func_opt_itemContext::STRICT_P() {
  return getToken(PostgreSQLParser::STRICT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Common_func_opt_itemContext::IMMUTABLE() {
  return getToken(PostgreSQLParser::IMMUTABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Common_func_opt_itemContext::STABLE() {
  return getToken(PostgreSQLParser::STABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Common_func_opt_itemContext::VOLATILE() {
  return getToken(PostgreSQLParser::VOLATILE, 0);
}

tree::TerminalNode* PostgreSQLParser::Common_func_opt_itemContext::EXTERNAL() {
  return getToken(PostgreSQLParser::EXTERNAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Common_func_opt_itemContext::SECURITY() {
  return getToken(PostgreSQLParser::SECURITY, 0);
}

tree::TerminalNode* PostgreSQLParser::Common_func_opt_itemContext::DEFINER() {
  return getToken(PostgreSQLParser::DEFINER, 0);
}

tree::TerminalNode* PostgreSQLParser::Common_func_opt_itemContext::INVOKER() {
  return getToken(PostgreSQLParser::INVOKER, 0);
}

tree::TerminalNode* PostgreSQLParser::Common_func_opt_itemContext::LEAKPROOF() {
  return getToken(PostgreSQLParser::LEAKPROOF, 0);
}

tree::TerminalNode* PostgreSQLParser::Common_func_opt_itemContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::Common_func_opt_itemContext::COST() {
  return getToken(PostgreSQLParser::COST, 0);
}

PostgreSQLParser::NumericonlyContext* PostgreSQLParser::Common_func_opt_itemContext::numericonly() {
  return getRuleContext<PostgreSQLParser::NumericonlyContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Common_func_opt_itemContext::ROWS() {
  return getToken(PostgreSQLParser::ROWS, 0);
}

tree::TerminalNode* PostgreSQLParser::Common_func_opt_itemContext::SUPPORT() {
  return getToken(PostgreSQLParser::SUPPORT, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::Common_func_opt_itemContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

PostgreSQLParser::FunctionsetresetclauseContext* PostgreSQLParser::Common_func_opt_itemContext::functionsetresetclause() {
  return getRuleContext<PostgreSQLParser::FunctionsetresetclauseContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Common_func_opt_itemContext::PARALLEL() {
  return getToken(PostgreSQLParser::PARALLEL, 0);
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Common_func_opt_itemContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}


size_t PostgreSQLParser::Common_func_opt_itemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCommon_func_opt_item;
}


std::any PostgreSQLParser::Common_func_opt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCommon_func_opt_item(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Common_func_opt_itemContext* PostgreSQLParser::common_func_opt_item() {
  Common_func_opt_itemContext *_localctx = _tracker.createInstance<Common_func_opt_itemContext>(_ctx, getState());
  enterRule(_localctx, 656, PostgreSQLParser::RuleCommon_func_opt_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5666);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 493, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5631);
      match(PostgreSQLParser::CALLED);
      setState(5632);
      match(PostgreSQLParser::ON);
      setState(5633);
      match(PostgreSQLParser::NULL_P);
      setState(5634);
      match(PostgreSQLParser::INPUT_P);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5635);
      match(PostgreSQLParser::RETURNS);
      setState(5636);
      match(PostgreSQLParser::NULL_P);
      setState(5637);
      match(PostgreSQLParser::ON);
      setState(5638);
      match(PostgreSQLParser::NULL_P);
      setState(5639);
      match(PostgreSQLParser::INPUT_P);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5640);
      match(PostgreSQLParser::STRICT_P);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5641);
      match(PostgreSQLParser::IMMUTABLE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5642);
      match(PostgreSQLParser::STABLE);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(5643);
      match(PostgreSQLParser::VOLATILE);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(5644);
      match(PostgreSQLParser::EXTERNAL);
      setState(5645);
      match(PostgreSQLParser::SECURITY);
      setState(5646);
      match(PostgreSQLParser::DEFINER);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(5647);
      match(PostgreSQLParser::EXTERNAL);
      setState(5648);
      match(PostgreSQLParser::SECURITY);
      setState(5649);
      match(PostgreSQLParser::INVOKER);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(5650);
      match(PostgreSQLParser::SECURITY);
      setState(5651);
      match(PostgreSQLParser::DEFINER);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(5652);
      match(PostgreSQLParser::SECURITY);
      setState(5653);
      match(PostgreSQLParser::INVOKER);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(5654);
      match(PostgreSQLParser::LEAKPROOF);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(5655);
      match(PostgreSQLParser::NOT);
      setState(5656);
      match(PostgreSQLParser::LEAKPROOF);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(5657);
      match(PostgreSQLParser::COST);
      setState(5658);
      numericonly();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(5659);
      match(PostgreSQLParser::ROWS);
      setState(5660);
      numericonly();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(5661);
      match(PostgreSQLParser::SUPPORT);
      setState(5662);
      any_name();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(5663);
      functionsetresetclause();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(5664);
      match(PostgreSQLParser::PARALLEL);
      setState(5665);
      colid();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Createfunc_opt_itemContext ------------------------------------------------------------------

PostgreSQLParser::Createfunc_opt_itemContext::Createfunc_opt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Createfunc_opt_itemContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

PostgreSQLParser::Func_asContext* PostgreSQLParser::Createfunc_opt_itemContext::func_as() {
  return getRuleContext<PostgreSQLParser::Func_asContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Createfunc_opt_itemContext::LANGUAGE() {
  return getToken(PostgreSQLParser::LANGUAGE, 0);
}

PostgreSQLParser::Nonreservedword_or_sconstContext* PostgreSQLParser::Createfunc_opt_itemContext::nonreservedword_or_sconst() {
  return getRuleContext<PostgreSQLParser::Nonreservedword_or_sconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Createfunc_opt_itemContext::TRANSFORM() {
  return getToken(PostgreSQLParser::TRANSFORM, 0);
}

PostgreSQLParser::Transform_type_listContext* PostgreSQLParser::Createfunc_opt_itemContext::transform_type_list() {
  return getRuleContext<PostgreSQLParser::Transform_type_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Createfunc_opt_itemContext::WINDOW() {
  return getToken(PostgreSQLParser::WINDOW, 0);
}

PostgreSQLParser::Common_func_opt_itemContext* PostgreSQLParser::Createfunc_opt_itemContext::common_func_opt_item() {
  return getRuleContext<PostgreSQLParser::Common_func_opt_itemContext>(0);
}


size_t PostgreSQLParser::Createfunc_opt_itemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatefunc_opt_item;
}


std::any PostgreSQLParser::Createfunc_opt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatefunc_opt_item(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Createfunc_opt_itemContext* PostgreSQLParser::createfunc_opt_item() {
  Createfunc_opt_itemContext *_localctx = _tracker.createInstance<Createfunc_opt_itemContext>(_ctx, getState());
  enterRule(_localctx, 658, PostgreSQLParser::RuleCreatefunc_opt_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5676);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::AS: {
        enterOuterAlt(_localctx, 1);
        setState(5668);
        match(PostgreSQLParser::AS);
        setState(5669);
        func_as();
        break;
      }

      case PostgreSQLParser::LANGUAGE: {
        enterOuterAlt(_localctx, 2);
        setState(5670);
        match(PostgreSQLParser::LANGUAGE);
        setState(5671);
        nonreservedword_or_sconst();
        break;
      }

      case PostgreSQLParser::TRANSFORM: {
        enterOuterAlt(_localctx, 3);
        setState(5672);
        match(PostgreSQLParser::TRANSFORM);
        setState(5673);
        transform_type_list();
        break;
      }

      case PostgreSQLParser::WINDOW: {
        enterOuterAlt(_localctx, 4);
        setState(5674);
        match(PostgreSQLParser::WINDOW);
        break;
      }

      case PostgreSQLParser::NOT:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL: {
        enterOuterAlt(_localctx, 5);
        setState(5675);
        common_func_opt_item();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_asContext ------------------------------------------------------------------

PostgreSQLParser::Func_asContext::Func_asContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::SconstContext *> PostgreSQLParser::Func_asContext::sconst() {
  return getRuleContexts<PostgreSQLParser::SconstContext>();
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Func_asContext::sconst(size_t i) {
  return getRuleContext<PostgreSQLParser::SconstContext>(i);
}

tree::TerminalNode* PostgreSQLParser::Func_asContext::COMMA() {
  return getToken(PostgreSQLParser::COMMA, 0);
}


size_t PostgreSQLParser::Func_asContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunc_as;
}


std::any PostgreSQLParser::Func_asContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunc_as(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Func_asContext* PostgreSQLParser::func_as() {
  Func_asContext *_localctx = _tracker.createInstance<Func_asContext>(_ctx, getState());
  enterRule(_localctx, 660, PostgreSQLParser::RuleFunc_as);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5683);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 495, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5678);
      antlrcpp::downCast<Func_asContext *>(_localctx)->def = sconst();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5679);
      sconst();
      setState(5680);
      match(PostgreSQLParser::COMMA);
      setState(5681);
      sconst();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Transform_type_listContext ------------------------------------------------------------------

PostgreSQLParser::Transform_type_listContext::Transform_type_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Transform_type_listContext::FOR() {
  return getTokens(PostgreSQLParser::FOR);
}

tree::TerminalNode* PostgreSQLParser::Transform_type_listContext::FOR(size_t i) {
  return getToken(PostgreSQLParser::FOR, i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Transform_type_listContext::TYPE_P() {
  return getTokens(PostgreSQLParser::TYPE_P);
}

tree::TerminalNode* PostgreSQLParser::Transform_type_listContext::TYPE_P(size_t i) {
  return getToken(PostgreSQLParser::TYPE_P, i);
}

std::vector<PostgreSQLParser::TypenameContext *> PostgreSQLParser::Transform_type_listContext::typename_() {
  return getRuleContexts<PostgreSQLParser::TypenameContext>();
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::Transform_type_listContext::typename_(size_t i) {
  return getRuleContext<PostgreSQLParser::TypenameContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Transform_type_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Transform_type_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Transform_type_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTransform_type_list;
}


std::any PostgreSQLParser::Transform_type_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTransform_type_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Transform_type_listContext* PostgreSQLParser::transform_type_list() {
  Transform_type_listContext *_localctx = _tracker.createInstance<Transform_type_listContext>(_ctx, getState());
  enterRule(_localctx, 662, PostgreSQLParser::RuleTransform_type_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5685);
    match(PostgreSQLParser::FOR);
    setState(5686);
    match(PostgreSQLParser::TYPE_P);
    setState(5687);
    typename_();
    setState(5694);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(5688);
      match(PostgreSQLParser::COMMA);
      setState(5689);
      match(PostgreSQLParser::FOR);
      setState(5690);
      match(PostgreSQLParser::TYPE_P);
      setState(5691);
      typename_();
      setState(5696);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Definition_Context ------------------------------------------------------------------

PostgreSQLParser::Definition_Context::Definition_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Definition_Context::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

PostgreSQLParser::DefinitionContext* PostgreSQLParser::Definition_Context::definition() {
  return getRuleContext<PostgreSQLParser::DefinitionContext>(0);
}


size_t PostgreSQLParser::Definition_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleDefinition_;
}


std::any PostgreSQLParser::Definition_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDefinition_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Definition_Context* PostgreSQLParser::definition_() {
  Definition_Context *_localctx = _tracker.createInstance<Definition_Context>(_ctx, getState());
  enterRule(_localctx, 664, PostgreSQLParser::RuleDefinition_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5697);
    match(PostgreSQLParser::WITH);
    setState(5698);
    definition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_func_columnContext ------------------------------------------------------------------

PostgreSQLParser::Table_func_columnContext::Table_func_columnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Param_nameContext* PostgreSQLParser::Table_func_columnContext::param_name() {
  return getRuleContext<PostgreSQLParser::Param_nameContext>(0);
}

PostgreSQLParser::Func_typeContext* PostgreSQLParser::Table_func_columnContext::func_type() {
  return getRuleContext<PostgreSQLParser::Func_typeContext>(0);
}


size_t PostgreSQLParser::Table_func_columnContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTable_func_column;
}


std::any PostgreSQLParser::Table_func_columnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTable_func_column(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Table_func_columnContext* PostgreSQLParser::table_func_column() {
  Table_func_columnContext *_localctx = _tracker.createInstance<Table_func_columnContext>(_ctx, getState());
  enterRule(_localctx, 666, PostgreSQLParser::RuleTable_func_column);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5700);
    param_name();
    setState(5701);
    func_type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_func_column_listContext ------------------------------------------------------------------

PostgreSQLParser::Table_func_column_listContext::Table_func_column_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Table_func_columnContext *> PostgreSQLParser::Table_func_column_listContext::table_func_column() {
  return getRuleContexts<PostgreSQLParser::Table_func_columnContext>();
}

PostgreSQLParser::Table_func_columnContext* PostgreSQLParser::Table_func_column_listContext::table_func_column(size_t i) {
  return getRuleContext<PostgreSQLParser::Table_func_columnContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Table_func_column_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Table_func_column_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Table_func_column_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTable_func_column_list;
}


std::any PostgreSQLParser::Table_func_column_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTable_func_column_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Table_func_column_listContext* PostgreSQLParser::table_func_column_list() {
  Table_func_column_listContext *_localctx = _tracker.createInstance<Table_func_column_listContext>(_ctx, getState());
  enterRule(_localctx, 668, PostgreSQLParser::RuleTable_func_column_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5703);
    table_func_column();
    setState(5708);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(5704);
      match(PostgreSQLParser::COMMA);
      setState(5705);
      table_func_column();
      setState(5710);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterfunctionstmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterfunctionstmtContext::AlterfunctionstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterfunctionstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

PostgreSQLParser::Function_with_argtypesContext* PostgreSQLParser::AlterfunctionstmtContext::function_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Function_with_argtypesContext>(0);
}

PostgreSQLParser::Alterfunc_opt_listContext* PostgreSQLParser::AlterfunctionstmtContext::alterfunc_opt_list() {
  return getRuleContext<PostgreSQLParser::Alterfunc_opt_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterfunctionstmtContext::FUNCTION() {
  return getToken(PostgreSQLParser::FUNCTION, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterfunctionstmtContext::PROCEDURE() {
  return getToken(PostgreSQLParser::PROCEDURE, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterfunctionstmtContext::ROUTINE() {
  return getToken(PostgreSQLParser::ROUTINE, 0);
}

PostgreSQLParser::Restrict_Context* PostgreSQLParser::AlterfunctionstmtContext::restrict_() {
  return getRuleContext<PostgreSQLParser::Restrict_Context>(0);
}


size_t PostgreSQLParser::AlterfunctionstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterfunctionstmt;
}


std::any PostgreSQLParser::AlterfunctionstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterfunctionstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterfunctionstmtContext* PostgreSQLParser::alterfunctionstmt() {
  AlterfunctionstmtContext *_localctx = _tracker.createInstance<AlterfunctionstmtContext>(_ctx, getState());
  enterRule(_localctx, 670, PostgreSQLParser::RuleAlterfunctionstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5711);
    match(PostgreSQLParser::ALTER);
    setState(5712);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::FUNCTION || _la == PostgreSQLParser::PROCEDURE || _la == PostgreSQLParser::ROUTINE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5713);
    function_with_argtypes();
    setState(5714);
    alterfunc_opt_list();
    setState(5716);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::RESTRICT) {
      setState(5715);
      restrict_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alterfunc_opt_listContext ------------------------------------------------------------------

PostgreSQLParser::Alterfunc_opt_listContext::Alterfunc_opt_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Common_func_opt_itemContext *> PostgreSQLParser::Alterfunc_opt_listContext::common_func_opt_item() {
  return getRuleContexts<PostgreSQLParser::Common_func_opt_itemContext>();
}

PostgreSQLParser::Common_func_opt_itemContext* PostgreSQLParser::Alterfunc_opt_listContext::common_func_opt_item(size_t i) {
  return getRuleContext<PostgreSQLParser::Common_func_opt_itemContext>(i);
}


size_t PostgreSQLParser::Alterfunc_opt_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterfunc_opt_list;
}


std::any PostgreSQLParser::Alterfunc_opt_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterfunc_opt_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Alterfunc_opt_listContext* PostgreSQLParser::alterfunc_opt_list() {
  Alterfunc_opt_listContext *_localctx = _tracker.createInstance<Alterfunc_opt_listContext>(_ctx, getState());
  enterRule(_localctx, 672, PostgreSQLParser::RuleAlterfunc_opt_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5719); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(5718);
      common_func_opt_item();
      setState(5721); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == PostgreSQLParser::NOT || ((((_la - 187) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 187)) & 72057594040025089) != 0) || _la == PostgreSQLParser::IMMUTABLE

    || _la == PostgreSQLParser::LEAKPROOF || ((((_la - 344) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 344)) & 8624554121) != 0) || _la == PostgreSQLParser::VOLATILE || _la == PostgreSQLParser::SUPPORT

    || _la == PostgreSQLParser::PARALLEL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Restrict_Context ------------------------------------------------------------------

PostgreSQLParser::Restrict_Context::Restrict_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Restrict_Context::RESTRICT() {
  return getToken(PostgreSQLParser::RESTRICT, 0);
}


size_t PostgreSQLParser::Restrict_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleRestrict_;
}


std::any PostgreSQLParser::Restrict_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRestrict_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Restrict_Context* PostgreSQLParser::restrict_() {
  Restrict_Context *_localctx = _tracker.createInstance<Restrict_Context>(_ctx, getState());
  enterRule(_localctx, 674, PostgreSQLParser::RuleRestrict_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5723);
    match(PostgreSQLParser::RESTRICT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RemovefuncstmtContext ------------------------------------------------------------------

PostgreSQLParser::RemovefuncstmtContext::RemovefuncstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::RemovefuncstmtContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

tree::TerminalNode* PostgreSQLParser::RemovefuncstmtContext::FUNCTION() {
  return getToken(PostgreSQLParser::FUNCTION, 0);
}

PostgreSQLParser::Function_with_argtypes_listContext* PostgreSQLParser::RemovefuncstmtContext::function_with_argtypes_list() {
  return getRuleContext<PostgreSQLParser::Function_with_argtypes_listContext>(0);
}

PostgreSQLParser::Drop_behavior_Context* PostgreSQLParser::RemovefuncstmtContext::drop_behavior_() {
  return getRuleContext<PostgreSQLParser::Drop_behavior_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::RemovefuncstmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::RemovefuncstmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

tree::TerminalNode* PostgreSQLParser::RemovefuncstmtContext::PROCEDURE() {
  return getToken(PostgreSQLParser::PROCEDURE, 0);
}

tree::TerminalNode* PostgreSQLParser::RemovefuncstmtContext::ROUTINE() {
  return getToken(PostgreSQLParser::ROUTINE, 0);
}


size_t PostgreSQLParser::RemovefuncstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRemovefuncstmt;
}


std::any PostgreSQLParser::RemovefuncstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRemovefuncstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RemovefuncstmtContext* PostgreSQLParser::removefuncstmt() {
  RemovefuncstmtContext *_localctx = _tracker.createInstance<RemovefuncstmtContext>(_ctx, getState());
  enterRule(_localctx, 676, PostgreSQLParser::RuleRemovefuncstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5767);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 506, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5725);
      match(PostgreSQLParser::DROP);
      setState(5726);
      match(PostgreSQLParser::FUNCTION);
      setState(5727);
      function_with_argtypes_list();
      setState(5729);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(5728);
        drop_behavior_();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5731);
      match(PostgreSQLParser::DROP);
      setState(5732);
      match(PostgreSQLParser::FUNCTION);
      setState(5733);
      match(PostgreSQLParser::IF_P);
      setState(5734);
      match(PostgreSQLParser::EXISTS);
      setState(5735);
      function_with_argtypes_list();
      setState(5737);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(5736);
        drop_behavior_();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5739);
      match(PostgreSQLParser::DROP);
      setState(5740);
      match(PostgreSQLParser::PROCEDURE);
      setState(5741);
      function_with_argtypes_list();
      setState(5743);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(5742);
        drop_behavior_();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5745);
      match(PostgreSQLParser::DROP);
      setState(5746);
      match(PostgreSQLParser::PROCEDURE);
      setState(5747);
      match(PostgreSQLParser::IF_P);
      setState(5748);
      match(PostgreSQLParser::EXISTS);
      setState(5749);
      function_with_argtypes_list();
      setState(5751);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(5750);
        drop_behavior_();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5753);
      match(PostgreSQLParser::DROP);
      setState(5754);
      match(PostgreSQLParser::ROUTINE);
      setState(5755);
      function_with_argtypes_list();
      setState(5757);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(5756);
        drop_behavior_();
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(5759);
      match(PostgreSQLParser::DROP);
      setState(5760);
      match(PostgreSQLParser::ROUTINE);
      setState(5761);
      match(PostgreSQLParser::IF_P);
      setState(5762);
      match(PostgreSQLParser::EXISTS);
      setState(5763);
      function_with_argtypes_list();
      setState(5765);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(5764);
        drop_behavior_();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RemoveaggrstmtContext ------------------------------------------------------------------

PostgreSQLParser::RemoveaggrstmtContext::RemoveaggrstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::RemoveaggrstmtContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

tree::TerminalNode* PostgreSQLParser::RemoveaggrstmtContext::AGGREGATE() {
  return getToken(PostgreSQLParser::AGGREGATE, 0);
}

PostgreSQLParser::Aggregate_with_argtypes_listContext* PostgreSQLParser::RemoveaggrstmtContext::aggregate_with_argtypes_list() {
  return getRuleContext<PostgreSQLParser::Aggregate_with_argtypes_listContext>(0);
}

PostgreSQLParser::Drop_behavior_Context* PostgreSQLParser::RemoveaggrstmtContext::drop_behavior_() {
  return getRuleContext<PostgreSQLParser::Drop_behavior_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::RemoveaggrstmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::RemoveaggrstmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}


size_t PostgreSQLParser::RemoveaggrstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRemoveaggrstmt;
}


std::any PostgreSQLParser::RemoveaggrstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRemoveaggrstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RemoveaggrstmtContext* PostgreSQLParser::removeaggrstmt() {
  RemoveaggrstmtContext *_localctx = _tracker.createInstance<RemoveaggrstmtContext>(_ctx, getState());
  enterRule(_localctx, 678, PostgreSQLParser::RuleRemoveaggrstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5783);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 509, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5769);
      match(PostgreSQLParser::DROP);
      setState(5770);
      match(PostgreSQLParser::AGGREGATE);
      setState(5771);
      aggregate_with_argtypes_list();
      setState(5773);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(5772);
        drop_behavior_();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5775);
      match(PostgreSQLParser::DROP);
      setState(5776);
      match(PostgreSQLParser::AGGREGATE);
      setState(5777);
      match(PostgreSQLParser::IF_P);
      setState(5778);
      match(PostgreSQLParser::EXISTS);
      setState(5779);
      aggregate_with_argtypes_list();
      setState(5781);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(5780);
        drop_behavior_();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RemoveoperstmtContext ------------------------------------------------------------------

PostgreSQLParser::RemoveoperstmtContext::RemoveoperstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::RemoveoperstmtContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

tree::TerminalNode* PostgreSQLParser::RemoveoperstmtContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

PostgreSQLParser::Operator_with_argtypes_listContext* PostgreSQLParser::RemoveoperstmtContext::operator_with_argtypes_list() {
  return getRuleContext<PostgreSQLParser::Operator_with_argtypes_listContext>(0);
}

PostgreSQLParser::Drop_behavior_Context* PostgreSQLParser::RemoveoperstmtContext::drop_behavior_() {
  return getRuleContext<PostgreSQLParser::Drop_behavior_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::RemoveoperstmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::RemoveoperstmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}


size_t PostgreSQLParser::RemoveoperstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRemoveoperstmt;
}


std::any PostgreSQLParser::RemoveoperstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRemoveoperstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RemoveoperstmtContext* PostgreSQLParser::removeoperstmt() {
  RemoveoperstmtContext *_localctx = _tracker.createInstance<RemoveoperstmtContext>(_ctx, getState());
  enterRule(_localctx, 680, PostgreSQLParser::RuleRemoveoperstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5799);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 512, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5785);
      match(PostgreSQLParser::DROP);
      setState(5786);
      match(PostgreSQLParser::OPERATOR);
      setState(5787);
      operator_with_argtypes_list();
      setState(5789);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(5788);
        drop_behavior_();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5791);
      match(PostgreSQLParser::DROP);
      setState(5792);
      match(PostgreSQLParser::OPERATOR);
      setState(5793);
      match(PostgreSQLParser::IF_P);
      setState(5794);
      match(PostgreSQLParser::EXISTS);
      setState(5795);
      operator_with_argtypes_list();
      setState(5797);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(5796);
        drop_behavior_();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Oper_argtypesContext ------------------------------------------------------------------

PostgreSQLParser::Oper_argtypesContext::Oper_argtypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Oper_argtypesContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

std::vector<PostgreSQLParser::TypenameContext *> PostgreSQLParser::Oper_argtypesContext::typename_() {
  return getRuleContexts<PostgreSQLParser::TypenameContext>();
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::Oper_argtypesContext::typename_(size_t i) {
  return getRuleContext<PostgreSQLParser::TypenameContext>(i);
}

tree::TerminalNode* PostgreSQLParser::Oper_argtypesContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::Oper_argtypesContext::COMMA() {
  return getToken(PostgreSQLParser::COMMA, 0);
}

tree::TerminalNode* PostgreSQLParser::Oper_argtypesContext::NONE() {
  return getToken(PostgreSQLParser::NONE, 0);
}


size_t PostgreSQLParser::Oper_argtypesContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOper_argtypes;
}


std::any PostgreSQLParser::Oper_argtypesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOper_argtypes(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Oper_argtypesContext* PostgreSQLParser::oper_argtypes() {
  Oper_argtypesContext *_localctx = _tracker.createInstance<Oper_argtypesContext>(_ctx, getState());
  enterRule(_localctx, 682, PostgreSQLParser::RuleOper_argtypes);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5823);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 513, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5801);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(5802);
      typename_();
      setState(5803);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5805);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(5806);
      typename_();
      setState(5807);
      match(PostgreSQLParser::COMMA);
      setState(5808);
      typename_();
      setState(5809);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5811);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(5812);
      match(PostgreSQLParser::NONE);
      setState(5813);
      match(PostgreSQLParser::COMMA);
      setState(5814);
      typename_();
      setState(5815);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5817);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(5818);
      typename_();
      setState(5819);
      match(PostgreSQLParser::COMMA);
      setState(5820);
      match(PostgreSQLParser::NONE);
      setState(5821);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Any_operatorContext ------------------------------------------------------------------

PostgreSQLParser::Any_operatorContext::Any_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::All_opContext* PostgreSQLParser::Any_operatorContext::all_op() {
  return getRuleContext<PostgreSQLParser::All_opContext>(0);
}

std::vector<PostgreSQLParser::ColidContext *> PostgreSQLParser::Any_operatorContext::colid() {
  return getRuleContexts<PostgreSQLParser::ColidContext>();
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Any_operatorContext::colid(size_t i) {
  return getRuleContext<PostgreSQLParser::ColidContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Any_operatorContext::DOT() {
  return getTokens(PostgreSQLParser::DOT);
}

tree::TerminalNode* PostgreSQLParser::Any_operatorContext::DOT(size_t i) {
  return getToken(PostgreSQLParser::DOT, i);
}


size_t PostgreSQLParser::Any_operatorContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAny_operator;
}


std::any PostgreSQLParser::Any_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAny_operator(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Any_operatorContext* PostgreSQLParser::any_operator() {
  Any_operatorContext *_localctx = _tracker.createInstance<Any_operatorContext>(_ctx, getState());
  enterRule(_localctx, 684, PostgreSQLParser::RuleAny_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5830);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 30) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 30)) & 137438949375) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 553)) & 536870983) != 0)) {
      setState(5825);
      colid();
      setState(5826);
      match(PostgreSQLParser::DOT);
      setState(5832);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5833);
    all_op();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Operator_with_argtypes_listContext ------------------------------------------------------------------

PostgreSQLParser::Operator_with_argtypes_listContext::Operator_with_argtypes_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Operator_with_argtypesContext *> PostgreSQLParser::Operator_with_argtypes_listContext::operator_with_argtypes() {
  return getRuleContexts<PostgreSQLParser::Operator_with_argtypesContext>();
}

PostgreSQLParser::Operator_with_argtypesContext* PostgreSQLParser::Operator_with_argtypes_listContext::operator_with_argtypes(size_t i) {
  return getRuleContext<PostgreSQLParser::Operator_with_argtypesContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Operator_with_argtypes_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Operator_with_argtypes_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Operator_with_argtypes_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOperator_with_argtypes_list;
}


std::any PostgreSQLParser::Operator_with_argtypes_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOperator_with_argtypes_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Operator_with_argtypes_listContext* PostgreSQLParser::operator_with_argtypes_list() {
  Operator_with_argtypes_listContext *_localctx = _tracker.createInstance<Operator_with_argtypes_listContext>(_ctx, getState());
  enterRule(_localctx, 686, PostgreSQLParser::RuleOperator_with_argtypes_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5835);
    operator_with_argtypes();
    setState(5840);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(5836);
      match(PostgreSQLParser::COMMA);
      setState(5837);
      operator_with_argtypes();
      setState(5842);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Operator_with_argtypesContext ------------------------------------------------------------------

PostgreSQLParser::Operator_with_argtypesContext::Operator_with_argtypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Any_operatorContext* PostgreSQLParser::Operator_with_argtypesContext::any_operator() {
  return getRuleContext<PostgreSQLParser::Any_operatorContext>(0);
}

PostgreSQLParser::Oper_argtypesContext* PostgreSQLParser::Operator_with_argtypesContext::oper_argtypes() {
  return getRuleContext<PostgreSQLParser::Oper_argtypesContext>(0);
}


size_t PostgreSQLParser::Operator_with_argtypesContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOperator_with_argtypes;
}


std::any PostgreSQLParser::Operator_with_argtypesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOperator_with_argtypes(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Operator_with_argtypesContext* PostgreSQLParser::operator_with_argtypes() {
  Operator_with_argtypesContext *_localctx = _tracker.createInstance<Operator_with_argtypesContext>(_ctx, getState());
  enterRule(_localctx, 688, PostgreSQLParser::RuleOperator_with_argtypes);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5843);
    any_operator();
    setState(5844);
    oper_argtypes();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DostmtContext ------------------------------------------------------------------

PostgreSQLParser::DostmtContext::DostmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DostmtContext::DO() {
  return getToken(PostgreSQLParser::DO, 0);
}

PostgreSQLParser::Dostmt_opt_listContext* PostgreSQLParser::DostmtContext::dostmt_opt_list() {
  return getRuleContext<PostgreSQLParser::Dostmt_opt_listContext>(0);
}


size_t PostgreSQLParser::DostmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDostmt;
}


std::any PostgreSQLParser::DostmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDostmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DostmtContext* PostgreSQLParser::dostmt() {
  DostmtContext *_localctx = _tracker.createInstance<DostmtContext>(_ctx, getState());
  enterRule(_localctx, 690, PostgreSQLParser::RuleDostmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5846);
    match(PostgreSQLParser::DO);
    setState(5847);
    dostmt_opt_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dostmt_opt_listContext ------------------------------------------------------------------

PostgreSQLParser::Dostmt_opt_listContext::Dostmt_opt_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Dostmt_opt_itemContext *> PostgreSQLParser::Dostmt_opt_listContext::dostmt_opt_item() {
  return getRuleContexts<PostgreSQLParser::Dostmt_opt_itemContext>();
}

PostgreSQLParser::Dostmt_opt_itemContext* PostgreSQLParser::Dostmt_opt_listContext::dostmt_opt_item(size_t i) {
  return getRuleContext<PostgreSQLParser::Dostmt_opt_itemContext>(i);
}


size_t PostgreSQLParser::Dostmt_opt_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDostmt_opt_list;
}


std::any PostgreSQLParser::Dostmt_opt_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDostmt_opt_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Dostmt_opt_listContext* PostgreSQLParser::dostmt_opt_list() {
  Dostmt_opt_listContext *_localctx = _tracker.createInstance<Dostmt_opt_listContext>(_ctx, getState());
  enterRule(_localctx, 692, PostgreSQLParser::RuleDostmt_opt_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5850); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(5849);
      dostmt_opt_item();
      setState(5852); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == PostgreSQLParser::LANGUAGE || ((((_la - 563) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 563)) & 134217749) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dostmt_opt_itemContext ------------------------------------------------------------------

PostgreSQLParser::Dostmt_opt_itemContext::Dostmt_opt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Dostmt_opt_itemContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Dostmt_opt_itemContext::LANGUAGE() {
  return getToken(PostgreSQLParser::LANGUAGE, 0);
}

PostgreSQLParser::Nonreservedword_or_sconstContext* PostgreSQLParser::Dostmt_opt_itemContext::nonreservedword_or_sconst() {
  return getRuleContext<PostgreSQLParser::Nonreservedword_or_sconstContext>(0);
}


size_t PostgreSQLParser::Dostmt_opt_itemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDostmt_opt_item;
}


std::any PostgreSQLParser::Dostmt_opt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDostmt_opt_item(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Dostmt_opt_itemContext* PostgreSQLParser::dostmt_opt_item() {
  Dostmt_opt_itemContext *_localctx = _tracker.createInstance<Dostmt_opt_itemContext>(_ctx, getState());
  enterRule(_localctx, 694, PostgreSQLParser::RuleDostmt_opt_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5857);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::EscapeStringConstant: {
        enterOuterAlt(_localctx, 1);
        setState(5854);
        sconst();
        break;
      }

      case PostgreSQLParser::LANGUAGE: {
        enterOuterAlt(_localctx, 2);
        setState(5855);
        match(PostgreSQLParser::LANGUAGE);
        setState(5856);
        nonreservedword_or_sconst();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreatecaststmtContext ------------------------------------------------------------------

PostgreSQLParser::CreatecaststmtContext::CreatecaststmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreatecaststmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatecaststmtContext::CAST() {
  return getToken(PostgreSQLParser::CAST, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatecaststmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

std::vector<PostgreSQLParser::TypenameContext *> PostgreSQLParser::CreatecaststmtContext::typename_() {
  return getRuleContexts<PostgreSQLParser::TypenameContext>();
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::CreatecaststmtContext::typename_(size_t i) {
  return getRuleContext<PostgreSQLParser::TypenameContext>(i);
}

tree::TerminalNode* PostgreSQLParser::CreatecaststmtContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatecaststmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatecaststmtContext::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatecaststmtContext::FUNCTION() {
  return getToken(PostgreSQLParser::FUNCTION, 0);
}

PostgreSQLParser::Function_with_argtypesContext* PostgreSQLParser::CreatecaststmtContext::function_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Function_with_argtypesContext>(0);
}

PostgreSQLParser::Cast_contextContext* PostgreSQLParser::CreatecaststmtContext::cast_context() {
  return getRuleContext<PostgreSQLParser::Cast_contextContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatecaststmtContext::WITHOUT() {
  return getToken(PostgreSQLParser::WITHOUT, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatecaststmtContext::INOUT() {
  return getToken(PostgreSQLParser::INOUT, 0);
}


size_t PostgreSQLParser::CreatecaststmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatecaststmt;
}


std::any PostgreSQLParser::CreatecaststmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatecaststmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreatecaststmtContext* PostgreSQLParser::createcaststmt() {
  CreatecaststmtContext *_localctx = _tracker.createInstance<CreatecaststmtContext>(_ctx, getState());
  enterRule(_localctx, 696, PostgreSQLParser::RuleCreatecaststmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5896);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 521, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5859);
      match(PostgreSQLParser::CREATE);
      setState(5860);
      match(PostgreSQLParser::CAST);
      setState(5861);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(5862);
      typename_();
      setState(5863);
      match(PostgreSQLParser::AS);
      setState(5864);
      typename_();
      setState(5865);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(5866);
      match(PostgreSQLParser::WITH);
      setState(5867);
      match(PostgreSQLParser::FUNCTION);
      setState(5868);
      function_with_argtypes();
      setState(5870);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::AS) {
        setState(5869);
        cast_context();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5872);
      match(PostgreSQLParser::CREATE);
      setState(5873);
      match(PostgreSQLParser::CAST);
      setState(5874);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(5875);
      typename_();
      setState(5876);
      match(PostgreSQLParser::AS);
      setState(5877);
      typename_();
      setState(5878);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(5879);
      match(PostgreSQLParser::WITHOUT);
      setState(5880);
      match(PostgreSQLParser::FUNCTION);
      setState(5882);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::AS) {
        setState(5881);
        cast_context();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5884);
      match(PostgreSQLParser::CREATE);
      setState(5885);
      match(PostgreSQLParser::CAST);
      setState(5886);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(5887);
      typename_();
      setState(5888);
      match(PostgreSQLParser::AS);
      setState(5889);
      typename_();
      setState(5890);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(5891);
      match(PostgreSQLParser::WITH);
      setState(5892);
      match(PostgreSQLParser::INOUT);
      setState(5894);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::AS) {
        setState(5893);
        cast_context();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cast_contextContext ------------------------------------------------------------------

PostgreSQLParser::Cast_contextContext::Cast_contextContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Cast_contextContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

tree::TerminalNode* PostgreSQLParser::Cast_contextContext::IMPLICIT_P() {
  return getToken(PostgreSQLParser::IMPLICIT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Cast_contextContext::ASSIGNMENT() {
  return getToken(PostgreSQLParser::ASSIGNMENT, 0);
}


size_t PostgreSQLParser::Cast_contextContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCast_context;
}


std::any PostgreSQLParser::Cast_contextContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCast_context(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Cast_contextContext* PostgreSQLParser::cast_context() {
  Cast_contextContext *_localctx = _tracker.createInstance<Cast_contextContext>(_ctx, getState());
  enterRule(_localctx, 698, PostgreSQLParser::RuleCast_context);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5902);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 522, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5898);
      match(PostgreSQLParser::AS);
      setState(5899);
      match(PostgreSQLParser::IMPLICIT_P);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5900);
      match(PostgreSQLParser::AS);
      setState(5901);
      match(PostgreSQLParser::ASSIGNMENT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropcaststmtContext ------------------------------------------------------------------

PostgreSQLParser::DropcaststmtContext::DropcaststmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DropcaststmtContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

tree::TerminalNode* PostgreSQLParser::DropcaststmtContext::CAST() {
  return getToken(PostgreSQLParser::CAST, 0);
}

tree::TerminalNode* PostgreSQLParser::DropcaststmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

std::vector<PostgreSQLParser::TypenameContext *> PostgreSQLParser::DropcaststmtContext::typename_() {
  return getRuleContexts<PostgreSQLParser::TypenameContext>();
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::DropcaststmtContext::typename_(size_t i) {
  return getRuleContext<PostgreSQLParser::TypenameContext>(i);
}

tree::TerminalNode* PostgreSQLParser::DropcaststmtContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

tree::TerminalNode* PostgreSQLParser::DropcaststmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::If_exists_Context* PostgreSQLParser::DropcaststmtContext::if_exists_() {
  return getRuleContext<PostgreSQLParser::If_exists_Context>(0);
}

PostgreSQLParser::Drop_behavior_Context* PostgreSQLParser::DropcaststmtContext::drop_behavior_() {
  return getRuleContext<PostgreSQLParser::Drop_behavior_Context>(0);
}


size_t PostgreSQLParser::DropcaststmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDropcaststmt;
}


std::any PostgreSQLParser::DropcaststmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDropcaststmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DropcaststmtContext* PostgreSQLParser::dropcaststmt() {
  DropcaststmtContext *_localctx = _tracker.createInstance<DropcaststmtContext>(_ctx, getState());
  enterRule(_localctx, 700, PostgreSQLParser::RuleDropcaststmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5904);
    match(PostgreSQLParser::DROP);
    setState(5905);
    match(PostgreSQLParser::CAST);
    setState(5907);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::IF_P) {
      setState(5906);
      if_exists_();
    }
    setState(5909);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(5910);
    typename_();
    setState(5911);
    match(PostgreSQLParser::AS);
    setState(5912);
    typename_();
    setState(5913);
    match(PostgreSQLParser::CLOSE_PAREN);
    setState(5915);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
      setState(5914);
      drop_behavior_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_exists_Context ------------------------------------------------------------------

PostgreSQLParser::If_exists_Context::If_exists_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::If_exists_Context::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::If_exists_Context::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}


size_t PostgreSQLParser::If_exists_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleIf_exists_;
}


std::any PostgreSQLParser::If_exists_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitIf_exists_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::If_exists_Context* PostgreSQLParser::if_exists_() {
  If_exists_Context *_localctx = _tracker.createInstance<If_exists_Context>(_ctx, getState());
  enterRule(_localctx, 702, PostgreSQLParser::RuleIf_exists_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5917);
    match(PostgreSQLParser::IF_P);
    setState(5918);
    match(PostgreSQLParser::EXISTS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreatetransformstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreatetransformstmtContext::CreatetransformstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreatetransformstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatetransformstmtContext::TRANSFORM() {
  return getToken(PostgreSQLParser::TRANSFORM, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatetransformstmtContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::CreatetransformstmtContext::typename_() {
  return getRuleContext<PostgreSQLParser::TypenameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatetransformstmtContext::LANGUAGE() {
  return getToken(PostgreSQLParser::LANGUAGE, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::CreatetransformstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatetransformstmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Transform_element_listContext* PostgreSQLParser::CreatetransformstmtContext::transform_element_list() {
  return getRuleContext<PostgreSQLParser::Transform_element_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatetransformstmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::Or_replace_Context* PostgreSQLParser::CreatetransformstmtContext::or_replace_() {
  return getRuleContext<PostgreSQLParser::Or_replace_Context>(0);
}


size_t PostgreSQLParser::CreatetransformstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatetransformstmt;
}


std::any PostgreSQLParser::CreatetransformstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatetransformstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreatetransformstmtContext* PostgreSQLParser::createtransformstmt() {
  CreatetransformstmtContext *_localctx = _tracker.createInstance<CreatetransformstmtContext>(_ctx, getState());
  enterRule(_localctx, 704, PostgreSQLParser::RuleCreatetransformstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5920);
    match(PostgreSQLParser::CREATE);
    setState(5922);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OR) {
      setState(5921);
      or_replace_();
    }
    setState(5924);
    match(PostgreSQLParser::TRANSFORM);
    setState(5925);
    match(PostgreSQLParser::FOR);
    setState(5926);
    typename_();
    setState(5927);
    match(PostgreSQLParser::LANGUAGE);
    setState(5928);
    name();
    setState(5929);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(5930);
    transform_element_list();
    setState(5931);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Transform_element_listContext ------------------------------------------------------------------

PostgreSQLParser::Transform_element_listContext::Transform_element_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Transform_element_listContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Transform_element_listContext::SQL_P() {
  return getTokens(PostgreSQLParser::SQL_P);
}

tree::TerminalNode* PostgreSQLParser::Transform_element_listContext::SQL_P(size_t i) {
  return getToken(PostgreSQLParser::SQL_P, i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Transform_element_listContext::WITH() {
  return getTokens(PostgreSQLParser::WITH);
}

tree::TerminalNode* PostgreSQLParser::Transform_element_listContext::WITH(size_t i) {
  return getToken(PostgreSQLParser::WITH, i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Transform_element_listContext::FUNCTION() {
  return getTokens(PostgreSQLParser::FUNCTION);
}

tree::TerminalNode* PostgreSQLParser::Transform_element_listContext::FUNCTION(size_t i) {
  return getToken(PostgreSQLParser::FUNCTION, i);
}

std::vector<PostgreSQLParser::Function_with_argtypesContext *> PostgreSQLParser::Transform_element_listContext::function_with_argtypes() {
  return getRuleContexts<PostgreSQLParser::Function_with_argtypesContext>();
}

PostgreSQLParser::Function_with_argtypesContext* PostgreSQLParser::Transform_element_listContext::function_with_argtypes(size_t i) {
  return getRuleContext<PostgreSQLParser::Function_with_argtypesContext>(i);
}

tree::TerminalNode* PostgreSQLParser::Transform_element_listContext::COMMA() {
  return getToken(PostgreSQLParser::COMMA, 0);
}

tree::TerminalNode* PostgreSQLParser::Transform_element_listContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}


size_t PostgreSQLParser::Transform_element_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTransform_element_list;
}


std::any PostgreSQLParser::Transform_element_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTransform_element_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Transform_element_listContext* PostgreSQLParser::transform_element_list() {
  Transform_element_listContext *_localctx = _tracker.createInstance<Transform_element_listContext>(_ctx, getState());
  enterRule(_localctx, 706, PostgreSQLParser::RuleTransform_element_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5967);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 526, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5933);
      match(PostgreSQLParser::FROM);
      setState(5934);
      match(PostgreSQLParser::SQL_P);
      setState(5935);
      match(PostgreSQLParser::WITH);
      setState(5936);
      match(PostgreSQLParser::FUNCTION);
      setState(5937);
      function_with_argtypes();
      setState(5938);
      match(PostgreSQLParser::COMMA);
      setState(5939);
      match(PostgreSQLParser::TO);
      setState(5940);
      match(PostgreSQLParser::SQL_P);
      setState(5941);
      match(PostgreSQLParser::WITH);
      setState(5942);
      match(PostgreSQLParser::FUNCTION);
      setState(5943);
      function_with_argtypes();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5945);
      match(PostgreSQLParser::TO);
      setState(5946);
      match(PostgreSQLParser::SQL_P);
      setState(5947);
      match(PostgreSQLParser::WITH);
      setState(5948);
      match(PostgreSQLParser::FUNCTION);
      setState(5949);
      function_with_argtypes();
      setState(5950);
      match(PostgreSQLParser::COMMA);
      setState(5951);
      match(PostgreSQLParser::FROM);
      setState(5952);
      match(PostgreSQLParser::SQL_P);
      setState(5953);
      match(PostgreSQLParser::WITH);
      setState(5954);
      match(PostgreSQLParser::FUNCTION);
      setState(5955);
      function_with_argtypes();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5957);
      match(PostgreSQLParser::FROM);
      setState(5958);
      match(PostgreSQLParser::SQL_P);
      setState(5959);
      match(PostgreSQLParser::WITH);
      setState(5960);
      match(PostgreSQLParser::FUNCTION);
      setState(5961);
      function_with_argtypes();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5962);
      match(PostgreSQLParser::TO);
      setState(5963);
      match(PostgreSQLParser::SQL_P);
      setState(5964);
      match(PostgreSQLParser::WITH);
      setState(5965);
      match(PostgreSQLParser::FUNCTION);
      setState(5966);
      function_with_argtypes();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DroptransformstmtContext ------------------------------------------------------------------

PostgreSQLParser::DroptransformstmtContext::DroptransformstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DroptransformstmtContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

tree::TerminalNode* PostgreSQLParser::DroptransformstmtContext::TRANSFORM() {
  return getToken(PostgreSQLParser::TRANSFORM, 0);
}

tree::TerminalNode* PostgreSQLParser::DroptransformstmtContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::DroptransformstmtContext::typename_() {
  return getRuleContext<PostgreSQLParser::TypenameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DroptransformstmtContext::LANGUAGE() {
  return getToken(PostgreSQLParser::LANGUAGE, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::DroptransformstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::If_exists_Context* PostgreSQLParser::DroptransformstmtContext::if_exists_() {
  return getRuleContext<PostgreSQLParser::If_exists_Context>(0);
}

PostgreSQLParser::Drop_behavior_Context* PostgreSQLParser::DroptransformstmtContext::drop_behavior_() {
  return getRuleContext<PostgreSQLParser::Drop_behavior_Context>(0);
}


size_t PostgreSQLParser::DroptransformstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDroptransformstmt;
}


std::any PostgreSQLParser::DroptransformstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDroptransformstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DroptransformstmtContext* PostgreSQLParser::droptransformstmt() {
  DroptransformstmtContext *_localctx = _tracker.createInstance<DroptransformstmtContext>(_ctx, getState());
  enterRule(_localctx, 708, PostgreSQLParser::RuleDroptransformstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5969);
    match(PostgreSQLParser::DROP);
    setState(5970);
    match(PostgreSQLParser::TRANSFORM);
    setState(5972);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::IF_P) {
      setState(5971);
      if_exists_();
    }
    setState(5974);
    match(PostgreSQLParser::FOR);
    setState(5975);
    typename_();
    setState(5976);
    match(PostgreSQLParser::LANGUAGE);
    setState(5977);
    name();
    setState(5979);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
      setState(5978);
      drop_behavior_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReindexstmtContext ------------------------------------------------------------------

PostgreSQLParser::ReindexstmtContext::ReindexstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::ReindexstmtContext::REINDEX() {
  return getToken(PostgreSQLParser::REINDEX, 0);
}

PostgreSQLParser::Reindex_target_relationContext* PostgreSQLParser::ReindexstmtContext::reindex_target_relation() {
  return getRuleContext<PostgreSQLParser::Reindex_target_relationContext>(0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::ReindexstmtContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

PostgreSQLParser::Reindex_option_listContext* PostgreSQLParser::ReindexstmtContext::reindex_option_list() {
  return getRuleContext<PostgreSQLParser::Reindex_option_listContext>(0);
}

PostgreSQLParser::Concurrently_Context* PostgreSQLParser::ReindexstmtContext::concurrently_() {
  return getRuleContext<PostgreSQLParser::Concurrently_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::ReindexstmtContext::SCHEMA() {
  return getToken(PostgreSQLParser::SCHEMA, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::ReindexstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::Reindex_target_allContext* PostgreSQLParser::ReindexstmtContext::reindex_target_all() {
  return getRuleContext<PostgreSQLParser::Reindex_target_allContext>(0);
}

PostgreSQLParser::Single_name_Context* PostgreSQLParser::ReindexstmtContext::single_name_() {
  return getRuleContext<PostgreSQLParser::Single_name_Context>(0);
}


size_t PostgreSQLParser::ReindexstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleReindexstmt;
}


std::any PostgreSQLParser::ReindexstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitReindexstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ReindexstmtContext* PostgreSQLParser::reindexstmt() {
  ReindexstmtContext *_localctx = _tracker.createInstance<ReindexstmtContext>(_ctx, getState());
  enterRule(_localctx, 710, PostgreSQLParser::RuleReindexstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6011);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 536, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5981);
      match(PostgreSQLParser::REINDEX);
      setState(5983);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPEN_PAREN) {
        setState(5982);
        reindex_option_list();
      }
      setState(5985);
      reindex_target_relation();
      setState(5987);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CONCURRENTLY) {
        setState(5986);
        concurrently_();
      }
      setState(5989);
      qualified_name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5991);
      match(PostgreSQLParser::REINDEX);
      setState(5993);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPEN_PAREN) {
        setState(5992);
        reindex_option_list();
      }
      setState(5995);
      match(PostgreSQLParser::SCHEMA);
      setState(5997);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CONCURRENTLY) {
        setState(5996);
        concurrently_();
      }
      setState(5999);
      name();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6000);
      match(PostgreSQLParser::REINDEX);
      setState(6002);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPEN_PAREN) {
        setState(6001);
        reindex_option_list();
      }
      setState(6004);
      reindex_target_all();
      setState(6006);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CONCURRENTLY) {
        setState(6005);
        concurrently_();
      }
      setState(6009);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 30) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 30)) & 137438949375) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 553)) & 536870983) != 0)) {
        setState(6008);
        single_name_();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reindex_target_relationContext ------------------------------------------------------------------

PostgreSQLParser::Reindex_target_relationContext::Reindex_target_relationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Reindex_target_relationContext::INDEX() {
  return getToken(PostgreSQLParser::INDEX, 0);
}

tree::TerminalNode* PostgreSQLParser::Reindex_target_relationContext::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}


size_t PostgreSQLParser::Reindex_target_relationContext::getRuleIndex() const {
  return PostgreSQLParser::RuleReindex_target_relation;
}


std::any PostgreSQLParser::Reindex_target_relationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitReindex_target_relation(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Reindex_target_relationContext* PostgreSQLParser::reindex_target_relation() {
  Reindex_target_relationContext *_localctx = _tracker.createInstance<Reindex_target_relationContext>(_ctx, getState());
  enterRule(_localctx, 712, PostgreSQLParser::RuleReindex_target_relation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6013);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::TABLE || _la == PostgreSQLParser::INDEX)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reindex_target_allContext ------------------------------------------------------------------

PostgreSQLParser::Reindex_target_allContext::Reindex_target_allContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Reindex_target_allContext::SYSTEM_P() {
  return getToken(PostgreSQLParser::SYSTEM_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Reindex_target_allContext::DATABASE() {
  return getToken(PostgreSQLParser::DATABASE, 0);
}


size_t PostgreSQLParser::Reindex_target_allContext::getRuleIndex() const {
  return PostgreSQLParser::RuleReindex_target_all;
}


std::any PostgreSQLParser::Reindex_target_allContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitReindex_target_all(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Reindex_target_allContext* PostgreSQLParser::reindex_target_all() {
  Reindex_target_allContext *_localctx = _tracker.createInstance<Reindex_target_allContext>(_ctx, getState());
  enterRule(_localctx, 714, PostgreSQLParser::RuleReindex_target_all);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6015);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::DATABASE || _la == PostgreSQLParser::SYSTEM_P)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reindex_option_listContext ------------------------------------------------------------------

PostgreSQLParser::Reindex_option_listContext::Reindex_option_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Reindex_option_listContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Utility_option_listContext* PostgreSQLParser::Reindex_option_listContext::utility_option_list() {
  return getRuleContext<PostgreSQLParser::Utility_option_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Reindex_option_listContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Reindex_option_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleReindex_option_list;
}


std::any PostgreSQLParser::Reindex_option_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitReindex_option_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Reindex_option_listContext* PostgreSQLParser::reindex_option_list() {
  Reindex_option_listContext *_localctx = _tracker.createInstance<Reindex_option_listContext>(_ctx, getState());
  enterRule(_localctx, 716, PostgreSQLParser::RuleReindex_option_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6017);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(6018);
    utility_option_list();
    setState(6019);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AltertblspcstmtContext ------------------------------------------------------------------

PostgreSQLParser::AltertblspcstmtContext::AltertblspcstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AltertblspcstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertblspcstmtContext::TABLESPACE() {
  return getToken(PostgreSQLParser::TABLESPACE, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::AltertblspcstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AltertblspcstmtContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

PostgreSQLParser::ReloptionsContext* PostgreSQLParser::AltertblspcstmtContext::reloptions() {
  return getRuleContext<PostgreSQLParser::ReloptionsContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AltertblspcstmtContext::RESET() {
  return getToken(PostgreSQLParser::RESET, 0);
}


size_t PostgreSQLParser::AltertblspcstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAltertblspcstmt;
}


std::any PostgreSQLParser::AltertblspcstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAltertblspcstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AltertblspcstmtContext* PostgreSQLParser::altertblspcstmt() {
  AltertblspcstmtContext *_localctx = _tracker.createInstance<AltertblspcstmtContext>(_ctx, getState());
  enterRule(_localctx, 718, PostgreSQLParser::RuleAltertblspcstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6033);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 537, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6021);
      match(PostgreSQLParser::ALTER);
      setState(6022);
      match(PostgreSQLParser::TABLESPACE);
      setState(6023);
      name();
      setState(6024);
      match(PostgreSQLParser::SET);
      setState(6025);
      reloptions();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6027);
      match(PostgreSQLParser::ALTER);
      setState(6028);
      match(PostgreSQLParser::TABLESPACE);
      setState(6029);
      name();
      setState(6030);
      match(PostgreSQLParser::RESET);
      setState(6031);
      reloptions();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RenamestmtContext ------------------------------------------------------------------

PostgreSQLParser::RenamestmtContext::RenamestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::AGGREGATE() {
  return getToken(PostgreSQLParser::AGGREGATE, 0);
}

PostgreSQLParser::Aggregate_with_argtypesContext* PostgreSQLParser::RenamestmtContext::aggregate_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Aggregate_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::RENAME() {
  return getToken(PostgreSQLParser::RENAME, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}

std::vector<PostgreSQLParser::NameContext *> PostgreSQLParser::RenamestmtContext::name() {
  return getRuleContexts<PostgreSQLParser::NameContext>();
}

PostgreSQLParser::NameContext* PostgreSQLParser::RenamestmtContext::name(size_t i) {
  return getRuleContext<PostgreSQLParser::NameContext>(i);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::COLLATION() {
  return getToken(PostgreSQLParser::COLLATION, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::RenamestmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::CONVERSION_P() {
  return getToken(PostgreSQLParser::CONVERSION_P, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::DATABASE() {
  return getToken(PostgreSQLParser::DATABASE, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::DOMAIN_P() {
  return getToken(PostgreSQLParser::DOMAIN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::CONSTRAINT() {
  return getToken(PostgreSQLParser::CONSTRAINT, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::FOREIGN() {
  return getToken(PostgreSQLParser::FOREIGN, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::DATA_P() {
  return getToken(PostgreSQLParser::DATA_P, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::WRAPPER() {
  return getToken(PostgreSQLParser::WRAPPER, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::FUNCTION() {
  return getToken(PostgreSQLParser::FUNCTION, 0);
}

PostgreSQLParser::Function_with_argtypesContext* PostgreSQLParser::RenamestmtContext::function_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Function_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::GROUP_P() {
  return getToken(PostgreSQLParser::GROUP_P, 0);
}

std::vector<PostgreSQLParser::RoleidContext *> PostgreSQLParser::RenamestmtContext::roleid() {
  return getRuleContexts<PostgreSQLParser::RoleidContext>();
}

PostgreSQLParser::RoleidContext* PostgreSQLParser::RenamestmtContext::roleid(size_t i) {
  return getRuleContext<PostgreSQLParser::RoleidContext>(i);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::LANGUAGE() {
  return getToken(PostgreSQLParser::LANGUAGE, 0);
}

PostgreSQLParser::Procedural_Context* PostgreSQLParser::RenamestmtContext::procedural_() {
  return getRuleContext<PostgreSQLParser::Procedural_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::CLASS() {
  return getToken(PostgreSQLParser::CLASS, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::FAMILY() {
  return getToken(PostgreSQLParser::FAMILY, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::POLICY() {
  return getToken(PostgreSQLParser::POLICY, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::RenamestmtContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::PROCEDURE() {
  return getToken(PostgreSQLParser::PROCEDURE, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::PUBLICATION() {
  return getToken(PostgreSQLParser::PUBLICATION, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::ROUTINE() {
  return getToken(PostgreSQLParser::ROUTINE, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::SCHEMA() {
  return getToken(PostgreSQLParser::SCHEMA, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::SERVER() {
  return getToken(PostgreSQLParser::SERVER, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::SUBSCRIPTION() {
  return getToken(PostgreSQLParser::SUBSCRIPTION, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}

PostgreSQLParser::Relation_exprContext* PostgreSQLParser::RenamestmtContext::relation_expr() {
  return getRuleContext<PostgreSQLParser::Relation_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::SEQUENCE() {
  return getToken(PostgreSQLParser::SEQUENCE, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::VIEW() {
  return getToken(PostgreSQLParser::VIEW, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::MATERIALIZED() {
  return getToken(PostgreSQLParser::MATERIALIZED, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::INDEX() {
  return getToken(PostgreSQLParser::INDEX, 0);
}

PostgreSQLParser::Column_Context* PostgreSQLParser::RenamestmtContext::column_() {
  return getRuleContext<PostgreSQLParser::Column_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::RULE() {
  return getToken(PostgreSQLParser::RULE, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::TRIGGER() {
  return getToken(PostgreSQLParser::TRIGGER, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::EVENT() {
  return getToken(PostgreSQLParser::EVENT, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::ROLE() {
  return getToken(PostgreSQLParser::ROLE, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::USER() {
  return getToken(PostgreSQLParser::USER, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::TABLESPACE() {
  return getToken(PostgreSQLParser::TABLESPACE, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::STATISTICS() {
  return getToken(PostgreSQLParser::STATISTICS, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::TEXT_P() {
  return getToken(PostgreSQLParser::TEXT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::SEARCH() {
  return getToken(PostgreSQLParser::SEARCH, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::PARSER() {
  return getToken(PostgreSQLParser::PARSER, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::DICTIONARY() {
  return getToken(PostgreSQLParser::DICTIONARY, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::TEMPLATE() {
  return getToken(PostgreSQLParser::TEMPLATE, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::CONFIGURATION() {
  return getToken(PostgreSQLParser::CONFIGURATION, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::RenamestmtContext::ATTRIBUTE() {
  return getToken(PostgreSQLParser::ATTRIBUTE, 0);
}

PostgreSQLParser::Drop_behavior_Context* PostgreSQLParser::RenamestmtContext::drop_behavior_() {
  return getRuleContext<PostgreSQLParser::Drop_behavior_Context>(0);
}


size_t PostgreSQLParser::RenamestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRenamestmt;
}


std::any PostgreSQLParser::RenamestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRenamestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RenamestmtContext* PostgreSQLParser::renamestmt() {
  RenamestmtContext *_localctx = _tracker.createInstance<RenamestmtContext>(_ctx, getState());
  enterRule(_localctx, 720, PostgreSQLParser::RuleRenamestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6522);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 548, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6035);
      match(PostgreSQLParser::ALTER);
      setState(6036);
      match(PostgreSQLParser::AGGREGATE);
      setState(6037);
      aggregate_with_argtypes();
      setState(6038);
      match(PostgreSQLParser::RENAME);
      setState(6039);
      match(PostgreSQLParser::TO);
      setState(6040);
      name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6042);
      match(PostgreSQLParser::ALTER);
      setState(6043);
      match(PostgreSQLParser::COLLATION);
      setState(6044);
      any_name();
      setState(6045);
      match(PostgreSQLParser::RENAME);
      setState(6046);
      match(PostgreSQLParser::TO);
      setState(6047);
      name();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6049);
      match(PostgreSQLParser::ALTER);
      setState(6050);
      match(PostgreSQLParser::CONVERSION_P);
      setState(6051);
      any_name();
      setState(6052);
      match(PostgreSQLParser::RENAME);
      setState(6053);
      match(PostgreSQLParser::TO);
      setState(6054);
      name();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6056);
      match(PostgreSQLParser::ALTER);
      setState(6057);
      match(PostgreSQLParser::DATABASE);
      setState(6058);
      name();
      setState(6059);
      match(PostgreSQLParser::RENAME);
      setState(6060);
      match(PostgreSQLParser::TO);
      setState(6061);
      name();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6063);
      match(PostgreSQLParser::ALTER);
      setState(6064);
      match(PostgreSQLParser::DOMAIN_P);
      setState(6065);
      any_name();
      setState(6066);
      match(PostgreSQLParser::RENAME);
      setState(6067);
      match(PostgreSQLParser::TO);
      setState(6068);
      name();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6070);
      match(PostgreSQLParser::ALTER);
      setState(6071);
      match(PostgreSQLParser::DOMAIN_P);
      setState(6072);
      any_name();
      setState(6073);
      match(PostgreSQLParser::RENAME);
      setState(6074);
      match(PostgreSQLParser::CONSTRAINT);
      setState(6075);
      name();
      setState(6076);
      match(PostgreSQLParser::TO);
      setState(6077);
      name();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6079);
      match(PostgreSQLParser::ALTER);
      setState(6080);
      match(PostgreSQLParser::FOREIGN);
      setState(6081);
      match(PostgreSQLParser::DATA_P);
      setState(6082);
      match(PostgreSQLParser::WRAPPER);
      setState(6083);
      name();
      setState(6084);
      match(PostgreSQLParser::RENAME);
      setState(6085);
      match(PostgreSQLParser::TO);
      setState(6086);
      name();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(6088);
      match(PostgreSQLParser::ALTER);
      setState(6089);
      match(PostgreSQLParser::FUNCTION);
      setState(6090);
      function_with_argtypes();
      setState(6091);
      match(PostgreSQLParser::RENAME);
      setState(6092);
      match(PostgreSQLParser::TO);
      setState(6093);
      name();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(6095);
      match(PostgreSQLParser::ALTER);
      setState(6096);
      match(PostgreSQLParser::GROUP_P);
      setState(6097);
      roleid();
      setState(6098);
      match(PostgreSQLParser::RENAME);
      setState(6099);
      match(PostgreSQLParser::TO);
      setState(6100);
      roleid();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(6102);
      match(PostgreSQLParser::ALTER);
      setState(6104);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::PROCEDURAL) {
        setState(6103);
        procedural_();
      }
      setState(6106);
      match(PostgreSQLParser::LANGUAGE);
      setState(6107);
      name();
      setState(6108);
      match(PostgreSQLParser::RENAME);
      setState(6109);
      match(PostgreSQLParser::TO);
      setState(6110);
      name();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(6112);
      match(PostgreSQLParser::ALTER);
      setState(6113);
      match(PostgreSQLParser::OPERATOR);
      setState(6114);
      match(PostgreSQLParser::CLASS);
      setState(6115);
      any_name();
      setState(6116);
      match(PostgreSQLParser::USING);
      setState(6117);
      name();
      setState(6118);
      match(PostgreSQLParser::RENAME);
      setState(6119);
      match(PostgreSQLParser::TO);
      setState(6120);
      name();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(6122);
      match(PostgreSQLParser::ALTER);
      setState(6123);
      match(PostgreSQLParser::OPERATOR);
      setState(6124);
      match(PostgreSQLParser::FAMILY);
      setState(6125);
      any_name();
      setState(6126);
      match(PostgreSQLParser::USING);
      setState(6127);
      name();
      setState(6128);
      match(PostgreSQLParser::RENAME);
      setState(6129);
      match(PostgreSQLParser::TO);
      setState(6130);
      name();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(6132);
      match(PostgreSQLParser::ALTER);
      setState(6133);
      match(PostgreSQLParser::POLICY);
      setState(6134);
      name();
      setState(6135);
      match(PostgreSQLParser::ON);
      setState(6136);
      qualified_name();
      setState(6137);
      match(PostgreSQLParser::RENAME);
      setState(6138);
      match(PostgreSQLParser::TO);
      setState(6139);
      name();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(6141);
      match(PostgreSQLParser::ALTER);
      setState(6142);
      match(PostgreSQLParser::POLICY);
      setState(6143);
      match(PostgreSQLParser::IF_P);
      setState(6144);
      match(PostgreSQLParser::EXISTS);
      setState(6145);
      name();
      setState(6146);
      match(PostgreSQLParser::ON);
      setState(6147);
      qualified_name();
      setState(6148);
      match(PostgreSQLParser::RENAME);
      setState(6149);
      match(PostgreSQLParser::TO);
      setState(6150);
      name();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(6152);
      match(PostgreSQLParser::ALTER);
      setState(6153);
      match(PostgreSQLParser::PROCEDURE);
      setState(6154);
      function_with_argtypes();
      setState(6155);
      match(PostgreSQLParser::RENAME);
      setState(6156);
      match(PostgreSQLParser::TO);
      setState(6157);
      name();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(6159);
      match(PostgreSQLParser::ALTER);
      setState(6160);
      match(PostgreSQLParser::PUBLICATION);
      setState(6161);
      name();
      setState(6162);
      match(PostgreSQLParser::RENAME);
      setState(6163);
      match(PostgreSQLParser::TO);
      setState(6164);
      name();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(6166);
      match(PostgreSQLParser::ALTER);
      setState(6167);
      match(PostgreSQLParser::ROUTINE);
      setState(6168);
      function_with_argtypes();
      setState(6169);
      match(PostgreSQLParser::RENAME);
      setState(6170);
      match(PostgreSQLParser::TO);
      setState(6171);
      name();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(6173);
      match(PostgreSQLParser::ALTER);
      setState(6174);
      match(PostgreSQLParser::SCHEMA);
      setState(6175);
      name();
      setState(6176);
      match(PostgreSQLParser::RENAME);
      setState(6177);
      match(PostgreSQLParser::TO);
      setState(6178);
      name();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(6180);
      match(PostgreSQLParser::ALTER);
      setState(6181);
      match(PostgreSQLParser::SERVER);
      setState(6182);
      name();
      setState(6183);
      match(PostgreSQLParser::RENAME);
      setState(6184);
      match(PostgreSQLParser::TO);
      setState(6185);
      name();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(6187);
      match(PostgreSQLParser::ALTER);
      setState(6188);
      match(PostgreSQLParser::SUBSCRIPTION);
      setState(6189);
      name();
      setState(6190);
      match(PostgreSQLParser::RENAME);
      setState(6191);
      match(PostgreSQLParser::TO);
      setState(6192);
      name();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(6194);
      match(PostgreSQLParser::ALTER);
      setState(6195);
      match(PostgreSQLParser::TABLE);
      setState(6196);
      relation_expr();
      setState(6197);
      match(PostgreSQLParser::RENAME);
      setState(6198);
      match(PostgreSQLParser::TO);
      setState(6199);
      name();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(6201);
      match(PostgreSQLParser::ALTER);
      setState(6202);
      match(PostgreSQLParser::TABLE);
      setState(6203);
      match(PostgreSQLParser::IF_P);
      setState(6204);
      match(PostgreSQLParser::EXISTS);
      setState(6205);
      relation_expr();
      setState(6206);
      match(PostgreSQLParser::RENAME);
      setState(6207);
      match(PostgreSQLParser::TO);
      setState(6208);
      name();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(6210);
      match(PostgreSQLParser::ALTER);
      setState(6211);
      match(PostgreSQLParser::SEQUENCE);
      setState(6212);
      qualified_name();
      setState(6213);
      match(PostgreSQLParser::RENAME);
      setState(6214);
      match(PostgreSQLParser::TO);
      setState(6215);
      name();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(6217);
      match(PostgreSQLParser::ALTER);
      setState(6218);
      match(PostgreSQLParser::SEQUENCE);
      setState(6219);
      match(PostgreSQLParser::IF_P);
      setState(6220);
      match(PostgreSQLParser::EXISTS);
      setState(6221);
      qualified_name();
      setState(6222);
      match(PostgreSQLParser::RENAME);
      setState(6223);
      match(PostgreSQLParser::TO);
      setState(6224);
      name();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(6226);
      match(PostgreSQLParser::ALTER);
      setState(6227);
      match(PostgreSQLParser::VIEW);
      setState(6228);
      qualified_name();
      setState(6229);
      match(PostgreSQLParser::RENAME);
      setState(6230);
      match(PostgreSQLParser::TO);
      setState(6231);
      name();
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(6233);
      match(PostgreSQLParser::ALTER);
      setState(6234);
      match(PostgreSQLParser::VIEW);
      setState(6235);
      match(PostgreSQLParser::IF_P);
      setState(6236);
      match(PostgreSQLParser::EXISTS);
      setState(6237);
      qualified_name();
      setState(6238);
      match(PostgreSQLParser::RENAME);
      setState(6239);
      match(PostgreSQLParser::TO);
      setState(6240);
      name();
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(6242);
      match(PostgreSQLParser::ALTER);
      setState(6243);
      match(PostgreSQLParser::MATERIALIZED);
      setState(6244);
      match(PostgreSQLParser::VIEW);
      setState(6245);
      qualified_name();
      setState(6246);
      match(PostgreSQLParser::RENAME);
      setState(6247);
      match(PostgreSQLParser::TO);
      setState(6248);
      name();
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(6250);
      match(PostgreSQLParser::ALTER);
      setState(6251);
      match(PostgreSQLParser::MATERIALIZED);
      setState(6252);
      match(PostgreSQLParser::VIEW);
      setState(6253);
      match(PostgreSQLParser::IF_P);
      setState(6254);
      match(PostgreSQLParser::EXISTS);
      setState(6255);
      qualified_name();
      setState(6256);
      match(PostgreSQLParser::RENAME);
      setState(6257);
      match(PostgreSQLParser::TO);
      setState(6258);
      name();
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(6260);
      match(PostgreSQLParser::ALTER);
      setState(6261);
      match(PostgreSQLParser::INDEX);
      setState(6262);
      qualified_name();
      setState(6263);
      match(PostgreSQLParser::RENAME);
      setState(6264);
      match(PostgreSQLParser::TO);
      setState(6265);
      name();
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(6267);
      match(PostgreSQLParser::ALTER);
      setState(6268);
      match(PostgreSQLParser::INDEX);
      setState(6269);
      match(PostgreSQLParser::IF_P);
      setState(6270);
      match(PostgreSQLParser::EXISTS);
      setState(6271);
      qualified_name();
      setState(6272);
      match(PostgreSQLParser::RENAME);
      setState(6273);
      match(PostgreSQLParser::TO);
      setState(6274);
      name();
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(6276);
      match(PostgreSQLParser::ALTER);
      setState(6277);
      match(PostgreSQLParser::FOREIGN);
      setState(6278);
      match(PostgreSQLParser::TABLE);
      setState(6279);
      relation_expr();
      setState(6280);
      match(PostgreSQLParser::RENAME);
      setState(6281);
      match(PostgreSQLParser::TO);
      setState(6282);
      name();
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(6284);
      match(PostgreSQLParser::ALTER);
      setState(6285);
      match(PostgreSQLParser::FOREIGN);
      setState(6286);
      match(PostgreSQLParser::TABLE);
      setState(6287);
      match(PostgreSQLParser::IF_P);
      setState(6288);
      match(PostgreSQLParser::EXISTS);
      setState(6289);
      relation_expr();
      setState(6290);
      match(PostgreSQLParser::RENAME);
      setState(6291);
      match(PostgreSQLParser::TO);
      setState(6292);
      name();
      break;
    }

    case 33: {
      enterOuterAlt(_localctx, 33);
      setState(6294);
      match(PostgreSQLParser::ALTER);
      setState(6295);
      match(PostgreSQLParser::TABLE);
      setState(6296);
      relation_expr();
      setState(6297);
      match(PostgreSQLParser::RENAME);
      setState(6299);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(6298);
        column_();
      }
      setState(6301);
      name();
      setState(6302);
      match(PostgreSQLParser::TO);
      setState(6303);
      name();
      break;
    }

    case 34: {
      enterOuterAlt(_localctx, 34);
      setState(6305);
      match(PostgreSQLParser::ALTER);
      setState(6306);
      match(PostgreSQLParser::TABLE);
      setState(6307);
      match(PostgreSQLParser::IF_P);
      setState(6308);
      match(PostgreSQLParser::EXISTS);
      setState(6309);
      relation_expr();
      setState(6310);
      match(PostgreSQLParser::RENAME);
      setState(6312);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(6311);
        column_();
      }
      setState(6314);
      name();
      setState(6315);
      match(PostgreSQLParser::TO);
      setState(6316);
      name();
      break;
    }

    case 35: {
      enterOuterAlt(_localctx, 35);
      setState(6318);
      match(PostgreSQLParser::ALTER);
      setState(6319);
      match(PostgreSQLParser::VIEW);
      setState(6320);
      qualified_name();
      setState(6321);
      match(PostgreSQLParser::RENAME);
      setState(6323);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(6322);
        column_();
      }
      setState(6325);
      name();
      setState(6326);
      match(PostgreSQLParser::TO);
      setState(6327);
      name();
      break;
    }

    case 36: {
      enterOuterAlt(_localctx, 36);
      setState(6329);
      match(PostgreSQLParser::ALTER);
      setState(6330);
      match(PostgreSQLParser::VIEW);
      setState(6331);
      match(PostgreSQLParser::IF_P);
      setState(6332);
      match(PostgreSQLParser::EXISTS);
      setState(6333);
      qualified_name();
      setState(6334);
      match(PostgreSQLParser::RENAME);
      setState(6336);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(6335);
        column_();
      }
      setState(6338);
      name();
      setState(6339);
      match(PostgreSQLParser::TO);
      setState(6340);
      name();
      break;
    }

    case 37: {
      enterOuterAlt(_localctx, 37);
      setState(6342);
      match(PostgreSQLParser::ALTER);
      setState(6343);
      match(PostgreSQLParser::MATERIALIZED);
      setState(6344);
      match(PostgreSQLParser::VIEW);
      setState(6345);
      qualified_name();
      setState(6346);
      match(PostgreSQLParser::RENAME);
      setState(6348);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(6347);
        column_();
      }
      setState(6350);
      name();
      setState(6351);
      match(PostgreSQLParser::TO);
      setState(6352);
      name();
      break;
    }

    case 38: {
      enterOuterAlt(_localctx, 38);
      setState(6354);
      match(PostgreSQLParser::ALTER);
      setState(6355);
      match(PostgreSQLParser::MATERIALIZED);
      setState(6356);
      match(PostgreSQLParser::VIEW);
      setState(6357);
      match(PostgreSQLParser::IF_P);
      setState(6358);
      match(PostgreSQLParser::EXISTS);
      setState(6359);
      qualified_name();
      setState(6360);
      match(PostgreSQLParser::RENAME);
      setState(6362);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(6361);
        column_();
      }
      setState(6364);
      name();
      setState(6365);
      match(PostgreSQLParser::TO);
      setState(6366);
      name();
      break;
    }

    case 39: {
      enterOuterAlt(_localctx, 39);
      setState(6368);
      match(PostgreSQLParser::ALTER);
      setState(6369);
      match(PostgreSQLParser::TABLE);
      setState(6370);
      relation_expr();
      setState(6371);
      match(PostgreSQLParser::RENAME);
      setState(6372);
      match(PostgreSQLParser::CONSTRAINT);
      setState(6373);
      name();
      setState(6374);
      match(PostgreSQLParser::TO);
      setState(6375);
      name();
      break;
    }

    case 40: {
      enterOuterAlt(_localctx, 40);
      setState(6377);
      match(PostgreSQLParser::ALTER);
      setState(6378);
      match(PostgreSQLParser::TABLE);
      setState(6379);
      match(PostgreSQLParser::IF_P);
      setState(6380);
      match(PostgreSQLParser::EXISTS);
      setState(6381);
      relation_expr();
      setState(6382);
      match(PostgreSQLParser::RENAME);
      setState(6383);
      match(PostgreSQLParser::CONSTRAINT);
      setState(6384);
      name();
      setState(6385);
      match(PostgreSQLParser::TO);
      setState(6386);
      name();
      break;
    }

    case 41: {
      enterOuterAlt(_localctx, 41);
      setState(6388);
      match(PostgreSQLParser::ALTER);
      setState(6389);
      match(PostgreSQLParser::FOREIGN);
      setState(6390);
      match(PostgreSQLParser::TABLE);
      setState(6391);
      relation_expr();
      setState(6392);
      match(PostgreSQLParser::RENAME);
      setState(6394);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(6393);
        column_();
      }
      setState(6396);
      name();
      setState(6397);
      match(PostgreSQLParser::TO);
      setState(6398);
      name();
      break;
    }

    case 42: {
      enterOuterAlt(_localctx, 42);
      setState(6400);
      match(PostgreSQLParser::ALTER);
      setState(6401);
      match(PostgreSQLParser::FOREIGN);
      setState(6402);
      match(PostgreSQLParser::TABLE);
      setState(6403);
      match(PostgreSQLParser::IF_P);
      setState(6404);
      match(PostgreSQLParser::EXISTS);
      setState(6405);
      relation_expr();
      setState(6406);
      match(PostgreSQLParser::RENAME);
      setState(6408);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COLUMN) {
        setState(6407);
        column_();
      }
      setState(6410);
      name();
      setState(6411);
      match(PostgreSQLParser::TO);
      setState(6412);
      name();
      break;
    }

    case 43: {
      enterOuterAlt(_localctx, 43);
      setState(6414);
      match(PostgreSQLParser::ALTER);
      setState(6415);
      match(PostgreSQLParser::RULE);
      setState(6416);
      name();
      setState(6417);
      match(PostgreSQLParser::ON);
      setState(6418);
      qualified_name();
      setState(6419);
      match(PostgreSQLParser::RENAME);
      setState(6420);
      match(PostgreSQLParser::TO);
      setState(6421);
      name();
      break;
    }

    case 44: {
      enterOuterAlt(_localctx, 44);
      setState(6423);
      match(PostgreSQLParser::ALTER);
      setState(6424);
      match(PostgreSQLParser::TRIGGER);
      setState(6425);
      name();
      setState(6426);
      match(PostgreSQLParser::ON);
      setState(6427);
      qualified_name();
      setState(6428);
      match(PostgreSQLParser::RENAME);
      setState(6429);
      match(PostgreSQLParser::TO);
      setState(6430);
      name();
      break;
    }

    case 45: {
      enterOuterAlt(_localctx, 45);
      setState(6432);
      match(PostgreSQLParser::ALTER);
      setState(6433);
      match(PostgreSQLParser::EVENT);
      setState(6434);
      match(PostgreSQLParser::TRIGGER);
      setState(6435);
      name();
      setState(6436);
      match(PostgreSQLParser::RENAME);
      setState(6437);
      match(PostgreSQLParser::TO);
      setState(6438);
      name();
      break;
    }

    case 46: {
      enterOuterAlt(_localctx, 46);
      setState(6440);
      match(PostgreSQLParser::ALTER);
      setState(6441);
      match(PostgreSQLParser::ROLE);
      setState(6442);
      roleid();
      setState(6443);
      match(PostgreSQLParser::RENAME);
      setState(6444);
      match(PostgreSQLParser::TO);
      setState(6445);
      roleid();
      break;
    }

    case 47: {
      enterOuterAlt(_localctx, 47);
      setState(6447);
      match(PostgreSQLParser::ALTER);
      setState(6448);
      match(PostgreSQLParser::USER);
      setState(6449);
      roleid();
      setState(6450);
      match(PostgreSQLParser::RENAME);
      setState(6451);
      match(PostgreSQLParser::TO);
      setState(6452);
      roleid();
      break;
    }

    case 48: {
      enterOuterAlt(_localctx, 48);
      setState(6454);
      match(PostgreSQLParser::ALTER);
      setState(6455);
      match(PostgreSQLParser::TABLESPACE);
      setState(6456);
      name();
      setState(6457);
      match(PostgreSQLParser::RENAME);
      setState(6458);
      match(PostgreSQLParser::TO);
      setState(6459);
      name();
      break;
    }

    case 49: {
      enterOuterAlt(_localctx, 49);
      setState(6461);
      match(PostgreSQLParser::ALTER);
      setState(6462);
      match(PostgreSQLParser::STATISTICS);
      setState(6463);
      any_name();
      setState(6464);
      match(PostgreSQLParser::RENAME);
      setState(6465);
      match(PostgreSQLParser::TO);
      setState(6466);
      name();
      break;
    }

    case 50: {
      enterOuterAlt(_localctx, 50);
      setState(6468);
      match(PostgreSQLParser::ALTER);
      setState(6469);
      match(PostgreSQLParser::TEXT_P);
      setState(6470);
      match(PostgreSQLParser::SEARCH);
      setState(6471);
      match(PostgreSQLParser::PARSER);
      setState(6472);
      any_name();
      setState(6473);
      match(PostgreSQLParser::RENAME);
      setState(6474);
      match(PostgreSQLParser::TO);
      setState(6475);
      name();
      break;
    }

    case 51: {
      enterOuterAlt(_localctx, 51);
      setState(6477);
      match(PostgreSQLParser::ALTER);
      setState(6478);
      match(PostgreSQLParser::TEXT_P);
      setState(6479);
      match(PostgreSQLParser::SEARCH);
      setState(6480);
      match(PostgreSQLParser::DICTIONARY);
      setState(6481);
      any_name();
      setState(6482);
      match(PostgreSQLParser::RENAME);
      setState(6483);
      match(PostgreSQLParser::TO);
      setState(6484);
      name();
      break;
    }

    case 52: {
      enterOuterAlt(_localctx, 52);
      setState(6486);
      match(PostgreSQLParser::ALTER);
      setState(6487);
      match(PostgreSQLParser::TEXT_P);
      setState(6488);
      match(PostgreSQLParser::SEARCH);
      setState(6489);
      match(PostgreSQLParser::TEMPLATE);
      setState(6490);
      any_name();
      setState(6491);
      match(PostgreSQLParser::RENAME);
      setState(6492);
      match(PostgreSQLParser::TO);
      setState(6493);
      name();
      break;
    }

    case 53: {
      enterOuterAlt(_localctx, 53);
      setState(6495);
      match(PostgreSQLParser::ALTER);
      setState(6496);
      match(PostgreSQLParser::TEXT_P);
      setState(6497);
      match(PostgreSQLParser::SEARCH);
      setState(6498);
      match(PostgreSQLParser::CONFIGURATION);
      setState(6499);
      any_name();
      setState(6500);
      match(PostgreSQLParser::RENAME);
      setState(6501);
      match(PostgreSQLParser::TO);
      setState(6502);
      name();
      break;
    }

    case 54: {
      enterOuterAlt(_localctx, 54);
      setState(6504);
      match(PostgreSQLParser::ALTER);
      setState(6505);
      match(PostgreSQLParser::TYPE_P);
      setState(6506);
      any_name();
      setState(6507);
      match(PostgreSQLParser::RENAME);
      setState(6508);
      match(PostgreSQLParser::TO);
      setState(6509);
      name();
      break;
    }

    case 55: {
      enterOuterAlt(_localctx, 55);
      setState(6511);
      match(PostgreSQLParser::ALTER);
      setState(6512);
      match(PostgreSQLParser::TYPE_P);
      setState(6513);
      any_name();
      setState(6514);
      match(PostgreSQLParser::RENAME);
      setState(6515);
      match(PostgreSQLParser::ATTRIBUTE);
      setState(6516);
      name();
      setState(6517);
      match(PostgreSQLParser::TO);
      setState(6518);
      name();
      setState(6520);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(6519);
        drop_behavior_();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_Context ------------------------------------------------------------------

PostgreSQLParser::Column_Context::Column_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Column_Context::COLUMN() {
  return getToken(PostgreSQLParser::COLUMN, 0);
}


size_t PostgreSQLParser::Column_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleColumn_;
}


std::any PostgreSQLParser::Column_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitColumn_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Column_Context* PostgreSQLParser::column_() {
  Column_Context *_localctx = _tracker.createInstance<Column_Context>(_ctx, getState());
  enterRule(_localctx, 722, PostgreSQLParser::RuleColumn_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6524);
    match(PostgreSQLParser::COLUMN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_data_Context ------------------------------------------------------------------

PostgreSQLParser::Set_data_Context::Set_data_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Set_data_Context::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

tree::TerminalNode* PostgreSQLParser::Set_data_Context::DATA_P() {
  return getToken(PostgreSQLParser::DATA_P, 0);
}


size_t PostgreSQLParser::Set_data_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleSet_data_;
}


std::any PostgreSQLParser::Set_data_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSet_data_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Set_data_Context* PostgreSQLParser::set_data_() {
  Set_data_Context *_localctx = _tracker.createInstance<Set_data_Context>(_ctx, getState());
  enterRule(_localctx, 724, PostgreSQLParser::RuleSet_data_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6526);
    match(PostgreSQLParser::SET);
    setState(6527);
    match(PostgreSQLParser::DATA_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterobjectdependsstmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterobjectdependsstmtContext::AlterobjectdependsstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterobjectdependsstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectdependsstmtContext::FUNCTION() {
  return getToken(PostgreSQLParser::FUNCTION, 0);
}

PostgreSQLParser::Function_with_argtypesContext* PostgreSQLParser::AlterobjectdependsstmtContext::function_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Function_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectdependsstmtContext::DEPENDS() {
  return getToken(PostgreSQLParser::DEPENDS, 0);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::AlterobjectdependsstmtContext::ON() {
  return getTokens(PostgreSQLParser::ON);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectdependsstmtContext::ON(size_t i) {
  return getToken(PostgreSQLParser::ON, i);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectdependsstmtContext::EXTENSION() {
  return getToken(PostgreSQLParser::EXTENSION, 0);
}

std::vector<PostgreSQLParser::NameContext *> PostgreSQLParser::AlterobjectdependsstmtContext::name() {
  return getRuleContexts<PostgreSQLParser::NameContext>();
}

PostgreSQLParser::NameContext* PostgreSQLParser::AlterobjectdependsstmtContext::name(size_t i) {
  return getRuleContext<PostgreSQLParser::NameContext>(i);
}

PostgreSQLParser::No_Context* PostgreSQLParser::AlterobjectdependsstmtContext::no_() {
  return getRuleContext<PostgreSQLParser::No_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectdependsstmtContext::PROCEDURE() {
  return getToken(PostgreSQLParser::PROCEDURE, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectdependsstmtContext::ROUTINE() {
  return getToken(PostgreSQLParser::ROUTINE, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectdependsstmtContext::TRIGGER() {
  return getToken(PostgreSQLParser::TRIGGER, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::AlterobjectdependsstmtContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectdependsstmtContext::MATERIALIZED() {
  return getToken(PostgreSQLParser::MATERIALIZED, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectdependsstmtContext::VIEW() {
  return getToken(PostgreSQLParser::VIEW, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectdependsstmtContext::INDEX() {
  return getToken(PostgreSQLParser::INDEX, 0);
}


size_t PostgreSQLParser::AlterobjectdependsstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterobjectdependsstmt;
}


std::any PostgreSQLParser::AlterobjectdependsstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterobjectdependsstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterobjectdependsstmtContext* PostgreSQLParser::alterobjectdependsstmt() {
  AlterobjectdependsstmtContext *_localctx = _tracker.createInstance<AlterobjectdependsstmtContext>(_ctx, getState());
  enterRule(_localctx, 726, PostgreSQLParser::RuleAlterobjectdependsstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6598);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 555, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6529);
      match(PostgreSQLParser::ALTER);
      setState(6530);
      match(PostgreSQLParser::FUNCTION);
      setState(6531);
      function_with_argtypes();
      setState(6533);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::NO) {
        setState(6532);
        no_();
      }
      setState(6535);
      match(PostgreSQLParser::DEPENDS);
      setState(6536);
      match(PostgreSQLParser::ON);
      setState(6537);
      match(PostgreSQLParser::EXTENSION);
      setState(6538);
      name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6540);
      match(PostgreSQLParser::ALTER);
      setState(6541);
      match(PostgreSQLParser::PROCEDURE);
      setState(6542);
      function_with_argtypes();
      setState(6544);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::NO) {
        setState(6543);
        no_();
      }
      setState(6546);
      match(PostgreSQLParser::DEPENDS);
      setState(6547);
      match(PostgreSQLParser::ON);
      setState(6548);
      match(PostgreSQLParser::EXTENSION);
      setState(6549);
      name();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6551);
      match(PostgreSQLParser::ALTER);
      setState(6552);
      match(PostgreSQLParser::ROUTINE);
      setState(6553);
      function_with_argtypes();
      setState(6555);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::NO) {
        setState(6554);
        no_();
      }
      setState(6557);
      match(PostgreSQLParser::DEPENDS);
      setState(6558);
      match(PostgreSQLParser::ON);
      setState(6559);
      match(PostgreSQLParser::EXTENSION);
      setState(6560);
      name();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6562);
      match(PostgreSQLParser::ALTER);
      setState(6563);
      match(PostgreSQLParser::TRIGGER);
      setState(6564);
      name();
      setState(6565);
      match(PostgreSQLParser::ON);
      setState(6566);
      qualified_name();
      setState(6568);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::NO) {
        setState(6567);
        no_();
      }
      setState(6570);
      match(PostgreSQLParser::DEPENDS);
      setState(6571);
      match(PostgreSQLParser::ON);
      setState(6572);
      match(PostgreSQLParser::EXTENSION);
      setState(6573);
      name();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6575);
      match(PostgreSQLParser::ALTER);
      setState(6576);
      match(PostgreSQLParser::MATERIALIZED);
      setState(6577);
      match(PostgreSQLParser::VIEW);
      setState(6578);
      qualified_name();
      setState(6580);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::NO) {
        setState(6579);
        no_();
      }
      setState(6582);
      match(PostgreSQLParser::DEPENDS);
      setState(6583);
      match(PostgreSQLParser::ON);
      setState(6584);
      match(PostgreSQLParser::EXTENSION);
      setState(6585);
      name();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6587);
      match(PostgreSQLParser::ALTER);
      setState(6588);
      match(PostgreSQLParser::INDEX);
      setState(6589);
      qualified_name();
      setState(6591);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::NO) {
        setState(6590);
        no_();
      }
      setState(6593);
      match(PostgreSQLParser::DEPENDS);
      setState(6594);
      match(PostgreSQLParser::ON);
      setState(6595);
      match(PostgreSQLParser::EXTENSION);
      setState(6596);
      name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- No_Context ------------------------------------------------------------------

PostgreSQLParser::No_Context::No_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::No_Context::NO() {
  return getToken(PostgreSQLParser::NO, 0);
}


size_t PostgreSQLParser::No_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleNo_;
}


std::any PostgreSQLParser::No_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitNo_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::No_Context* PostgreSQLParser::no_() {
  No_Context *_localctx = _tracker.createInstance<No_Context>(_ctx, getState());
  enterRule(_localctx, 728, PostgreSQLParser::RuleNo_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6600);
    match(PostgreSQLParser::NO);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterobjectschemastmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterobjectschemastmtContext::AlterobjectschemastmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::AGGREGATE() {
  return getToken(PostgreSQLParser::AGGREGATE, 0);
}

PostgreSQLParser::Aggregate_with_argtypesContext* PostgreSQLParser::AlterobjectschemastmtContext::aggregate_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Aggregate_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::SCHEMA() {
  return getToken(PostgreSQLParser::SCHEMA, 0);
}

std::vector<PostgreSQLParser::NameContext *> PostgreSQLParser::AlterobjectschemastmtContext::name() {
  return getRuleContexts<PostgreSQLParser::NameContext>();
}

PostgreSQLParser::NameContext* PostgreSQLParser::AlterobjectschemastmtContext::name(size_t i) {
  return getRuleContext<PostgreSQLParser::NameContext>(i);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::COLLATION() {
  return getToken(PostgreSQLParser::COLLATION, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::AlterobjectschemastmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::CONVERSION_P() {
  return getToken(PostgreSQLParser::CONVERSION_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::DOMAIN_P() {
  return getToken(PostgreSQLParser::DOMAIN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::EXTENSION() {
  return getToken(PostgreSQLParser::EXTENSION, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::FUNCTION() {
  return getToken(PostgreSQLParser::FUNCTION, 0);
}

PostgreSQLParser::Function_with_argtypesContext* PostgreSQLParser::AlterobjectschemastmtContext::function_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Function_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

PostgreSQLParser::Operator_with_argtypesContext* PostgreSQLParser::AlterobjectschemastmtContext::operator_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Operator_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::CLASS() {
  return getToken(PostgreSQLParser::CLASS, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::FAMILY() {
  return getToken(PostgreSQLParser::FAMILY, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::PROCEDURE() {
  return getToken(PostgreSQLParser::PROCEDURE, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::ROUTINE() {
  return getToken(PostgreSQLParser::ROUTINE, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}

PostgreSQLParser::Relation_exprContext* PostgreSQLParser::AlterobjectschemastmtContext::relation_expr() {
  return getRuleContext<PostgreSQLParser::Relation_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::STATISTICS() {
  return getToken(PostgreSQLParser::STATISTICS, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::TEXT_P() {
  return getToken(PostgreSQLParser::TEXT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::SEARCH() {
  return getToken(PostgreSQLParser::SEARCH, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::PARSER() {
  return getToken(PostgreSQLParser::PARSER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::DICTIONARY() {
  return getToken(PostgreSQLParser::DICTIONARY, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::TEMPLATE() {
  return getToken(PostgreSQLParser::TEMPLATE, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::CONFIGURATION() {
  return getToken(PostgreSQLParser::CONFIGURATION, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::SEQUENCE() {
  return getToken(PostgreSQLParser::SEQUENCE, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::AlterobjectschemastmtContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::VIEW() {
  return getToken(PostgreSQLParser::VIEW, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::MATERIALIZED() {
  return getToken(PostgreSQLParser::MATERIALIZED, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::FOREIGN() {
  return getToken(PostgreSQLParser::FOREIGN, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterobjectschemastmtContext::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}


size_t PostgreSQLParser::AlterobjectschemastmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterobjectschemastmt;
}


std::any PostgreSQLParser::AlterobjectschemastmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterobjectschemastmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterobjectschemastmtContext* PostgreSQLParser::alterobjectschemastmt() {
  AlterobjectschemastmtContext *_localctx = _tracker.createInstance<AlterobjectschemastmtContext>(_ctx, getState());
  enterRule(_localctx, 730, PostgreSQLParser::RuleAlterobjectschemastmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6819);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 556, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6602);
      match(PostgreSQLParser::ALTER);
      setState(6603);
      match(PostgreSQLParser::AGGREGATE);
      setState(6604);
      aggregate_with_argtypes();
      setState(6605);
      match(PostgreSQLParser::SET);
      setState(6606);
      match(PostgreSQLParser::SCHEMA);
      setState(6607);
      name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6609);
      match(PostgreSQLParser::ALTER);
      setState(6610);
      match(PostgreSQLParser::COLLATION);
      setState(6611);
      any_name();
      setState(6612);
      match(PostgreSQLParser::SET);
      setState(6613);
      match(PostgreSQLParser::SCHEMA);
      setState(6614);
      name();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6616);
      match(PostgreSQLParser::ALTER);
      setState(6617);
      match(PostgreSQLParser::CONVERSION_P);
      setState(6618);
      any_name();
      setState(6619);
      match(PostgreSQLParser::SET);
      setState(6620);
      match(PostgreSQLParser::SCHEMA);
      setState(6621);
      name();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6623);
      match(PostgreSQLParser::ALTER);
      setState(6624);
      match(PostgreSQLParser::DOMAIN_P);
      setState(6625);
      any_name();
      setState(6626);
      match(PostgreSQLParser::SET);
      setState(6627);
      match(PostgreSQLParser::SCHEMA);
      setState(6628);
      name();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6630);
      match(PostgreSQLParser::ALTER);
      setState(6631);
      match(PostgreSQLParser::EXTENSION);
      setState(6632);
      name();
      setState(6633);
      match(PostgreSQLParser::SET);
      setState(6634);
      match(PostgreSQLParser::SCHEMA);
      setState(6635);
      name();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6637);
      match(PostgreSQLParser::ALTER);
      setState(6638);
      match(PostgreSQLParser::FUNCTION);
      setState(6639);
      function_with_argtypes();
      setState(6640);
      match(PostgreSQLParser::SET);
      setState(6641);
      match(PostgreSQLParser::SCHEMA);
      setState(6642);
      name();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6644);
      match(PostgreSQLParser::ALTER);
      setState(6645);
      match(PostgreSQLParser::OPERATOR);
      setState(6646);
      operator_with_argtypes();
      setState(6647);
      match(PostgreSQLParser::SET);
      setState(6648);
      match(PostgreSQLParser::SCHEMA);
      setState(6649);
      name();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(6651);
      match(PostgreSQLParser::ALTER);
      setState(6652);
      match(PostgreSQLParser::OPERATOR);
      setState(6653);
      match(PostgreSQLParser::CLASS);
      setState(6654);
      any_name();
      setState(6655);
      match(PostgreSQLParser::USING);
      setState(6656);
      name();
      setState(6657);
      match(PostgreSQLParser::SET);
      setState(6658);
      match(PostgreSQLParser::SCHEMA);
      setState(6659);
      name();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(6661);
      match(PostgreSQLParser::ALTER);
      setState(6662);
      match(PostgreSQLParser::OPERATOR);
      setState(6663);
      match(PostgreSQLParser::FAMILY);
      setState(6664);
      any_name();
      setState(6665);
      match(PostgreSQLParser::USING);
      setState(6666);
      name();
      setState(6667);
      match(PostgreSQLParser::SET);
      setState(6668);
      match(PostgreSQLParser::SCHEMA);
      setState(6669);
      name();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(6671);
      match(PostgreSQLParser::ALTER);
      setState(6672);
      match(PostgreSQLParser::PROCEDURE);
      setState(6673);
      function_with_argtypes();
      setState(6674);
      match(PostgreSQLParser::SET);
      setState(6675);
      match(PostgreSQLParser::SCHEMA);
      setState(6676);
      name();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(6678);
      match(PostgreSQLParser::ALTER);
      setState(6679);
      match(PostgreSQLParser::ROUTINE);
      setState(6680);
      function_with_argtypes();
      setState(6681);
      match(PostgreSQLParser::SET);
      setState(6682);
      match(PostgreSQLParser::SCHEMA);
      setState(6683);
      name();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(6685);
      match(PostgreSQLParser::ALTER);
      setState(6686);
      match(PostgreSQLParser::TABLE);
      setState(6687);
      relation_expr();
      setState(6688);
      match(PostgreSQLParser::SET);
      setState(6689);
      match(PostgreSQLParser::SCHEMA);
      setState(6690);
      name();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(6692);
      match(PostgreSQLParser::ALTER);
      setState(6693);
      match(PostgreSQLParser::TABLE);
      setState(6694);
      match(PostgreSQLParser::IF_P);
      setState(6695);
      match(PostgreSQLParser::EXISTS);
      setState(6696);
      relation_expr();
      setState(6697);
      match(PostgreSQLParser::SET);
      setState(6698);
      match(PostgreSQLParser::SCHEMA);
      setState(6699);
      name();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(6701);
      match(PostgreSQLParser::ALTER);
      setState(6702);
      match(PostgreSQLParser::STATISTICS);
      setState(6703);
      any_name();
      setState(6704);
      match(PostgreSQLParser::SET);
      setState(6705);
      match(PostgreSQLParser::SCHEMA);
      setState(6706);
      name();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(6708);
      match(PostgreSQLParser::ALTER);
      setState(6709);
      match(PostgreSQLParser::TEXT_P);
      setState(6710);
      match(PostgreSQLParser::SEARCH);
      setState(6711);
      match(PostgreSQLParser::PARSER);
      setState(6712);
      any_name();
      setState(6713);
      match(PostgreSQLParser::SET);
      setState(6714);
      match(PostgreSQLParser::SCHEMA);
      setState(6715);
      name();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(6717);
      match(PostgreSQLParser::ALTER);
      setState(6718);
      match(PostgreSQLParser::TEXT_P);
      setState(6719);
      match(PostgreSQLParser::SEARCH);
      setState(6720);
      match(PostgreSQLParser::DICTIONARY);
      setState(6721);
      any_name();
      setState(6722);
      match(PostgreSQLParser::SET);
      setState(6723);
      match(PostgreSQLParser::SCHEMA);
      setState(6724);
      name();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(6726);
      match(PostgreSQLParser::ALTER);
      setState(6727);
      match(PostgreSQLParser::TEXT_P);
      setState(6728);
      match(PostgreSQLParser::SEARCH);
      setState(6729);
      match(PostgreSQLParser::TEMPLATE);
      setState(6730);
      any_name();
      setState(6731);
      match(PostgreSQLParser::SET);
      setState(6732);
      match(PostgreSQLParser::SCHEMA);
      setState(6733);
      name();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(6735);
      match(PostgreSQLParser::ALTER);
      setState(6736);
      match(PostgreSQLParser::TEXT_P);
      setState(6737);
      match(PostgreSQLParser::SEARCH);
      setState(6738);
      match(PostgreSQLParser::CONFIGURATION);
      setState(6739);
      any_name();
      setState(6740);
      match(PostgreSQLParser::SET);
      setState(6741);
      match(PostgreSQLParser::SCHEMA);
      setState(6742);
      name();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(6744);
      match(PostgreSQLParser::ALTER);
      setState(6745);
      match(PostgreSQLParser::SEQUENCE);
      setState(6746);
      qualified_name();
      setState(6747);
      match(PostgreSQLParser::SET);
      setState(6748);
      match(PostgreSQLParser::SCHEMA);
      setState(6749);
      name();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(6751);
      match(PostgreSQLParser::ALTER);
      setState(6752);
      match(PostgreSQLParser::SEQUENCE);
      setState(6753);
      match(PostgreSQLParser::IF_P);
      setState(6754);
      match(PostgreSQLParser::EXISTS);
      setState(6755);
      qualified_name();
      setState(6756);
      match(PostgreSQLParser::SET);
      setState(6757);
      match(PostgreSQLParser::SCHEMA);
      setState(6758);
      name();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(6760);
      match(PostgreSQLParser::ALTER);
      setState(6761);
      match(PostgreSQLParser::VIEW);
      setState(6762);
      qualified_name();
      setState(6763);
      match(PostgreSQLParser::SET);
      setState(6764);
      match(PostgreSQLParser::SCHEMA);
      setState(6765);
      name();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(6767);
      match(PostgreSQLParser::ALTER);
      setState(6768);
      match(PostgreSQLParser::VIEW);
      setState(6769);
      match(PostgreSQLParser::IF_P);
      setState(6770);
      match(PostgreSQLParser::EXISTS);
      setState(6771);
      qualified_name();
      setState(6772);
      match(PostgreSQLParser::SET);
      setState(6773);
      match(PostgreSQLParser::SCHEMA);
      setState(6774);
      name();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(6776);
      match(PostgreSQLParser::ALTER);
      setState(6777);
      match(PostgreSQLParser::MATERIALIZED);
      setState(6778);
      match(PostgreSQLParser::VIEW);
      setState(6779);
      qualified_name();
      setState(6780);
      match(PostgreSQLParser::SET);
      setState(6781);
      match(PostgreSQLParser::SCHEMA);
      setState(6782);
      name();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(6784);
      match(PostgreSQLParser::ALTER);
      setState(6785);
      match(PostgreSQLParser::MATERIALIZED);
      setState(6786);
      match(PostgreSQLParser::VIEW);
      setState(6787);
      match(PostgreSQLParser::IF_P);
      setState(6788);
      match(PostgreSQLParser::EXISTS);
      setState(6789);
      qualified_name();
      setState(6790);
      match(PostgreSQLParser::SET);
      setState(6791);
      match(PostgreSQLParser::SCHEMA);
      setState(6792);
      name();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(6794);
      match(PostgreSQLParser::ALTER);
      setState(6795);
      match(PostgreSQLParser::FOREIGN);
      setState(6796);
      match(PostgreSQLParser::TABLE);
      setState(6797);
      relation_expr();
      setState(6798);
      match(PostgreSQLParser::SET);
      setState(6799);
      match(PostgreSQLParser::SCHEMA);
      setState(6800);
      name();
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(6802);
      match(PostgreSQLParser::ALTER);
      setState(6803);
      match(PostgreSQLParser::FOREIGN);
      setState(6804);
      match(PostgreSQLParser::TABLE);
      setState(6805);
      match(PostgreSQLParser::IF_P);
      setState(6806);
      match(PostgreSQLParser::EXISTS);
      setState(6807);
      relation_expr();
      setState(6808);
      match(PostgreSQLParser::SET);
      setState(6809);
      match(PostgreSQLParser::SCHEMA);
      setState(6810);
      name();
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(6812);
      match(PostgreSQLParser::ALTER);
      setState(6813);
      match(PostgreSQLParser::TYPE_P);
      setState(6814);
      any_name();
      setState(6815);
      match(PostgreSQLParser::SET);
      setState(6816);
      match(PostgreSQLParser::SCHEMA);
      setState(6817);
      name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlteroperatorstmtContext ------------------------------------------------------------------

PostgreSQLParser::AlteroperatorstmtContext::AlteroperatorstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlteroperatorstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlteroperatorstmtContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

PostgreSQLParser::Operator_with_argtypesContext* PostgreSQLParser::AlteroperatorstmtContext::operator_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Operator_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlteroperatorstmtContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

tree::TerminalNode* PostgreSQLParser::AlteroperatorstmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Operator_def_listContext* PostgreSQLParser::AlteroperatorstmtContext::operator_def_list() {
  return getRuleContext<PostgreSQLParser::Operator_def_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlteroperatorstmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::AlteroperatorstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlteroperatorstmt;
}


std::any PostgreSQLParser::AlteroperatorstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlteroperatorstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlteroperatorstmtContext* PostgreSQLParser::alteroperatorstmt() {
  AlteroperatorstmtContext *_localctx = _tracker.createInstance<AlteroperatorstmtContext>(_ctx, getState());
  enterRule(_localctx, 732, PostgreSQLParser::RuleAlteroperatorstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6821);
    match(PostgreSQLParser::ALTER);
    setState(6822);
    match(PostgreSQLParser::OPERATOR);
    setState(6823);
    operator_with_argtypes();
    setState(6824);
    match(PostgreSQLParser::SET);
    setState(6825);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(6826);
    operator_def_list();
    setState(6827);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Operator_def_listContext ------------------------------------------------------------------

PostgreSQLParser::Operator_def_listContext::Operator_def_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Operator_def_elemContext *> PostgreSQLParser::Operator_def_listContext::operator_def_elem() {
  return getRuleContexts<PostgreSQLParser::Operator_def_elemContext>();
}

PostgreSQLParser::Operator_def_elemContext* PostgreSQLParser::Operator_def_listContext::operator_def_elem(size_t i) {
  return getRuleContext<PostgreSQLParser::Operator_def_elemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Operator_def_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Operator_def_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Operator_def_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOperator_def_list;
}


std::any PostgreSQLParser::Operator_def_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOperator_def_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Operator_def_listContext* PostgreSQLParser::operator_def_list() {
  Operator_def_listContext *_localctx = _tracker.createInstance<Operator_def_listContext>(_ctx, getState());
  enterRule(_localctx, 734, PostgreSQLParser::RuleOperator_def_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6829);
    operator_def_elem();
    setState(6834);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(6830);
      match(PostgreSQLParser::COMMA);
      setState(6831);
      operator_def_elem();
      setState(6836);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Operator_def_elemContext ------------------------------------------------------------------

PostgreSQLParser::Operator_def_elemContext::Operator_def_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColLabelContext* PostgreSQLParser::Operator_def_elemContext::colLabel() {
  return getRuleContext<PostgreSQLParser::ColLabelContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Operator_def_elemContext::EQUAL() {
  return getToken(PostgreSQLParser::EQUAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Operator_def_elemContext::NONE() {
  return getToken(PostgreSQLParser::NONE, 0);
}

PostgreSQLParser::Operator_def_argContext* PostgreSQLParser::Operator_def_elemContext::operator_def_arg() {
  return getRuleContext<PostgreSQLParser::Operator_def_argContext>(0);
}


size_t PostgreSQLParser::Operator_def_elemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOperator_def_elem;
}


std::any PostgreSQLParser::Operator_def_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOperator_def_elem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Operator_def_elemContext* PostgreSQLParser::operator_def_elem() {
  Operator_def_elemContext *_localctx = _tracker.createInstance<Operator_def_elemContext>(_ctx, getState());
  enterRule(_localctx, 736, PostgreSQLParser::RuleOperator_def_elem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6845);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 558, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6837);
      colLabel();
      setState(6838);
      match(PostgreSQLParser::EQUAL);
      setState(6839);
      match(PostgreSQLParser::NONE);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6841);
      colLabel();
      setState(6842);
      match(PostgreSQLParser::EQUAL);
      setState(6843);
      operator_def_arg();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Operator_def_argContext ------------------------------------------------------------------

PostgreSQLParser::Operator_def_argContext::Operator_def_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Func_typeContext* PostgreSQLParser::Operator_def_argContext::func_type() {
  return getRuleContext<PostgreSQLParser::Func_typeContext>(0);
}

PostgreSQLParser::Reserved_keywordContext* PostgreSQLParser::Operator_def_argContext::reserved_keyword() {
  return getRuleContext<PostgreSQLParser::Reserved_keywordContext>(0);
}

PostgreSQLParser::Qual_all_opContext* PostgreSQLParser::Operator_def_argContext::qual_all_op() {
  return getRuleContext<PostgreSQLParser::Qual_all_opContext>(0);
}

PostgreSQLParser::NumericonlyContext* PostgreSQLParser::Operator_def_argContext::numericonly() {
  return getRuleContext<PostgreSQLParser::NumericonlyContext>(0);
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Operator_def_argContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}


size_t PostgreSQLParser::Operator_def_argContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOperator_def_arg;
}


std::any PostgreSQLParser::Operator_def_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOperator_def_arg(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Operator_def_argContext* PostgreSQLParser::operator_def_arg() {
  Operator_def_argContext *_localctx = _tracker.createInstance<Operator_def_argContext>(_ctx, getState());
  enterRule(_localctx, 738, PostgreSQLParser::RuleOperator_def_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6852);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 559, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6847);
      func_type();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6848);
      reserved_keyword();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6849);
      qual_all_op();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6850);
      numericonly();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6851);
      sconst();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AltertypestmtContext ------------------------------------------------------------------

PostgreSQLParser::AltertypestmtContext::AltertypestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AltertypestmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertypestmtContext::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::AltertypestmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AltertypestmtContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertypestmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Operator_def_listContext* PostgreSQLParser::AltertypestmtContext::operator_def_list() {
  return getRuleContext<PostgreSQLParser::Operator_def_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AltertypestmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::AltertypestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAltertypestmt;
}


std::any PostgreSQLParser::AltertypestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAltertypestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AltertypestmtContext* PostgreSQLParser::altertypestmt() {
  AltertypestmtContext *_localctx = _tracker.createInstance<AltertypestmtContext>(_ctx, getState());
  enterRule(_localctx, 740, PostgreSQLParser::RuleAltertypestmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6854);
    match(PostgreSQLParser::ALTER);
    setState(6855);
    match(PostgreSQLParser::TYPE_P);
    setState(6856);
    any_name();
    setState(6857);
    match(PostgreSQLParser::SET);
    setState(6858);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(6859);
    operator_def_list();
    setState(6860);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterownerstmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterownerstmtContext::AlterownerstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::AGGREGATE() {
  return getToken(PostgreSQLParser::AGGREGATE, 0);
}

PostgreSQLParser::Aggregate_with_argtypesContext* PostgreSQLParser::AlterownerstmtContext::aggregate_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Aggregate_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::OWNER() {
  return getToken(PostgreSQLParser::OWNER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}

PostgreSQLParser::RolespecContext* PostgreSQLParser::AlterownerstmtContext::rolespec() {
  return getRuleContext<PostgreSQLParser::RolespecContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::COLLATION() {
  return getToken(PostgreSQLParser::COLLATION, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::AlterownerstmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::CONVERSION_P() {
  return getToken(PostgreSQLParser::CONVERSION_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::DATABASE() {
  return getToken(PostgreSQLParser::DATABASE, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::AlterownerstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::DOMAIN_P() {
  return getToken(PostgreSQLParser::DOMAIN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::FUNCTION() {
  return getToken(PostgreSQLParser::FUNCTION, 0);
}

PostgreSQLParser::Function_with_argtypesContext* PostgreSQLParser::AlterownerstmtContext::function_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Function_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::LANGUAGE() {
  return getToken(PostgreSQLParser::LANGUAGE, 0);
}

PostgreSQLParser::Procedural_Context* PostgreSQLParser::AlterownerstmtContext::procedural_() {
  return getRuleContext<PostgreSQLParser::Procedural_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::LARGE_P() {
  return getToken(PostgreSQLParser::LARGE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::OBJECT_P() {
  return getToken(PostgreSQLParser::OBJECT_P, 0);
}

PostgreSQLParser::NumericonlyContext* PostgreSQLParser::AlterownerstmtContext::numericonly() {
  return getRuleContext<PostgreSQLParser::NumericonlyContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

PostgreSQLParser::Operator_with_argtypesContext* PostgreSQLParser::AlterownerstmtContext::operator_with_argtypes() {
  return getRuleContext<PostgreSQLParser::Operator_with_argtypesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::CLASS() {
  return getToken(PostgreSQLParser::CLASS, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::FAMILY() {
  return getToken(PostgreSQLParser::FAMILY, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::PROCEDURE() {
  return getToken(PostgreSQLParser::PROCEDURE, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::ROUTINE() {
  return getToken(PostgreSQLParser::ROUTINE, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::SCHEMA() {
  return getToken(PostgreSQLParser::SCHEMA, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::TABLESPACE() {
  return getToken(PostgreSQLParser::TABLESPACE, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::STATISTICS() {
  return getToken(PostgreSQLParser::STATISTICS, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::TEXT_P() {
  return getToken(PostgreSQLParser::TEXT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::SEARCH() {
  return getToken(PostgreSQLParser::SEARCH, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::DICTIONARY() {
  return getToken(PostgreSQLParser::DICTIONARY, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::CONFIGURATION() {
  return getToken(PostgreSQLParser::CONFIGURATION, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::FOREIGN() {
  return getToken(PostgreSQLParser::FOREIGN, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::DATA_P() {
  return getToken(PostgreSQLParser::DATA_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::WRAPPER() {
  return getToken(PostgreSQLParser::WRAPPER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::SERVER() {
  return getToken(PostgreSQLParser::SERVER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::EVENT() {
  return getToken(PostgreSQLParser::EVENT, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::TRIGGER() {
  return getToken(PostgreSQLParser::TRIGGER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::PUBLICATION() {
  return getToken(PostgreSQLParser::PUBLICATION, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterownerstmtContext::SUBSCRIPTION() {
  return getToken(PostgreSQLParser::SUBSCRIPTION, 0);
}


size_t PostgreSQLParser::AlterownerstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterownerstmt;
}


std::any PostgreSQLParser::AlterownerstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterownerstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterownerstmtContext* PostgreSQLParser::alterownerstmt() {
  AlterownerstmtContext *_localctx = _tracker.createInstance<AlterownerstmtContext>(_ctx, getState());
  enterRule(_localctx, 742, PostgreSQLParser::RuleAlterownerstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7047);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 561, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6862);
      match(PostgreSQLParser::ALTER);
      setState(6863);
      match(PostgreSQLParser::AGGREGATE);
      setState(6864);
      aggregate_with_argtypes();
      setState(6865);
      match(PostgreSQLParser::OWNER);
      setState(6866);
      match(PostgreSQLParser::TO);
      setState(6867);
      rolespec();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6869);
      match(PostgreSQLParser::ALTER);
      setState(6870);
      match(PostgreSQLParser::COLLATION);
      setState(6871);
      any_name();
      setState(6872);
      match(PostgreSQLParser::OWNER);
      setState(6873);
      match(PostgreSQLParser::TO);
      setState(6874);
      rolespec();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6876);
      match(PostgreSQLParser::ALTER);
      setState(6877);
      match(PostgreSQLParser::CONVERSION_P);
      setState(6878);
      any_name();
      setState(6879);
      match(PostgreSQLParser::OWNER);
      setState(6880);
      match(PostgreSQLParser::TO);
      setState(6881);
      rolespec();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6883);
      match(PostgreSQLParser::ALTER);
      setState(6884);
      match(PostgreSQLParser::DATABASE);
      setState(6885);
      name();
      setState(6886);
      match(PostgreSQLParser::OWNER);
      setState(6887);
      match(PostgreSQLParser::TO);
      setState(6888);
      rolespec();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6890);
      match(PostgreSQLParser::ALTER);
      setState(6891);
      match(PostgreSQLParser::DOMAIN_P);
      setState(6892);
      any_name();
      setState(6893);
      match(PostgreSQLParser::OWNER);
      setState(6894);
      match(PostgreSQLParser::TO);
      setState(6895);
      rolespec();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6897);
      match(PostgreSQLParser::ALTER);
      setState(6898);
      match(PostgreSQLParser::FUNCTION);
      setState(6899);
      function_with_argtypes();
      setState(6900);
      match(PostgreSQLParser::OWNER);
      setState(6901);
      match(PostgreSQLParser::TO);
      setState(6902);
      rolespec();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6904);
      match(PostgreSQLParser::ALTER);
      setState(6906);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::PROCEDURAL) {
        setState(6905);
        procedural_();
      }
      setState(6908);
      match(PostgreSQLParser::LANGUAGE);
      setState(6909);
      name();
      setState(6910);
      match(PostgreSQLParser::OWNER);
      setState(6911);
      match(PostgreSQLParser::TO);
      setState(6912);
      rolespec();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(6914);
      match(PostgreSQLParser::ALTER);
      setState(6915);
      match(PostgreSQLParser::LARGE_P);
      setState(6916);
      match(PostgreSQLParser::OBJECT_P);
      setState(6917);
      numericonly();
      setState(6918);
      match(PostgreSQLParser::OWNER);
      setState(6919);
      match(PostgreSQLParser::TO);
      setState(6920);
      rolespec();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(6922);
      match(PostgreSQLParser::ALTER);
      setState(6923);
      match(PostgreSQLParser::OPERATOR);
      setState(6924);
      operator_with_argtypes();
      setState(6925);
      match(PostgreSQLParser::OWNER);
      setState(6926);
      match(PostgreSQLParser::TO);
      setState(6927);
      rolespec();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(6929);
      match(PostgreSQLParser::ALTER);
      setState(6930);
      match(PostgreSQLParser::OPERATOR);
      setState(6931);
      match(PostgreSQLParser::CLASS);
      setState(6932);
      any_name();
      setState(6933);
      match(PostgreSQLParser::USING);
      setState(6934);
      name();
      setState(6935);
      match(PostgreSQLParser::OWNER);
      setState(6936);
      match(PostgreSQLParser::TO);
      setState(6937);
      rolespec();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(6939);
      match(PostgreSQLParser::ALTER);
      setState(6940);
      match(PostgreSQLParser::OPERATOR);
      setState(6941);
      match(PostgreSQLParser::FAMILY);
      setState(6942);
      any_name();
      setState(6943);
      match(PostgreSQLParser::USING);
      setState(6944);
      name();
      setState(6945);
      match(PostgreSQLParser::OWNER);
      setState(6946);
      match(PostgreSQLParser::TO);
      setState(6947);
      rolespec();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(6949);
      match(PostgreSQLParser::ALTER);
      setState(6950);
      match(PostgreSQLParser::PROCEDURE);
      setState(6951);
      function_with_argtypes();
      setState(6952);
      match(PostgreSQLParser::OWNER);
      setState(6953);
      match(PostgreSQLParser::TO);
      setState(6954);
      rolespec();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(6956);
      match(PostgreSQLParser::ALTER);
      setState(6957);
      match(PostgreSQLParser::ROUTINE);
      setState(6958);
      function_with_argtypes();
      setState(6959);
      match(PostgreSQLParser::OWNER);
      setState(6960);
      match(PostgreSQLParser::TO);
      setState(6961);
      rolespec();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(6963);
      match(PostgreSQLParser::ALTER);
      setState(6964);
      match(PostgreSQLParser::SCHEMA);
      setState(6965);
      name();
      setState(6966);
      match(PostgreSQLParser::OWNER);
      setState(6967);
      match(PostgreSQLParser::TO);
      setState(6968);
      rolespec();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(6970);
      match(PostgreSQLParser::ALTER);
      setState(6971);
      match(PostgreSQLParser::TYPE_P);
      setState(6972);
      any_name();
      setState(6973);
      match(PostgreSQLParser::OWNER);
      setState(6974);
      match(PostgreSQLParser::TO);
      setState(6975);
      rolespec();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(6977);
      match(PostgreSQLParser::ALTER);
      setState(6978);
      match(PostgreSQLParser::TABLESPACE);
      setState(6979);
      name();
      setState(6980);
      match(PostgreSQLParser::OWNER);
      setState(6981);
      match(PostgreSQLParser::TO);
      setState(6982);
      rolespec();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(6984);
      match(PostgreSQLParser::ALTER);
      setState(6985);
      match(PostgreSQLParser::STATISTICS);
      setState(6986);
      any_name();
      setState(6987);
      match(PostgreSQLParser::OWNER);
      setState(6988);
      match(PostgreSQLParser::TO);
      setState(6989);
      rolespec();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(6991);
      match(PostgreSQLParser::ALTER);
      setState(6992);
      match(PostgreSQLParser::TEXT_P);
      setState(6993);
      match(PostgreSQLParser::SEARCH);
      setState(6994);
      match(PostgreSQLParser::DICTIONARY);
      setState(6995);
      any_name();
      setState(6996);
      match(PostgreSQLParser::OWNER);
      setState(6997);
      match(PostgreSQLParser::TO);
      setState(6998);
      rolespec();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(7000);
      match(PostgreSQLParser::ALTER);
      setState(7001);
      match(PostgreSQLParser::TEXT_P);
      setState(7002);
      match(PostgreSQLParser::SEARCH);
      setState(7003);
      match(PostgreSQLParser::CONFIGURATION);
      setState(7004);
      any_name();
      setState(7005);
      match(PostgreSQLParser::OWNER);
      setState(7006);
      match(PostgreSQLParser::TO);
      setState(7007);
      rolespec();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(7009);
      match(PostgreSQLParser::ALTER);
      setState(7010);
      match(PostgreSQLParser::FOREIGN);
      setState(7011);
      match(PostgreSQLParser::DATA_P);
      setState(7012);
      match(PostgreSQLParser::WRAPPER);
      setState(7013);
      name();
      setState(7014);
      match(PostgreSQLParser::OWNER);
      setState(7015);
      match(PostgreSQLParser::TO);
      setState(7016);
      rolespec();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(7018);
      match(PostgreSQLParser::ALTER);
      setState(7019);
      match(PostgreSQLParser::SERVER);
      setState(7020);
      name();
      setState(7021);
      match(PostgreSQLParser::OWNER);
      setState(7022);
      match(PostgreSQLParser::TO);
      setState(7023);
      rolespec();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(7025);
      match(PostgreSQLParser::ALTER);
      setState(7026);
      match(PostgreSQLParser::EVENT);
      setState(7027);
      match(PostgreSQLParser::TRIGGER);
      setState(7028);
      name();
      setState(7029);
      match(PostgreSQLParser::OWNER);
      setState(7030);
      match(PostgreSQLParser::TO);
      setState(7031);
      rolespec();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(7033);
      match(PostgreSQLParser::ALTER);
      setState(7034);
      match(PostgreSQLParser::PUBLICATION);
      setState(7035);
      name();
      setState(7036);
      match(PostgreSQLParser::OWNER);
      setState(7037);
      match(PostgreSQLParser::TO);
      setState(7038);
      rolespec();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(7040);
      match(PostgreSQLParser::ALTER);
      setState(7041);
      match(PostgreSQLParser::SUBSCRIPTION);
      setState(7042);
      name();
      setState(7043);
      match(PostgreSQLParser::OWNER);
      setState(7044);
      match(PostgreSQLParser::TO);
      setState(7045);
      rolespec();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreatepublicationstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreatepublicationstmtContext::CreatepublicationstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreatepublicationstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatepublicationstmtContext::PUBLICATION() {
  return getToken(PostgreSQLParser::PUBLICATION, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::CreatepublicationstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::Publication_for_tables_Context* PostgreSQLParser::CreatepublicationstmtContext::publication_for_tables_() {
  return getRuleContext<PostgreSQLParser::Publication_for_tables_Context>(0);
}

PostgreSQLParser::Definition_Context* PostgreSQLParser::CreatepublicationstmtContext::definition_() {
  return getRuleContext<PostgreSQLParser::Definition_Context>(0);
}


size_t PostgreSQLParser::CreatepublicationstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatepublicationstmt;
}


std::any PostgreSQLParser::CreatepublicationstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatepublicationstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreatepublicationstmtContext* PostgreSQLParser::createpublicationstmt() {
  CreatepublicationstmtContext *_localctx = _tracker.createInstance<CreatepublicationstmtContext>(_ctx, getState());
  enterRule(_localctx, 744, PostgreSQLParser::RuleCreatepublicationstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7049);
    match(PostgreSQLParser::CREATE);
    setState(7050);
    match(PostgreSQLParser::PUBLICATION);
    setState(7051);
    name();
    setState(7053);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::FOR) {
      setState(7052);
      publication_for_tables_();
    }
    setState(7056);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(7055);
      definition_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Publication_for_tables_Context ------------------------------------------------------------------

PostgreSQLParser::Publication_for_tables_Context::Publication_for_tables_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Publication_for_tablesContext* PostgreSQLParser::Publication_for_tables_Context::publication_for_tables() {
  return getRuleContext<PostgreSQLParser::Publication_for_tablesContext>(0);
}


size_t PostgreSQLParser::Publication_for_tables_Context::getRuleIndex() const {
  return PostgreSQLParser::RulePublication_for_tables_;
}


std::any PostgreSQLParser::Publication_for_tables_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitPublication_for_tables_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Publication_for_tables_Context* PostgreSQLParser::publication_for_tables_() {
  Publication_for_tables_Context *_localctx = _tracker.createInstance<Publication_for_tables_Context>(_ctx, getState());
  enterRule(_localctx, 746, PostgreSQLParser::RulePublication_for_tables_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7058);
    publication_for_tables();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Publication_for_tablesContext ------------------------------------------------------------------

PostgreSQLParser::Publication_for_tablesContext::Publication_for_tablesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Publication_for_tablesContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

tree::TerminalNode* PostgreSQLParser::Publication_for_tablesContext::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}

PostgreSQLParser::Relation_expr_listContext* PostgreSQLParser::Publication_for_tablesContext::relation_expr_list() {
  return getRuleContext<PostgreSQLParser::Relation_expr_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Publication_for_tablesContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}

tree::TerminalNode* PostgreSQLParser::Publication_for_tablesContext::TABLES() {
  return getToken(PostgreSQLParser::TABLES, 0);
}


size_t PostgreSQLParser::Publication_for_tablesContext::getRuleIndex() const {
  return PostgreSQLParser::RulePublication_for_tables;
}


std::any PostgreSQLParser::Publication_for_tablesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitPublication_for_tables(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Publication_for_tablesContext* PostgreSQLParser::publication_for_tables() {
  Publication_for_tablesContext *_localctx = _tracker.createInstance<Publication_for_tablesContext>(_ctx, getState());
  enterRule(_localctx, 748, PostgreSQLParser::RulePublication_for_tables);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7066);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 564, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7060);
      match(PostgreSQLParser::FOR);
      setState(7061);
      match(PostgreSQLParser::TABLE);
      setState(7062);
      relation_expr_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7063);
      match(PostgreSQLParser::FOR);
      setState(7064);
      match(PostgreSQLParser::ALL);
      setState(7065);
      match(PostgreSQLParser::TABLES);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterpublicationstmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterpublicationstmtContext::AlterpublicationstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterpublicationstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterpublicationstmtContext::PUBLICATION() {
  return getToken(PostgreSQLParser::PUBLICATION, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::AlterpublicationstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterpublicationstmtContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

PostgreSQLParser::DefinitionContext* PostgreSQLParser::AlterpublicationstmtContext::definition() {
  return getRuleContext<PostgreSQLParser::DefinitionContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterpublicationstmtContext::ADD_P() {
  return getToken(PostgreSQLParser::ADD_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterpublicationstmtContext::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}

PostgreSQLParser::Relation_expr_listContext* PostgreSQLParser::AlterpublicationstmtContext::relation_expr_list() {
  return getRuleContext<PostgreSQLParser::Relation_expr_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterpublicationstmtContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}


size_t PostgreSQLParser::AlterpublicationstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterpublicationstmt;
}


std::any PostgreSQLParser::AlterpublicationstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterpublicationstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterpublicationstmtContext* PostgreSQLParser::alterpublicationstmt() {
  AlterpublicationstmtContext *_localctx = _tracker.createInstance<AlterpublicationstmtContext>(_ctx, getState());
  enterRule(_localctx, 750, PostgreSQLParser::RuleAlterpublicationstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7095);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 565, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7068);
      match(PostgreSQLParser::ALTER);
      setState(7069);
      match(PostgreSQLParser::PUBLICATION);
      setState(7070);
      name();
      setState(7071);
      match(PostgreSQLParser::SET);
      setState(7072);
      definition();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7074);
      match(PostgreSQLParser::ALTER);
      setState(7075);
      match(PostgreSQLParser::PUBLICATION);
      setState(7076);
      name();
      setState(7077);
      match(PostgreSQLParser::ADD_P);
      setState(7078);
      match(PostgreSQLParser::TABLE);
      setState(7079);
      relation_expr_list();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7081);
      match(PostgreSQLParser::ALTER);
      setState(7082);
      match(PostgreSQLParser::PUBLICATION);
      setState(7083);
      name();
      setState(7084);
      match(PostgreSQLParser::SET);
      setState(7085);
      match(PostgreSQLParser::TABLE);
      setState(7086);
      relation_expr_list();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7088);
      match(PostgreSQLParser::ALTER);
      setState(7089);
      match(PostgreSQLParser::PUBLICATION);
      setState(7090);
      name();
      setState(7091);
      match(PostgreSQLParser::DROP);
      setState(7092);
      match(PostgreSQLParser::TABLE);
      setState(7093);
      relation_expr_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreatesubscriptionstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreatesubscriptionstmtContext::CreatesubscriptionstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreatesubscriptionstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatesubscriptionstmtContext::SUBSCRIPTION() {
  return getToken(PostgreSQLParser::SUBSCRIPTION, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::CreatesubscriptionstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatesubscriptionstmtContext::CONNECTION() {
  return getToken(PostgreSQLParser::CONNECTION, 0);
}

PostgreSQLParser::SconstContext* PostgreSQLParser::CreatesubscriptionstmtContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CreatesubscriptionstmtContext::PUBLICATION() {
  return getToken(PostgreSQLParser::PUBLICATION, 0);
}

PostgreSQLParser::Publication_name_listContext* PostgreSQLParser::CreatesubscriptionstmtContext::publication_name_list() {
  return getRuleContext<PostgreSQLParser::Publication_name_listContext>(0);
}

PostgreSQLParser::Definition_Context* PostgreSQLParser::CreatesubscriptionstmtContext::definition_() {
  return getRuleContext<PostgreSQLParser::Definition_Context>(0);
}


size_t PostgreSQLParser::CreatesubscriptionstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatesubscriptionstmt;
}


std::any PostgreSQLParser::CreatesubscriptionstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatesubscriptionstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreatesubscriptionstmtContext* PostgreSQLParser::createsubscriptionstmt() {
  CreatesubscriptionstmtContext *_localctx = _tracker.createInstance<CreatesubscriptionstmtContext>(_ctx, getState());
  enterRule(_localctx, 752, PostgreSQLParser::RuleCreatesubscriptionstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7097);
    match(PostgreSQLParser::CREATE);
    setState(7098);
    match(PostgreSQLParser::SUBSCRIPTION);
    setState(7099);
    name();
    setState(7100);
    match(PostgreSQLParser::CONNECTION);
    setState(7101);
    sconst();
    setState(7102);
    match(PostgreSQLParser::PUBLICATION);
    setState(7103);
    publication_name_list();
    setState(7105);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(7104);
      definition_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Publication_name_listContext ------------------------------------------------------------------

PostgreSQLParser::Publication_name_listContext::Publication_name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Publication_name_itemContext *> PostgreSQLParser::Publication_name_listContext::publication_name_item() {
  return getRuleContexts<PostgreSQLParser::Publication_name_itemContext>();
}

PostgreSQLParser::Publication_name_itemContext* PostgreSQLParser::Publication_name_listContext::publication_name_item(size_t i) {
  return getRuleContext<PostgreSQLParser::Publication_name_itemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Publication_name_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Publication_name_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Publication_name_listContext::getRuleIndex() const {
  return PostgreSQLParser::RulePublication_name_list;
}


std::any PostgreSQLParser::Publication_name_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitPublication_name_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Publication_name_listContext* PostgreSQLParser::publication_name_list() {
  Publication_name_listContext *_localctx = _tracker.createInstance<Publication_name_listContext>(_ctx, getState());
  enterRule(_localctx, 754, PostgreSQLParser::RulePublication_name_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7107);
    publication_name_item();
    setState(7112);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(7108);
      match(PostgreSQLParser::COMMA);
      setState(7109);
      publication_name_item();
      setState(7114);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Publication_name_itemContext ------------------------------------------------------------------

PostgreSQLParser::Publication_name_itemContext::Publication_name_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColLabelContext* PostgreSQLParser::Publication_name_itemContext::colLabel() {
  return getRuleContext<PostgreSQLParser::ColLabelContext>(0);
}


size_t PostgreSQLParser::Publication_name_itemContext::getRuleIndex() const {
  return PostgreSQLParser::RulePublication_name_item;
}


std::any PostgreSQLParser::Publication_name_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitPublication_name_item(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Publication_name_itemContext* PostgreSQLParser::publication_name_item() {
  Publication_name_itemContext *_localctx = _tracker.createInstance<Publication_name_itemContext>(_ctx, getState());
  enterRule(_localctx, 756, PostgreSQLParser::RulePublication_name_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7115);
    colLabel();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AltersubscriptionstmtContext ------------------------------------------------------------------

PostgreSQLParser::AltersubscriptionstmtContext::AltersubscriptionstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AltersubscriptionstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AltersubscriptionstmtContext::SUBSCRIPTION() {
  return getToken(PostgreSQLParser::SUBSCRIPTION, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::AltersubscriptionstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AltersubscriptionstmtContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

PostgreSQLParser::DefinitionContext* PostgreSQLParser::AltersubscriptionstmtContext::definition() {
  return getRuleContext<PostgreSQLParser::DefinitionContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AltersubscriptionstmtContext::CONNECTION() {
  return getToken(PostgreSQLParser::CONNECTION, 0);
}

PostgreSQLParser::SconstContext* PostgreSQLParser::AltersubscriptionstmtContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AltersubscriptionstmtContext::REFRESH() {
  return getToken(PostgreSQLParser::REFRESH, 0);
}

tree::TerminalNode* PostgreSQLParser::AltersubscriptionstmtContext::PUBLICATION() {
  return getToken(PostgreSQLParser::PUBLICATION, 0);
}

PostgreSQLParser::Definition_Context* PostgreSQLParser::AltersubscriptionstmtContext::definition_() {
  return getRuleContext<PostgreSQLParser::Definition_Context>(0);
}

PostgreSQLParser::Publication_name_listContext* PostgreSQLParser::AltersubscriptionstmtContext::publication_name_list() {
  return getRuleContext<PostgreSQLParser::Publication_name_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AltersubscriptionstmtContext::ENABLE_P() {
  return getToken(PostgreSQLParser::ENABLE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AltersubscriptionstmtContext::DISABLE_P() {
  return getToken(PostgreSQLParser::DISABLE_P, 0);
}


size_t PostgreSQLParser::AltersubscriptionstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAltersubscriptionstmt;
}


std::any PostgreSQLParser::AltersubscriptionstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAltersubscriptionstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AltersubscriptionstmtContext* PostgreSQLParser::altersubscriptionstmt() {
  AltersubscriptionstmtContext *_localctx = _tracker.createInstance<AltersubscriptionstmtContext>(_ctx, getState());
  enterRule(_localctx, 758, PostgreSQLParser::RuleAltersubscriptionstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7156);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 570, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7117);
      match(PostgreSQLParser::ALTER);
      setState(7118);
      match(PostgreSQLParser::SUBSCRIPTION);
      setState(7119);
      name();
      setState(7120);
      match(PostgreSQLParser::SET);
      setState(7121);
      definition();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7123);
      match(PostgreSQLParser::ALTER);
      setState(7124);
      match(PostgreSQLParser::SUBSCRIPTION);
      setState(7125);
      name();
      setState(7126);
      match(PostgreSQLParser::CONNECTION);
      setState(7127);
      sconst();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7129);
      match(PostgreSQLParser::ALTER);
      setState(7130);
      match(PostgreSQLParser::SUBSCRIPTION);
      setState(7131);
      name();
      setState(7132);
      match(PostgreSQLParser::REFRESH);
      setState(7133);
      match(PostgreSQLParser::PUBLICATION);
      setState(7135);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::WITH) {
        setState(7134);
        definition_();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7137);
      match(PostgreSQLParser::ALTER);
      setState(7138);
      match(PostgreSQLParser::SUBSCRIPTION);
      setState(7139);
      name();
      setState(7140);
      match(PostgreSQLParser::SET);
      setState(7141);
      match(PostgreSQLParser::PUBLICATION);
      setState(7142);
      publication_name_list();
      setState(7144);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::WITH) {
        setState(7143);
        definition_();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7146);
      match(PostgreSQLParser::ALTER);
      setState(7147);
      match(PostgreSQLParser::SUBSCRIPTION);
      setState(7148);
      name();
      setState(7149);
      match(PostgreSQLParser::ENABLE_P);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(7151);
      match(PostgreSQLParser::ALTER);
      setState(7152);
      match(PostgreSQLParser::SUBSCRIPTION);
      setState(7153);
      name();
      setState(7154);
      match(PostgreSQLParser::DISABLE_P);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropsubscriptionstmtContext ------------------------------------------------------------------

PostgreSQLParser::DropsubscriptionstmtContext::DropsubscriptionstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DropsubscriptionstmtContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

tree::TerminalNode* PostgreSQLParser::DropsubscriptionstmtContext::SUBSCRIPTION() {
  return getToken(PostgreSQLParser::SUBSCRIPTION, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::DropsubscriptionstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::Drop_behavior_Context* PostgreSQLParser::DropsubscriptionstmtContext::drop_behavior_() {
  return getRuleContext<PostgreSQLParser::Drop_behavior_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::DropsubscriptionstmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::DropsubscriptionstmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}


size_t PostgreSQLParser::DropsubscriptionstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDropsubscriptionstmt;
}


std::any PostgreSQLParser::DropsubscriptionstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDropsubscriptionstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DropsubscriptionstmtContext* PostgreSQLParser::dropsubscriptionstmt() {
  DropsubscriptionstmtContext *_localctx = _tracker.createInstance<DropsubscriptionstmtContext>(_ctx, getState());
  enterRule(_localctx, 760, PostgreSQLParser::RuleDropsubscriptionstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7172);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 573, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7158);
      match(PostgreSQLParser::DROP);
      setState(7159);
      match(PostgreSQLParser::SUBSCRIPTION);
      setState(7160);
      name();
      setState(7162);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(7161);
        drop_behavior_();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7164);
      match(PostgreSQLParser::DROP);
      setState(7165);
      match(PostgreSQLParser::SUBSCRIPTION);
      setState(7166);
      match(PostgreSQLParser::IF_P);
      setState(7167);
      match(PostgreSQLParser::EXISTS);
      setState(7168);
      name();
      setState(7170);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(7169);
        drop_behavior_();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RulestmtContext ------------------------------------------------------------------

PostgreSQLParser::RulestmtContext::RulestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::RulestmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::RulestmtContext::RULE() {
  return getToken(PostgreSQLParser::RULE, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::RulestmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::RulestmtContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

tree::TerminalNode* PostgreSQLParser::RulestmtContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

PostgreSQLParser::EventContext* PostgreSQLParser::RulestmtContext::event() {
  return getRuleContext<PostgreSQLParser::EventContext>(0);
}

tree::TerminalNode* PostgreSQLParser::RulestmtContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::RulestmtContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::RulestmtContext::DO() {
  return getToken(PostgreSQLParser::DO, 0);
}

PostgreSQLParser::RuleactionlistContext* PostgreSQLParser::RulestmtContext::ruleactionlist() {
  return getRuleContext<PostgreSQLParser::RuleactionlistContext>(0);
}

PostgreSQLParser::Or_replace_Context* PostgreSQLParser::RulestmtContext::or_replace_() {
  return getRuleContext<PostgreSQLParser::Or_replace_Context>(0);
}

PostgreSQLParser::Where_clauseContext* PostgreSQLParser::RulestmtContext::where_clause() {
  return getRuleContext<PostgreSQLParser::Where_clauseContext>(0);
}

PostgreSQLParser::Instead_Context* PostgreSQLParser::RulestmtContext::instead_() {
  return getRuleContext<PostgreSQLParser::Instead_Context>(0);
}


size_t PostgreSQLParser::RulestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRulestmt;
}


std::any PostgreSQLParser::RulestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRulestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RulestmtContext* PostgreSQLParser::rulestmt() {
  RulestmtContext *_localctx = _tracker.createInstance<RulestmtContext>(_ctx, getState());
  enterRule(_localctx, 762, PostgreSQLParser::RuleRulestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7174);
    match(PostgreSQLParser::CREATE);
    setState(7176);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OR) {
      setState(7175);
      or_replace_();
    }
    setState(7178);
    match(PostgreSQLParser::RULE);
    setState(7179);
    name();
    setState(7180);
    match(PostgreSQLParser::AS);
    setState(7181);
    match(PostgreSQLParser::ON);
    setState(7182);
    event();
    setState(7183);
    match(PostgreSQLParser::TO);
    setState(7184);
    qualified_name();
    setState(7186);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WHERE) {
      setState(7185);
      where_clause();
    }
    setState(7188);
    match(PostgreSQLParser::DO);
    setState(7190);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::ALSO || _la == PostgreSQLParser::INSTEAD) {
      setState(7189);
      instead_();
    }
    setState(7192);
    ruleactionlist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuleactionlistContext ------------------------------------------------------------------

PostgreSQLParser::RuleactionlistContext::RuleactionlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::RuleactionlistContext::NOTHING() {
  return getToken(PostgreSQLParser::NOTHING, 0);
}

PostgreSQLParser::RuleactionstmtContext* PostgreSQLParser::RuleactionlistContext::ruleactionstmt() {
  return getRuleContext<PostgreSQLParser::RuleactionstmtContext>(0);
}

tree::TerminalNode* PostgreSQLParser::RuleactionlistContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::RuleactionmultiContext* PostgreSQLParser::RuleactionlistContext::ruleactionmulti() {
  return getRuleContext<PostgreSQLParser::RuleactionmultiContext>(0);
}

tree::TerminalNode* PostgreSQLParser::RuleactionlistContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::RuleactionlistContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRuleactionlist;
}


std::any PostgreSQLParser::RuleactionlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRuleactionlist(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RuleactionlistContext* PostgreSQLParser::ruleactionlist() {
  RuleactionlistContext *_localctx = _tracker.createInstance<RuleactionlistContext>(_ctx, getState());
  enterRule(_localctx, 764, PostgreSQLParser::RuleRuleactionlist);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7200);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 577, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7194);
      match(PostgreSQLParser::NOTHING);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7195);
      ruleactionstmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7196);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(7197);
      ruleactionmulti();
      setState(7198);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuleactionmultiContext ------------------------------------------------------------------

PostgreSQLParser::RuleactionmultiContext::RuleactionmultiContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::RuleactionstmtOrEmptyContext *> PostgreSQLParser::RuleactionmultiContext::ruleactionstmtOrEmpty() {
  return getRuleContexts<PostgreSQLParser::RuleactionstmtOrEmptyContext>();
}

PostgreSQLParser::RuleactionstmtOrEmptyContext* PostgreSQLParser::RuleactionmultiContext::ruleactionstmtOrEmpty(size_t i) {
  return getRuleContext<PostgreSQLParser::RuleactionstmtOrEmptyContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::RuleactionmultiContext::SEMI() {
  return getTokens(PostgreSQLParser::SEMI);
}

tree::TerminalNode* PostgreSQLParser::RuleactionmultiContext::SEMI(size_t i) {
  return getToken(PostgreSQLParser::SEMI, i);
}


size_t PostgreSQLParser::RuleactionmultiContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRuleactionmulti;
}


std::any PostgreSQLParser::RuleactionmultiContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRuleactionmulti(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RuleactionmultiContext* PostgreSQLParser::ruleactionmulti() {
  RuleactionmultiContext *_localctx = _tracker.createInstance<RuleactionmultiContext>(_ctx, getState());
  enterRule(_localctx, 766, PostgreSQLParser::RuleRuleactionmulti);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7203);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OPEN_PAREN || ((((_la - 126) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 126)) & 131089) != 0) || _la == PostgreSQLParser::DELETE_P

    || _la == PostgreSQLParser::INSERT || _la == PostgreSQLParser::NOTIFY || _la == PostgreSQLParser::UPDATE

    || _la == PostgreSQLParser::VALUES) {
      setState(7202);
      ruleactionstmtOrEmpty();
    }
    setState(7211);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::SEMI) {
      setState(7205);
      match(PostgreSQLParser::SEMI);
      setState(7207);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPEN_PAREN || ((((_la - 126) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 126)) & 131089) != 0) || _la == PostgreSQLParser::DELETE_P

      || _la == PostgreSQLParser::INSERT || _la == PostgreSQLParser::NOTIFY || _la == PostgreSQLParser::UPDATE

      || _la == PostgreSQLParser::VALUES) {
        setState(7206);
        ruleactionstmtOrEmpty();
      }
      setState(7213);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuleactionstmtContext ------------------------------------------------------------------

PostgreSQLParser::RuleactionstmtContext::RuleactionstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::SelectstmtContext* PostgreSQLParser::RuleactionstmtContext::selectstmt() {
  return getRuleContext<PostgreSQLParser::SelectstmtContext>(0);
}

PostgreSQLParser::InsertstmtContext* PostgreSQLParser::RuleactionstmtContext::insertstmt() {
  return getRuleContext<PostgreSQLParser::InsertstmtContext>(0);
}

PostgreSQLParser::UpdatestmtContext* PostgreSQLParser::RuleactionstmtContext::updatestmt() {
  return getRuleContext<PostgreSQLParser::UpdatestmtContext>(0);
}

PostgreSQLParser::DeletestmtContext* PostgreSQLParser::RuleactionstmtContext::deletestmt() {
  return getRuleContext<PostgreSQLParser::DeletestmtContext>(0);
}

PostgreSQLParser::NotifystmtContext* PostgreSQLParser::RuleactionstmtContext::notifystmt() {
  return getRuleContext<PostgreSQLParser::NotifystmtContext>(0);
}


size_t PostgreSQLParser::RuleactionstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRuleactionstmt;
}


std::any PostgreSQLParser::RuleactionstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRuleactionstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RuleactionstmtContext* PostgreSQLParser::ruleactionstmt() {
  RuleactionstmtContext *_localctx = _tracker.createInstance<RuleactionstmtContext>(_ctx, getState());
  enterRule(_localctx, 768, PostgreSQLParser::RuleRuleactionstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7219);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 581, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7214);
      selectstmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7215);
      insertstmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7216);
      updatestmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7217);
      deletestmt();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7218);
      notifystmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuleactionstmtOrEmptyContext ------------------------------------------------------------------

PostgreSQLParser::RuleactionstmtOrEmptyContext::RuleactionstmtOrEmptyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::RuleactionstmtContext* PostgreSQLParser::RuleactionstmtOrEmptyContext::ruleactionstmt() {
  return getRuleContext<PostgreSQLParser::RuleactionstmtContext>(0);
}


size_t PostgreSQLParser::RuleactionstmtOrEmptyContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRuleactionstmtOrEmpty;
}


std::any PostgreSQLParser::RuleactionstmtOrEmptyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRuleactionstmtOrEmpty(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RuleactionstmtOrEmptyContext* PostgreSQLParser::ruleactionstmtOrEmpty() {
  RuleactionstmtOrEmptyContext *_localctx = _tracker.createInstance<RuleactionstmtOrEmptyContext>(_ctx, getState());
  enterRule(_localctx, 770, PostgreSQLParser::RuleRuleactionstmtOrEmpty);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7221);
    ruleactionstmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventContext ------------------------------------------------------------------

PostgreSQLParser::EventContext::EventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::EventContext::SELECT() {
  return getToken(PostgreSQLParser::SELECT, 0);
}

tree::TerminalNode* PostgreSQLParser::EventContext::UPDATE() {
  return getToken(PostgreSQLParser::UPDATE, 0);
}

tree::TerminalNode* PostgreSQLParser::EventContext::DELETE_P() {
  return getToken(PostgreSQLParser::DELETE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::EventContext::INSERT() {
  return getToken(PostgreSQLParser::INSERT, 0);
}


size_t PostgreSQLParser::EventContext::getRuleIndex() const {
  return PostgreSQLParser::RuleEvent;
}


std::any PostgreSQLParser::EventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitEvent(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::EventContext* PostgreSQLParser::event() {
  EventContext *_localctx = _tracker.createInstance<EventContext>(_ctx, getState());
  enterRule(_localctx, 772, PostgreSQLParser::RuleEvent);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7223);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::SELECT || _la == PostgreSQLParser::DELETE_P

    || _la == PostgreSQLParser::INSERT || _la == PostgreSQLParser::UPDATE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Instead_Context ------------------------------------------------------------------

PostgreSQLParser::Instead_Context::Instead_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Instead_Context::INSTEAD() {
  return getToken(PostgreSQLParser::INSTEAD, 0);
}

tree::TerminalNode* PostgreSQLParser::Instead_Context::ALSO() {
  return getToken(PostgreSQLParser::ALSO, 0);
}


size_t PostgreSQLParser::Instead_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleInstead_;
}


std::any PostgreSQLParser::Instead_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitInstead_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Instead_Context* PostgreSQLParser::instead_() {
  Instead_Context *_localctx = _tracker.createInstance<Instead_Context>(_ctx, getState());
  enterRule(_localctx, 774, PostgreSQLParser::RuleInstead_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7225);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::ALSO || _la == PostgreSQLParser::INSTEAD)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NotifystmtContext ------------------------------------------------------------------

PostgreSQLParser::NotifystmtContext::NotifystmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::NotifystmtContext::NOTIFY() {
  return getToken(PostgreSQLParser::NOTIFY, 0);
}

PostgreSQLParser::ColidContext* PostgreSQLParser::NotifystmtContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

PostgreSQLParser::Notify_payloadContext* PostgreSQLParser::NotifystmtContext::notify_payload() {
  return getRuleContext<PostgreSQLParser::Notify_payloadContext>(0);
}


size_t PostgreSQLParser::NotifystmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleNotifystmt;
}


std::any PostgreSQLParser::NotifystmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitNotifystmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::NotifystmtContext* PostgreSQLParser::notifystmt() {
  NotifystmtContext *_localctx = _tracker.createInstance<NotifystmtContext>(_ctx, getState());
  enterRule(_localctx, 776, PostgreSQLParser::RuleNotifystmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7227);
    match(PostgreSQLParser::NOTIFY);
    setState(7228);
    colid();
    setState(7230);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::COMMA) {
      setState(7229);
      notify_payload();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Notify_payloadContext ------------------------------------------------------------------

PostgreSQLParser::Notify_payloadContext::Notify_payloadContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Notify_payloadContext::COMMA() {
  return getToken(PostgreSQLParser::COMMA, 0);
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Notify_payloadContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}


size_t PostgreSQLParser::Notify_payloadContext::getRuleIndex() const {
  return PostgreSQLParser::RuleNotify_payload;
}


std::any PostgreSQLParser::Notify_payloadContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitNotify_payload(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Notify_payloadContext* PostgreSQLParser::notify_payload() {
  Notify_payloadContext *_localctx = _tracker.createInstance<Notify_payloadContext>(_ctx, getState());
  enterRule(_localctx, 778, PostgreSQLParser::RuleNotify_payload);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7232);
    match(PostgreSQLParser::COMMA);
    setState(7233);
    sconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ListenstmtContext ------------------------------------------------------------------

PostgreSQLParser::ListenstmtContext::ListenstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::ListenstmtContext::LISTEN() {
  return getToken(PostgreSQLParser::LISTEN, 0);
}

PostgreSQLParser::ColidContext* PostgreSQLParser::ListenstmtContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}


size_t PostgreSQLParser::ListenstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleListenstmt;
}


std::any PostgreSQLParser::ListenstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitListenstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ListenstmtContext* PostgreSQLParser::listenstmt() {
  ListenstmtContext *_localctx = _tracker.createInstance<ListenstmtContext>(_ctx, getState());
  enterRule(_localctx, 780, PostgreSQLParser::RuleListenstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7235);
    match(PostgreSQLParser::LISTEN);
    setState(7236);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnlistenstmtContext ------------------------------------------------------------------

PostgreSQLParser::UnlistenstmtContext::UnlistenstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::UnlistenstmtContext::UNLISTEN() {
  return getToken(PostgreSQLParser::UNLISTEN, 0);
}

PostgreSQLParser::ColidContext* PostgreSQLParser::UnlistenstmtContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

tree::TerminalNode* PostgreSQLParser::UnlistenstmtContext::STAR() {
  return getToken(PostgreSQLParser::STAR, 0);
}


size_t PostgreSQLParser::UnlistenstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleUnlistenstmt;
}


std::any PostgreSQLParser::UnlistenstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitUnlistenstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::UnlistenstmtContext* PostgreSQLParser::unlistenstmt() {
  UnlistenstmtContext *_localctx = _tracker.createInstance<UnlistenstmtContext>(_ctx, getState());
  enterRule(_localctx, 782, PostgreSQLParser::RuleUnlistenstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7242);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 583, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7238);
      match(PostgreSQLParser::UNLISTEN);
      setState(7239);
      colid();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7240);
      match(PostgreSQLParser::UNLISTEN);
      setState(7241);
      match(PostgreSQLParser::STAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransactionstmtContext ------------------------------------------------------------------

PostgreSQLParser::TransactionstmtContext::TransactionstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::TransactionstmtContext::ABORT_P() {
  return getToken(PostgreSQLParser::ABORT_P, 0);
}

PostgreSQLParser::Transaction_Context* PostgreSQLParser::TransactionstmtContext::transaction_() {
  return getRuleContext<PostgreSQLParser::Transaction_Context>(0);
}

PostgreSQLParser::Transaction_chain_Context* PostgreSQLParser::TransactionstmtContext::transaction_chain_() {
  return getRuleContext<PostgreSQLParser::Transaction_chain_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::TransactionstmtContext::BEGIN_P() {
  return getToken(PostgreSQLParser::BEGIN_P, 0);
}

PostgreSQLParser::Transaction_mode_list_or_emptyContext* PostgreSQLParser::TransactionstmtContext::transaction_mode_list_or_empty() {
  return getRuleContext<PostgreSQLParser::Transaction_mode_list_or_emptyContext>(0);
}

tree::TerminalNode* PostgreSQLParser::TransactionstmtContext::START() {
  return getToken(PostgreSQLParser::START, 0);
}

tree::TerminalNode* PostgreSQLParser::TransactionstmtContext::TRANSACTION() {
  return getToken(PostgreSQLParser::TRANSACTION, 0);
}

tree::TerminalNode* PostgreSQLParser::TransactionstmtContext::COMMIT() {
  return getToken(PostgreSQLParser::COMMIT, 0);
}

tree::TerminalNode* PostgreSQLParser::TransactionstmtContext::END_P() {
  return getToken(PostgreSQLParser::END_P, 0);
}

tree::TerminalNode* PostgreSQLParser::TransactionstmtContext::ROLLBACK() {
  return getToken(PostgreSQLParser::ROLLBACK, 0);
}

tree::TerminalNode* PostgreSQLParser::TransactionstmtContext::SAVEPOINT() {
  return getToken(PostgreSQLParser::SAVEPOINT, 0);
}

PostgreSQLParser::ColidContext* PostgreSQLParser::TransactionstmtContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

tree::TerminalNode* PostgreSQLParser::TransactionstmtContext::RELEASE() {
  return getToken(PostgreSQLParser::RELEASE, 0);
}

tree::TerminalNode* PostgreSQLParser::TransactionstmtContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}

tree::TerminalNode* PostgreSQLParser::TransactionstmtContext::PREPARE() {
  return getToken(PostgreSQLParser::PREPARE, 0);
}

PostgreSQLParser::SconstContext* PostgreSQLParser::TransactionstmtContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::TransactionstmtContext::PREPARED() {
  return getToken(PostgreSQLParser::PREPARED, 0);
}


size_t PostgreSQLParser::TransactionstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTransactionstmt;
}


std::any PostgreSQLParser::TransactionstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTransactionstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TransactionstmtContext* PostgreSQLParser::transactionstmt() {
  TransactionstmtContext *_localctx = _tracker.createInstance<TransactionstmtContext>(_ctx, getState());
  enterRule(_localctx, 784, PostgreSQLParser::RuleTransactionstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7313);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 597, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7244);
      match(PostgreSQLParser::ABORT_P);
      setState(7246);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::TRANSACTION

      || _la == PostgreSQLParser::WORK) {
        setState(7245);
        transaction_();
      }
      setState(7249);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::AND) {
        setState(7248);
        transaction_chain_();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7251);
      match(PostgreSQLParser::BEGIN_P);
      setState(7253);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::TRANSACTION

      || _la == PostgreSQLParser::WORK) {
        setState(7252);
        transaction_();
      }
      setState(7256);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::DEFERRABLE

      || _la == PostgreSQLParser::NOT || _la == PostgreSQLParser::ISOLATION

      || _la == PostgreSQLParser::READ) {
        setState(7255);
        transaction_mode_list_or_empty();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7258);
      match(PostgreSQLParser::START);
      setState(7259);
      match(PostgreSQLParser::TRANSACTION);
      setState(7261);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::DEFERRABLE

      || _la == PostgreSQLParser::NOT || _la == PostgreSQLParser::ISOLATION

      || _la == PostgreSQLParser::READ) {
        setState(7260);
        transaction_mode_list_or_empty();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7263);
      match(PostgreSQLParser::COMMIT);
      setState(7265);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::TRANSACTION

      || _la == PostgreSQLParser::WORK) {
        setState(7264);
        transaction_();
      }
      setState(7268);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::AND) {
        setState(7267);
        transaction_chain_();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7270);
      match(PostgreSQLParser::END_P);
      setState(7272);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::TRANSACTION

      || _la == PostgreSQLParser::WORK) {
        setState(7271);
        transaction_();
      }
      setState(7275);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::AND) {
        setState(7274);
        transaction_chain_();
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(7277);
      match(PostgreSQLParser::ROLLBACK);
      setState(7279);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::TRANSACTION

      || _la == PostgreSQLParser::WORK) {
        setState(7278);
        transaction_();
      }
      setState(7282);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::AND) {
        setState(7281);
        transaction_chain_();
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(7284);
      match(PostgreSQLParser::SAVEPOINT);
      setState(7285);
      colid();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(7286);
      match(PostgreSQLParser::RELEASE);
      setState(7287);
      match(PostgreSQLParser::SAVEPOINT);
      setState(7288);
      colid();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(7289);
      match(PostgreSQLParser::RELEASE);
      setState(7290);
      colid();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(7291);
      match(PostgreSQLParser::ROLLBACK);
      setState(7293);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::TRANSACTION

      || _la == PostgreSQLParser::WORK) {
        setState(7292);
        transaction_();
      }
      setState(7295);
      match(PostgreSQLParser::TO);
      setState(7296);
      match(PostgreSQLParser::SAVEPOINT);
      setState(7297);
      colid();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(7298);
      match(PostgreSQLParser::ROLLBACK);
      setState(7300);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::TRANSACTION

      || _la == PostgreSQLParser::WORK) {
        setState(7299);
        transaction_();
      }
      setState(7302);
      match(PostgreSQLParser::TO);
      setState(7303);
      colid();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(7304);
      match(PostgreSQLParser::PREPARE);
      setState(7305);
      match(PostgreSQLParser::TRANSACTION);
      setState(7306);
      sconst();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(7307);
      match(PostgreSQLParser::COMMIT);
      setState(7308);
      match(PostgreSQLParser::PREPARED);
      setState(7309);
      sconst();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(7310);
      match(PostgreSQLParser::ROLLBACK);
      setState(7311);
      match(PostgreSQLParser::PREPARED);
      setState(7312);
      sconst();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Transaction_Context ------------------------------------------------------------------

PostgreSQLParser::Transaction_Context::Transaction_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Transaction_Context::WORK() {
  return getToken(PostgreSQLParser::WORK, 0);
}

tree::TerminalNode* PostgreSQLParser::Transaction_Context::TRANSACTION() {
  return getToken(PostgreSQLParser::TRANSACTION, 0);
}


size_t PostgreSQLParser::Transaction_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleTransaction_;
}


std::any PostgreSQLParser::Transaction_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTransaction_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Transaction_Context* PostgreSQLParser::transaction_() {
  Transaction_Context *_localctx = _tracker.createInstance<Transaction_Context>(_ctx, getState());
  enterRule(_localctx, 786, PostgreSQLParser::RuleTransaction_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7315);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::TRANSACTION

    || _la == PostgreSQLParser::WORK)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Transaction_mode_itemContext ------------------------------------------------------------------

PostgreSQLParser::Transaction_mode_itemContext::Transaction_mode_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Transaction_mode_itemContext::ISOLATION() {
  return getToken(PostgreSQLParser::ISOLATION, 0);
}

tree::TerminalNode* PostgreSQLParser::Transaction_mode_itemContext::LEVEL() {
  return getToken(PostgreSQLParser::LEVEL, 0);
}

PostgreSQLParser::Iso_levelContext* PostgreSQLParser::Transaction_mode_itemContext::iso_level() {
  return getRuleContext<PostgreSQLParser::Iso_levelContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Transaction_mode_itemContext::READ() {
  return getToken(PostgreSQLParser::READ, 0);
}

tree::TerminalNode* PostgreSQLParser::Transaction_mode_itemContext::ONLY() {
  return getToken(PostgreSQLParser::ONLY, 0);
}

tree::TerminalNode* PostgreSQLParser::Transaction_mode_itemContext::WRITE() {
  return getToken(PostgreSQLParser::WRITE, 0);
}

tree::TerminalNode* PostgreSQLParser::Transaction_mode_itemContext::DEFERRABLE() {
  return getToken(PostgreSQLParser::DEFERRABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Transaction_mode_itemContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}


size_t PostgreSQLParser::Transaction_mode_itemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTransaction_mode_item;
}


std::any PostgreSQLParser::Transaction_mode_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTransaction_mode_item(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Transaction_mode_itemContext* PostgreSQLParser::transaction_mode_item() {
  Transaction_mode_itemContext *_localctx = _tracker.createInstance<Transaction_mode_itemContext>(_ctx, getState());
  enterRule(_localctx, 788, PostgreSQLParser::RuleTransaction_mode_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7327);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 598, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7317);
      match(PostgreSQLParser::ISOLATION);
      setState(7318);
      match(PostgreSQLParser::LEVEL);
      setState(7319);
      iso_level();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7320);
      match(PostgreSQLParser::READ);
      setState(7321);
      match(PostgreSQLParser::ONLY);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7322);
      match(PostgreSQLParser::READ);
      setState(7323);
      match(PostgreSQLParser::WRITE);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7324);
      match(PostgreSQLParser::DEFERRABLE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7325);
      match(PostgreSQLParser::NOT);
      setState(7326);
      match(PostgreSQLParser::DEFERRABLE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Transaction_mode_listContext ------------------------------------------------------------------

PostgreSQLParser::Transaction_mode_listContext::Transaction_mode_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Transaction_mode_itemContext *> PostgreSQLParser::Transaction_mode_listContext::transaction_mode_item() {
  return getRuleContexts<PostgreSQLParser::Transaction_mode_itemContext>();
}

PostgreSQLParser::Transaction_mode_itemContext* PostgreSQLParser::Transaction_mode_listContext::transaction_mode_item(size_t i) {
  return getRuleContext<PostgreSQLParser::Transaction_mode_itemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Transaction_mode_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Transaction_mode_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Transaction_mode_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTransaction_mode_list;
}


std::any PostgreSQLParser::Transaction_mode_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTransaction_mode_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Transaction_mode_listContext* PostgreSQLParser::transaction_mode_list() {
  Transaction_mode_listContext *_localctx = _tracker.createInstance<Transaction_mode_listContext>(_ctx, getState());
  enterRule(_localctx, 790, PostgreSQLParser::RuleTransaction_mode_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7329);
    transaction_mode_item();
    setState(7336);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA || _la == PostgreSQLParser::DEFERRABLE

    || _la == PostgreSQLParser::NOT || _la == PostgreSQLParser::ISOLATION

    || _la == PostgreSQLParser::READ) {
      setState(7331);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::COMMA) {
        setState(7330);
        match(PostgreSQLParser::COMMA);
      }
      setState(7333);
      transaction_mode_item();
      setState(7338);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Transaction_mode_list_or_emptyContext ------------------------------------------------------------------

PostgreSQLParser::Transaction_mode_list_or_emptyContext::Transaction_mode_list_or_emptyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Transaction_mode_listContext* PostgreSQLParser::Transaction_mode_list_or_emptyContext::transaction_mode_list() {
  return getRuleContext<PostgreSQLParser::Transaction_mode_listContext>(0);
}


size_t PostgreSQLParser::Transaction_mode_list_or_emptyContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTransaction_mode_list_or_empty;
}


std::any PostgreSQLParser::Transaction_mode_list_or_emptyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTransaction_mode_list_or_empty(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Transaction_mode_list_or_emptyContext* PostgreSQLParser::transaction_mode_list_or_empty() {
  Transaction_mode_list_or_emptyContext *_localctx = _tracker.createInstance<Transaction_mode_list_or_emptyContext>(_ctx, getState());
  enterRule(_localctx, 792, PostgreSQLParser::RuleTransaction_mode_list_or_empty);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7339);
    transaction_mode_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Transaction_chain_Context ------------------------------------------------------------------

PostgreSQLParser::Transaction_chain_Context::Transaction_chain_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Transaction_chain_Context::AND() {
  return getToken(PostgreSQLParser::AND, 0);
}

tree::TerminalNode* PostgreSQLParser::Transaction_chain_Context::CHAIN() {
  return getToken(PostgreSQLParser::CHAIN, 0);
}

tree::TerminalNode* PostgreSQLParser::Transaction_chain_Context::NO() {
  return getToken(PostgreSQLParser::NO, 0);
}


size_t PostgreSQLParser::Transaction_chain_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleTransaction_chain_;
}


std::any PostgreSQLParser::Transaction_chain_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTransaction_chain_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Transaction_chain_Context* PostgreSQLParser::transaction_chain_() {
  Transaction_chain_Context *_localctx = _tracker.createInstance<Transaction_chain_Context>(_ctx, getState());
  enterRule(_localctx, 794, PostgreSQLParser::RuleTransaction_chain_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7341);
    match(PostgreSQLParser::AND);
    setState(7343);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::NO) {
      setState(7342);
      match(PostgreSQLParser::NO);
    }
    setState(7345);
    match(PostgreSQLParser::CHAIN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewstmtContext ------------------------------------------------------------------

PostgreSQLParser::ViewstmtContext::ViewstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::ViewstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::ViewstmtContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

PostgreSQLParser::SelectstmtContext* PostgreSQLParser::ViewstmtContext::selectstmt() {
  return getRuleContext<PostgreSQLParser::SelectstmtContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ViewstmtContext::VIEW() {
  return getToken(PostgreSQLParser::VIEW, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::ViewstmtContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ViewstmtContext::RECURSIVE() {
  return getToken(PostgreSQLParser::RECURSIVE, 0);
}

tree::TerminalNode* PostgreSQLParser::ViewstmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::ColumnlistContext* PostgreSQLParser::ViewstmtContext::columnlist() {
  return getRuleContext<PostgreSQLParser::ColumnlistContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ViewstmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::ViewstmtContext::OR() {
  return getToken(PostgreSQLParser::OR, 0);
}

tree::TerminalNode* PostgreSQLParser::ViewstmtContext::REPLACE() {
  return getToken(PostgreSQLParser::REPLACE, 0);
}

PostgreSQLParser::OpttempContext* PostgreSQLParser::ViewstmtContext::opttemp() {
  return getRuleContext<PostgreSQLParser::OpttempContext>(0);
}

PostgreSQLParser::Check_option_Context* PostgreSQLParser::ViewstmtContext::check_option_() {
  return getRuleContext<PostgreSQLParser::Check_option_Context>(0);
}

PostgreSQLParser::Column_list_Context* PostgreSQLParser::ViewstmtContext::column_list_() {
  return getRuleContext<PostgreSQLParser::Column_list_Context>(0);
}

PostgreSQLParser::Reloptions_Context* PostgreSQLParser::ViewstmtContext::reloptions_() {
  return getRuleContext<PostgreSQLParser::Reloptions_Context>(0);
}


size_t PostgreSQLParser::ViewstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleViewstmt;
}


std::any PostgreSQLParser::ViewstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitViewstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ViewstmtContext* PostgreSQLParser::viewstmt() {
  ViewstmtContext *_localctx = _tracker.createInstance<ViewstmtContext>(_ctx, getState());
  enterRule(_localctx, 796, PostgreSQLParser::RuleViewstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7347);
    match(PostgreSQLParser::CREATE);
    setState(7350);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OR) {
      setState(7348);
      match(PostgreSQLParser::OR);
      setState(7349);
      match(PostgreSQLParser::REPLACE);
    }
    setState(7353);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::GLOBAL

    || _la == PostgreSQLParser::LOCAL || ((((_la - 383) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 383)) & 32773) != 0)) {
      setState(7352);
      opttemp();
    }
    setState(7372);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::VIEW: {
        setState(7355);
        match(PostgreSQLParser::VIEW);
        setState(7356);
        qualified_name();
        setState(7358);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::OPEN_PAREN) {
          setState(7357);
          column_list_();
        }
        setState(7361);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::WITH) {
          setState(7360);
          reloptions_();
        }
        break;
      }

      case PostgreSQLParser::RECURSIVE: {
        setState(7363);
        match(PostgreSQLParser::RECURSIVE);
        setState(7364);
        match(PostgreSQLParser::VIEW);
        setState(7365);
        qualified_name();
        setState(7366);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(7367);
        columnlist();
        setState(7368);
        match(PostgreSQLParser::CLOSE_PAREN);
        setState(7370);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::WITH) {
          setState(7369);
          reloptions_();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(7374);
    match(PostgreSQLParser::AS);
    setState(7375);
    selectstmt();
    setState(7377);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(7376);
      check_option_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Check_option_Context ------------------------------------------------------------------

PostgreSQLParser::Check_option_Context::Check_option_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Check_option_Context::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

tree::TerminalNode* PostgreSQLParser::Check_option_Context::CHECK() {
  return getToken(PostgreSQLParser::CHECK, 0);
}

tree::TerminalNode* PostgreSQLParser::Check_option_Context::OPTION() {
  return getToken(PostgreSQLParser::OPTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Check_option_Context::CASCADED() {
  return getToken(PostgreSQLParser::CASCADED, 0);
}

tree::TerminalNode* PostgreSQLParser::Check_option_Context::LOCAL() {
  return getToken(PostgreSQLParser::LOCAL, 0);
}


size_t PostgreSQLParser::Check_option_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleCheck_option_;
}


std::any PostgreSQLParser::Check_option_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCheck_option_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Check_option_Context* PostgreSQLParser::check_option_() {
  Check_option_Context *_localctx = _tracker.createInstance<Check_option_Context>(_ctx, getState());
  enterRule(_localctx, 798, PostgreSQLParser::RuleCheck_option_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7379);
    match(PostgreSQLParser::WITH);
    setState(7381);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::CASCADED || _la == PostgreSQLParser::LOCAL) {
      setState(7380);
      _la = _input->LA(1);
      if (!(_la == PostgreSQLParser::CASCADED || _la == PostgreSQLParser::LOCAL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(7383);
    match(PostgreSQLParser::CHECK);
    setState(7384);
    match(PostgreSQLParser::OPTION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadstmtContext ------------------------------------------------------------------

PostgreSQLParser::LoadstmtContext::LoadstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::LoadstmtContext::LOAD() {
  return getToken(PostgreSQLParser::LOAD, 0);
}

PostgreSQLParser::File_nameContext* PostgreSQLParser::LoadstmtContext::file_name() {
  return getRuleContext<PostgreSQLParser::File_nameContext>(0);
}


size_t PostgreSQLParser::LoadstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleLoadstmt;
}


std::any PostgreSQLParser::LoadstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitLoadstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::LoadstmtContext* PostgreSQLParser::loadstmt() {
  LoadstmtContext *_localctx = _tracker.createInstance<LoadstmtContext>(_ctx, getState());
  enterRule(_localctx, 800, PostgreSQLParser::RuleLoadstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7386);
    match(PostgreSQLParser::LOAD);
    setState(7387);
    file_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreatedbstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreatedbstmtContext::CreatedbstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreatedbstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatedbstmtContext::DATABASE() {
  return getToken(PostgreSQLParser::DATABASE, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::CreatedbstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::With_Context* PostgreSQLParser::CreatedbstmtContext::with_() {
  return getRuleContext<PostgreSQLParser::With_Context>(0);
}

PostgreSQLParser::Createdb_opt_listContext* PostgreSQLParser::CreatedbstmtContext::createdb_opt_list() {
  return getRuleContext<PostgreSQLParser::Createdb_opt_listContext>(0);
}


size_t PostgreSQLParser::CreatedbstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatedbstmt;
}


std::any PostgreSQLParser::CreatedbstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatedbstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreatedbstmtContext* PostgreSQLParser::createdbstmt() {
  CreatedbstmtContext *_localctx = _tracker.createInstance<CreatedbstmtContext>(_ctx, getState());
  enterRule(_localctx, 802, PostgreSQLParser::RuleCreatedbstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7389);
    match(PostgreSQLParser::CREATE);
    setState(7390);
    match(PostgreSQLParser::DATABASE);
    setState(7391);
    name();
    setState(7393);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(7392);
      with_();
    }
    setState(7396);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::CONNECTION

    || _la == PostgreSQLParser::ENCODING || _la == PostgreSQLParser::LOCATION

    || _la == PostgreSQLParser::OWNER || _la == PostgreSQLParser::TABLESPACE

    || _la == PostgreSQLParser::TEMPLATE || ((((_la - 554) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 554)) & 268435491) != 0)) {
      setState(7395);
      createdb_opt_list();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Createdb_opt_listContext ------------------------------------------------------------------

PostgreSQLParser::Createdb_opt_listContext::Createdb_opt_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Createdb_opt_itemsContext* PostgreSQLParser::Createdb_opt_listContext::createdb_opt_items() {
  return getRuleContext<PostgreSQLParser::Createdb_opt_itemsContext>(0);
}


size_t PostgreSQLParser::Createdb_opt_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatedb_opt_list;
}


std::any PostgreSQLParser::Createdb_opt_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatedb_opt_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Createdb_opt_listContext* PostgreSQLParser::createdb_opt_list() {
  Createdb_opt_listContext *_localctx = _tracker.createInstance<Createdb_opt_listContext>(_ctx, getState());
  enterRule(_localctx, 804, PostgreSQLParser::RuleCreatedb_opt_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7398);
    createdb_opt_items();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Createdb_opt_itemsContext ------------------------------------------------------------------

PostgreSQLParser::Createdb_opt_itemsContext::Createdb_opt_itemsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Createdb_opt_itemContext *> PostgreSQLParser::Createdb_opt_itemsContext::createdb_opt_item() {
  return getRuleContexts<PostgreSQLParser::Createdb_opt_itemContext>();
}

PostgreSQLParser::Createdb_opt_itemContext* PostgreSQLParser::Createdb_opt_itemsContext::createdb_opt_item(size_t i) {
  return getRuleContext<PostgreSQLParser::Createdb_opt_itemContext>(i);
}


size_t PostgreSQLParser::Createdb_opt_itemsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatedb_opt_items;
}


std::any PostgreSQLParser::Createdb_opt_itemsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatedb_opt_items(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Createdb_opt_itemsContext* PostgreSQLParser::createdb_opt_items() {
  Createdb_opt_itemsContext *_localctx = _tracker.createInstance<Createdb_opt_itemsContext>(_ctx, getState());
  enterRule(_localctx, 806, PostgreSQLParser::RuleCreatedb_opt_items);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7401); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(7400);
      createdb_opt_item();
      setState(7403); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == PostgreSQLParser::CONNECTION

    || _la == PostgreSQLParser::ENCODING || _la == PostgreSQLParser::LOCATION

    || _la == PostgreSQLParser::OWNER || _la == PostgreSQLParser::TABLESPACE

    || _la == PostgreSQLParser::TEMPLATE || ((((_la - 554) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 554)) & 268435491) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Createdb_opt_itemContext ------------------------------------------------------------------

PostgreSQLParser::Createdb_opt_itemContext::Createdb_opt_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Createdb_opt_nameContext* PostgreSQLParser::Createdb_opt_itemContext::createdb_opt_name() {
  return getRuleContext<PostgreSQLParser::Createdb_opt_nameContext>(0);
}

PostgreSQLParser::SignediconstContext* PostgreSQLParser::Createdb_opt_itemContext::signediconst() {
  return getRuleContext<PostgreSQLParser::SignediconstContext>(0);
}

PostgreSQLParser::Boolean_or_string_Context* PostgreSQLParser::Createdb_opt_itemContext::boolean_or_string_() {
  return getRuleContext<PostgreSQLParser::Boolean_or_string_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::Createdb_opt_itemContext::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}

PostgreSQLParser::Equal_Context* PostgreSQLParser::Createdb_opt_itemContext::equal_() {
  return getRuleContext<PostgreSQLParser::Equal_Context>(0);
}


size_t PostgreSQLParser::Createdb_opt_itemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatedb_opt_item;
}


std::any PostgreSQLParser::Createdb_opt_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatedb_opt_item(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Createdb_opt_itemContext* PostgreSQLParser::createdb_opt_item() {
  Createdb_opt_itemContext *_localctx = _tracker.createInstance<Createdb_opt_itemContext>(_ctx, getState());
  enterRule(_localctx, 808, PostgreSQLParser::RuleCreatedb_opt_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7405);
    createdb_opt_name();
    setState(7407);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::EQUAL) {
      setState(7406);
      equal_();
    }
    setState(7412);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::PLUS:
      case PostgreSQLParser::MINUS:
      case PostgreSQLParser::Integral:
      case PostgreSQLParser::BinaryIntegral:
      case PostgreSQLParser::OctalIntegral:
      case PostgreSQLParser::HexadecimalIntegral: {
        setState(7409);
        signediconst();
        break;
      }

      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::FALSE_P:
      case PostgreSQLParser::ON:
      case PostgreSQLParser::TRUE_P:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::PLSQLVARIABLENAME:
      case PostgreSQLParser::EscapeStringConstant: {
        setState(7410);
        boolean_or_string_();
        break;
      }

      case PostgreSQLParser::DEFAULT: {
        setState(7411);
        match(PostgreSQLParser::DEFAULT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Createdb_opt_nameContext ------------------------------------------------------------------

PostgreSQLParser::Createdb_opt_nameContext::Createdb_opt_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::IdentifierContext* PostgreSQLParser::Createdb_opt_nameContext::identifier() {
  return getRuleContext<PostgreSQLParser::IdentifierContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Createdb_opt_nameContext::CONNECTION() {
  return getToken(PostgreSQLParser::CONNECTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Createdb_opt_nameContext::LIMIT() {
  return getToken(PostgreSQLParser::LIMIT, 0);
}

tree::TerminalNode* PostgreSQLParser::Createdb_opt_nameContext::ENCODING() {
  return getToken(PostgreSQLParser::ENCODING, 0);
}

tree::TerminalNode* PostgreSQLParser::Createdb_opt_nameContext::LOCATION() {
  return getToken(PostgreSQLParser::LOCATION, 0);
}

tree::TerminalNode* PostgreSQLParser::Createdb_opt_nameContext::OWNER() {
  return getToken(PostgreSQLParser::OWNER, 0);
}

tree::TerminalNode* PostgreSQLParser::Createdb_opt_nameContext::TABLESPACE() {
  return getToken(PostgreSQLParser::TABLESPACE, 0);
}

tree::TerminalNode* PostgreSQLParser::Createdb_opt_nameContext::TEMPLATE() {
  return getToken(PostgreSQLParser::TEMPLATE, 0);
}


size_t PostgreSQLParser::Createdb_opt_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatedb_opt_name;
}


std::any PostgreSQLParser::Createdb_opt_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatedb_opt_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Createdb_opt_nameContext* PostgreSQLParser::createdb_opt_name() {
  Createdb_opt_nameContext *_localctx = _tracker.createInstance<Createdb_opt_nameContext>(_ctx, getState());
  enterRule(_localctx, 810, PostgreSQLParser::RuleCreatedb_opt_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7422);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 1);
        setState(7414);
        identifier();
        break;
      }

      case PostgreSQLParser::CONNECTION: {
        enterOuterAlt(_localctx, 2);
        setState(7415);
        match(PostgreSQLParser::CONNECTION);
        setState(7416);
        match(PostgreSQLParser::LIMIT);
        break;
      }

      case PostgreSQLParser::ENCODING: {
        enterOuterAlt(_localctx, 3);
        setState(7417);
        match(PostgreSQLParser::ENCODING);
        break;
      }

      case PostgreSQLParser::LOCATION: {
        enterOuterAlt(_localctx, 4);
        setState(7418);
        match(PostgreSQLParser::LOCATION);
        break;
      }

      case PostgreSQLParser::OWNER: {
        enterOuterAlt(_localctx, 5);
        setState(7419);
        match(PostgreSQLParser::OWNER);
        break;
      }

      case PostgreSQLParser::TABLESPACE: {
        enterOuterAlt(_localctx, 6);
        setState(7420);
        match(PostgreSQLParser::TABLESPACE);
        break;
      }

      case PostgreSQLParser::TEMPLATE: {
        enterOuterAlt(_localctx, 7);
        setState(7421);
        match(PostgreSQLParser::TEMPLATE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Equal_Context ------------------------------------------------------------------

PostgreSQLParser::Equal_Context::Equal_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Equal_Context::EQUAL() {
  return getToken(PostgreSQLParser::EQUAL, 0);
}


size_t PostgreSQLParser::Equal_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleEqual_;
}


std::any PostgreSQLParser::Equal_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitEqual_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Equal_Context* PostgreSQLParser::equal_() {
  Equal_Context *_localctx = _tracker.createInstance<Equal_Context>(_ctx, getState());
  enterRule(_localctx, 812, PostgreSQLParser::RuleEqual_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7424);
    match(PostgreSQLParser::EQUAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterdatabasestmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterdatabasestmtContext::AlterdatabasestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterdatabasestmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterdatabasestmtContext::DATABASE() {
  return getToken(PostgreSQLParser::DATABASE, 0);
}

std::vector<PostgreSQLParser::NameContext *> PostgreSQLParser::AlterdatabasestmtContext::name() {
  return getRuleContexts<PostgreSQLParser::NameContext>();
}

PostgreSQLParser::NameContext* PostgreSQLParser::AlterdatabasestmtContext::name(size_t i) {
  return getRuleContext<PostgreSQLParser::NameContext>(i);
}

tree::TerminalNode* PostgreSQLParser::AlterdatabasestmtContext::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterdatabasestmtContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterdatabasestmtContext::TABLESPACE() {
  return getToken(PostgreSQLParser::TABLESPACE, 0);
}

PostgreSQLParser::Createdb_opt_listContext* PostgreSQLParser::AlterdatabasestmtContext::createdb_opt_list() {
  return getRuleContext<PostgreSQLParser::Createdb_opt_listContext>(0);
}


size_t PostgreSQLParser::AlterdatabasestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterdatabasestmt;
}


std::any PostgreSQLParser::AlterdatabasestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterdatabasestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterdatabasestmtContext* PostgreSQLParser::alterdatabasestmt() {
  AlterdatabasestmtContext *_localctx = _tracker.createInstance<AlterdatabasestmtContext>(_ctx, getState());
  enterRule(_localctx, 814, PostgreSQLParser::RuleAlterdatabasestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7426);
    match(PostgreSQLParser::ALTER);
    setState(7427);
    match(PostgreSQLParser::DATABASE);
    setState(7428);
    name();
    setState(7439);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::WITH: {
        setState(7429);
        match(PostgreSQLParser::WITH);
        setState(7431);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::CONNECTION

        || _la == PostgreSQLParser::ENCODING || _la == PostgreSQLParser::LOCATION

        || _la == PostgreSQLParser::OWNER || _la == PostgreSQLParser::TABLESPACE

        || _la == PostgreSQLParser::TEMPLATE || ((((_la - 554) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 554)) & 268435491) != 0)) {
          setState(7430);
          createdb_opt_list();
        }
        break;
      }

      case PostgreSQLParser::EOF:
      case PostgreSQLParser::SEMI:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        setState(7434);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::CONNECTION

        || _la == PostgreSQLParser::ENCODING || _la == PostgreSQLParser::LOCATION

        || _la == PostgreSQLParser::OWNER || _la == PostgreSQLParser::TABLESPACE

        || _la == PostgreSQLParser::TEMPLATE || ((((_la - 554) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 554)) & 268435491) != 0)) {
          setState(7433);
          createdb_opt_list();
        }
        break;
      }

      case PostgreSQLParser::SET: {
        setState(7436);
        match(PostgreSQLParser::SET);
        setState(7437);
        match(PostgreSQLParser::TABLESPACE);
        setState(7438);
        name();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterdatabasesetstmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterdatabasesetstmtContext::AlterdatabasesetstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterdatabasesetstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterdatabasesetstmtContext::DATABASE() {
  return getToken(PostgreSQLParser::DATABASE, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::AlterdatabasesetstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::SetresetclauseContext* PostgreSQLParser::AlterdatabasesetstmtContext::setresetclause() {
  return getRuleContext<PostgreSQLParser::SetresetclauseContext>(0);
}


size_t PostgreSQLParser::AlterdatabasesetstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterdatabasesetstmt;
}


std::any PostgreSQLParser::AlterdatabasesetstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterdatabasesetstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterdatabasesetstmtContext* PostgreSQLParser::alterdatabasesetstmt() {
  AlterdatabasesetstmtContext *_localctx = _tracker.createInstance<AlterdatabasesetstmtContext>(_ctx, getState());
  enterRule(_localctx, 816, PostgreSQLParser::RuleAlterdatabasesetstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7441);
    match(PostgreSQLParser::ALTER);
    setState(7442);
    match(PostgreSQLParser::DATABASE);
    setState(7443);
    name();
    setState(7444);
    setresetclause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropdbstmtContext ------------------------------------------------------------------

PostgreSQLParser::DropdbstmtContext::DropdbstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DropdbstmtContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

tree::TerminalNode* PostgreSQLParser::DropdbstmtContext::DATABASE() {
  return getToken(PostgreSQLParser::DATABASE, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::DropdbstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DropdbstmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::DropdbstmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

tree::TerminalNode* PostgreSQLParser::DropdbstmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Drop_option_listContext* PostgreSQLParser::DropdbstmtContext::drop_option_list() {
  return getRuleContext<PostgreSQLParser::Drop_option_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DropdbstmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::With_Context* PostgreSQLParser::DropdbstmtContext::with_() {
  return getRuleContext<PostgreSQLParser::With_Context>(0);
}


size_t PostgreSQLParser::DropdbstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDropdbstmt;
}


std::any PostgreSQLParser::DropdbstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDropdbstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DropdbstmtContext* PostgreSQLParser::dropdbstmt() {
  DropdbstmtContext *_localctx = _tracker.createInstance<DropdbstmtContext>(_ctx, getState());
  enterRule(_localctx, 818, PostgreSQLParser::RuleDropdbstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7446);
    match(PostgreSQLParser::DROP);
    setState(7447);
    match(PostgreSQLParser::DATABASE);
    setState(7450);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 619, _ctx)) {
    case 1: {
      setState(7448);
      match(PostgreSQLParser::IF_P);
      setState(7449);
      match(PostgreSQLParser::EXISTS);
      break;
    }

    default:
      break;
    }
    setState(7452);
    name();
    setState(7460);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OPEN_PAREN || _la == PostgreSQLParser::WITH) {
      setState(7454);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::WITH) {
        setState(7453);
        with_();
      }
      setState(7456);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(7457);
      drop_option_list();
      setState(7458);
      match(PostgreSQLParser::CLOSE_PAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_option_listContext ------------------------------------------------------------------

PostgreSQLParser::Drop_option_listContext::Drop_option_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Drop_optionContext *> PostgreSQLParser::Drop_option_listContext::drop_option() {
  return getRuleContexts<PostgreSQLParser::Drop_optionContext>();
}

PostgreSQLParser::Drop_optionContext* PostgreSQLParser::Drop_option_listContext::drop_option(size_t i) {
  return getRuleContext<PostgreSQLParser::Drop_optionContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Drop_option_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Drop_option_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Drop_option_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDrop_option_list;
}


std::any PostgreSQLParser::Drop_option_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDrop_option_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Drop_option_listContext* PostgreSQLParser::drop_option_list() {
  Drop_option_listContext *_localctx = _tracker.createInstance<Drop_option_listContext>(_ctx, getState());
  enterRule(_localctx, 820, PostgreSQLParser::RuleDrop_option_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7462);
    drop_option();
    setState(7467);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(7463);
      match(PostgreSQLParser::COMMA);
      setState(7464);
      drop_option();
      setState(7469);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_optionContext ------------------------------------------------------------------

PostgreSQLParser::Drop_optionContext::Drop_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Drop_optionContext::FORCE() {
  return getToken(PostgreSQLParser::FORCE, 0);
}


size_t PostgreSQLParser::Drop_optionContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDrop_option;
}


std::any PostgreSQLParser::Drop_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDrop_option(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Drop_optionContext* PostgreSQLParser::drop_option() {
  Drop_optionContext *_localctx = _tracker.createInstance<Drop_optionContext>(_ctx, getState());
  enterRule(_localctx, 822, PostgreSQLParser::RuleDrop_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7470);
    match(PostgreSQLParser::FORCE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AltercollationstmtContext ------------------------------------------------------------------

PostgreSQLParser::AltercollationstmtContext::AltercollationstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AltercollationstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AltercollationstmtContext::COLLATION() {
  return getToken(PostgreSQLParser::COLLATION, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::AltercollationstmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AltercollationstmtContext::REFRESH() {
  return getToken(PostgreSQLParser::REFRESH, 0);
}

tree::TerminalNode* PostgreSQLParser::AltercollationstmtContext::VERSION_P() {
  return getToken(PostgreSQLParser::VERSION_P, 0);
}


size_t PostgreSQLParser::AltercollationstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAltercollationstmt;
}


std::any PostgreSQLParser::AltercollationstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAltercollationstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AltercollationstmtContext* PostgreSQLParser::altercollationstmt() {
  AltercollationstmtContext *_localctx = _tracker.createInstance<AltercollationstmtContext>(_ctx, getState());
  enterRule(_localctx, 824, PostgreSQLParser::RuleAltercollationstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7472);
    match(PostgreSQLParser::ALTER);
    setState(7473);
    match(PostgreSQLParser::COLLATION);
    setState(7474);
    any_name();
    setState(7475);
    match(PostgreSQLParser::REFRESH);
    setState(7476);
    match(PostgreSQLParser::VERSION_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AltersystemstmtContext ------------------------------------------------------------------

PostgreSQLParser::AltersystemstmtContext::AltersystemstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AltersystemstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AltersystemstmtContext::SYSTEM_P() {
  return getToken(PostgreSQLParser::SYSTEM_P, 0);
}

PostgreSQLParser::Generic_setContext* PostgreSQLParser::AltersystemstmtContext::generic_set() {
  return getRuleContext<PostgreSQLParser::Generic_setContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AltersystemstmtContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

tree::TerminalNode* PostgreSQLParser::AltersystemstmtContext::RESET() {
  return getToken(PostgreSQLParser::RESET, 0);
}


size_t PostgreSQLParser::AltersystemstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAltersystemstmt;
}


std::any PostgreSQLParser::AltersystemstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAltersystemstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AltersystemstmtContext* PostgreSQLParser::altersystemstmt() {
  AltersystemstmtContext *_localctx = _tracker.createInstance<AltersystemstmtContext>(_ctx, getState());
  enterRule(_localctx, 826, PostgreSQLParser::RuleAltersystemstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7478);
    match(PostgreSQLParser::ALTER);
    setState(7479);
    match(PostgreSQLParser::SYSTEM_P);
    setState(7480);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::RESET

    || _la == PostgreSQLParser::SET)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(7481);
    generic_set();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreatedomainstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreatedomainstmtContext::CreatedomainstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreatedomainstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreatedomainstmtContext::DOMAIN_P() {
  return getToken(PostgreSQLParser::DOMAIN_P, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::CreatedomainstmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::CreatedomainstmtContext::typename_() {
  return getRuleContext<PostgreSQLParser::TypenameContext>(0);
}

PostgreSQLParser::ColquallistContext* PostgreSQLParser::CreatedomainstmtContext::colquallist() {
  return getRuleContext<PostgreSQLParser::ColquallistContext>(0);
}

PostgreSQLParser::As_Context* PostgreSQLParser::CreatedomainstmtContext::as_() {
  return getRuleContext<PostgreSQLParser::As_Context>(0);
}


size_t PostgreSQLParser::CreatedomainstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreatedomainstmt;
}


std::any PostgreSQLParser::CreatedomainstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreatedomainstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreatedomainstmtContext* PostgreSQLParser::createdomainstmt() {
  CreatedomainstmtContext *_localctx = _tracker.createInstance<CreatedomainstmtContext>(_ctx, getState());
  enterRule(_localctx, 828, PostgreSQLParser::RuleCreatedomainstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7483);
    match(PostgreSQLParser::CREATE);
    setState(7484);
    match(PostgreSQLParser::DOMAIN_P);
    setState(7485);
    any_name();
    setState(7487);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::AS) {
      setState(7486);
      as_();
    }
    setState(7489);
    typename_();
    setState(7490);
    colquallist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterdomainstmtContext ------------------------------------------------------------------

PostgreSQLParser::AlterdomainstmtContext::AlterdomainstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AlterdomainstmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterdomainstmtContext::DOMAIN_P() {
  return getToken(PostgreSQLParser::DOMAIN_P, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::AlterdomainstmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

PostgreSQLParser::Alter_column_defaultContext* PostgreSQLParser::AlterdomainstmtContext::alter_column_default() {
  return getRuleContext<PostgreSQLParser::Alter_column_defaultContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterdomainstmtContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterdomainstmtContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterdomainstmtContext::NULL_P() {
  return getToken(PostgreSQLParser::NULL_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterdomainstmtContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterdomainstmtContext::ADD_P() {
  return getToken(PostgreSQLParser::ADD_P, 0);
}

PostgreSQLParser::TableconstraintContext* PostgreSQLParser::AlterdomainstmtContext::tableconstraint() {
  return getRuleContext<PostgreSQLParser::TableconstraintContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterdomainstmtContext::CONSTRAINT() {
  return getToken(PostgreSQLParser::CONSTRAINT, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::AlterdomainstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AlterdomainstmtContext::VALIDATE() {
  return getToken(PostgreSQLParser::VALIDATE, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterdomainstmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AlterdomainstmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

PostgreSQLParser::Drop_behavior_Context* PostgreSQLParser::AlterdomainstmtContext::drop_behavior_() {
  return getRuleContext<PostgreSQLParser::Drop_behavior_Context>(0);
}


size_t PostgreSQLParser::AlterdomainstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlterdomainstmt;
}


std::any PostgreSQLParser::AlterdomainstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlterdomainstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AlterdomainstmtContext* PostgreSQLParser::alterdomainstmt() {
  AlterdomainstmtContext *_localctx = _tracker.createInstance<AlterdomainstmtContext>(_ctx, getState());
  enterRule(_localctx, 830, PostgreSQLParser::RuleAlterdomainstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7492);
    match(PostgreSQLParser::ALTER);
    setState(7493);
    match(PostgreSQLParser::DOMAIN_P);
    setState(7494);
    any_name();
    setState(7517);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 626, _ctx)) {
    case 1: {
      setState(7495);
      alter_column_default();
      break;
    }

    case 2: {
      setState(7496);
      match(PostgreSQLParser::DROP);
      setState(7497);
      match(PostgreSQLParser::NOT);
      setState(7498);
      match(PostgreSQLParser::NULL_P);
      break;
    }

    case 3: {
      setState(7499);
      match(PostgreSQLParser::SET);
      setState(7500);
      match(PostgreSQLParser::NOT);
      setState(7501);
      match(PostgreSQLParser::NULL_P);
      break;
    }

    case 4: {
      setState(7502);
      match(PostgreSQLParser::ADD_P);
      setState(7503);
      tableconstraint();
      break;
    }

    case 5: {
      setState(7504);
      match(PostgreSQLParser::DROP);
      setState(7505);
      match(PostgreSQLParser::CONSTRAINT);
      setState(7508);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 624, _ctx)) {
      case 1: {
        setState(7506);
        match(PostgreSQLParser::IF_P);
        setState(7507);
        match(PostgreSQLParser::EXISTS);
        break;
      }

      default:
        break;
      }
      setState(7510);
      name();
      setState(7512);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::CASCADE || _la == PostgreSQLParser::RESTRICT) {
        setState(7511);
        drop_behavior_();
      }
      break;
    }

    case 6: {
      setState(7514);
      match(PostgreSQLParser::VALIDATE);
      setState(7515);
      match(PostgreSQLParser::CONSTRAINT);
      setState(7516);
      name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- As_Context ------------------------------------------------------------------

PostgreSQLParser::As_Context::As_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::As_Context::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}


size_t PostgreSQLParser::As_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleAs_;
}


std::any PostgreSQLParser::As_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAs_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::As_Context* PostgreSQLParser::as_() {
  As_Context *_localctx = _tracker.createInstance<As_Context>(_ctx, getState());
  enterRule(_localctx, 832, PostgreSQLParser::RuleAs_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7519);
    match(PostgreSQLParser::AS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AltertsdictionarystmtContext ------------------------------------------------------------------

PostgreSQLParser::AltertsdictionarystmtContext::AltertsdictionarystmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AltertsdictionarystmtContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertsdictionarystmtContext::TEXT_P() {
  return getToken(PostgreSQLParser::TEXT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertsdictionarystmtContext::SEARCH() {
  return getToken(PostgreSQLParser::SEARCH, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertsdictionarystmtContext::DICTIONARY() {
  return getToken(PostgreSQLParser::DICTIONARY, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::AltertsdictionarystmtContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}

PostgreSQLParser::DefinitionContext* PostgreSQLParser::AltertsdictionarystmtContext::definition() {
  return getRuleContext<PostgreSQLParser::DefinitionContext>(0);
}


size_t PostgreSQLParser::AltertsdictionarystmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAltertsdictionarystmt;
}


std::any PostgreSQLParser::AltertsdictionarystmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAltertsdictionarystmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AltertsdictionarystmtContext* PostgreSQLParser::altertsdictionarystmt() {
  AltertsdictionarystmtContext *_localctx = _tracker.createInstance<AltertsdictionarystmtContext>(_ctx, getState());
  enterRule(_localctx, 834, PostgreSQLParser::RuleAltertsdictionarystmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7521);
    match(PostgreSQLParser::ALTER);
    setState(7522);
    match(PostgreSQLParser::TEXT_P);
    setState(7523);
    match(PostgreSQLParser::SEARCH);
    setState(7524);
    match(PostgreSQLParser::DICTIONARY);
    setState(7525);
    any_name();
    setState(7526);
    definition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AltertsconfigurationstmtContext ------------------------------------------------------------------

PostgreSQLParser::AltertsconfigurationstmtContext::AltertsconfigurationstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> PostgreSQLParser::AltertsconfigurationstmtContext::ALTER() {
  return getTokens(PostgreSQLParser::ALTER);
}

tree::TerminalNode* PostgreSQLParser::AltertsconfigurationstmtContext::ALTER(size_t i) {
  return getToken(PostgreSQLParser::ALTER, i);
}

tree::TerminalNode* PostgreSQLParser::AltertsconfigurationstmtContext::TEXT_P() {
  return getToken(PostgreSQLParser::TEXT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertsconfigurationstmtContext::SEARCH() {
  return getToken(PostgreSQLParser::SEARCH, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertsconfigurationstmtContext::CONFIGURATION() {
  return getToken(PostgreSQLParser::CONFIGURATION, 0);
}

std::vector<PostgreSQLParser::Any_nameContext *> PostgreSQLParser::AltertsconfigurationstmtContext::any_name() {
  return getRuleContexts<PostgreSQLParser::Any_nameContext>();
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::AltertsconfigurationstmtContext::any_name(size_t i) {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(i);
}

tree::TerminalNode* PostgreSQLParser::AltertsconfigurationstmtContext::ADD_P() {
  return getToken(PostgreSQLParser::ADD_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertsconfigurationstmtContext::MAPPING() {
  return getToken(PostgreSQLParser::MAPPING, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertsconfigurationstmtContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

PostgreSQLParser::Name_listContext* PostgreSQLParser::AltertsconfigurationstmtContext::name_list() {
  return getRuleContext<PostgreSQLParser::Name_listContext>(0);
}

PostgreSQLParser::Any_withContext* PostgreSQLParser::AltertsconfigurationstmtContext::any_with() {
  return getRuleContext<PostgreSQLParser::Any_withContext>(0);
}

PostgreSQLParser::Any_name_list_Context* PostgreSQLParser::AltertsconfigurationstmtContext::any_name_list_() {
  return getRuleContext<PostgreSQLParser::Any_name_list_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::AltertsconfigurationstmtContext::REPLACE() {
  return getToken(PostgreSQLParser::REPLACE, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertsconfigurationstmtContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertsconfigurationstmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AltertsconfigurationstmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}


size_t PostgreSQLParser::AltertsconfigurationstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAltertsconfigurationstmt;
}


std::any PostgreSQLParser::AltertsconfigurationstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAltertsconfigurationstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AltertsconfigurationstmtContext* PostgreSQLParser::altertsconfigurationstmt() {
  AltertsconfigurationstmtContext *_localctx = _tracker.createInstance<AltertsconfigurationstmtContext>(_ctx, getState());
  enterRule(_localctx, 836, PostgreSQLParser::RuleAltertsconfigurationstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7600);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 627, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7528);
      match(PostgreSQLParser::ALTER);
      setState(7529);
      match(PostgreSQLParser::TEXT_P);
      setState(7530);
      match(PostgreSQLParser::SEARCH);
      setState(7531);
      match(PostgreSQLParser::CONFIGURATION);
      setState(7532);
      any_name();
      setState(7533);
      match(PostgreSQLParser::ADD_P);
      setState(7534);
      match(PostgreSQLParser::MAPPING);
      setState(7535);
      match(PostgreSQLParser::FOR);
      setState(7536);
      name_list();
      setState(7537);
      any_with();
      setState(7538);
      any_name_list_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7540);
      match(PostgreSQLParser::ALTER);
      setState(7541);
      match(PostgreSQLParser::TEXT_P);
      setState(7542);
      match(PostgreSQLParser::SEARCH);
      setState(7543);
      match(PostgreSQLParser::CONFIGURATION);
      setState(7544);
      any_name();
      setState(7545);
      match(PostgreSQLParser::ALTER);
      setState(7546);
      match(PostgreSQLParser::MAPPING);
      setState(7547);
      match(PostgreSQLParser::FOR);
      setState(7548);
      name_list();
      setState(7549);
      any_with();
      setState(7550);
      any_name_list_();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7552);
      match(PostgreSQLParser::ALTER);
      setState(7553);
      match(PostgreSQLParser::TEXT_P);
      setState(7554);
      match(PostgreSQLParser::SEARCH);
      setState(7555);
      match(PostgreSQLParser::CONFIGURATION);
      setState(7556);
      any_name();
      setState(7557);
      match(PostgreSQLParser::ALTER);
      setState(7558);
      match(PostgreSQLParser::MAPPING);
      setState(7559);
      match(PostgreSQLParser::REPLACE);
      setState(7560);
      any_name();
      setState(7561);
      any_with();
      setState(7562);
      any_name();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7564);
      match(PostgreSQLParser::ALTER);
      setState(7565);
      match(PostgreSQLParser::TEXT_P);
      setState(7566);
      match(PostgreSQLParser::SEARCH);
      setState(7567);
      match(PostgreSQLParser::CONFIGURATION);
      setState(7568);
      any_name();
      setState(7569);
      match(PostgreSQLParser::ALTER);
      setState(7570);
      match(PostgreSQLParser::MAPPING);
      setState(7571);
      match(PostgreSQLParser::FOR);
      setState(7572);
      name_list();
      setState(7573);
      match(PostgreSQLParser::REPLACE);
      setState(7574);
      any_name();
      setState(7575);
      any_with();
      setState(7576);
      any_name();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7578);
      match(PostgreSQLParser::ALTER);
      setState(7579);
      match(PostgreSQLParser::TEXT_P);
      setState(7580);
      match(PostgreSQLParser::SEARCH);
      setState(7581);
      match(PostgreSQLParser::CONFIGURATION);
      setState(7582);
      any_name();
      setState(7583);
      match(PostgreSQLParser::DROP);
      setState(7584);
      match(PostgreSQLParser::MAPPING);
      setState(7585);
      match(PostgreSQLParser::FOR);
      setState(7586);
      name_list();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(7588);
      match(PostgreSQLParser::ALTER);
      setState(7589);
      match(PostgreSQLParser::TEXT_P);
      setState(7590);
      match(PostgreSQLParser::SEARCH);
      setState(7591);
      match(PostgreSQLParser::CONFIGURATION);
      setState(7592);
      any_name();
      setState(7593);
      match(PostgreSQLParser::DROP);
      setState(7594);
      match(PostgreSQLParser::MAPPING);
      setState(7595);
      match(PostgreSQLParser::IF_P);
      setState(7596);
      match(PostgreSQLParser::EXISTS);
      setState(7597);
      match(PostgreSQLParser::FOR);
      setState(7598);
      name_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Any_withContext ------------------------------------------------------------------

PostgreSQLParser::Any_withContext::Any_withContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Any_withContext::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}


size_t PostgreSQLParser::Any_withContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAny_with;
}


std::any PostgreSQLParser::Any_withContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAny_with(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Any_withContext* PostgreSQLParser::any_with() {
  Any_withContext *_localctx = _tracker.createInstance<Any_withContext>(_ctx, getState());
  enterRule(_localctx, 838, PostgreSQLParser::RuleAny_with);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7602);
    match(PostgreSQLParser::WITH);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateconversionstmtContext ------------------------------------------------------------------

PostgreSQLParser::CreateconversionstmtContext::CreateconversionstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::CreateconversionstmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateconversionstmtContext::CONVERSION_P() {
  return getToken(PostgreSQLParser::CONVERSION_P, 0);
}

std::vector<PostgreSQLParser::Any_nameContext *> PostgreSQLParser::CreateconversionstmtContext::any_name() {
  return getRuleContexts<PostgreSQLParser::Any_nameContext>();
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::CreateconversionstmtContext::any_name(size_t i) {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(i);
}

tree::TerminalNode* PostgreSQLParser::CreateconversionstmtContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

std::vector<PostgreSQLParser::SconstContext *> PostgreSQLParser::CreateconversionstmtContext::sconst() {
  return getRuleContexts<PostgreSQLParser::SconstContext>();
}

PostgreSQLParser::SconstContext* PostgreSQLParser::CreateconversionstmtContext::sconst(size_t i) {
  return getRuleContext<PostgreSQLParser::SconstContext>(i);
}

tree::TerminalNode* PostgreSQLParser::CreateconversionstmtContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}

tree::TerminalNode* PostgreSQLParser::CreateconversionstmtContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

PostgreSQLParser::Default_Context* PostgreSQLParser::CreateconversionstmtContext::default_() {
  return getRuleContext<PostgreSQLParser::Default_Context>(0);
}


size_t PostgreSQLParser::CreateconversionstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCreateconversionstmt;
}


std::any PostgreSQLParser::CreateconversionstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCreateconversionstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CreateconversionstmtContext* PostgreSQLParser::createconversionstmt() {
  CreateconversionstmtContext *_localctx = _tracker.createInstance<CreateconversionstmtContext>(_ctx, getState());
  enterRule(_localctx, 840, PostgreSQLParser::RuleCreateconversionstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7604);
    match(PostgreSQLParser::CREATE);
    setState(7606);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::DEFAULT) {
      setState(7605);
      default_();
    }
    setState(7608);
    match(PostgreSQLParser::CONVERSION_P);
    setState(7609);
    any_name();
    setState(7610);
    match(PostgreSQLParser::FOR);
    setState(7611);
    sconst();
    setState(7612);
    match(PostgreSQLParser::TO);
    setState(7613);
    sconst();
    setState(7614);
    match(PostgreSQLParser::FROM);
    setState(7615);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClusterstmtContext ------------------------------------------------------------------

PostgreSQLParser::ClusterstmtContext::ClusterstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::ClusterstmtContext::CLUSTER() {
  return getToken(PostgreSQLParser::CLUSTER, 0);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::ClusterstmtContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

PostgreSQLParser::Verbose_Context* PostgreSQLParser::ClusterstmtContext::verbose_() {
  return getRuleContext<PostgreSQLParser::Verbose_Context>(0);
}

PostgreSQLParser::Cluster_index_specificationContext* PostgreSQLParser::ClusterstmtContext::cluster_index_specification() {
  return getRuleContext<PostgreSQLParser::Cluster_index_specificationContext>(0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::ClusterstmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ClusterstmtContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}


size_t PostgreSQLParser::ClusterstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleClusterstmt;
}


std::any PostgreSQLParser::ClusterstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitClusterstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ClusterstmtContext* PostgreSQLParser::clusterstmt() {
  ClusterstmtContext *_localctx = _tracker.createInstance<ClusterstmtContext>(_ctx, getState());
  enterRule(_localctx, 842, PostgreSQLParser::RuleClusterstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7637);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 633, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7617);
      match(PostgreSQLParser::CLUSTER);
      setState(7619);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::VERBOSE) {
        setState(7618);
        verbose_();
      }
      setState(7621);
      qualified_name();
      setState(7623);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::USING) {
        setState(7622);
        cluster_index_specification();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7625);
      match(PostgreSQLParser::CLUSTER);
      setState(7627);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::VERBOSE) {
        setState(7626);
        verbose_();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7629);
      match(PostgreSQLParser::CLUSTER);
      setState(7631);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::VERBOSE) {
        setState(7630);
        verbose_();
      }
      setState(7633);
      name();
      setState(7634);
      match(PostgreSQLParser::ON);
      setState(7635);
      qualified_name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cluster_index_specificationContext ------------------------------------------------------------------

PostgreSQLParser::Cluster_index_specificationContext::Cluster_index_specificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Cluster_index_specificationContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::Cluster_index_specificationContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}


size_t PostgreSQLParser::Cluster_index_specificationContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCluster_index_specification;
}


std::any PostgreSQLParser::Cluster_index_specificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCluster_index_specification(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Cluster_index_specificationContext* PostgreSQLParser::cluster_index_specification() {
  Cluster_index_specificationContext *_localctx = _tracker.createInstance<Cluster_index_specificationContext>(_ctx, getState());
  enterRule(_localctx, 844, PostgreSQLParser::RuleCluster_index_specification);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7639);
    match(PostgreSQLParser::USING);
    setState(7640);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VacuumstmtContext ------------------------------------------------------------------

PostgreSQLParser::VacuumstmtContext::VacuumstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::VacuumstmtContext::VACUUM() {
  return getToken(PostgreSQLParser::VACUUM, 0);
}

PostgreSQLParser::Full_Context* PostgreSQLParser::VacuumstmtContext::full_() {
  return getRuleContext<PostgreSQLParser::Full_Context>(0);
}

PostgreSQLParser::Freeze_Context* PostgreSQLParser::VacuumstmtContext::freeze_() {
  return getRuleContext<PostgreSQLParser::Freeze_Context>(0);
}

PostgreSQLParser::Verbose_Context* PostgreSQLParser::VacuumstmtContext::verbose_() {
  return getRuleContext<PostgreSQLParser::Verbose_Context>(0);
}

PostgreSQLParser::Analyze_Context* PostgreSQLParser::VacuumstmtContext::analyze_() {
  return getRuleContext<PostgreSQLParser::Analyze_Context>(0);
}

PostgreSQLParser::Vacuum_relation_list_Context* PostgreSQLParser::VacuumstmtContext::vacuum_relation_list_() {
  return getRuleContext<PostgreSQLParser::Vacuum_relation_list_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::VacuumstmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Vac_analyze_option_listContext* PostgreSQLParser::VacuumstmtContext::vac_analyze_option_list() {
  return getRuleContext<PostgreSQLParser::Vac_analyze_option_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::VacuumstmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::VacuumstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleVacuumstmt;
}


std::any PostgreSQLParser::VacuumstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitVacuumstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::VacuumstmtContext* PostgreSQLParser::vacuumstmt() {
  VacuumstmtContext *_localctx = _tracker.createInstance<VacuumstmtContext>(_ctx, getState());
  enterRule(_localctx, 846, PostgreSQLParser::RuleVacuumstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7665);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 640, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7642);
      match(PostgreSQLParser::VACUUM);
      setState(7644);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FULL) {
        setState(7643);
        full_();
      }
      setState(7647);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::FREEZE) {
        setState(7646);
        freeze_();
      }
      setState(7650);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::VERBOSE) {
        setState(7649);
        verbose_();
      }
      setState(7653);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::ANALYSE

      || _la == PostgreSQLParser::ANALYZE) {
        setState(7652);
        analyze_();
      }
      setState(7656);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 30) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 30)) & 137438949375) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 553)) & 536870983) != 0)) {
        setState(7655);
        vacuum_relation_list_();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7658);
      match(PostgreSQLParser::VACUUM);
      setState(7659);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(7660);
      vac_analyze_option_list();
      setState(7661);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(7663);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 30) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 30)) & 137438949375) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 553)) & 536870983) != 0)) {
        setState(7662);
        vacuum_relation_list_();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnalyzestmtContext ------------------------------------------------------------------

PostgreSQLParser::AnalyzestmtContext::AnalyzestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Analyze_keywordContext* PostgreSQLParser::AnalyzestmtContext::analyze_keyword() {
  return getRuleContext<PostgreSQLParser::Analyze_keywordContext>(0);
}

PostgreSQLParser::Verbose_Context* PostgreSQLParser::AnalyzestmtContext::verbose_() {
  return getRuleContext<PostgreSQLParser::Verbose_Context>(0);
}

PostgreSQLParser::Vacuum_relation_list_Context* PostgreSQLParser::AnalyzestmtContext::vacuum_relation_list_() {
  return getRuleContext<PostgreSQLParser::Vacuum_relation_list_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::AnalyzestmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Vac_analyze_option_listContext* PostgreSQLParser::AnalyzestmtContext::vac_analyze_option_list() {
  return getRuleContext<PostgreSQLParser::Vac_analyze_option_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AnalyzestmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::AnalyzestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAnalyzestmt;
}


std::any PostgreSQLParser::AnalyzestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAnalyzestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AnalyzestmtContext* PostgreSQLParser::analyzestmt() {
  AnalyzestmtContext *_localctx = _tracker.createInstance<AnalyzestmtContext>(_ctx, getState());
  enterRule(_localctx, 848, PostgreSQLParser::RuleAnalyzestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7681);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 644, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7667);
      analyze_keyword();
      setState(7669);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::VERBOSE) {
        setState(7668);
        verbose_();
      }
      setState(7672);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 30) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 30)) & 137438949375) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 553)) & 536870983) != 0)) {
        setState(7671);
        vacuum_relation_list_();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7674);
      analyze_keyword();
      setState(7675);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(7676);
      vac_analyze_option_list();
      setState(7677);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(7679);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 30) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 30)) & 137438949375) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 553)) & 536870983) != 0)) {
        setState(7678);
        vacuum_relation_list_();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Utility_option_listContext ------------------------------------------------------------------

PostgreSQLParser::Utility_option_listContext::Utility_option_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Utility_option_elemContext *> PostgreSQLParser::Utility_option_listContext::utility_option_elem() {
  return getRuleContexts<PostgreSQLParser::Utility_option_elemContext>();
}

PostgreSQLParser::Utility_option_elemContext* PostgreSQLParser::Utility_option_listContext::utility_option_elem(size_t i) {
  return getRuleContext<PostgreSQLParser::Utility_option_elemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Utility_option_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Utility_option_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Utility_option_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleUtility_option_list;
}


std::any PostgreSQLParser::Utility_option_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitUtility_option_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Utility_option_listContext* PostgreSQLParser::utility_option_list() {
  Utility_option_listContext *_localctx = _tracker.createInstance<Utility_option_listContext>(_ctx, getState());
  enterRule(_localctx, 850, PostgreSQLParser::RuleUtility_option_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7683);
    utility_option_elem();
    setState(7688);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(7684);
      match(PostgreSQLParser::COMMA);
      setState(7685);
      utility_option_elem();
      setState(7690);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Vac_analyze_option_listContext ------------------------------------------------------------------

PostgreSQLParser::Vac_analyze_option_listContext::Vac_analyze_option_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Vac_analyze_option_elemContext *> PostgreSQLParser::Vac_analyze_option_listContext::vac_analyze_option_elem() {
  return getRuleContexts<PostgreSQLParser::Vac_analyze_option_elemContext>();
}

PostgreSQLParser::Vac_analyze_option_elemContext* PostgreSQLParser::Vac_analyze_option_listContext::vac_analyze_option_elem(size_t i) {
  return getRuleContext<PostgreSQLParser::Vac_analyze_option_elemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Vac_analyze_option_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Vac_analyze_option_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Vac_analyze_option_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleVac_analyze_option_list;
}


std::any PostgreSQLParser::Vac_analyze_option_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitVac_analyze_option_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Vac_analyze_option_listContext* PostgreSQLParser::vac_analyze_option_list() {
  Vac_analyze_option_listContext *_localctx = _tracker.createInstance<Vac_analyze_option_listContext>(_ctx, getState());
  enterRule(_localctx, 852, PostgreSQLParser::RuleVac_analyze_option_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7691);
    vac_analyze_option_elem();
    setState(7696);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(7692);
      match(PostgreSQLParser::COMMA);
      setState(7693);
      vac_analyze_option_elem();
      setState(7698);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Analyze_keywordContext ------------------------------------------------------------------

PostgreSQLParser::Analyze_keywordContext::Analyze_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Analyze_keywordContext::ANALYZE() {
  return getToken(PostgreSQLParser::ANALYZE, 0);
}

tree::TerminalNode* PostgreSQLParser::Analyze_keywordContext::ANALYSE() {
  return getToken(PostgreSQLParser::ANALYSE, 0);
}


size_t PostgreSQLParser::Analyze_keywordContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAnalyze_keyword;
}


std::any PostgreSQLParser::Analyze_keywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAnalyze_keyword(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Analyze_keywordContext* PostgreSQLParser::analyze_keyword() {
  Analyze_keywordContext *_localctx = _tracker.createInstance<Analyze_keywordContext>(_ctx, getState());
  enterRule(_localctx, 854, PostgreSQLParser::RuleAnalyze_keyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7699);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::ANALYSE

    || _la == PostgreSQLParser::ANALYZE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Utility_option_elemContext ------------------------------------------------------------------

PostgreSQLParser::Utility_option_elemContext::Utility_option_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Utility_option_nameContext* PostgreSQLParser::Utility_option_elemContext::utility_option_name() {
  return getRuleContext<PostgreSQLParser::Utility_option_nameContext>(0);
}

PostgreSQLParser::Utility_option_argContext* PostgreSQLParser::Utility_option_elemContext::utility_option_arg() {
  return getRuleContext<PostgreSQLParser::Utility_option_argContext>(0);
}


size_t PostgreSQLParser::Utility_option_elemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleUtility_option_elem;
}


std::any PostgreSQLParser::Utility_option_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitUtility_option_elem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Utility_option_elemContext* PostgreSQLParser::utility_option_elem() {
  Utility_option_elemContext *_localctx = _tracker.createInstance<Utility_option_elemContext>(_ctx, getState());
  enterRule(_localctx, 856, PostgreSQLParser::RuleUtility_option_elem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7701);
    utility_option_name();
    setState(7703);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 12) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 12)) & 36028795944960003) != 0) || ((((_la - 98) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 98)) & -70300023652351) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 162)) & -1) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 482)) & 1153132602249444351) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 553)) & 138370110535) != 0)) {
      setState(7702);
      utility_option_arg();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Utility_option_nameContext ------------------------------------------------------------------

PostgreSQLParser::Utility_option_nameContext::Utility_option_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::NonreservedwordContext* PostgreSQLParser::Utility_option_nameContext::nonreservedword() {
  return getRuleContext<PostgreSQLParser::NonreservedwordContext>(0);
}

PostgreSQLParser::Analyze_keywordContext* PostgreSQLParser::Utility_option_nameContext::analyze_keyword() {
  return getRuleContext<PostgreSQLParser::Analyze_keywordContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Utility_option_nameContext::FORMAT_LA() {
  return getToken(PostgreSQLParser::FORMAT_LA, 0);
}


size_t PostgreSQLParser::Utility_option_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleUtility_option_name;
}


std::any PostgreSQLParser::Utility_option_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitUtility_option_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Utility_option_nameContext* PostgreSQLParser::utility_option_name() {
  Utility_option_nameContext *_localctx = _tracker.createInstance<Utility_option_nameContext>(_ctx, getState());
  enterRule(_localctx, 858, PostgreSQLParser::RuleUtility_option_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7708);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 1);
        setState(7705);
        nonreservedword();
        break;
      }

      case PostgreSQLParser::ANALYSE:
      case PostgreSQLParser::ANALYZE: {
        enterOuterAlt(_localctx, 2);
        setState(7706);
        analyze_keyword();
        break;
      }

      case PostgreSQLParser::FORMAT_LA: {
        enterOuterAlt(_localctx, 3);
        setState(7707);
        match(PostgreSQLParser::FORMAT_LA);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Utility_option_argContext ------------------------------------------------------------------

PostgreSQLParser::Utility_option_argContext::Utility_option_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Boolean_or_string_Context* PostgreSQLParser::Utility_option_argContext::boolean_or_string_() {
  return getRuleContext<PostgreSQLParser::Boolean_or_string_Context>(0);
}

PostgreSQLParser::NumericonlyContext* PostgreSQLParser::Utility_option_argContext::numericonly() {
  return getRuleContext<PostgreSQLParser::NumericonlyContext>(0);
}


size_t PostgreSQLParser::Utility_option_argContext::getRuleIndex() const {
  return PostgreSQLParser::RuleUtility_option_arg;
}


std::any PostgreSQLParser::Utility_option_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitUtility_option_arg(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Utility_option_argContext* PostgreSQLParser::utility_option_arg() {
  Utility_option_argContext *_localctx = _tracker.createInstance<Utility_option_argContext>(_ctx, getState());
  enterRule(_localctx, 860, PostgreSQLParser::RuleUtility_option_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7712);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::FALSE_P:
      case PostgreSQLParser::ON:
      case PostgreSQLParser::TRUE_P:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::PLSQLVARIABLENAME:
      case PostgreSQLParser::EscapeStringConstant: {
        enterOuterAlt(_localctx, 1);
        setState(7710);
        boolean_or_string_();
        break;
      }

      case PostgreSQLParser::PLUS:
      case PostgreSQLParser::MINUS:
      case PostgreSQLParser::Integral:
      case PostgreSQLParser::BinaryIntegral:
      case PostgreSQLParser::OctalIntegral:
      case PostgreSQLParser::HexadecimalIntegral:
      case PostgreSQLParser::Numeric: {
        enterOuterAlt(_localctx, 2);
        setState(7711);
        numericonly();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Vac_analyze_option_elemContext ------------------------------------------------------------------

PostgreSQLParser::Vac_analyze_option_elemContext::Vac_analyze_option_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Vac_analyze_option_nameContext* PostgreSQLParser::Vac_analyze_option_elemContext::vac_analyze_option_name() {
  return getRuleContext<PostgreSQLParser::Vac_analyze_option_nameContext>(0);
}

PostgreSQLParser::Vac_analyze_option_argContext* PostgreSQLParser::Vac_analyze_option_elemContext::vac_analyze_option_arg() {
  return getRuleContext<PostgreSQLParser::Vac_analyze_option_argContext>(0);
}


size_t PostgreSQLParser::Vac_analyze_option_elemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleVac_analyze_option_elem;
}


std::any PostgreSQLParser::Vac_analyze_option_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitVac_analyze_option_elem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Vac_analyze_option_elemContext* PostgreSQLParser::vac_analyze_option_elem() {
  Vac_analyze_option_elemContext *_localctx = _tracker.createInstance<Vac_analyze_option_elemContext>(_ctx, getState());
  enterRule(_localctx, 862, PostgreSQLParser::RuleVac_analyze_option_elem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7714);
    vac_analyze_option_name();
    setState(7716);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 12) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 12)) & 36028795944960003) != 0) || ((((_la - 98) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 98)) & -70300023652351) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 162)) & -1) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 482)) & 1153132602249444351) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 553)) & 138370110535) != 0)) {
      setState(7715);
      vac_analyze_option_arg();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Vac_analyze_option_nameContext ------------------------------------------------------------------

PostgreSQLParser::Vac_analyze_option_nameContext::Vac_analyze_option_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::NonreservedwordContext* PostgreSQLParser::Vac_analyze_option_nameContext::nonreservedword() {
  return getRuleContext<PostgreSQLParser::NonreservedwordContext>(0);
}

PostgreSQLParser::Analyze_keywordContext* PostgreSQLParser::Vac_analyze_option_nameContext::analyze_keyword() {
  return getRuleContext<PostgreSQLParser::Analyze_keywordContext>(0);
}


size_t PostgreSQLParser::Vac_analyze_option_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleVac_analyze_option_name;
}


std::any PostgreSQLParser::Vac_analyze_option_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitVac_analyze_option_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Vac_analyze_option_nameContext* PostgreSQLParser::vac_analyze_option_name() {
  Vac_analyze_option_nameContext *_localctx = _tracker.createInstance<Vac_analyze_option_nameContext>(_ctx, getState());
  enterRule(_localctx, 864, PostgreSQLParser::RuleVac_analyze_option_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7720);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 1);
        setState(7718);
        nonreservedword();
        break;
      }

      case PostgreSQLParser::ANALYSE:
      case PostgreSQLParser::ANALYZE: {
        enterOuterAlt(_localctx, 2);
        setState(7719);
        analyze_keyword();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Vac_analyze_option_argContext ------------------------------------------------------------------

PostgreSQLParser::Vac_analyze_option_argContext::Vac_analyze_option_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Boolean_or_string_Context* PostgreSQLParser::Vac_analyze_option_argContext::boolean_or_string_() {
  return getRuleContext<PostgreSQLParser::Boolean_or_string_Context>(0);
}

PostgreSQLParser::NumericonlyContext* PostgreSQLParser::Vac_analyze_option_argContext::numericonly() {
  return getRuleContext<PostgreSQLParser::NumericonlyContext>(0);
}


size_t PostgreSQLParser::Vac_analyze_option_argContext::getRuleIndex() const {
  return PostgreSQLParser::RuleVac_analyze_option_arg;
}


std::any PostgreSQLParser::Vac_analyze_option_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitVac_analyze_option_arg(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Vac_analyze_option_argContext* PostgreSQLParser::vac_analyze_option_arg() {
  Vac_analyze_option_argContext *_localctx = _tracker.createInstance<Vac_analyze_option_argContext>(_ctx, getState());
  enterRule(_localctx, 866, PostgreSQLParser::RuleVac_analyze_option_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7724);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::FALSE_P:
      case PostgreSQLParser::ON:
      case PostgreSQLParser::TRUE_P:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::PLSQLVARIABLENAME:
      case PostgreSQLParser::EscapeStringConstant: {
        enterOuterAlt(_localctx, 1);
        setState(7722);
        boolean_or_string_();
        break;
      }

      case PostgreSQLParser::PLUS:
      case PostgreSQLParser::MINUS:
      case PostgreSQLParser::Integral:
      case PostgreSQLParser::BinaryIntegral:
      case PostgreSQLParser::OctalIntegral:
      case PostgreSQLParser::HexadecimalIntegral:
      case PostgreSQLParser::Numeric: {
        enterOuterAlt(_localctx, 2);
        setState(7723);
        numericonly();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Analyze_Context ------------------------------------------------------------------

PostgreSQLParser::Analyze_Context::Analyze_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Analyze_keywordContext* PostgreSQLParser::Analyze_Context::analyze_keyword() {
  return getRuleContext<PostgreSQLParser::Analyze_keywordContext>(0);
}


size_t PostgreSQLParser::Analyze_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleAnalyze_;
}


std::any PostgreSQLParser::Analyze_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAnalyze_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Analyze_Context* PostgreSQLParser::analyze_() {
  Analyze_Context *_localctx = _tracker.createInstance<Analyze_Context>(_ctx, getState());
  enterRule(_localctx, 868, PostgreSQLParser::RuleAnalyze_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7726);
    analyze_keyword();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Verbose_Context ------------------------------------------------------------------

PostgreSQLParser::Verbose_Context::Verbose_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Verbose_Context::VERBOSE() {
  return getToken(PostgreSQLParser::VERBOSE, 0);
}


size_t PostgreSQLParser::Verbose_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleVerbose_;
}


std::any PostgreSQLParser::Verbose_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitVerbose_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Verbose_Context* PostgreSQLParser::verbose_() {
  Verbose_Context *_localctx = _tracker.createInstance<Verbose_Context>(_ctx, getState());
  enterRule(_localctx, 870, PostgreSQLParser::RuleVerbose_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7728);
    match(PostgreSQLParser::VERBOSE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_Context ------------------------------------------------------------------

PostgreSQLParser::Full_Context::Full_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Full_Context::FULL() {
  return getToken(PostgreSQLParser::FULL, 0);
}


size_t PostgreSQLParser::Full_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleFull_;
}


std::any PostgreSQLParser::Full_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFull_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Full_Context* PostgreSQLParser::full_() {
  Full_Context *_localctx = _tracker.createInstance<Full_Context>(_ctx, getState());
  enterRule(_localctx, 872, PostgreSQLParser::RuleFull_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7730);
    match(PostgreSQLParser::FULL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Freeze_Context ------------------------------------------------------------------

PostgreSQLParser::Freeze_Context::Freeze_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Freeze_Context::FREEZE() {
  return getToken(PostgreSQLParser::FREEZE, 0);
}


size_t PostgreSQLParser::Freeze_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleFreeze_;
}


std::any PostgreSQLParser::Freeze_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFreeze_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Freeze_Context* PostgreSQLParser::freeze_() {
  Freeze_Context *_localctx = _tracker.createInstance<Freeze_Context>(_ctx, getState());
  enterRule(_localctx, 874, PostgreSQLParser::RuleFreeze_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7732);
    match(PostgreSQLParser::FREEZE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_list_Context ------------------------------------------------------------------

PostgreSQLParser::Name_list_Context::Name_list_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Name_list_Context::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Name_listContext* PostgreSQLParser::Name_list_Context::name_list() {
  return getRuleContext<PostgreSQLParser::Name_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Name_list_Context::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Name_list_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleName_list_;
}


std::any PostgreSQLParser::Name_list_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitName_list_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Name_list_Context* PostgreSQLParser::name_list_() {
  Name_list_Context *_localctx = _tracker.createInstance<Name_list_Context>(_ctx, getState());
  enterRule(_localctx, 876, PostgreSQLParser::RuleName_list_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7734);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(7735);
    name_list();
    setState(7736);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Vacuum_relationContext ------------------------------------------------------------------

PostgreSQLParser::Vacuum_relationContext::Vacuum_relationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::Vacuum_relationContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

PostgreSQLParser::Name_list_Context* PostgreSQLParser::Vacuum_relationContext::name_list_() {
  return getRuleContext<PostgreSQLParser::Name_list_Context>(0);
}


size_t PostgreSQLParser::Vacuum_relationContext::getRuleIndex() const {
  return PostgreSQLParser::RuleVacuum_relation;
}


std::any PostgreSQLParser::Vacuum_relationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitVacuum_relation(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Vacuum_relationContext* PostgreSQLParser::vacuum_relation() {
  Vacuum_relationContext *_localctx = _tracker.createInstance<Vacuum_relationContext>(_ctx, getState());
  enterRule(_localctx, 878, PostgreSQLParser::RuleVacuum_relation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7738);
    qualified_name();
    setState(7740);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OPEN_PAREN) {
      setState(7739);
      name_list_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Vacuum_relation_listContext ------------------------------------------------------------------

PostgreSQLParser::Vacuum_relation_listContext::Vacuum_relation_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Vacuum_relationContext *> PostgreSQLParser::Vacuum_relation_listContext::vacuum_relation() {
  return getRuleContexts<PostgreSQLParser::Vacuum_relationContext>();
}

PostgreSQLParser::Vacuum_relationContext* PostgreSQLParser::Vacuum_relation_listContext::vacuum_relation(size_t i) {
  return getRuleContext<PostgreSQLParser::Vacuum_relationContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Vacuum_relation_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Vacuum_relation_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Vacuum_relation_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleVacuum_relation_list;
}


std::any PostgreSQLParser::Vacuum_relation_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitVacuum_relation_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Vacuum_relation_listContext* PostgreSQLParser::vacuum_relation_list() {
  Vacuum_relation_listContext *_localctx = _tracker.createInstance<Vacuum_relation_listContext>(_ctx, getState());
  enterRule(_localctx, 880, PostgreSQLParser::RuleVacuum_relation_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7742);
    vacuum_relation();
    setState(7747);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(7743);
      match(PostgreSQLParser::COMMA);
      setState(7744);
      vacuum_relation();
      setState(7749);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Vacuum_relation_list_Context ------------------------------------------------------------------

PostgreSQLParser::Vacuum_relation_list_Context::Vacuum_relation_list_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Vacuum_relation_listContext* PostgreSQLParser::Vacuum_relation_list_Context::vacuum_relation_list() {
  return getRuleContext<PostgreSQLParser::Vacuum_relation_listContext>(0);
}


size_t PostgreSQLParser::Vacuum_relation_list_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleVacuum_relation_list_;
}


std::any PostgreSQLParser::Vacuum_relation_list_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitVacuum_relation_list_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Vacuum_relation_list_Context* PostgreSQLParser::vacuum_relation_list_() {
  Vacuum_relation_list_Context *_localctx = _tracker.createInstance<Vacuum_relation_list_Context>(_ctx, getState());
  enterRule(_localctx, 882, PostgreSQLParser::RuleVacuum_relation_list_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7750);
    vacuum_relation_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplainstmtContext ------------------------------------------------------------------

PostgreSQLParser::ExplainstmtContext::ExplainstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::ExplainstmtContext::EXPLAIN() {
  return getToken(PostgreSQLParser::EXPLAIN, 0);
}

PostgreSQLParser::ExplainablestmtContext* PostgreSQLParser::ExplainstmtContext::explainablestmt() {
  return getRuleContext<PostgreSQLParser::ExplainablestmtContext>(0);
}

PostgreSQLParser::Analyze_keywordContext* PostgreSQLParser::ExplainstmtContext::analyze_keyword() {
  return getRuleContext<PostgreSQLParser::Analyze_keywordContext>(0);
}

PostgreSQLParser::Verbose_Context* PostgreSQLParser::ExplainstmtContext::verbose_() {
  return getRuleContext<PostgreSQLParser::Verbose_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::ExplainstmtContext::VERBOSE() {
  return getToken(PostgreSQLParser::VERBOSE, 0);
}

tree::TerminalNode* PostgreSQLParser::ExplainstmtContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Explain_option_listContext* PostgreSQLParser::ExplainstmtContext::explain_option_list() {
  return getRuleContext<PostgreSQLParser::Explain_option_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ExplainstmtContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::ExplainstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleExplainstmt;
}


std::any PostgreSQLParser::ExplainstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitExplainstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ExplainstmtContext* PostgreSQLParser::explainstmt() {
  ExplainstmtContext *_localctx = _tracker.createInstance<ExplainstmtContext>(_ctx, getState());
  enterRule(_localctx, 884, PostgreSQLParser::RuleExplainstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7770);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 656, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7752);
      match(PostgreSQLParser::EXPLAIN);
      setState(7753);
      explainablestmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7754);
      match(PostgreSQLParser::EXPLAIN);
      setState(7755);
      analyze_keyword();
      setState(7757);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::VERBOSE) {
        setState(7756);
        verbose_();
      }
      setState(7759);
      explainablestmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7761);
      match(PostgreSQLParser::EXPLAIN);
      setState(7762);
      match(PostgreSQLParser::VERBOSE);
      setState(7763);
      explainablestmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7764);
      match(PostgreSQLParser::EXPLAIN);
      setState(7765);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(7766);
      explain_option_list();
      setState(7767);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(7768);
      explainablestmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplainablestmtContext ------------------------------------------------------------------

PostgreSQLParser::ExplainablestmtContext::ExplainablestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::SelectstmtContext* PostgreSQLParser::ExplainablestmtContext::selectstmt() {
  return getRuleContext<PostgreSQLParser::SelectstmtContext>(0);
}

PostgreSQLParser::InsertstmtContext* PostgreSQLParser::ExplainablestmtContext::insertstmt() {
  return getRuleContext<PostgreSQLParser::InsertstmtContext>(0);
}

PostgreSQLParser::UpdatestmtContext* PostgreSQLParser::ExplainablestmtContext::updatestmt() {
  return getRuleContext<PostgreSQLParser::UpdatestmtContext>(0);
}

PostgreSQLParser::DeletestmtContext* PostgreSQLParser::ExplainablestmtContext::deletestmt() {
  return getRuleContext<PostgreSQLParser::DeletestmtContext>(0);
}

PostgreSQLParser::DeclarecursorstmtContext* PostgreSQLParser::ExplainablestmtContext::declarecursorstmt() {
  return getRuleContext<PostgreSQLParser::DeclarecursorstmtContext>(0);
}

PostgreSQLParser::CreateasstmtContext* PostgreSQLParser::ExplainablestmtContext::createasstmt() {
  return getRuleContext<PostgreSQLParser::CreateasstmtContext>(0);
}

PostgreSQLParser::CreatematviewstmtContext* PostgreSQLParser::ExplainablestmtContext::creatematviewstmt() {
  return getRuleContext<PostgreSQLParser::CreatematviewstmtContext>(0);
}

PostgreSQLParser::RefreshmatviewstmtContext* PostgreSQLParser::ExplainablestmtContext::refreshmatviewstmt() {
  return getRuleContext<PostgreSQLParser::RefreshmatviewstmtContext>(0);
}

PostgreSQLParser::ExecutestmtContext* PostgreSQLParser::ExplainablestmtContext::executestmt() {
  return getRuleContext<PostgreSQLParser::ExecutestmtContext>(0);
}


size_t PostgreSQLParser::ExplainablestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleExplainablestmt;
}


std::any PostgreSQLParser::ExplainablestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitExplainablestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ExplainablestmtContext* PostgreSQLParser::explainablestmt() {
  ExplainablestmtContext *_localctx = _tracker.createInstance<ExplainablestmtContext>(_ctx, getState());
  enterRule(_localctx, 886, PostgreSQLParser::RuleExplainablestmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7781);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 657, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7772);
      selectstmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7773);
      insertstmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7774);
      updatestmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7775);
      deletestmt();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7776);
      declarecursorstmt();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(7777);
      createasstmt();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(7778);
      creatematviewstmt();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(7779);
      refreshmatviewstmt();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(7780);
      executestmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Explain_option_listContext ------------------------------------------------------------------

PostgreSQLParser::Explain_option_listContext::Explain_option_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Explain_option_elemContext *> PostgreSQLParser::Explain_option_listContext::explain_option_elem() {
  return getRuleContexts<PostgreSQLParser::Explain_option_elemContext>();
}

PostgreSQLParser::Explain_option_elemContext* PostgreSQLParser::Explain_option_listContext::explain_option_elem(size_t i) {
  return getRuleContext<PostgreSQLParser::Explain_option_elemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Explain_option_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Explain_option_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Explain_option_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleExplain_option_list;
}


std::any PostgreSQLParser::Explain_option_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitExplain_option_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Explain_option_listContext* PostgreSQLParser::explain_option_list() {
  Explain_option_listContext *_localctx = _tracker.createInstance<Explain_option_listContext>(_ctx, getState());
  enterRule(_localctx, 888, PostgreSQLParser::RuleExplain_option_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7783);
    explain_option_elem();
    setState(7788);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(7784);
      match(PostgreSQLParser::COMMA);
      setState(7785);
      explain_option_elem();
      setState(7790);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Explain_option_elemContext ------------------------------------------------------------------

PostgreSQLParser::Explain_option_elemContext::Explain_option_elemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Explain_option_nameContext* PostgreSQLParser::Explain_option_elemContext::explain_option_name() {
  return getRuleContext<PostgreSQLParser::Explain_option_nameContext>(0);
}

PostgreSQLParser::Explain_option_argContext* PostgreSQLParser::Explain_option_elemContext::explain_option_arg() {
  return getRuleContext<PostgreSQLParser::Explain_option_argContext>(0);
}


size_t PostgreSQLParser::Explain_option_elemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleExplain_option_elem;
}


std::any PostgreSQLParser::Explain_option_elemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitExplain_option_elem(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Explain_option_elemContext* PostgreSQLParser::explain_option_elem() {
  Explain_option_elemContext *_localctx = _tracker.createInstance<Explain_option_elemContext>(_ctx, getState());
  enterRule(_localctx, 890, PostgreSQLParser::RuleExplain_option_elem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7791);
    explain_option_name();
    setState(7793);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 12) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 12)) & 36028795944960003) != 0) || ((((_la - 98) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 98)) & -70300023652351) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 162)) & -1) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 482)) & 1153132602249444351) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 553)) & 138370110535) != 0)) {
      setState(7792);
      explain_option_arg();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Explain_option_nameContext ------------------------------------------------------------------

PostgreSQLParser::Explain_option_nameContext::Explain_option_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::NonreservedwordContext* PostgreSQLParser::Explain_option_nameContext::nonreservedword() {
  return getRuleContext<PostgreSQLParser::NonreservedwordContext>(0);
}

PostgreSQLParser::Analyze_keywordContext* PostgreSQLParser::Explain_option_nameContext::analyze_keyword() {
  return getRuleContext<PostgreSQLParser::Analyze_keywordContext>(0);
}


size_t PostgreSQLParser::Explain_option_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleExplain_option_name;
}


std::any PostgreSQLParser::Explain_option_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitExplain_option_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Explain_option_nameContext* PostgreSQLParser::explain_option_name() {
  Explain_option_nameContext *_localctx = _tracker.createInstance<Explain_option_nameContext>(_ctx, getState());
  enterRule(_localctx, 892, PostgreSQLParser::RuleExplain_option_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7797);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 1);
        setState(7795);
        nonreservedword();
        break;
      }

      case PostgreSQLParser::ANALYSE:
      case PostgreSQLParser::ANALYZE: {
        enterOuterAlt(_localctx, 2);
        setState(7796);
        analyze_keyword();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Explain_option_argContext ------------------------------------------------------------------

PostgreSQLParser::Explain_option_argContext::Explain_option_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Boolean_or_string_Context* PostgreSQLParser::Explain_option_argContext::boolean_or_string_() {
  return getRuleContext<PostgreSQLParser::Boolean_or_string_Context>(0);
}

PostgreSQLParser::NumericonlyContext* PostgreSQLParser::Explain_option_argContext::numericonly() {
  return getRuleContext<PostgreSQLParser::NumericonlyContext>(0);
}


size_t PostgreSQLParser::Explain_option_argContext::getRuleIndex() const {
  return PostgreSQLParser::RuleExplain_option_arg;
}


std::any PostgreSQLParser::Explain_option_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitExplain_option_arg(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Explain_option_argContext* PostgreSQLParser::explain_option_arg() {
  Explain_option_argContext *_localctx = _tracker.createInstance<Explain_option_argContext>(_ctx, getState());
  enterRule(_localctx, 894, PostgreSQLParser::RuleExplain_option_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7801);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::FALSE_P:
      case PostgreSQLParser::ON:
      case PostgreSQLParser::TRUE_P:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::PLSQLVARIABLENAME:
      case PostgreSQLParser::EscapeStringConstant: {
        enterOuterAlt(_localctx, 1);
        setState(7799);
        boolean_or_string_();
        break;
      }

      case PostgreSQLParser::PLUS:
      case PostgreSQLParser::MINUS:
      case PostgreSQLParser::Integral:
      case PostgreSQLParser::BinaryIntegral:
      case PostgreSQLParser::OctalIntegral:
      case PostgreSQLParser::HexadecimalIntegral:
      case PostgreSQLParser::Numeric: {
        enterOuterAlt(_localctx, 2);
        setState(7800);
        numericonly();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PreparestmtContext ------------------------------------------------------------------

PostgreSQLParser::PreparestmtContext::PreparestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::PreparestmtContext::PREPARE() {
  return getToken(PostgreSQLParser::PREPARE, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::PreparestmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::PreparestmtContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

PostgreSQLParser::PreparablestmtContext* PostgreSQLParser::PreparestmtContext::preparablestmt() {
  return getRuleContext<PostgreSQLParser::PreparablestmtContext>(0);
}

PostgreSQLParser::Prep_type_clauseContext* PostgreSQLParser::PreparestmtContext::prep_type_clause() {
  return getRuleContext<PostgreSQLParser::Prep_type_clauseContext>(0);
}


size_t PostgreSQLParser::PreparestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RulePreparestmt;
}


std::any PostgreSQLParser::PreparestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitPreparestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::PreparestmtContext* PostgreSQLParser::preparestmt() {
  PreparestmtContext *_localctx = _tracker.createInstance<PreparestmtContext>(_ctx, getState());
  enterRule(_localctx, 896, PostgreSQLParser::RulePreparestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7803);
    match(PostgreSQLParser::PREPARE);
    setState(7804);
    name();
    setState(7806);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OPEN_PAREN) {
      setState(7805);
      prep_type_clause();
    }
    setState(7808);
    match(PostgreSQLParser::AS);
    setState(7809);
    preparablestmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Prep_type_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Prep_type_clauseContext::Prep_type_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Prep_type_clauseContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Type_listContext* PostgreSQLParser::Prep_type_clauseContext::type_list() {
  return getRuleContext<PostgreSQLParser::Type_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Prep_type_clauseContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Prep_type_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RulePrep_type_clause;
}


std::any PostgreSQLParser::Prep_type_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitPrep_type_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Prep_type_clauseContext* PostgreSQLParser::prep_type_clause() {
  Prep_type_clauseContext *_localctx = _tracker.createInstance<Prep_type_clauseContext>(_ctx, getState());
  enterRule(_localctx, 898, PostgreSQLParser::RulePrep_type_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7811);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(7812);
    type_list();
    setState(7813);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PreparablestmtContext ------------------------------------------------------------------

PostgreSQLParser::PreparablestmtContext::PreparablestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::SelectstmtContext* PostgreSQLParser::PreparablestmtContext::selectstmt() {
  return getRuleContext<PostgreSQLParser::SelectstmtContext>(0);
}

PostgreSQLParser::InsertstmtContext* PostgreSQLParser::PreparablestmtContext::insertstmt() {
  return getRuleContext<PostgreSQLParser::InsertstmtContext>(0);
}

PostgreSQLParser::UpdatestmtContext* PostgreSQLParser::PreparablestmtContext::updatestmt() {
  return getRuleContext<PostgreSQLParser::UpdatestmtContext>(0);
}

PostgreSQLParser::DeletestmtContext* PostgreSQLParser::PreparablestmtContext::deletestmt() {
  return getRuleContext<PostgreSQLParser::DeletestmtContext>(0);
}


size_t PostgreSQLParser::PreparablestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RulePreparablestmt;
}


std::any PostgreSQLParser::PreparablestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitPreparablestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::PreparablestmtContext* PostgreSQLParser::preparablestmt() {
  PreparablestmtContext *_localctx = _tracker.createInstance<PreparablestmtContext>(_ctx, getState());
  enterRule(_localctx, 900, PostgreSQLParser::RulePreparablestmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7819);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 663, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7815);
      selectstmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7816);
      insertstmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7817);
      updatestmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7818);
      deletestmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExecutestmtContext ------------------------------------------------------------------

PostgreSQLParser::ExecutestmtContext::ExecutestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::ExecutestmtContext::EXECUTE() {
  return getToken(PostgreSQLParser::EXECUTE, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::ExecutestmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

PostgreSQLParser::Execute_param_clauseContext* PostgreSQLParser::ExecutestmtContext::execute_param_clause() {
  return getRuleContext<PostgreSQLParser::Execute_param_clauseContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ExecutestmtContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::ExecutestmtContext::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}

PostgreSQLParser::Create_as_targetContext* PostgreSQLParser::ExecutestmtContext::create_as_target() {
  return getRuleContext<PostgreSQLParser::Create_as_targetContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ExecutestmtContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

PostgreSQLParser::OpttempContext* PostgreSQLParser::ExecutestmtContext::opttemp() {
  return getRuleContext<PostgreSQLParser::OpttempContext>(0);
}

PostgreSQLParser::With_data_Context* PostgreSQLParser::ExecutestmtContext::with_data_() {
  return getRuleContext<PostgreSQLParser::With_data_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::ExecutestmtContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::ExecutestmtContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::ExecutestmtContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}


size_t PostgreSQLParser::ExecutestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleExecutestmt;
}


std::any PostgreSQLParser::ExecutestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitExecutestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ExecutestmtContext* PostgreSQLParser::executestmt() {
  ExecutestmtContext *_localctx = _tracker.createInstance<ExecutestmtContext>(_ctx, getState());
  enterRule(_localctx, 902, PostgreSQLParser::RuleExecutestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7859);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 671, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7821);
      match(PostgreSQLParser::EXECUTE);
      setState(7822);
      name();
      setState(7824);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPEN_PAREN) {
        setState(7823);
        execute_param_clause();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7826);
      match(PostgreSQLParser::CREATE);
      setState(7828);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::GLOBAL

      || _la == PostgreSQLParser::LOCAL || ((((_la - 383) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 383)) & 32773) != 0)) {
        setState(7827);
        opttemp();
      }
      setState(7830);
      match(PostgreSQLParser::TABLE);
      setState(7831);
      create_as_target();
      setState(7832);
      match(PostgreSQLParser::AS);
      setState(7833);
      match(PostgreSQLParser::EXECUTE);
      setState(7834);
      name();
      setState(7836);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPEN_PAREN) {
        setState(7835);
        execute_param_clause();
      }
      setState(7839);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::WITH) {
        setState(7838);
        with_data_();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7841);
      match(PostgreSQLParser::CREATE);
      setState(7843);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::GLOBAL

      || _la == PostgreSQLParser::LOCAL || ((((_la - 383) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 383)) & 32773) != 0)) {
        setState(7842);
        opttemp();
      }
      setState(7845);
      match(PostgreSQLParser::TABLE);
      setState(7846);
      match(PostgreSQLParser::IF_P);
      setState(7847);
      match(PostgreSQLParser::NOT);
      setState(7848);
      match(PostgreSQLParser::EXISTS);
      setState(7849);
      create_as_target();
      setState(7850);
      match(PostgreSQLParser::AS);
      setState(7851);
      match(PostgreSQLParser::EXECUTE);
      setState(7852);
      name();
      setState(7854);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OPEN_PAREN) {
        setState(7853);
        execute_param_clause();
      }
      setState(7857);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::WITH) {
        setState(7856);
        with_data_();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Execute_param_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Execute_param_clauseContext::Execute_param_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Execute_param_clauseContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::Execute_param_clauseContext::expr_list() {
  return getRuleContext<PostgreSQLParser::Expr_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Execute_param_clauseContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Execute_param_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleExecute_param_clause;
}


std::any PostgreSQLParser::Execute_param_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitExecute_param_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Execute_param_clauseContext* PostgreSQLParser::execute_param_clause() {
  Execute_param_clauseContext *_localctx = _tracker.createInstance<Execute_param_clauseContext>(_ctx, getState());
  enterRule(_localctx, 904, PostgreSQLParser::RuleExecute_param_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7861);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(7862);
    expr_list();
    setState(7863);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeallocatestmtContext ------------------------------------------------------------------

PostgreSQLParser::DeallocatestmtContext::DeallocatestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DeallocatestmtContext::DEALLOCATE() {
  return getToken(PostgreSQLParser::DEALLOCATE, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::DeallocatestmtContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DeallocatestmtContext::PREPARE() {
  return getToken(PostgreSQLParser::PREPARE, 0);
}

tree::TerminalNode* PostgreSQLParser::DeallocatestmtContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}


size_t PostgreSQLParser::DeallocatestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDeallocatestmt;
}


std::any PostgreSQLParser::DeallocatestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDeallocatestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DeallocatestmtContext* PostgreSQLParser::deallocatestmt() {
  DeallocatestmtContext *_localctx = _tracker.createInstance<DeallocatestmtContext>(_ctx, getState());
  enterRule(_localctx, 906, PostgreSQLParser::RuleDeallocatestmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7875);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 672, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7865);
      match(PostgreSQLParser::DEALLOCATE);
      setState(7866);
      name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7867);
      match(PostgreSQLParser::DEALLOCATE);
      setState(7868);
      match(PostgreSQLParser::PREPARE);
      setState(7869);
      name();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7870);
      match(PostgreSQLParser::DEALLOCATE);
      setState(7871);
      match(PostgreSQLParser::ALL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7872);
      match(PostgreSQLParser::DEALLOCATE);
      setState(7873);
      match(PostgreSQLParser::PREPARE);
      setState(7874);
      match(PostgreSQLParser::ALL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertstmtContext ------------------------------------------------------------------

PostgreSQLParser::InsertstmtContext::InsertstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::InsertstmtContext::INSERT() {
  return getToken(PostgreSQLParser::INSERT, 0);
}

tree::TerminalNode* PostgreSQLParser::InsertstmtContext::INTO() {
  return getToken(PostgreSQLParser::INTO, 0);
}

PostgreSQLParser::Insert_targetContext* PostgreSQLParser::InsertstmtContext::insert_target() {
  return getRuleContext<PostgreSQLParser::Insert_targetContext>(0);
}

PostgreSQLParser::Insert_restContext* PostgreSQLParser::InsertstmtContext::insert_rest() {
  return getRuleContext<PostgreSQLParser::Insert_restContext>(0);
}

PostgreSQLParser::With_clause_Context* PostgreSQLParser::InsertstmtContext::with_clause_() {
  return getRuleContext<PostgreSQLParser::With_clause_Context>(0);
}

PostgreSQLParser::On_conflict_Context* PostgreSQLParser::InsertstmtContext::on_conflict_() {
  return getRuleContext<PostgreSQLParser::On_conflict_Context>(0);
}

PostgreSQLParser::Returning_clauseContext* PostgreSQLParser::InsertstmtContext::returning_clause() {
  return getRuleContext<PostgreSQLParser::Returning_clauseContext>(0);
}


size_t PostgreSQLParser::InsertstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleInsertstmt;
}


std::any PostgreSQLParser::InsertstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitInsertstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::InsertstmtContext* PostgreSQLParser::insertstmt() {
  InsertstmtContext *_localctx = _tracker.createInstance<InsertstmtContext>(_ctx, getState());
  enterRule(_localctx, 908, PostgreSQLParser::RuleInsertstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7878);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(7877);
      with_clause_();
    }
    setState(7880);
    match(PostgreSQLParser::INSERT);
    setState(7881);
    match(PostgreSQLParser::INTO);
    setState(7882);
    insert_target();
    setState(7883);
    insert_rest();
    setState(7885);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::ON) {
      setState(7884);
      on_conflict_();
    }
    setState(7888);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::RETURNING) {
      setState(7887);
      returning_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_targetContext ------------------------------------------------------------------

PostgreSQLParser::Insert_targetContext::Insert_targetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::Insert_targetContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Insert_targetContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Insert_targetContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}


size_t PostgreSQLParser::Insert_targetContext::getRuleIndex() const {
  return PostgreSQLParser::RuleInsert_target;
}


std::any PostgreSQLParser::Insert_targetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitInsert_target(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Insert_targetContext* PostgreSQLParser::insert_target() {
  Insert_targetContext *_localctx = _tracker.createInstance<Insert_targetContext>(_ctx, getState());
  enterRule(_localctx, 910, PostgreSQLParser::RuleInsert_target);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7890);
    qualified_name();
    setState(7893);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::AS) {
      setState(7891);
      match(PostgreSQLParser::AS);
      setState(7892);
      colid();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_restContext ------------------------------------------------------------------

PostgreSQLParser::Insert_restContext::Insert_restContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::SelectstmtContext* PostgreSQLParser::Insert_restContext::selectstmt() {
  return getRuleContext<PostgreSQLParser::SelectstmtContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Insert_restContext::OVERRIDING() {
  return getToken(PostgreSQLParser::OVERRIDING, 0);
}

PostgreSQLParser::Override_kindContext* PostgreSQLParser::Insert_restContext::override_kind() {
  return getRuleContext<PostgreSQLParser::Override_kindContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Insert_restContext::VALUE_P() {
  return getToken(PostgreSQLParser::VALUE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Insert_restContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Insert_column_listContext* PostgreSQLParser::Insert_restContext::insert_column_list() {
  return getRuleContext<PostgreSQLParser::Insert_column_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Insert_restContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::Insert_restContext::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}

tree::TerminalNode* PostgreSQLParser::Insert_restContext::VALUES() {
  return getToken(PostgreSQLParser::VALUES, 0);
}


size_t PostgreSQLParser::Insert_restContext::getRuleIndex() const {
  return PostgreSQLParser::RuleInsert_rest;
}


std::any PostgreSQLParser::Insert_restContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitInsert_rest(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Insert_restContext* PostgreSQLParser::insert_rest() {
  Insert_restContext *_localctx = _tracker.createInstance<Insert_restContext>(_ctx, getState());
  enterRule(_localctx, 912, PostgreSQLParser::RuleInsert_rest);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7914);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 678, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7895);
      selectstmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7896);
      match(PostgreSQLParser::OVERRIDING);
      setState(7897);
      override_kind();
      setState(7898);
      match(PostgreSQLParser::VALUE_P);
      setState(7899);
      selectstmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7901);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(7902);
      insert_column_list();
      setState(7903);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(7908);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::OVERRIDING) {
        setState(7904);
        match(PostgreSQLParser::OVERRIDING);
        setState(7905);
        override_kind();
        setState(7906);
        match(PostgreSQLParser::VALUE_P);
      }
      setState(7910);
      selectstmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7912);
      match(PostgreSQLParser::DEFAULT);
      setState(7913);
      match(PostgreSQLParser::VALUES);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Override_kindContext ------------------------------------------------------------------

PostgreSQLParser::Override_kindContext::Override_kindContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Override_kindContext::USER() {
  return getToken(PostgreSQLParser::USER, 0);
}

tree::TerminalNode* PostgreSQLParser::Override_kindContext::SYSTEM_P() {
  return getToken(PostgreSQLParser::SYSTEM_P, 0);
}


size_t PostgreSQLParser::Override_kindContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOverride_kind;
}


std::any PostgreSQLParser::Override_kindContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOverride_kind(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Override_kindContext* PostgreSQLParser::override_kind() {
  Override_kindContext *_localctx = _tracker.createInstance<Override_kindContext>(_ctx, getState());
  enterRule(_localctx, 914, PostgreSQLParser::RuleOverride_kind);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7916);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::USER || _la == PostgreSQLParser::SYSTEM_P)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_column_listContext ------------------------------------------------------------------

PostgreSQLParser::Insert_column_listContext::Insert_column_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Insert_column_itemContext *> PostgreSQLParser::Insert_column_listContext::insert_column_item() {
  return getRuleContexts<PostgreSQLParser::Insert_column_itemContext>();
}

PostgreSQLParser::Insert_column_itemContext* PostgreSQLParser::Insert_column_listContext::insert_column_item(size_t i) {
  return getRuleContext<PostgreSQLParser::Insert_column_itemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Insert_column_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Insert_column_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Insert_column_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleInsert_column_list;
}


std::any PostgreSQLParser::Insert_column_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitInsert_column_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Insert_column_listContext* PostgreSQLParser::insert_column_list() {
  Insert_column_listContext *_localctx = _tracker.createInstance<Insert_column_listContext>(_ctx, getState());
  enterRule(_localctx, 916, PostgreSQLParser::RuleInsert_column_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7918);
    insert_column_item();
    setState(7923);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(7919);
      match(PostgreSQLParser::COMMA);
      setState(7920);
      insert_column_item();
      setState(7925);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_column_itemContext ------------------------------------------------------------------

PostgreSQLParser::Insert_column_itemContext::Insert_column_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Insert_column_itemContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

PostgreSQLParser::Opt_indirectionContext* PostgreSQLParser::Insert_column_itemContext::opt_indirection() {
  return getRuleContext<PostgreSQLParser::Opt_indirectionContext>(0);
}


size_t PostgreSQLParser::Insert_column_itemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleInsert_column_item;
}


std::any PostgreSQLParser::Insert_column_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitInsert_column_item(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Insert_column_itemContext* PostgreSQLParser::insert_column_item() {
  Insert_column_itemContext *_localctx = _tracker.createInstance<Insert_column_itemContext>(_ctx, getState());
  enterRule(_localctx, 918, PostgreSQLParser::RuleInsert_column_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7926);
    colid();
    setState(7927);
    opt_indirection();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- On_conflict_Context ------------------------------------------------------------------

PostgreSQLParser::On_conflict_Context::On_conflict_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::On_conflict_Context::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

tree::TerminalNode* PostgreSQLParser::On_conflict_Context::CONFLICT() {
  return getToken(PostgreSQLParser::CONFLICT, 0);
}

tree::TerminalNode* PostgreSQLParser::On_conflict_Context::DO() {
  return getToken(PostgreSQLParser::DO, 0);
}

tree::TerminalNode* PostgreSQLParser::On_conflict_Context::UPDATE() {
  return getToken(PostgreSQLParser::UPDATE, 0);
}

tree::TerminalNode* PostgreSQLParser::On_conflict_Context::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

PostgreSQLParser::Set_clause_listContext* PostgreSQLParser::On_conflict_Context::set_clause_list() {
  return getRuleContext<PostgreSQLParser::Set_clause_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::On_conflict_Context::NOTHING() {
  return getToken(PostgreSQLParser::NOTHING, 0);
}

PostgreSQLParser::Conf_expr_Context* PostgreSQLParser::On_conflict_Context::conf_expr_() {
  return getRuleContext<PostgreSQLParser::Conf_expr_Context>(0);
}

PostgreSQLParser::Where_clauseContext* PostgreSQLParser::On_conflict_Context::where_clause() {
  return getRuleContext<PostgreSQLParser::Where_clauseContext>(0);
}


size_t PostgreSQLParser::On_conflict_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleOn_conflict_;
}


std::any PostgreSQLParser::On_conflict_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOn_conflict_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::On_conflict_Context* PostgreSQLParser::on_conflict_() {
  On_conflict_Context *_localctx = _tracker.createInstance<On_conflict_Context>(_ctx, getState());
  enterRule(_localctx, 920, PostgreSQLParser::RuleOn_conflict_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7929);
    match(PostgreSQLParser::ON);
    setState(7930);
    match(PostgreSQLParser::CONFLICT);
    setState(7932);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OPEN_PAREN || _la == PostgreSQLParser::ON) {
      setState(7931);
      conf_expr_();
    }
    setState(7934);
    match(PostgreSQLParser::DO);
    setState(7942);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::UPDATE: {
        setState(7935);
        match(PostgreSQLParser::UPDATE);
        setState(7936);
        match(PostgreSQLParser::SET);
        setState(7937);
        set_clause_list();
        setState(7939);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::WHERE) {
          setState(7938);
          where_clause();
        }
        break;
      }

      case PostgreSQLParser::NOTHING: {
        setState(7941);
        match(PostgreSQLParser::NOTHING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Conf_expr_Context ------------------------------------------------------------------

PostgreSQLParser::Conf_expr_Context::Conf_expr_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Conf_expr_Context::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Index_paramsContext* PostgreSQLParser::Conf_expr_Context::index_params() {
  return getRuleContext<PostgreSQLParser::Index_paramsContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Conf_expr_Context::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::Where_clauseContext* PostgreSQLParser::Conf_expr_Context::where_clause() {
  return getRuleContext<PostgreSQLParser::Where_clauseContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Conf_expr_Context::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

tree::TerminalNode* PostgreSQLParser::Conf_expr_Context::CONSTRAINT() {
  return getToken(PostgreSQLParser::CONSTRAINT, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::Conf_expr_Context::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}


size_t PostgreSQLParser::Conf_expr_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleConf_expr_;
}


std::any PostgreSQLParser::Conf_expr_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitConf_expr_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Conf_expr_Context* PostgreSQLParser::conf_expr_() {
  Conf_expr_Context *_localctx = _tracker.createInstance<Conf_expr_Context>(_ctx, getState());
  enterRule(_localctx, 922, PostgreSQLParser::RuleConf_expr_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7953);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::OPEN_PAREN: {
        enterOuterAlt(_localctx, 1);
        setState(7944);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(7945);
        index_params();
        setState(7946);
        match(PostgreSQLParser::CLOSE_PAREN);
        setState(7948);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::WHERE) {
          setState(7947);
          where_clause();
        }
        break;
      }

      case PostgreSQLParser::ON: {
        enterOuterAlt(_localctx, 2);
        setState(7950);
        match(PostgreSQLParser::ON);
        setState(7951);
        match(PostgreSQLParser::CONSTRAINT);
        setState(7952);
        name();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Returning_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Returning_clauseContext::Returning_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Returning_clauseContext::RETURNING() {
  return getToken(PostgreSQLParser::RETURNING, 0);
}

PostgreSQLParser::Target_listContext* PostgreSQLParser::Returning_clauseContext::target_list() {
  return getRuleContext<PostgreSQLParser::Target_listContext>(0);
}


size_t PostgreSQLParser::Returning_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleReturning_clause;
}


std::any PostgreSQLParser::Returning_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitReturning_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Returning_clauseContext* PostgreSQLParser::returning_clause() {
  Returning_clauseContext *_localctx = _tracker.createInstance<Returning_clauseContext>(_ctx, getState());
  enterRule(_localctx, 924, PostgreSQLParser::RuleReturning_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7955);
    match(PostgreSQLParser::RETURNING);
    setState(7956);
    target_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MergestmtContext ------------------------------------------------------------------

PostgreSQLParser::MergestmtContext::MergestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::MergestmtContext::MERGE() {
  return getToken(PostgreSQLParser::MERGE, 0);
}

std::vector<PostgreSQLParser::Qualified_nameContext *> PostgreSQLParser::MergestmtContext::qualified_name() {
  return getRuleContexts<PostgreSQLParser::Qualified_nameContext>();
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::MergestmtContext::qualified_name(size_t i) {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(i);
}

tree::TerminalNode* PostgreSQLParser::MergestmtContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

tree::TerminalNode* PostgreSQLParser::MergestmtContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::MergestmtContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

PostgreSQLParser::Select_with_parensContext* PostgreSQLParser::MergestmtContext::select_with_parens() {
  return getRuleContext<PostgreSQLParser::Select_with_parensContext>(0);
}

PostgreSQLParser::Merge_insert_clauseContext* PostgreSQLParser::MergestmtContext::merge_insert_clause() {
  return getRuleContext<PostgreSQLParser::Merge_insert_clauseContext>(0);
}

PostgreSQLParser::Merge_update_clauseContext* PostgreSQLParser::MergestmtContext::merge_update_clause() {
  return getRuleContext<PostgreSQLParser::Merge_update_clauseContext>(0);
}

tree::TerminalNode* PostgreSQLParser::MergestmtContext::INTO() {
  return getToken(PostgreSQLParser::INTO, 0);
}

std::vector<PostgreSQLParser::Alias_clauseContext *> PostgreSQLParser::MergestmtContext::alias_clause() {
  return getRuleContexts<PostgreSQLParser::Alias_clauseContext>();
}

PostgreSQLParser::Alias_clauseContext* PostgreSQLParser::MergestmtContext::alias_clause(size_t i) {
  return getRuleContext<PostgreSQLParser::Alias_clauseContext>(i);
}

PostgreSQLParser::Merge_delete_clauseContext* PostgreSQLParser::MergestmtContext::merge_delete_clause() {
  return getRuleContext<PostgreSQLParser::Merge_delete_clauseContext>(0);
}


size_t PostgreSQLParser::MergestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleMergestmt;
}


std::any PostgreSQLParser::MergestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitMergestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::MergestmtContext* PostgreSQLParser::mergestmt() {
  MergestmtContext *_localctx = _tracker.createInstance<MergestmtContext>(_ctx, getState());
  enterRule(_localctx, 926, PostgreSQLParser::RuleMergestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7958);
    match(PostgreSQLParser::MERGE);
    setState(7960);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::INTO) {
      setState(7959);
      match(PostgreSQLParser::INTO);
    }
    setState(7962);
    qualified_name();
    setState(7964);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 30) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 30)) & 17729624993791) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 553)) & 536870983) != 0)) {
      setState(7963);
      alias_clause();
    }
    setState(7966);
    match(PostgreSQLParser::USING);
    setState(7969);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::OPEN_PAREN: {
        setState(7967);
        select_with_parens();
        break;
      }

      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        setState(7968);
        qualified_name();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(7972);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 30) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 30)) & 17729624993791) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 553)) & 536870983) != 0)) {
      setState(7971);
      alias_clause();
    }
    setState(7974);
    match(PostgreSQLParser::ON);
    setState(7975);
    a_expr();
    setState(7984);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 691, _ctx)) {
    case 1: {
      setState(7976);
      merge_insert_clause();
      setState(7978);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 689, _ctx)) {
      case 1: {
        setState(7977);
        merge_update_clause();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      setState(7980);
      merge_update_clause();
      setState(7982);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 690, _ctx)) {
      case 1: {
        setState(7981);
        merge_insert_clause();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    setState(7987);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WHEN) {
      setState(7986);
      merge_delete_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Merge_insert_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Merge_insert_clauseContext::Merge_insert_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Merge_insert_clauseContext::WHEN() {
  return getToken(PostgreSQLParser::WHEN, 0);
}

tree::TerminalNode* PostgreSQLParser::Merge_insert_clauseContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::Merge_insert_clauseContext::MATCHED() {
  return getToken(PostgreSQLParser::MATCHED, 0);
}

tree::TerminalNode* PostgreSQLParser::Merge_insert_clauseContext::INSERT() {
  return getToken(PostgreSQLParser::INSERT, 0);
}

PostgreSQLParser::Values_clauseContext* PostgreSQLParser::Merge_insert_clauseContext::values_clause() {
  return getRuleContext<PostgreSQLParser::Values_clauseContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Merge_insert_clauseContext::AND() {
  return getToken(PostgreSQLParser::AND, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Merge_insert_clauseContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Merge_insert_clauseContext::THEN() {
  return getToken(PostgreSQLParser::THEN, 0);
}

tree::TerminalNode* PostgreSQLParser::Merge_insert_clauseContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Insert_column_listContext* PostgreSQLParser::Merge_insert_clauseContext::insert_column_list() {
  return getRuleContext<PostgreSQLParser::Insert_column_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Merge_insert_clauseContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Merge_insert_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleMerge_insert_clause;
}


std::any PostgreSQLParser::Merge_insert_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitMerge_insert_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Merge_insert_clauseContext* PostgreSQLParser::merge_insert_clause() {
  Merge_insert_clauseContext *_localctx = _tracker.createInstance<Merge_insert_clauseContext>(_ctx, getState());
  enterRule(_localctx, 928, PostgreSQLParser::RuleMerge_insert_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7989);
    match(PostgreSQLParser::WHEN);
    setState(7990);
    match(PostgreSQLParser::NOT);
    setState(7991);
    match(PostgreSQLParser::MATCHED);
    setState(7994);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::AND) {
      setState(7992);
      match(PostgreSQLParser::AND);
      setState(7993);
      a_expr();
    }
    setState(7997);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::THEN) {
      setState(7996);
      match(PostgreSQLParser::THEN);
    }
    setState(7999);
    match(PostgreSQLParser::INSERT);
    setState(8004);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OPEN_PAREN) {
      setState(8000);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(8001);
      insert_column_list();
      setState(8002);
      match(PostgreSQLParser::CLOSE_PAREN);
    }
    setState(8006);
    values_clause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Merge_update_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Merge_update_clauseContext::Merge_update_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Merge_update_clauseContext::WHEN() {
  return getToken(PostgreSQLParser::WHEN, 0);
}

tree::TerminalNode* PostgreSQLParser::Merge_update_clauseContext::MATCHED() {
  return getToken(PostgreSQLParser::MATCHED, 0);
}

tree::TerminalNode* PostgreSQLParser::Merge_update_clauseContext::UPDATE() {
  return getToken(PostgreSQLParser::UPDATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Merge_update_clauseContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

PostgreSQLParser::Set_clause_listContext* PostgreSQLParser::Merge_update_clauseContext::set_clause_list() {
  return getRuleContext<PostgreSQLParser::Set_clause_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Merge_update_clauseContext::AND() {
  return getToken(PostgreSQLParser::AND, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Merge_update_clauseContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Merge_update_clauseContext::THEN() {
  return getToken(PostgreSQLParser::THEN, 0);
}


size_t PostgreSQLParser::Merge_update_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleMerge_update_clause;
}


std::any PostgreSQLParser::Merge_update_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitMerge_update_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Merge_update_clauseContext* PostgreSQLParser::merge_update_clause() {
  Merge_update_clauseContext *_localctx = _tracker.createInstance<Merge_update_clauseContext>(_ctx, getState());
  enterRule(_localctx, 930, PostgreSQLParser::RuleMerge_update_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8008);
    match(PostgreSQLParser::WHEN);
    setState(8009);
    match(PostgreSQLParser::MATCHED);
    setState(8012);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::AND) {
      setState(8010);
      match(PostgreSQLParser::AND);
      setState(8011);
      a_expr();
    }
    setState(8015);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::THEN) {
      setState(8014);
      match(PostgreSQLParser::THEN);
    }
    setState(8017);
    match(PostgreSQLParser::UPDATE);
    setState(8018);
    match(PostgreSQLParser::SET);
    setState(8019);
    set_clause_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Merge_delete_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Merge_delete_clauseContext::Merge_delete_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Merge_delete_clauseContext::WHEN() {
  return getToken(PostgreSQLParser::WHEN, 0);
}

tree::TerminalNode* PostgreSQLParser::Merge_delete_clauseContext::MATCHED() {
  return getToken(PostgreSQLParser::MATCHED, 0);
}

tree::TerminalNode* PostgreSQLParser::Merge_delete_clauseContext::DELETE_P() {
  return getToken(PostgreSQLParser::DELETE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Merge_delete_clauseContext::THEN() {
  return getToken(PostgreSQLParser::THEN, 0);
}


size_t PostgreSQLParser::Merge_delete_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleMerge_delete_clause;
}


std::any PostgreSQLParser::Merge_delete_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitMerge_delete_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Merge_delete_clauseContext* PostgreSQLParser::merge_delete_clause() {
  Merge_delete_clauseContext *_localctx = _tracker.createInstance<Merge_delete_clauseContext>(_ctx, getState());
  enterRule(_localctx, 932, PostgreSQLParser::RuleMerge_delete_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8021);
    match(PostgreSQLParser::WHEN);
    setState(8022);
    match(PostgreSQLParser::MATCHED);
    setState(8024);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::THEN) {
      setState(8023);
      match(PostgreSQLParser::THEN);
    }
    setState(8026);
    match(PostgreSQLParser::DELETE_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeletestmtContext ------------------------------------------------------------------

PostgreSQLParser::DeletestmtContext::DeletestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DeletestmtContext::DELETE_P() {
  return getToken(PostgreSQLParser::DELETE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::DeletestmtContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

PostgreSQLParser::Relation_expr_opt_aliasContext* PostgreSQLParser::DeletestmtContext::relation_expr_opt_alias() {
  return getRuleContext<PostgreSQLParser::Relation_expr_opt_aliasContext>(0);
}

PostgreSQLParser::With_clause_Context* PostgreSQLParser::DeletestmtContext::with_clause_() {
  return getRuleContext<PostgreSQLParser::With_clause_Context>(0);
}

PostgreSQLParser::Using_clauseContext* PostgreSQLParser::DeletestmtContext::using_clause() {
  return getRuleContext<PostgreSQLParser::Using_clauseContext>(0);
}

PostgreSQLParser::Where_or_current_clauseContext* PostgreSQLParser::DeletestmtContext::where_or_current_clause() {
  return getRuleContext<PostgreSQLParser::Where_or_current_clauseContext>(0);
}

PostgreSQLParser::Returning_clauseContext* PostgreSQLParser::DeletestmtContext::returning_clause() {
  return getRuleContext<PostgreSQLParser::Returning_clauseContext>(0);
}


size_t PostgreSQLParser::DeletestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDeletestmt;
}


std::any PostgreSQLParser::DeletestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDeletestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DeletestmtContext* PostgreSQLParser::deletestmt() {
  DeletestmtContext *_localctx = _tracker.createInstance<DeletestmtContext>(_ctx, getState());
  enterRule(_localctx, 934, PostgreSQLParser::RuleDeletestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8029);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(8028);
      with_clause_();
    }
    setState(8031);
    match(PostgreSQLParser::DELETE_P);
    setState(8032);
    match(PostgreSQLParser::FROM);
    setState(8033);
    relation_expr_opt_alias();
    setState(8035);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::USING) {
      setState(8034);
      using_clause();
    }
    setState(8038);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WHERE) {
      setState(8037);
      where_or_current_clause();
    }
    setState(8041);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::RETURNING) {
      setState(8040);
      returning_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Using_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Using_clauseContext::Using_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Using_clauseContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

PostgreSQLParser::From_listContext* PostgreSQLParser::Using_clauseContext::from_list() {
  return getRuleContext<PostgreSQLParser::From_listContext>(0);
}


size_t PostgreSQLParser::Using_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleUsing_clause;
}


std::any PostgreSQLParser::Using_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitUsing_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Using_clauseContext* PostgreSQLParser::using_clause() {
  Using_clauseContext *_localctx = _tracker.createInstance<Using_clauseContext>(_ctx, getState());
  enterRule(_localctx, 936, PostgreSQLParser::RuleUsing_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8043);
    match(PostgreSQLParser::USING);
    setState(8044);
    from_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockstmtContext ------------------------------------------------------------------

PostgreSQLParser::LockstmtContext::LockstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::LockstmtContext::LOCK_P() {
  return getToken(PostgreSQLParser::LOCK_P, 0);
}

PostgreSQLParser::Relation_expr_listContext* PostgreSQLParser::LockstmtContext::relation_expr_list() {
  return getRuleContext<PostgreSQLParser::Relation_expr_listContext>(0);
}

PostgreSQLParser::Table_Context* PostgreSQLParser::LockstmtContext::table_() {
  return getRuleContext<PostgreSQLParser::Table_Context>(0);
}

PostgreSQLParser::Lock_Context* PostgreSQLParser::LockstmtContext::lock_() {
  return getRuleContext<PostgreSQLParser::Lock_Context>(0);
}

PostgreSQLParser::Nowait_Context* PostgreSQLParser::LockstmtContext::nowait_() {
  return getRuleContext<PostgreSQLParser::Nowait_Context>(0);
}


size_t PostgreSQLParser::LockstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleLockstmt;
}


std::any PostgreSQLParser::LockstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitLockstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::LockstmtContext* PostgreSQLParser::lockstmt() {
  LockstmtContext *_localctx = _tracker.createInstance<LockstmtContext>(_ctx, getState());
  enterRule(_localctx, 938, PostgreSQLParser::RuleLockstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8046);
    match(PostgreSQLParser::LOCK_P);
    setState(8048);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::TABLE) {
      setState(8047);
      table_();
    }
    setState(8050);
    relation_expr_list();
    setState(8052);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::IN_P) {
      setState(8051);
      lock_();
    }
    setState(8055);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::NOWAIT) {
      setState(8054);
      nowait_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Lock_Context ------------------------------------------------------------------

PostgreSQLParser::Lock_Context::Lock_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Lock_Context::IN_P() {
  return getToken(PostgreSQLParser::IN_P, 0);
}

PostgreSQLParser::Lock_typeContext* PostgreSQLParser::Lock_Context::lock_type() {
  return getRuleContext<PostgreSQLParser::Lock_typeContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Lock_Context::MODE() {
  return getToken(PostgreSQLParser::MODE, 0);
}


size_t PostgreSQLParser::Lock_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleLock_;
}


std::any PostgreSQLParser::Lock_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitLock_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Lock_Context* PostgreSQLParser::lock_() {
  Lock_Context *_localctx = _tracker.createInstance<Lock_Context>(_ctx, getState());
  enterRule(_localctx, 940, PostgreSQLParser::RuleLock_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8057);
    match(PostgreSQLParser::IN_P);
    setState(8058);
    lock_type();
    setState(8059);
    match(PostgreSQLParser::MODE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Lock_typeContext ------------------------------------------------------------------

PostgreSQLParser::Lock_typeContext::Lock_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Lock_typeContext::ACCESS() {
  return getToken(PostgreSQLParser::ACCESS, 0);
}

tree::TerminalNode* PostgreSQLParser::Lock_typeContext::SHARE() {
  return getToken(PostgreSQLParser::SHARE, 0);
}

tree::TerminalNode* PostgreSQLParser::Lock_typeContext::EXCLUSIVE() {
  return getToken(PostgreSQLParser::EXCLUSIVE, 0);
}

tree::TerminalNode* PostgreSQLParser::Lock_typeContext::ROW() {
  return getToken(PostgreSQLParser::ROW, 0);
}

tree::TerminalNode* PostgreSQLParser::Lock_typeContext::UPDATE() {
  return getToken(PostgreSQLParser::UPDATE, 0);
}


size_t PostgreSQLParser::Lock_typeContext::getRuleIndex() const {
  return PostgreSQLParser::RuleLock_type;
}


std::any PostgreSQLParser::Lock_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitLock_type(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Lock_typeContext* PostgreSQLParser::lock_type() {
  Lock_typeContext *_localctx = _tracker.createInstance<Lock_typeContext>(_ctx, getState());
  enterRule(_localctx, 942, PostgreSQLParser::RuleLock_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8073);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::ACCESS: {
        enterOuterAlt(_localctx, 1);
        setState(8061);
        match(PostgreSQLParser::ACCESS);
        setState(8062);
        _la = _input->LA(1);
        if (!(_la == PostgreSQLParser::EXCLUSIVE || _la == PostgreSQLParser::SHARE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case PostgreSQLParser::ROW: {
        enterOuterAlt(_localctx, 2);
        setState(8063);
        match(PostgreSQLParser::ROW);
        setState(8064);
        _la = _input->LA(1);
        if (!(_la == PostgreSQLParser::EXCLUSIVE || _la == PostgreSQLParser::SHARE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case PostgreSQLParser::SHARE: {
        enterOuterAlt(_localctx, 3);
        setState(8065);
        match(PostgreSQLParser::SHARE);
        setState(8070);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case PostgreSQLParser::UPDATE: {
            setState(8066);
            match(PostgreSQLParser::UPDATE);
            setState(8067);
            match(PostgreSQLParser::EXCLUSIVE);
            break;
          }

          case PostgreSQLParser::ROW: {
            setState(8068);
            match(PostgreSQLParser::ROW);
            setState(8069);
            match(PostgreSQLParser::EXCLUSIVE);
            break;
          }

          case PostgreSQLParser::MODE: {
            break;
          }

        default:
          break;
        }
        break;
      }

      case PostgreSQLParser::EXCLUSIVE: {
        enterOuterAlt(_localctx, 4);
        setState(8072);
        match(PostgreSQLParser::EXCLUSIVE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nowait_Context ------------------------------------------------------------------

PostgreSQLParser::Nowait_Context::Nowait_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Nowait_Context::NOWAIT() {
  return getToken(PostgreSQLParser::NOWAIT, 0);
}


size_t PostgreSQLParser::Nowait_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleNowait_;
}


std::any PostgreSQLParser::Nowait_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitNowait_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Nowait_Context* PostgreSQLParser::nowait_() {
  Nowait_Context *_localctx = _tracker.createInstance<Nowait_Context>(_ctx, getState());
  enterRule(_localctx, 944, PostgreSQLParser::RuleNowait_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8075);
    match(PostgreSQLParser::NOWAIT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nowait_or_skip_Context ------------------------------------------------------------------

PostgreSQLParser::Nowait_or_skip_Context::Nowait_or_skip_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Nowait_or_skip_Context::NOWAIT() {
  return getToken(PostgreSQLParser::NOWAIT, 0);
}

tree::TerminalNode* PostgreSQLParser::Nowait_or_skip_Context::SKIP_P() {
  return getToken(PostgreSQLParser::SKIP_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Nowait_or_skip_Context::LOCKED() {
  return getToken(PostgreSQLParser::LOCKED, 0);
}


size_t PostgreSQLParser::Nowait_or_skip_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleNowait_or_skip_;
}


std::any PostgreSQLParser::Nowait_or_skip_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitNowait_or_skip_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Nowait_or_skip_Context* PostgreSQLParser::nowait_or_skip_() {
  Nowait_or_skip_Context *_localctx = _tracker.createInstance<Nowait_or_skip_Context>(_ctx, getState());
  enterRule(_localctx, 946, PostgreSQLParser::RuleNowait_or_skip_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8080);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::NOWAIT: {
        enterOuterAlt(_localctx, 1);
        setState(8077);
        match(PostgreSQLParser::NOWAIT);
        break;
      }

      case PostgreSQLParser::SKIP_P: {
        enterOuterAlt(_localctx, 2);
        setState(8078);
        match(PostgreSQLParser::SKIP_P);
        setState(8079);
        match(PostgreSQLParser::LOCKED);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpdatestmtContext ------------------------------------------------------------------

PostgreSQLParser::UpdatestmtContext::UpdatestmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::UpdatestmtContext::UPDATE() {
  return getToken(PostgreSQLParser::UPDATE, 0);
}

PostgreSQLParser::Relation_expr_opt_aliasContext* PostgreSQLParser::UpdatestmtContext::relation_expr_opt_alias() {
  return getRuleContext<PostgreSQLParser::Relation_expr_opt_aliasContext>(0);
}

tree::TerminalNode* PostgreSQLParser::UpdatestmtContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

PostgreSQLParser::Set_clause_listContext* PostgreSQLParser::UpdatestmtContext::set_clause_list() {
  return getRuleContext<PostgreSQLParser::Set_clause_listContext>(0);
}

PostgreSQLParser::With_clause_Context* PostgreSQLParser::UpdatestmtContext::with_clause_() {
  return getRuleContext<PostgreSQLParser::With_clause_Context>(0);
}

PostgreSQLParser::From_clauseContext* PostgreSQLParser::UpdatestmtContext::from_clause() {
  return getRuleContext<PostgreSQLParser::From_clauseContext>(0);
}

PostgreSQLParser::Where_or_current_clauseContext* PostgreSQLParser::UpdatestmtContext::where_or_current_clause() {
  return getRuleContext<PostgreSQLParser::Where_or_current_clauseContext>(0);
}

PostgreSQLParser::Returning_clauseContext* PostgreSQLParser::UpdatestmtContext::returning_clause() {
  return getRuleContext<PostgreSQLParser::Returning_clauseContext>(0);
}


size_t PostgreSQLParser::UpdatestmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleUpdatestmt;
}


std::any PostgreSQLParser::UpdatestmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitUpdatestmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::UpdatestmtContext* PostgreSQLParser::updatestmt() {
  UpdatestmtContext *_localctx = _tracker.createInstance<UpdatestmtContext>(_ctx, getState());
  enterRule(_localctx, 948, PostgreSQLParser::RuleUpdatestmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8083);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH) {
      setState(8082);
      with_clause_();
    }
    setState(8085);
    match(PostgreSQLParser::UPDATE);
    setState(8086);
    relation_expr_opt_alias();
    setState(8087);
    match(PostgreSQLParser::SET);
    setState(8088);
    set_clause_list();
    setState(8090);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::FROM) {
      setState(8089);
      from_clause();
    }
    setState(8093);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WHERE) {
      setState(8092);
      where_or_current_clause();
    }
    setState(8096);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::RETURNING) {
      setState(8095);
      returning_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_clause_listContext ------------------------------------------------------------------

PostgreSQLParser::Set_clause_listContext::Set_clause_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Set_clauseContext *> PostgreSQLParser::Set_clause_listContext::set_clause() {
  return getRuleContexts<PostgreSQLParser::Set_clauseContext>();
}

PostgreSQLParser::Set_clauseContext* PostgreSQLParser::Set_clause_listContext::set_clause(size_t i) {
  return getRuleContext<PostgreSQLParser::Set_clauseContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Set_clause_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Set_clause_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Set_clause_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSet_clause_list;
}


std::any PostgreSQLParser::Set_clause_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSet_clause_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Set_clause_listContext* PostgreSQLParser::set_clause_list() {
  Set_clause_listContext *_localctx = _tracker.createInstance<Set_clause_listContext>(_ctx, getState());
  enterRule(_localctx, 950, PostgreSQLParser::RuleSet_clause_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8098);
    set_clause();
    setState(8103);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(8099);
      match(PostgreSQLParser::COMMA);
      setState(8100);
      set_clause();
      setState(8105);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Set_clauseContext::Set_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Set_targetContext* PostgreSQLParser::Set_clauseContext::set_target() {
  return getRuleContext<PostgreSQLParser::Set_targetContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Set_clauseContext::EQUAL() {
  return getToken(PostgreSQLParser::EQUAL, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Set_clauseContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Set_clauseContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Set_target_listContext* PostgreSQLParser::Set_clauseContext::set_target_list() {
  return getRuleContext<PostgreSQLParser::Set_target_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Set_clauseContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Set_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSet_clause;
}


std::any PostgreSQLParser::Set_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSet_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Set_clauseContext* PostgreSQLParser::set_clause() {
  Set_clauseContext *_localctx = _tracker.createInstance<Set_clauseContext>(_ctx, getState());
  enterRule(_localctx, 952, PostgreSQLParser::RuleSet_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8116);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 1);
        setState(8106);
        set_target();
        setState(8107);
        match(PostgreSQLParser::EQUAL);
        setState(8108);
        a_expr();
        break;
      }

      case PostgreSQLParser::OPEN_PAREN: {
        enterOuterAlt(_localctx, 2);
        setState(8110);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(8111);
        set_target_list();
        setState(8112);
        match(PostgreSQLParser::CLOSE_PAREN);
        setState(8113);
        match(PostgreSQLParser::EQUAL);
        setState(8114);
        a_expr();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_targetContext ------------------------------------------------------------------

PostgreSQLParser::Set_targetContext::Set_targetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Set_targetContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

PostgreSQLParser::Opt_indirectionContext* PostgreSQLParser::Set_targetContext::opt_indirection() {
  return getRuleContext<PostgreSQLParser::Opt_indirectionContext>(0);
}


size_t PostgreSQLParser::Set_targetContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSet_target;
}


std::any PostgreSQLParser::Set_targetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSet_target(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Set_targetContext* PostgreSQLParser::set_target() {
  Set_targetContext *_localctx = _tracker.createInstance<Set_targetContext>(_ctx, getState());
  enterRule(_localctx, 954, PostgreSQLParser::RuleSet_target);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8118);
    colid();
    setState(8119);
    opt_indirection();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Set_target_listContext ------------------------------------------------------------------

PostgreSQLParser::Set_target_listContext::Set_target_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Set_targetContext *> PostgreSQLParser::Set_target_listContext::set_target() {
  return getRuleContexts<PostgreSQLParser::Set_targetContext>();
}

PostgreSQLParser::Set_targetContext* PostgreSQLParser::Set_target_listContext::set_target(size_t i) {
  return getRuleContext<PostgreSQLParser::Set_targetContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Set_target_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Set_target_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Set_target_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSet_target_list;
}


std::any PostgreSQLParser::Set_target_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSet_target_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Set_target_listContext* PostgreSQLParser::set_target_list() {
  Set_target_listContext *_localctx = _tracker.createInstance<Set_target_listContext>(_ctx, getState());
  enterRule(_localctx, 956, PostgreSQLParser::RuleSet_target_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8121);
    set_target();
    setState(8126);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(8122);
      match(PostgreSQLParser::COMMA);
      setState(8123);
      set_target();
      setState(8128);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclarecursorstmtContext ------------------------------------------------------------------

PostgreSQLParser::DeclarecursorstmtContext::DeclarecursorstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::DeclarecursorstmtContext::DECLARE() {
  return getToken(PostgreSQLParser::DECLARE, 0);
}

PostgreSQLParser::Cursor_nameContext* PostgreSQLParser::DeclarecursorstmtContext::cursor_name() {
  return getRuleContext<PostgreSQLParser::Cursor_nameContext>(0);
}

PostgreSQLParser::Cursor_optionsContext* PostgreSQLParser::DeclarecursorstmtContext::cursor_options() {
  return getRuleContext<PostgreSQLParser::Cursor_optionsContext>(0);
}

tree::TerminalNode* PostgreSQLParser::DeclarecursorstmtContext::CURSOR() {
  return getToken(PostgreSQLParser::CURSOR, 0);
}

tree::TerminalNode* PostgreSQLParser::DeclarecursorstmtContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

PostgreSQLParser::SelectstmtContext* PostgreSQLParser::DeclarecursorstmtContext::selectstmt() {
  return getRuleContext<PostgreSQLParser::SelectstmtContext>(0);
}

PostgreSQLParser::Hold_Context* PostgreSQLParser::DeclarecursorstmtContext::hold_() {
  return getRuleContext<PostgreSQLParser::Hold_Context>(0);
}


size_t PostgreSQLParser::DeclarecursorstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDeclarecursorstmt;
}


std::any PostgreSQLParser::DeclarecursorstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDeclarecursorstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::DeclarecursorstmtContext* PostgreSQLParser::declarecursorstmt() {
  DeclarecursorstmtContext *_localctx = _tracker.createInstance<DeclarecursorstmtContext>(_ctx, getState());
  enterRule(_localctx, 958, PostgreSQLParser::RuleDeclarecursorstmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8129);
    match(PostgreSQLParser::DECLARE);
    setState(8130);
    cursor_name();
    setState(8131);
    cursor_options();
    setState(8132);
    match(PostgreSQLParser::CURSOR);
    setState(8134);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::WITH || _la == PostgreSQLParser::WITHOUT) {
      setState(8133);
      hold_();
    }
    setState(8136);
    match(PostgreSQLParser::FOR);
    setState(8137);
    selectstmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cursor_nameContext ------------------------------------------------------------------

PostgreSQLParser::Cursor_nameContext::Cursor_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::NameContext* PostgreSQLParser::Cursor_nameContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}


size_t PostgreSQLParser::Cursor_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCursor_name;
}


std::any PostgreSQLParser::Cursor_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCursor_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Cursor_nameContext* PostgreSQLParser::cursor_name() {
  Cursor_nameContext *_localctx = _tracker.createInstance<Cursor_nameContext>(_ctx, getState());
  enterRule(_localctx, 960, PostgreSQLParser::RuleCursor_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8139);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cursor_optionsContext ------------------------------------------------------------------

PostgreSQLParser::Cursor_optionsContext::Cursor_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Cursor_optionsContext::NO() {
  return getTokens(PostgreSQLParser::NO);
}

tree::TerminalNode* PostgreSQLParser::Cursor_optionsContext::NO(size_t i) {
  return getToken(PostgreSQLParser::NO, i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Cursor_optionsContext::SCROLL() {
  return getTokens(PostgreSQLParser::SCROLL);
}

tree::TerminalNode* PostgreSQLParser::Cursor_optionsContext::SCROLL(size_t i) {
  return getToken(PostgreSQLParser::SCROLL, i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Cursor_optionsContext::BINARY() {
  return getTokens(PostgreSQLParser::BINARY);
}

tree::TerminalNode* PostgreSQLParser::Cursor_optionsContext::BINARY(size_t i) {
  return getToken(PostgreSQLParser::BINARY, i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Cursor_optionsContext::INSENSITIVE() {
  return getTokens(PostgreSQLParser::INSENSITIVE);
}

tree::TerminalNode* PostgreSQLParser::Cursor_optionsContext::INSENSITIVE(size_t i) {
  return getToken(PostgreSQLParser::INSENSITIVE, i);
}


size_t PostgreSQLParser::Cursor_optionsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCursor_options;
}


std::any PostgreSQLParser::Cursor_optionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCursor_options(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Cursor_optionsContext* PostgreSQLParser::cursor_options() {
  Cursor_optionsContext *_localctx = _tracker.createInstance<Cursor_optionsContext>(_ctx, getState());
  enterRule(_localctx, 962, PostgreSQLParser::RuleCursor_options);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8148);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::BINARY || _la == PostgreSQLParser::INSENSITIVE

    || _la == PostgreSQLParser::NO || _la == PostgreSQLParser::SCROLL) {
      setState(8146);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case PostgreSQLParser::NO: {
          setState(8141);
          match(PostgreSQLParser::NO);
          setState(8142);
          match(PostgreSQLParser::SCROLL);
          break;
        }

        case PostgreSQLParser::SCROLL: {
          setState(8143);
          match(PostgreSQLParser::SCROLL);
          break;
        }

        case PostgreSQLParser::BINARY: {
          setState(8144);
          match(PostgreSQLParser::BINARY);
          break;
        }

        case PostgreSQLParser::INSENSITIVE: {
          setState(8145);
          match(PostgreSQLParser::INSENSITIVE);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(8150);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hold_Context ------------------------------------------------------------------

PostgreSQLParser::Hold_Context::Hold_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Hold_Context::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

tree::TerminalNode* PostgreSQLParser::Hold_Context::HOLD() {
  return getToken(PostgreSQLParser::HOLD, 0);
}

tree::TerminalNode* PostgreSQLParser::Hold_Context::WITHOUT() {
  return getToken(PostgreSQLParser::WITHOUT, 0);
}


size_t PostgreSQLParser::Hold_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleHold_;
}


std::any PostgreSQLParser::Hold_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitHold_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Hold_Context* PostgreSQLParser::hold_() {
  Hold_Context *_localctx = _tracker.createInstance<Hold_Context>(_ctx, getState());
  enterRule(_localctx, 964, PostgreSQLParser::RuleHold_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8155);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::WITH: {
        enterOuterAlt(_localctx, 1);
        setState(8151);
        match(PostgreSQLParser::WITH);
        setState(8152);
        match(PostgreSQLParser::HOLD);
        break;
      }

      case PostgreSQLParser::WITHOUT: {
        enterOuterAlt(_localctx, 2);
        setState(8153);
        match(PostgreSQLParser::WITHOUT);
        setState(8154);
        match(PostgreSQLParser::HOLD);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectstmtContext ------------------------------------------------------------------

PostgreSQLParser::SelectstmtContext::SelectstmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Select_no_parensContext* PostgreSQLParser::SelectstmtContext::select_no_parens() {
  return getRuleContext<PostgreSQLParser::Select_no_parensContext>(0);
}

PostgreSQLParser::Select_with_parensContext* PostgreSQLParser::SelectstmtContext::select_with_parens() {
  return getRuleContext<PostgreSQLParser::Select_with_parensContext>(0);
}


size_t PostgreSQLParser::SelectstmtContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSelectstmt;
}


std::any PostgreSQLParser::SelectstmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSelectstmt(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::SelectstmtContext* PostgreSQLParser::selectstmt() {
  SelectstmtContext *_localctx = _tracker.createInstance<SelectstmtContext>(_ctx, getState());
  enterRule(_localctx, 966, PostgreSQLParser::RuleSelectstmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8159);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 720, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8157);
      select_no_parens();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8158);
      select_with_parens();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_with_parensContext ------------------------------------------------------------------

PostgreSQLParser::Select_with_parensContext::Select_with_parensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Select_with_parensContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Select_no_parensContext* PostgreSQLParser::Select_with_parensContext::select_no_parens() {
  return getRuleContext<PostgreSQLParser::Select_no_parensContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Select_with_parensContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::Select_with_parensContext* PostgreSQLParser::Select_with_parensContext::select_with_parens() {
  return getRuleContext<PostgreSQLParser::Select_with_parensContext>(0);
}


size_t PostgreSQLParser::Select_with_parensContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSelect_with_parens;
}


std::any PostgreSQLParser::Select_with_parensContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSelect_with_parens(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Select_with_parensContext* PostgreSQLParser::select_with_parens() {
  Select_with_parensContext *_localctx = _tracker.createInstance<Select_with_parensContext>(_ctx, getState());
  enterRule(_localctx, 968, PostgreSQLParser::RuleSelect_with_parens);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8169);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 721, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8161);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(8162);
      select_no_parens();
      setState(8163);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8165);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(8166);
      select_with_parens();
      setState(8167);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_no_parensContext ------------------------------------------------------------------

PostgreSQLParser::Select_no_parensContext::Select_no_parensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Select_clauseContext* PostgreSQLParser::Select_no_parensContext::select_clause() {
  return getRuleContext<PostgreSQLParser::Select_clauseContext>(0);
}

PostgreSQLParser::Sort_clause_Context* PostgreSQLParser::Select_no_parensContext::sort_clause_() {
  return getRuleContext<PostgreSQLParser::Sort_clause_Context>(0);
}

PostgreSQLParser::For_locking_clauseContext* PostgreSQLParser::Select_no_parensContext::for_locking_clause() {
  return getRuleContext<PostgreSQLParser::For_locking_clauseContext>(0);
}

PostgreSQLParser::Select_limitContext* PostgreSQLParser::Select_no_parensContext::select_limit() {
  return getRuleContext<PostgreSQLParser::Select_limitContext>(0);
}

PostgreSQLParser::Select_limit_Context* PostgreSQLParser::Select_no_parensContext::select_limit_() {
  return getRuleContext<PostgreSQLParser::Select_limit_Context>(0);
}

PostgreSQLParser::For_locking_clause_Context* PostgreSQLParser::Select_no_parensContext::for_locking_clause_() {
  return getRuleContext<PostgreSQLParser::For_locking_clause_Context>(0);
}

PostgreSQLParser::With_clauseContext* PostgreSQLParser::Select_no_parensContext::with_clause() {
  return getRuleContext<PostgreSQLParser::With_clauseContext>(0);
}


size_t PostgreSQLParser::Select_no_parensContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSelect_no_parens;
}


std::any PostgreSQLParser::Select_no_parensContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSelect_no_parens(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Select_no_parensContext* PostgreSQLParser::select_no_parens() {
  Select_no_parensContext *_localctx = _tracker.createInstance<Select_no_parensContext>(_ctx, getState());
  enterRule(_localctx, 970, PostgreSQLParser::RuleSelect_no_parens);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8200);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::OPEN_PAREN:
      case PostgreSQLParser::SELECT:
      case PostgreSQLParser::TABLE:
      case PostgreSQLParser::VALUES: {
        enterOuterAlt(_localctx, 1);
        setState(8171);
        select_clause();
        setState(8173);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::ORDER) {
          setState(8172);
          sort_clause_();
        }
        setState(8183);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case PostgreSQLParser::FOR: {
            setState(8175);
            for_locking_clause();
            setState(8177);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (((((_la - 99) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 99)) & 270337) != 0)) {
              setState(8176);
              select_limit_();
            }
            break;
          }

          case PostgreSQLParser::FETCH:
          case PostgreSQLParser::LIMIT:
          case PostgreSQLParser::OFFSET: {
            setState(8179);
            select_limit();
            setState(8181);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::FOR) {
              setState(8180);
              for_locking_clause_();
            }
            break;
          }

          case PostgreSQLParser::EOF:
          case PostgreSQLParser::CLOSE_PAREN:
          case PostgreSQLParser::SEMI:
          case PostgreSQLParser::FORMAT_LA:
          case PostgreSQLParser::CREATE:
          case PostgreSQLParser::GRANT:
          case PostgreSQLParser::ON:
          case PostgreSQLParser::RETURNING:
          case PostgreSQLParser::WITH: {
            break;
          }

        default:
          break;
        }
        break;
      }

      case PostgreSQLParser::WITH: {
        enterOuterAlt(_localctx, 2);
        setState(8185);
        with_clause();
        setState(8186);
        select_clause();
        setState(8188);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::ORDER) {
          setState(8187);
          sort_clause_();
        }
        setState(8198);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case PostgreSQLParser::FOR: {
            setState(8190);
            for_locking_clause();
            setState(8192);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (((((_la - 99) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 99)) & 270337) != 0)) {
              setState(8191);
              select_limit_();
            }
            break;
          }

          case PostgreSQLParser::FETCH:
          case PostgreSQLParser::LIMIT:
          case PostgreSQLParser::OFFSET: {
            setState(8194);
            select_limit();
            setState(8196);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::FOR) {
              setState(8195);
              for_locking_clause_();
            }
            break;
          }

          case PostgreSQLParser::EOF:
          case PostgreSQLParser::CLOSE_PAREN:
          case PostgreSQLParser::SEMI:
          case PostgreSQLParser::FORMAT_LA:
          case PostgreSQLParser::CREATE:
          case PostgreSQLParser::GRANT:
          case PostgreSQLParser::ON:
          case PostgreSQLParser::RETURNING:
          case PostgreSQLParser::WITH: {
            break;
          }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Select_clauseContext::Select_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Simple_select_intersectContext *> PostgreSQLParser::Select_clauseContext::simple_select_intersect() {
  return getRuleContexts<PostgreSQLParser::Simple_select_intersectContext>();
}

PostgreSQLParser::Simple_select_intersectContext* PostgreSQLParser::Select_clauseContext::simple_select_intersect(size_t i) {
  return getRuleContext<PostgreSQLParser::Simple_select_intersectContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Select_clauseContext::UNION() {
  return getTokens(PostgreSQLParser::UNION);
}

tree::TerminalNode* PostgreSQLParser::Select_clauseContext::UNION(size_t i) {
  return getToken(PostgreSQLParser::UNION, i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Select_clauseContext::EXCEPT() {
  return getTokens(PostgreSQLParser::EXCEPT);
}

tree::TerminalNode* PostgreSQLParser::Select_clauseContext::EXCEPT(size_t i) {
  return getToken(PostgreSQLParser::EXCEPT, i);
}

std::vector<PostgreSQLParser::All_or_distinctContext *> PostgreSQLParser::Select_clauseContext::all_or_distinct() {
  return getRuleContexts<PostgreSQLParser::All_or_distinctContext>();
}

PostgreSQLParser::All_or_distinctContext* PostgreSQLParser::Select_clauseContext::all_or_distinct(size_t i) {
  return getRuleContext<PostgreSQLParser::All_or_distinctContext>(i);
}


size_t PostgreSQLParser::Select_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSelect_clause;
}


std::any PostgreSQLParser::Select_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSelect_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Select_clauseContext* PostgreSQLParser::select_clause() {
  Select_clauseContext *_localctx = _tracker.createInstance<Select_clauseContext>(_ctx, getState());
  enterRule(_localctx, 972, PostgreSQLParser::RuleSelect_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8202);
    simple_select_intersect();
    setState(8210);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::EXCEPT

    || _la == PostgreSQLParser::UNION) {
      setState(8203);
      _la = _input->LA(1);
      if (!(_la == PostgreSQLParser::EXCEPT

      || _la == PostgreSQLParser::UNION)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(8205);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::ALL

      || _la == PostgreSQLParser::DISTINCT) {
        setState(8204);
        all_or_distinct();
      }
      setState(8207);
      simple_select_intersect();
      setState(8212);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_select_intersectContext ------------------------------------------------------------------

PostgreSQLParser::Simple_select_intersectContext::Simple_select_intersectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Simple_select_pramaryContext *> PostgreSQLParser::Simple_select_intersectContext::simple_select_pramary() {
  return getRuleContexts<PostgreSQLParser::Simple_select_pramaryContext>();
}

PostgreSQLParser::Simple_select_pramaryContext* PostgreSQLParser::Simple_select_intersectContext::simple_select_pramary(size_t i) {
  return getRuleContext<PostgreSQLParser::Simple_select_pramaryContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Simple_select_intersectContext::INTERSECT() {
  return getTokens(PostgreSQLParser::INTERSECT);
}

tree::TerminalNode* PostgreSQLParser::Simple_select_intersectContext::INTERSECT(size_t i) {
  return getToken(PostgreSQLParser::INTERSECT, i);
}

std::vector<PostgreSQLParser::All_or_distinctContext *> PostgreSQLParser::Simple_select_intersectContext::all_or_distinct() {
  return getRuleContexts<PostgreSQLParser::All_or_distinctContext>();
}

PostgreSQLParser::All_or_distinctContext* PostgreSQLParser::Simple_select_intersectContext::all_or_distinct(size_t i) {
  return getRuleContext<PostgreSQLParser::All_or_distinctContext>(i);
}


size_t PostgreSQLParser::Simple_select_intersectContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSimple_select_intersect;
}


std::any PostgreSQLParser::Simple_select_intersectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSimple_select_intersect(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Simple_select_intersectContext* PostgreSQLParser::simple_select_intersect() {
  Simple_select_intersectContext *_localctx = _tracker.createInstance<Simple_select_intersectContext>(_ctx, getState());
  enterRule(_localctx, 974, PostgreSQLParser::RuleSimple_select_intersect);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8213);
    simple_select_pramary();
    setState(8221);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::INTERSECT) {
      setState(8214);
      match(PostgreSQLParser::INTERSECT);
      setState(8216);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::ALL

      || _la == PostgreSQLParser::DISTINCT) {
        setState(8215);
        all_or_distinct();
      }
      setState(8218);
      simple_select_pramary();
      setState(8223);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_select_pramaryContext ------------------------------------------------------------------

PostgreSQLParser::Simple_select_pramaryContext::Simple_select_pramaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Simple_select_pramaryContext::SELECT() {
  return getToken(PostgreSQLParser::SELECT, 0);
}

PostgreSQLParser::Distinct_clauseContext* PostgreSQLParser::Simple_select_pramaryContext::distinct_clause() {
  return getRuleContext<PostgreSQLParser::Distinct_clauseContext>(0);
}

PostgreSQLParser::Target_listContext* PostgreSQLParser::Simple_select_pramaryContext::target_list() {
  return getRuleContext<PostgreSQLParser::Target_listContext>(0);
}

PostgreSQLParser::All_clause_Context* PostgreSQLParser::Simple_select_pramaryContext::all_clause_() {
  return getRuleContext<PostgreSQLParser::All_clause_Context>(0);
}

PostgreSQLParser::Target_list_Context* PostgreSQLParser::Simple_select_pramaryContext::target_list_() {
  return getRuleContext<PostgreSQLParser::Target_list_Context>(0);
}

PostgreSQLParser::Into_clauseContext* PostgreSQLParser::Simple_select_pramaryContext::into_clause() {
  return getRuleContext<PostgreSQLParser::Into_clauseContext>(0);
}

PostgreSQLParser::From_clauseContext* PostgreSQLParser::Simple_select_pramaryContext::from_clause() {
  return getRuleContext<PostgreSQLParser::From_clauseContext>(0);
}

PostgreSQLParser::Where_clauseContext* PostgreSQLParser::Simple_select_pramaryContext::where_clause() {
  return getRuleContext<PostgreSQLParser::Where_clauseContext>(0);
}

PostgreSQLParser::Group_clauseContext* PostgreSQLParser::Simple_select_pramaryContext::group_clause() {
  return getRuleContext<PostgreSQLParser::Group_clauseContext>(0);
}

PostgreSQLParser::Having_clauseContext* PostgreSQLParser::Simple_select_pramaryContext::having_clause() {
  return getRuleContext<PostgreSQLParser::Having_clauseContext>(0);
}

PostgreSQLParser::Window_clauseContext* PostgreSQLParser::Simple_select_pramaryContext::window_clause() {
  return getRuleContext<PostgreSQLParser::Window_clauseContext>(0);
}

PostgreSQLParser::Values_clauseContext* PostgreSQLParser::Simple_select_pramaryContext::values_clause() {
  return getRuleContext<PostgreSQLParser::Values_clauseContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Simple_select_pramaryContext::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}

PostgreSQLParser::Relation_exprContext* PostgreSQLParser::Simple_select_pramaryContext::relation_expr() {
  return getRuleContext<PostgreSQLParser::Relation_exprContext>(0);
}

PostgreSQLParser::Select_with_parensContext* PostgreSQLParser::Simple_select_pramaryContext::select_with_parens() {
  return getRuleContext<PostgreSQLParser::Select_with_parensContext>(0);
}


size_t PostgreSQLParser::Simple_select_pramaryContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSimple_select_pramary;
}


std::any PostgreSQLParser::Simple_select_pramaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSimple_select_pramary(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Simple_select_pramaryContext* PostgreSQLParser::simple_select_pramary() {
  Simple_select_pramaryContext *_localctx = _tracker.createInstance<Simple_select_pramaryContext>(_ctx, getState());
  enterRule(_localctx, 976, PostgreSQLParser::RuleSimple_select_pramary);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8275);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::SELECT: {
        enterOuterAlt(_localctx, 1);
        setState(8224);
        match(PostgreSQLParser::SELECT);
        setState(8269);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case PostgreSQLParser::EOF:
          case PostgreSQLParser::OPEN_PAREN:
          case PostgreSQLParser::CLOSE_PAREN:
          case PostgreSQLParser::SEMI:
          case PostgreSQLParser::STAR:
          case PostgreSQLParser::PLUS:
          case PostgreSQLParser::MINUS:
          case PostgreSQLParser::PARAM:
          case PostgreSQLParser::Operator:
          case PostgreSQLParser::JSON:
          case PostgreSQLParser::JSON_ARRAY:
          case PostgreSQLParser::JSON_ARRAYAGG:
          case PostgreSQLParser::JSON_EXISTS:
          case PostgreSQLParser::JSON_OBJECT:
          case PostgreSQLParser::JSON_OBJECTAGG:
          case PostgreSQLParser::JSON_QUERY:
          case PostgreSQLParser::JSON_SCALAR:
          case PostgreSQLParser::JSON_SERIALIZE:
          case PostgreSQLParser::JSON_TABLE:
          case PostgreSQLParser::JSON_VALUE:
          case PostgreSQLParser::MERGE_ACTION:
          case PostgreSQLParser::SYSTEM_USER:
          case PostgreSQLParser::ABSENT:
          case PostgreSQLParser::ASENSITIVE:
          case PostgreSQLParser::ATOMIC:
          case PostgreSQLParser::BREADTH:
          case PostgreSQLParser::COMPRESSION:
          case PostgreSQLParser::CONDITIONAL:
          case PostgreSQLParser::DEPTH:
          case PostgreSQLParser::EMPTY_P:
          case PostgreSQLParser::FINALIZE:
          case PostgreSQLParser::INDENT:
          case PostgreSQLParser::KEEP:
          case PostgreSQLParser::KEYS:
          case PostgreSQLParser::NESTED:
          case PostgreSQLParser::OMIT:
          case PostgreSQLParser::PARAMETER:
          case PostgreSQLParser::PATH:
          case PostgreSQLParser::PLAN:
          case PostgreSQLParser::QUOTES:
          case PostgreSQLParser::SCALAR:
          case PostgreSQLParser::SOURCE:
          case PostgreSQLParser::STRING_P:
          case PostgreSQLParser::TARGET:
          case PostgreSQLParser::UNCONDITIONAL:
          case PostgreSQLParser::PERIOD:
          case PostgreSQLParser::FORMAT_LA:
          case PostgreSQLParser::ALL:
          case PostgreSQLParser::ARRAY:
          case PostgreSQLParser::CASE:
          case PostgreSQLParser::CAST:
          case PostgreSQLParser::CREATE:
          case PostgreSQLParser::CURRENT_CATALOG:
          case PostgreSQLParser::CURRENT_DATE:
          case PostgreSQLParser::CURRENT_ROLE:
          case PostgreSQLParser::CURRENT_TIME:
          case PostgreSQLParser::CURRENT_TIMESTAMP:
          case PostgreSQLParser::CURRENT_USER:
          case PostgreSQLParser::DEFAULT:
          case PostgreSQLParser::EXCEPT:
          case PostgreSQLParser::FALSE_P:
          case PostgreSQLParser::FETCH:
          case PostgreSQLParser::FOR:
          case PostgreSQLParser::FROM:
          case PostgreSQLParser::GRANT:
          case PostgreSQLParser::GROUP_P:
          case PostgreSQLParser::HAVING:
          case PostgreSQLParser::INTERSECT:
          case PostgreSQLParser::INTO:
          case PostgreSQLParser::LIMIT:
          case PostgreSQLParser::LOCALTIME:
          case PostgreSQLParser::LOCALTIMESTAMP:
          case PostgreSQLParser::NOT:
          case PostgreSQLParser::NULL_P:
          case PostgreSQLParser::OFFSET:
          case PostgreSQLParser::ON:
          case PostgreSQLParser::ORDER:
          case PostgreSQLParser::RETURNING:
          case PostgreSQLParser::SESSION_USER:
          case PostgreSQLParser::TRUE_P:
          case PostgreSQLParser::UNION:
          case PostgreSQLParser::UNIQUE:
          case PostgreSQLParser::USER:
          case PostgreSQLParser::WHERE:
          case PostgreSQLParser::WINDOW:
          case PostgreSQLParser::WITH:
          case PostgreSQLParser::AUTHORIZATION:
          case PostgreSQLParser::BINARY:
          case PostgreSQLParser::COLLATION:
          case PostgreSQLParser::CONCURRENTLY:
          case PostgreSQLParser::CROSS:
          case PostgreSQLParser::CURRENT_SCHEMA:
          case PostgreSQLParser::FREEZE:
          case PostgreSQLParser::FULL:
          case PostgreSQLParser::ILIKE:
          case PostgreSQLParser::INNER_P:
          case PostgreSQLParser::IS:
          case PostgreSQLParser::ISNULL:
          case PostgreSQLParser::JOIN:
          case PostgreSQLParser::LEFT:
          case PostgreSQLParser::LIKE:
          case PostgreSQLParser::NATURAL:
          case PostgreSQLParser::NOTNULL:
          case PostgreSQLParser::OUTER_P:
          case PostgreSQLParser::OVER:
          case PostgreSQLParser::OVERLAPS:
          case PostgreSQLParser::RIGHT:
          case PostgreSQLParser::SIMILAR:
          case PostgreSQLParser::VERBOSE:
          case PostgreSQLParser::ABORT_P:
          case PostgreSQLParser::ABSOLUTE_P:
          case PostgreSQLParser::ACCESS:
          case PostgreSQLParser::ACTION:
          case PostgreSQLParser::ADD_P:
          case PostgreSQLParser::ADMIN:
          case PostgreSQLParser::AFTER:
          case PostgreSQLParser::AGGREGATE:
          case PostgreSQLParser::ALSO:
          case PostgreSQLParser::ALTER:
          case PostgreSQLParser::ALWAYS:
          case PostgreSQLParser::ASSERTION:
          case PostgreSQLParser::ASSIGNMENT:
          case PostgreSQLParser::AT:
          case PostgreSQLParser::ATTRIBUTE:
          case PostgreSQLParser::BACKWARD:
          case PostgreSQLParser::BEFORE:
          case PostgreSQLParser::BEGIN_P:
          case PostgreSQLParser::BY:
          case PostgreSQLParser::CACHE:
          case PostgreSQLParser::CALLED:
          case PostgreSQLParser::CASCADE:
          case PostgreSQLParser::CASCADED:
          case PostgreSQLParser::CATALOG:
          case PostgreSQLParser::CHAIN:
          case PostgreSQLParser::CHARACTERISTICS:
          case PostgreSQLParser::CHECKPOINT:
          case PostgreSQLParser::CLASS:
          case PostgreSQLParser::CLOSE:
          case PostgreSQLParser::CLUSTER:
          case PostgreSQLParser::COMMENT:
          case PostgreSQLParser::COMMENTS:
          case PostgreSQLParser::COMMIT:
          case PostgreSQLParser::COMMITTED:
          case PostgreSQLParser::CONFIGURATION:
          case PostgreSQLParser::CONNECTION:
          case PostgreSQLParser::CONSTRAINTS:
          case PostgreSQLParser::CONTENT_P:
          case PostgreSQLParser::CONTINUE_P:
          case PostgreSQLParser::CONVERSION_P:
          case PostgreSQLParser::COPY:
          case PostgreSQLParser::COST:
          case PostgreSQLParser::CSV:
          case PostgreSQLParser::CURSOR:
          case PostgreSQLParser::CYCLE:
          case PostgreSQLParser::DATA_P:
          case PostgreSQLParser::DATABASE:
          case PostgreSQLParser::DAY_P:
          case PostgreSQLParser::DEALLOCATE:
          case PostgreSQLParser::DECLARE:
          case PostgreSQLParser::DEFAULTS:
          case PostgreSQLParser::DEFERRED:
          case PostgreSQLParser::DEFINER:
          case PostgreSQLParser::DELETE_P:
          case PostgreSQLParser::DELIMITER:
          case PostgreSQLParser::DELIMITERS:
          case PostgreSQLParser::DICTIONARY:
          case PostgreSQLParser::DISABLE_P:
          case PostgreSQLParser::DISCARD:
          case PostgreSQLParser::DOCUMENT_P:
          case PostgreSQLParser::DOMAIN_P:
          case PostgreSQLParser::DOUBLE_P:
          case PostgreSQLParser::DROP:
          case PostgreSQLParser::EACH:
          case PostgreSQLParser::ENABLE_P:
          case PostgreSQLParser::ENCODING:
          case PostgreSQLParser::ENCRYPTED:
          case PostgreSQLParser::ENUM_P:
          case PostgreSQLParser::ESCAPE:
          case PostgreSQLParser::EVENT:
          case PostgreSQLParser::EXCLUDE:
          case PostgreSQLParser::EXCLUDING:
          case PostgreSQLParser::EXCLUSIVE:
          case PostgreSQLParser::EXECUTE:
          case PostgreSQLParser::EXPLAIN:
          case PostgreSQLParser::EXTENSION:
          case PostgreSQLParser::EXTERNAL:
          case PostgreSQLParser::FAMILY:
          case PostgreSQLParser::FIRST_P:
          case PostgreSQLParser::FOLLOWING:
          case PostgreSQLParser::FORCE:
          case PostgreSQLParser::FORWARD:
          case PostgreSQLParser::FUNCTION:
          case PostgreSQLParser::FUNCTIONS:
          case PostgreSQLParser::GLOBAL:
          case PostgreSQLParser::GRANTED:
          case PostgreSQLParser::HANDLER:
          case PostgreSQLParser::HEADER_P:
          case PostgreSQLParser::HOLD:
          case PostgreSQLParser::HOUR_P:
          case PostgreSQLParser::IDENTITY_P:
          case PostgreSQLParser::IF_P:
          case PostgreSQLParser::IMMEDIATE:
          case PostgreSQLParser::IMMUTABLE:
          case PostgreSQLParser::IMPLICIT_P:
          case PostgreSQLParser::INCLUDING:
          case PostgreSQLParser::INCREMENT:
          case PostgreSQLParser::INDEX:
          case PostgreSQLParser::INDEXES:
          case PostgreSQLParser::INHERIT:
          case PostgreSQLParser::INHERITS:
          case PostgreSQLParser::INLINE_P:
          case PostgreSQLParser::INSENSITIVE:
          case PostgreSQLParser::INSERT:
          case PostgreSQLParser::INSTEAD:
          case PostgreSQLParser::INVOKER:
          case PostgreSQLParser::ISOLATION:
          case PostgreSQLParser::KEY:
          case PostgreSQLParser::LABEL:
          case PostgreSQLParser::LANGUAGE:
          case PostgreSQLParser::LARGE_P:
          case PostgreSQLParser::LAST_P:
          case PostgreSQLParser::LEAKPROOF:
          case PostgreSQLParser::LEVEL:
          case PostgreSQLParser::LISTEN:
          case PostgreSQLParser::LOAD:
          case PostgreSQLParser::LOCAL:
          case PostgreSQLParser::LOCATION:
          case PostgreSQLParser::LOCK_P:
          case PostgreSQLParser::MAPPING:
          case PostgreSQLParser::MATCH:
          case PostgreSQLParser::MATCHED:
          case PostgreSQLParser::MATERIALIZED:
          case PostgreSQLParser::MAXVALUE:
          case PostgreSQLParser::MERGE:
          case PostgreSQLParser::MINUTE_P:
          case PostgreSQLParser::MINVALUE:
          case PostgreSQLParser::MODE:
          case PostgreSQLParser::MONTH_P:
          case PostgreSQLParser::MOVE:
          case PostgreSQLParser::NAME_P:
          case PostgreSQLParser::NAMES:
          case PostgreSQLParser::NEXT:
          case PostgreSQLParser::NO:
          case PostgreSQLParser::NOTHING:
          case PostgreSQLParser::NOTIFY:
          case PostgreSQLParser::NOWAIT:
          case PostgreSQLParser::NULLS_P:
          case PostgreSQLParser::OBJECT_P:
          case PostgreSQLParser::OF:
          case PostgreSQLParser::OFF:
          case PostgreSQLParser::OIDS:
          case PostgreSQLParser::OPERATOR:
          case PostgreSQLParser::OPTION:
          case PostgreSQLParser::OPTIONS:
          case PostgreSQLParser::OWNED:
          case PostgreSQLParser::OWNER:
          case PostgreSQLParser::PARSER:
          case PostgreSQLParser::PARTIAL:
          case PostgreSQLParser::PARTITION:
          case PostgreSQLParser::PASSING:
          case PostgreSQLParser::PASSWORD:
          case PostgreSQLParser::PLANS:
          case PostgreSQLParser::PRECEDING:
          case PostgreSQLParser::PREPARE:
          case PostgreSQLParser::PREPARED:
          case PostgreSQLParser::PRESERVE:
          case PostgreSQLParser::PRIOR:
          case PostgreSQLParser::PRIVILEGES:
          case PostgreSQLParser::PROCEDURAL:
          case PostgreSQLParser::PROCEDURE:
          case PostgreSQLParser::PROGRAM:
          case PostgreSQLParser::QUOTE:
          case PostgreSQLParser::RANGE:
          case PostgreSQLParser::READ:
          case PostgreSQLParser::REASSIGN:
          case PostgreSQLParser::RECURSIVE:
          case PostgreSQLParser::REF:
          case PostgreSQLParser::REFRESH:
          case PostgreSQLParser::REINDEX:
          case PostgreSQLParser::RELATIVE_P:
          case PostgreSQLParser::RELEASE:
          case PostgreSQLParser::RENAME:
          case PostgreSQLParser::REPEATABLE:
          case PostgreSQLParser::REPLACE:
          case PostgreSQLParser::REPLICA:
          case PostgreSQLParser::RESET:
          case PostgreSQLParser::RESTART:
          case PostgreSQLParser::RESTRICT:
          case PostgreSQLParser::RETURNS:
          case PostgreSQLParser::REVOKE:
          case PostgreSQLParser::ROLE:
          case PostgreSQLParser::ROLLBACK:
          case PostgreSQLParser::ROWS:
          case PostgreSQLParser::RULE:
          case PostgreSQLParser::SAVEPOINT:
          case PostgreSQLParser::SCHEMA:
          case PostgreSQLParser::SCROLL:
          case PostgreSQLParser::SEARCH:
          case PostgreSQLParser::SECOND_P:
          case PostgreSQLParser::SECURITY:
          case PostgreSQLParser::SEQUENCE:
          case PostgreSQLParser::SEQUENCES:
          case PostgreSQLParser::SERIALIZABLE:
          case PostgreSQLParser::SERVER:
          case PostgreSQLParser::SESSION:
          case PostgreSQLParser::SET:
          case PostgreSQLParser::SHARE:
          case PostgreSQLParser::SHOW:
          case PostgreSQLParser::SIMPLE:
          case PostgreSQLParser::SNAPSHOT:
          case PostgreSQLParser::STABLE:
          case PostgreSQLParser::STANDALONE_P:
          case PostgreSQLParser::START:
          case PostgreSQLParser::STATEMENT:
          case PostgreSQLParser::STATISTICS:
          case PostgreSQLParser::STDIN:
          case PostgreSQLParser::STDOUT:
          case PostgreSQLParser::STORAGE:
          case PostgreSQLParser::STRICT_P:
          case PostgreSQLParser::STRIP_P:
          case PostgreSQLParser::SYSID:
          case PostgreSQLParser::SYSTEM_P:
          case PostgreSQLParser::TABLES:
          case PostgreSQLParser::TABLESPACE:
          case PostgreSQLParser::TEMP:
          case PostgreSQLParser::TEMPLATE:
          case PostgreSQLParser::TEMPORARY:
          case PostgreSQLParser::TEXT_P:
          case PostgreSQLParser::TRANSACTION:
          case PostgreSQLParser::TRIGGER:
          case PostgreSQLParser::TRUNCATE:
          case PostgreSQLParser::TRUSTED:
          case PostgreSQLParser::TYPE_P:
          case PostgreSQLParser::TYPES_P:
          case PostgreSQLParser::UNBOUNDED:
          case PostgreSQLParser::UNCOMMITTED:
          case PostgreSQLParser::UNENCRYPTED:
          case PostgreSQLParser::UNKNOWN:
          case PostgreSQLParser::UNLISTEN:
          case PostgreSQLParser::UNLOGGED:
          case PostgreSQLParser::UNTIL:
          case PostgreSQLParser::UPDATE:
          case PostgreSQLParser::VACUUM:
          case PostgreSQLParser::VALID:
          case PostgreSQLParser::VALIDATE:
          case PostgreSQLParser::VALIDATOR:
          case PostgreSQLParser::VARYING:
          case PostgreSQLParser::VERSION_P:
          case PostgreSQLParser::VIEW:
          case PostgreSQLParser::VOLATILE:
          case PostgreSQLParser::WHITESPACE_P:
          case PostgreSQLParser::WITHOUT:
          case PostgreSQLParser::WORK:
          case PostgreSQLParser::WRAPPER:
          case PostgreSQLParser::WRITE:
          case PostgreSQLParser::XML_P:
          case PostgreSQLParser::YEAR_P:
          case PostgreSQLParser::YES_P:
          case PostgreSQLParser::ZONE:
          case PostgreSQLParser::BETWEEN:
          case PostgreSQLParser::BIGINT:
          case PostgreSQLParser::BIT:
          case PostgreSQLParser::BOOLEAN_P:
          case PostgreSQLParser::CHAR_P:
          case PostgreSQLParser::CHARACTER:
          case PostgreSQLParser::COALESCE:
          case PostgreSQLParser::DEC:
          case PostgreSQLParser::DECIMAL_P:
          case PostgreSQLParser::EXISTS:
          case PostgreSQLParser::EXTRACT:
          case PostgreSQLParser::FLOAT_P:
          case PostgreSQLParser::GREATEST:
          case PostgreSQLParser::INOUT:
          case PostgreSQLParser::INT_P:
          case PostgreSQLParser::INTEGER:
          case PostgreSQLParser::INTERVAL:
          case PostgreSQLParser::LEAST:
          case PostgreSQLParser::NATIONAL:
          case PostgreSQLParser::NCHAR:
          case PostgreSQLParser::NONE:
          case PostgreSQLParser::NULLIF:
          case PostgreSQLParser::NUMERIC:
          case PostgreSQLParser::OVERLAY:
          case PostgreSQLParser::POSITION:
          case PostgreSQLParser::PRECISION:
          case PostgreSQLParser::REAL:
          case PostgreSQLParser::ROW:
          case PostgreSQLParser::SETOF:
          case PostgreSQLParser::SMALLINT:
          case PostgreSQLParser::SUBSTRING:
          case PostgreSQLParser::TIME:
          case PostgreSQLParser::TIMESTAMP:
          case PostgreSQLParser::TREAT:
          case PostgreSQLParser::TRIM:
          case PostgreSQLParser::VALUES:
          case PostgreSQLParser::VARCHAR:
          case PostgreSQLParser::XMLATTRIBUTES:
          case PostgreSQLParser::XMLCONCAT:
          case PostgreSQLParser::XMLELEMENT:
          case PostgreSQLParser::XMLEXISTS:
          case PostgreSQLParser::XMLFOREST:
          case PostgreSQLParser::XMLPARSE:
          case PostgreSQLParser::XMLPI:
          case PostgreSQLParser::XMLROOT:
          case PostgreSQLParser::XMLSERIALIZE:
          case PostgreSQLParser::CALL:
          case PostgreSQLParser::CURRENT_P:
          case PostgreSQLParser::ATTACH:
          case PostgreSQLParser::DETACH:
          case PostgreSQLParser::EXPRESSION:
          case PostgreSQLParser::GENERATED:
          case PostgreSQLParser::LOGGED:
          case PostgreSQLParser::STORED:
          case PostgreSQLParser::INCLUDE:
          case PostgreSQLParser::ROUTINE:
          case PostgreSQLParser::TRANSFORM:
          case PostgreSQLParser::IMPORT_P:
          case PostgreSQLParser::POLICY:
          case PostgreSQLParser::METHOD:
          case PostgreSQLParser::REFERENCING:
          case PostgreSQLParser::NEW:
          case PostgreSQLParser::OLD:
          case PostgreSQLParser::VALUE_P:
          case PostgreSQLParser::SUBSCRIPTION:
          case PostgreSQLParser::PUBLICATION:
          case PostgreSQLParser::OUT_P:
          case PostgreSQLParser::ROUTINES:
          case PostgreSQLParser::SCHEMAS:
          case PostgreSQLParser::PROCEDURES:
          case PostgreSQLParser::INPUT_P:
          case PostgreSQLParser::SUPPORT:
          case PostgreSQLParser::PARALLEL:
          case PostgreSQLParser::SQL_P:
          case PostgreSQLParser::DEPENDS:
          case PostgreSQLParser::OVERRIDING:
          case PostgreSQLParser::CONFLICT:
          case PostgreSQLParser::SKIP_P:
          case PostgreSQLParser::LOCKED:
          case PostgreSQLParser::TIES:
          case PostgreSQLParser::ROLLUP:
          case PostgreSQLParser::CUBE:
          case PostgreSQLParser::GROUPING:
          case PostgreSQLParser::SETS:
          case PostgreSQLParser::TABLESAMPLE:
          case PostgreSQLParser::ORDINALITY:
          case PostgreSQLParser::XMLTABLE:
          case PostgreSQLParser::COLUMNS:
          case PostgreSQLParser::XMLNAMESPACES:
          case PostgreSQLParser::NORMALIZED:
          case PostgreSQLParser::WITHIN:
          case PostgreSQLParser::FILTER:
          case PostgreSQLParser::GROUPS:
          case PostgreSQLParser::OTHERS:
          case PostgreSQLParser::NFC:
          case PostgreSQLParser::NFD:
          case PostgreSQLParser::NFKC:
          case PostgreSQLParser::NFKD:
          case PostgreSQLParser::UESCAPE:
          case PostgreSQLParser::VIEWS:
          case PostgreSQLParser::NORMALIZE:
          case PostgreSQLParser::ERROR:
          case PostgreSQLParser::RETURN:
          case PostgreSQLParser::FORMAT:
          case PostgreSQLParser::Identifier:
          case PostgreSQLParser::QuotedIdentifier:
          case PostgreSQLParser::UnicodeQuotedIdentifier:
          case PostgreSQLParser::StringConstant:
          case PostgreSQLParser::UnicodeEscapeStringConstant:
          case PostgreSQLParser::BeginDollarStringConstant:
          case PostgreSQLParser::BinaryStringConstant:
          case PostgreSQLParser::HexadecimalStringConstant:
          case PostgreSQLParser::Integral:
          case PostgreSQLParser::BinaryIntegral:
          case PostgreSQLParser::OctalIntegral:
          case PostgreSQLParser::HexadecimalIntegral:
          case PostgreSQLParser::Numeric:
          case PostgreSQLParser::PLSQLVARIABLENAME:
          case PostgreSQLParser::EscapeStringConstant: {
            setState(8226);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::ALL) {
              setState(8225);
              all_clause_();
            }
            setState(8229);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if ((((_la & ~ 0x3fULL) == 0) &&
              ((1ULL << _la) & -268422652) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 64)) & -9214927770107198969) != 0) || ((((_la - 134) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 134)) & -1011) != 0) || ((((_la - 198) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 198)) & -1) != 0) || ((((_la - 262) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 262)) & -1) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 326)) & -129) != 0) || ((((_la - 390) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 390)) & -1) != 0) || ((((_la - 454) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 454)) & -2305843284091601405) != 0) || ((((_la - 518) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 518)) & -4880034784790705153) != 0) || _la == PostgreSQLParser::PLSQLVARIABLENAME

            || _la == PostgreSQLParser::EscapeStringConstant) {
              setState(8228);
              target_list_();
            }
            setState(8232);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::INTO) {
              setState(8231);
              into_clause();
            }
            setState(8235);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::FROM) {
              setState(8234);
              from_clause();
            }
            setState(8238);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::WHERE) {
              setState(8237);
              where_clause();
            }
            setState(8241);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::GROUP_P) {
              setState(8240);
              group_clause();
            }
            setState(8244);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::HAVING) {
              setState(8243);
              having_clause();
            }
            setState(8247);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::WINDOW) {
              setState(8246);
              window_clause();
            }
            break;
          }

          case PostgreSQLParser::DISTINCT: {
            setState(8249);
            distinct_clause();
            setState(8250);
            target_list();
            setState(8252);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::INTO) {
              setState(8251);
              into_clause();
            }
            setState(8255);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::FROM) {
              setState(8254);
              from_clause();
            }
            setState(8258);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::WHERE) {
              setState(8257);
              where_clause();
            }
            setState(8261);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::GROUP_P) {
              setState(8260);
              group_clause();
            }
            setState(8264);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::HAVING) {
              setState(8263);
              having_clause();
            }
            setState(8267);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == PostgreSQLParser::WINDOW) {
              setState(8266);
              window_clause();
            }
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case PostgreSQLParser::VALUES: {
        enterOuterAlt(_localctx, 2);
        setState(8271);
        values_clause();
        break;
      }

      case PostgreSQLParser::TABLE: {
        enterOuterAlt(_localctx, 3);
        setState(8272);
        match(PostgreSQLParser::TABLE);
        setState(8273);
        relation_expr();
        break;
      }

      case PostgreSQLParser::OPEN_PAREN: {
        enterOuterAlt(_localctx, 4);
        setState(8274);
        select_with_parens();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_clauseContext ------------------------------------------------------------------

PostgreSQLParser::With_clauseContext::With_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::With_clauseContext::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

PostgreSQLParser::Cte_listContext* PostgreSQLParser::With_clauseContext::cte_list() {
  return getRuleContext<PostgreSQLParser::Cte_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::With_clauseContext::RECURSIVE() {
  return getToken(PostgreSQLParser::RECURSIVE, 0);
}


size_t PostgreSQLParser::With_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleWith_clause;
}


std::any PostgreSQLParser::With_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitWith_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::With_clauseContext* PostgreSQLParser::with_clause() {
  With_clauseContext *_localctx = _tracker.createInstance<With_clauseContext>(_ctx, getState());
  enterRule(_localctx, 978, PostgreSQLParser::RuleWith_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8277);
    match(PostgreSQLParser::WITH);
    setState(8279);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 751, _ctx)) {
    case 1: {
      setState(8278);
      match(PostgreSQLParser::RECURSIVE);
      break;
    }

    default:
      break;
    }
    setState(8281);
    cte_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cte_listContext ------------------------------------------------------------------

PostgreSQLParser::Cte_listContext::Cte_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Common_table_exprContext *> PostgreSQLParser::Cte_listContext::common_table_expr() {
  return getRuleContexts<PostgreSQLParser::Common_table_exprContext>();
}

PostgreSQLParser::Common_table_exprContext* PostgreSQLParser::Cte_listContext::common_table_expr(size_t i) {
  return getRuleContext<PostgreSQLParser::Common_table_exprContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Cte_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Cte_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Cte_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCte_list;
}


std::any PostgreSQLParser::Cte_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCte_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Cte_listContext* PostgreSQLParser::cte_list() {
  Cte_listContext *_localctx = _tracker.createInstance<Cte_listContext>(_ctx, getState());
  enterRule(_localctx, 980, PostgreSQLParser::RuleCte_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8283);
    common_table_expr();
    setState(8288);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(8284);
      match(PostgreSQLParser::COMMA);
      setState(8285);
      common_table_expr();
      setState(8290);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Common_table_exprContext ------------------------------------------------------------------

PostgreSQLParser::Common_table_exprContext::Common_table_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::NameContext* PostgreSQLParser::Common_table_exprContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Common_table_exprContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

tree::TerminalNode* PostgreSQLParser::Common_table_exprContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::PreparablestmtContext* PostgreSQLParser::Common_table_exprContext::preparablestmt() {
  return getRuleContext<PostgreSQLParser::PreparablestmtContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Common_table_exprContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::Name_list_Context* PostgreSQLParser::Common_table_exprContext::name_list_() {
  return getRuleContext<PostgreSQLParser::Name_list_Context>(0);
}

PostgreSQLParser::Materialized_Context* PostgreSQLParser::Common_table_exprContext::materialized_() {
  return getRuleContext<PostgreSQLParser::Materialized_Context>(0);
}


size_t PostgreSQLParser::Common_table_exprContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCommon_table_expr;
}


std::any PostgreSQLParser::Common_table_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCommon_table_expr(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Common_table_exprContext* PostgreSQLParser::common_table_expr() {
  Common_table_exprContext *_localctx = _tracker.createInstance<Common_table_exprContext>(_ctx, getState());
  enterRule(_localctx, 982, PostgreSQLParser::RuleCommon_table_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8291);
    name();
    setState(8293);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OPEN_PAREN) {
      setState(8292);
      name_list_();
    }
    setState(8295);
    match(PostgreSQLParser::AS);
    setState(8297);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::NOT || _la == PostgreSQLParser::MATERIALIZED) {
      setState(8296);
      materialized_();
    }
    setState(8299);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(8300);
    preparablestmt();
    setState(8301);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Materialized_Context ------------------------------------------------------------------

PostgreSQLParser::Materialized_Context::Materialized_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Materialized_Context::MATERIALIZED() {
  return getToken(PostgreSQLParser::MATERIALIZED, 0);
}

tree::TerminalNode* PostgreSQLParser::Materialized_Context::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}


size_t PostgreSQLParser::Materialized_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleMaterialized_;
}


std::any PostgreSQLParser::Materialized_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitMaterialized_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Materialized_Context* PostgreSQLParser::materialized_() {
  Materialized_Context *_localctx = _tracker.createInstance<Materialized_Context>(_ctx, getState());
  enterRule(_localctx, 984, PostgreSQLParser::RuleMaterialized_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8306);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::MATERIALIZED: {
        enterOuterAlt(_localctx, 1);
        setState(8303);
        match(PostgreSQLParser::MATERIALIZED);
        break;
      }

      case PostgreSQLParser::NOT: {
        enterOuterAlt(_localctx, 2);
        setState(8304);
        match(PostgreSQLParser::NOT);
        setState(8305);
        match(PostgreSQLParser::MATERIALIZED);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_clause_Context ------------------------------------------------------------------

PostgreSQLParser::With_clause_Context::With_clause_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::With_clauseContext* PostgreSQLParser::With_clause_Context::with_clause() {
  return getRuleContext<PostgreSQLParser::With_clauseContext>(0);
}


size_t PostgreSQLParser::With_clause_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleWith_clause_;
}


std::any PostgreSQLParser::With_clause_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitWith_clause_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::With_clause_Context* PostgreSQLParser::with_clause_() {
  With_clause_Context *_localctx = _tracker.createInstance<With_clause_Context>(_ctx, getState());
  enterRule(_localctx, 986, PostgreSQLParser::RuleWith_clause_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8308);
    with_clause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Into_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Into_clauseContext::Into_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Into_clauseContext::INTO() {
  return getToken(PostgreSQLParser::INTO, 0);
}

PostgreSQLParser::OpttempTableNameContext* PostgreSQLParser::Into_clauseContext::opttempTableName() {
  return getRuleContext<PostgreSQLParser::OpttempTableNameContext>(0);
}


size_t PostgreSQLParser::Into_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleInto_clause;
}


std::any PostgreSQLParser::Into_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitInto_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Into_clauseContext* PostgreSQLParser::into_clause() {
  Into_clauseContext *_localctx = _tracker.createInstance<Into_clauseContext>(_ctx, getState());
  enterRule(_localctx, 988, PostgreSQLParser::RuleInto_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8310);
    match(PostgreSQLParser::INTO);
    setState(8311);
    opttempTableName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Strict_Context ------------------------------------------------------------------

PostgreSQLParser::Strict_Context::Strict_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Strict_Context::STRICT_P() {
  return getToken(PostgreSQLParser::STRICT_P, 0);
}


size_t PostgreSQLParser::Strict_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleStrict_;
}


std::any PostgreSQLParser::Strict_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitStrict_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Strict_Context* PostgreSQLParser::strict_() {
  Strict_Context *_localctx = _tracker.createInstance<Strict_Context>(_ctx, getState());
  enterRule(_localctx, 990, PostgreSQLParser::RuleStrict_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8313);
    match(PostgreSQLParser::STRICT_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OpttempTableNameContext ------------------------------------------------------------------

PostgreSQLParser::OpttempTableNameContext::OpttempTableNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::OpttempTableNameContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::OpttempTableNameContext::TEMPORARY() {
  return getToken(PostgreSQLParser::TEMPORARY, 0);
}

tree::TerminalNode* PostgreSQLParser::OpttempTableNameContext::TEMP() {
  return getToken(PostgreSQLParser::TEMP, 0);
}

PostgreSQLParser::Table_Context* PostgreSQLParser::OpttempTableNameContext::table_() {
  return getRuleContext<PostgreSQLParser::Table_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::OpttempTableNameContext::LOCAL() {
  return getToken(PostgreSQLParser::LOCAL, 0);
}

tree::TerminalNode* PostgreSQLParser::OpttempTableNameContext::GLOBAL() {
  return getToken(PostgreSQLParser::GLOBAL, 0);
}

tree::TerminalNode* PostgreSQLParser::OpttempTableNameContext::UNLOGGED() {
  return getToken(PostgreSQLParser::UNLOGGED, 0);
}

tree::TerminalNode* PostgreSQLParser::OpttempTableNameContext::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}


size_t PostgreSQLParser::OpttempTableNameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOpttempTableName;
}


std::any PostgreSQLParser::OpttempTableNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOpttempTableName(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::OpttempTableNameContext* PostgreSQLParser::opttempTableName() {
  OpttempTableNameContext *_localctx = _tracker.createInstance<OpttempTableNameContext>(_ctx, getState());
  enterRule(_localctx, 992, PostgreSQLParser::RuleOpttempTableName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8331);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 759, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8316);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::GLOBAL

      || _la == PostgreSQLParser::LOCAL) {
        setState(8315);
        _la = _input->LA(1);
        if (!(_la == PostgreSQLParser::GLOBAL

        || _la == PostgreSQLParser::LOCAL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(8318);
      _la = _input->LA(1);
      if (!(_la == PostgreSQLParser::TEMP

      || _la == PostgreSQLParser::TEMPORARY)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(8320);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::TABLE) {
        setState(8319);
        table_();
      }
      setState(8322);
      qualified_name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8323);
      match(PostgreSQLParser::UNLOGGED);
      setState(8325);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::TABLE) {
        setState(8324);
        table_();
      }
      setState(8327);
      qualified_name();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(8328);
      match(PostgreSQLParser::TABLE);
      setState(8329);
      qualified_name();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(8330);
      qualified_name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_Context ------------------------------------------------------------------

PostgreSQLParser::Table_Context::Table_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Table_Context::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}


size_t PostgreSQLParser::Table_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleTable_;
}


std::any PostgreSQLParser::Table_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTable_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Table_Context* PostgreSQLParser::table_() {
  Table_Context *_localctx = _tracker.createInstance<Table_Context>(_ctx, getState());
  enterRule(_localctx, 994, PostgreSQLParser::RuleTable_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8333);
    match(PostgreSQLParser::TABLE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- All_or_distinctContext ------------------------------------------------------------------

PostgreSQLParser::All_or_distinctContext::All_or_distinctContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::All_or_distinctContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}

tree::TerminalNode* PostgreSQLParser::All_or_distinctContext::DISTINCT() {
  return getToken(PostgreSQLParser::DISTINCT, 0);
}


size_t PostgreSQLParser::All_or_distinctContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAll_or_distinct;
}


std::any PostgreSQLParser::All_or_distinctContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAll_or_distinct(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::All_or_distinctContext* PostgreSQLParser::all_or_distinct() {
  All_or_distinctContext *_localctx = _tracker.createInstance<All_or_distinctContext>(_ctx, getState());
  enterRule(_localctx, 996, PostgreSQLParser::RuleAll_or_distinct);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8335);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::ALL

    || _la == PostgreSQLParser::DISTINCT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Distinct_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Distinct_clauseContext::Distinct_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Distinct_clauseContext::DISTINCT() {
  return getToken(PostgreSQLParser::DISTINCT, 0);
}

tree::TerminalNode* PostgreSQLParser::Distinct_clauseContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

tree::TerminalNode* PostgreSQLParser::Distinct_clauseContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::Distinct_clauseContext::expr_list() {
  return getRuleContext<PostgreSQLParser::Expr_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Distinct_clauseContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Distinct_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDistinct_clause;
}


std::any PostgreSQLParser::Distinct_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDistinct_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Distinct_clauseContext* PostgreSQLParser::distinct_clause() {
  Distinct_clauseContext *_localctx = _tracker.createInstance<Distinct_clauseContext>(_ctx, getState());
  enterRule(_localctx, 998, PostgreSQLParser::RuleDistinct_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8337);
    match(PostgreSQLParser::DISTINCT);
    setState(8343);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::ON) {
      setState(8338);
      match(PostgreSQLParser::ON);
      setState(8339);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(8340);
      expr_list();
      setState(8341);
      match(PostgreSQLParser::CLOSE_PAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- All_clause_Context ------------------------------------------------------------------

PostgreSQLParser::All_clause_Context::All_clause_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::All_clause_Context::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}


size_t PostgreSQLParser::All_clause_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleAll_clause_;
}


std::any PostgreSQLParser::All_clause_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAll_clause_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::All_clause_Context* PostgreSQLParser::all_clause_() {
  All_clause_Context *_localctx = _tracker.createInstance<All_clause_Context>(_ctx, getState());
  enterRule(_localctx, 1000, PostgreSQLParser::RuleAll_clause_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8345);
    match(PostgreSQLParser::ALL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sort_clause_Context ------------------------------------------------------------------

PostgreSQLParser::Sort_clause_Context::Sort_clause_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Sort_clauseContext* PostgreSQLParser::Sort_clause_Context::sort_clause() {
  return getRuleContext<PostgreSQLParser::Sort_clauseContext>(0);
}


size_t PostgreSQLParser::Sort_clause_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleSort_clause_;
}


std::any PostgreSQLParser::Sort_clause_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSort_clause_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Sort_clause_Context* PostgreSQLParser::sort_clause_() {
  Sort_clause_Context *_localctx = _tracker.createInstance<Sort_clause_Context>(_ctx, getState());
  enterRule(_localctx, 1002, PostgreSQLParser::RuleSort_clause_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8347);
    sort_clause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sort_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Sort_clauseContext::Sort_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Sort_clauseContext::ORDER() {
  return getToken(PostgreSQLParser::ORDER, 0);
}

tree::TerminalNode* PostgreSQLParser::Sort_clauseContext::BY() {
  return getToken(PostgreSQLParser::BY, 0);
}

PostgreSQLParser::Sortby_listContext* PostgreSQLParser::Sort_clauseContext::sortby_list() {
  return getRuleContext<PostgreSQLParser::Sortby_listContext>(0);
}


size_t PostgreSQLParser::Sort_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSort_clause;
}


std::any PostgreSQLParser::Sort_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSort_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Sort_clauseContext* PostgreSQLParser::sort_clause() {
  Sort_clauseContext *_localctx = _tracker.createInstance<Sort_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1004, PostgreSQLParser::RuleSort_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8349);
    match(PostgreSQLParser::ORDER);
    setState(8350);
    match(PostgreSQLParser::BY);
    setState(8351);
    sortby_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sortby_listContext ------------------------------------------------------------------

PostgreSQLParser::Sortby_listContext::Sortby_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::SortbyContext *> PostgreSQLParser::Sortby_listContext::sortby() {
  return getRuleContexts<PostgreSQLParser::SortbyContext>();
}

PostgreSQLParser::SortbyContext* PostgreSQLParser::Sortby_listContext::sortby(size_t i) {
  return getRuleContext<PostgreSQLParser::SortbyContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Sortby_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Sortby_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Sortby_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSortby_list;
}


std::any PostgreSQLParser::Sortby_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSortby_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Sortby_listContext* PostgreSQLParser::sortby_list() {
  Sortby_listContext *_localctx = _tracker.createInstance<Sortby_listContext>(_ctx, getState());
  enterRule(_localctx, 1006, PostgreSQLParser::RuleSortby_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8353);
    sortby();
    setState(8358);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(8354);
      match(PostgreSQLParser::COMMA);
      setState(8355);
      sortby();
      setState(8360);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SortbyContext ------------------------------------------------------------------

PostgreSQLParser::SortbyContext::SortbyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::SortbyContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::SortbyContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

PostgreSQLParser::Qual_all_opContext* PostgreSQLParser::SortbyContext::qual_all_op() {
  return getRuleContext<PostgreSQLParser::Qual_all_opContext>(0);
}

PostgreSQLParser::Nulls_order_Context* PostgreSQLParser::SortbyContext::nulls_order_() {
  return getRuleContext<PostgreSQLParser::Nulls_order_Context>(0);
}

PostgreSQLParser::Asc_desc_Context* PostgreSQLParser::SortbyContext::asc_desc_() {
  return getRuleContext<PostgreSQLParser::Asc_desc_Context>(0);
}


size_t PostgreSQLParser::SortbyContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSortby;
}


std::any PostgreSQLParser::SortbyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSortby(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::SortbyContext* PostgreSQLParser::sortby() {
  SortbyContext *_localctx = _tracker.createInstance<SortbyContext>(_ctx, getState());
  enterRule(_localctx, 1008, PostgreSQLParser::RuleSortby);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8361);
    a_expr();
    setState(8367);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::USING: {
        setState(8362);
        match(PostgreSQLParser::USING);
        setState(8363);
        qual_all_op();
        break;
      }

      case PostgreSQLParser::EOF:
      case PostgreSQLParser::CLOSE_PAREN:
      case PostgreSQLParser::COMMA:
      case PostgreSQLParser::SEMI:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::FORMAT_LA:
      case PostgreSQLParser::ASC:
      case PostgreSQLParser::CREATE:
      case PostgreSQLParser::DESC:
      case PostgreSQLParser::FETCH:
      case PostgreSQLParser::FOR:
      case PostgreSQLParser::GRANT:
      case PostgreSQLParser::LIMIT:
      case PostgreSQLParser::NULL_P:
      case PostgreSQLParser::OFFSET:
      case PostgreSQLParser::ON:
      case PostgreSQLParser::RETURNING:
      case PostgreSQLParser::WITH:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::GROUPS: {
        setState(8365);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::ASC

        || _la == PostgreSQLParser::DESC) {
          setState(8364);
          asc_desc_();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(8370);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::NULLS_P) {
      setState(8369);
      nulls_order_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_limitContext ------------------------------------------------------------------

PostgreSQLParser::Select_limitContext::Select_limitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Limit_clauseContext* PostgreSQLParser::Select_limitContext::limit_clause() {
  return getRuleContext<PostgreSQLParser::Limit_clauseContext>(0);
}

PostgreSQLParser::Offset_clauseContext* PostgreSQLParser::Select_limitContext::offset_clause() {
  return getRuleContext<PostgreSQLParser::Offset_clauseContext>(0);
}


size_t PostgreSQLParser::Select_limitContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSelect_limit;
}


std::any PostgreSQLParser::Select_limitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSelect_limit(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Select_limitContext* PostgreSQLParser::select_limit() {
  Select_limitContext *_localctx = _tracker.createInstance<Select_limitContext>(_ctx, getState());
  enterRule(_localctx, 1010, PostgreSQLParser::RuleSelect_limit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8380);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::FETCH:
      case PostgreSQLParser::LIMIT: {
        enterOuterAlt(_localctx, 1);
        setState(8372);
        limit_clause();
        setState(8374);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::OFFSET) {
          setState(8373);
          offset_clause();
        }
        break;
      }

      case PostgreSQLParser::OFFSET: {
        enterOuterAlt(_localctx, 2);
        setState(8376);
        offset_clause();
        setState(8378);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::FETCH

        || _la == PostgreSQLParser::LIMIT) {
          setState(8377);
          limit_clause();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_limit_Context ------------------------------------------------------------------

PostgreSQLParser::Select_limit_Context::Select_limit_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Select_limitContext* PostgreSQLParser::Select_limit_Context::select_limit() {
  return getRuleContext<PostgreSQLParser::Select_limitContext>(0);
}


size_t PostgreSQLParser::Select_limit_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleSelect_limit_;
}


std::any PostgreSQLParser::Select_limit_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSelect_limit_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Select_limit_Context* PostgreSQLParser::select_limit_() {
  Select_limit_Context *_localctx = _tracker.createInstance<Select_limit_Context>(_ctx, getState());
  enterRule(_localctx, 1012, PostgreSQLParser::RuleSelect_limit_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8382);
    select_limit();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Limit_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Limit_clauseContext::Limit_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Limit_clauseContext::LIMIT() {
  return getToken(PostgreSQLParser::LIMIT, 0);
}

PostgreSQLParser::Select_limit_valueContext* PostgreSQLParser::Limit_clauseContext::select_limit_value() {
  return getRuleContext<PostgreSQLParser::Select_limit_valueContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Limit_clauseContext::COMMA() {
  return getToken(PostgreSQLParser::COMMA, 0);
}

PostgreSQLParser::Select_offset_valueContext* PostgreSQLParser::Limit_clauseContext::select_offset_value() {
  return getRuleContext<PostgreSQLParser::Select_offset_valueContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Limit_clauseContext::FETCH() {
  return getToken(PostgreSQLParser::FETCH, 0);
}

PostgreSQLParser::First_or_nextContext* PostgreSQLParser::Limit_clauseContext::first_or_next() {
  return getRuleContext<PostgreSQLParser::First_or_nextContext>(0);
}

PostgreSQLParser::Select_fetch_first_valueContext* PostgreSQLParser::Limit_clauseContext::select_fetch_first_value() {
  return getRuleContext<PostgreSQLParser::Select_fetch_first_valueContext>(0);
}

PostgreSQLParser::Row_or_rowsContext* PostgreSQLParser::Limit_clauseContext::row_or_rows() {
  return getRuleContext<PostgreSQLParser::Row_or_rowsContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Limit_clauseContext::ONLY() {
  return getToken(PostgreSQLParser::ONLY, 0);
}

tree::TerminalNode* PostgreSQLParser::Limit_clauseContext::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

tree::TerminalNode* PostgreSQLParser::Limit_clauseContext::TIES() {
  return getToken(PostgreSQLParser::TIES, 0);
}


size_t PostgreSQLParser::Limit_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleLimit_clause;
}


std::any PostgreSQLParser::Limit_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitLimit_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Limit_clauseContext* PostgreSQLParser::limit_clause() {
  Limit_clauseContext *_localctx = _tracker.createInstance<Limit_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1014, PostgreSQLParser::RuleLimit_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8407);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::LIMIT: {
        enterOuterAlt(_localctx, 1);
        setState(8384);
        match(PostgreSQLParser::LIMIT);
        setState(8385);
        select_limit_value();
        setState(8388);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::COMMA) {
          setState(8386);
          match(PostgreSQLParser::COMMA);
          setState(8387);
          select_offset_value();
        }
        break;
      }

      case PostgreSQLParser::FETCH: {
        enterOuterAlt(_localctx, 2);
        setState(8390);
        match(PostgreSQLParser::FETCH);
        setState(8391);
        first_or_next();
        setState(8405);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 771, _ctx)) {
        case 1: {
          setState(8392);
          select_fetch_first_value();
          setState(8393);
          row_or_rows();
          setState(8397);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case PostgreSQLParser::ONLY: {
              setState(8394);
              match(PostgreSQLParser::ONLY);
              break;
            }

            case PostgreSQLParser::WITH: {
              setState(8395);
              match(PostgreSQLParser::WITH);
              setState(8396);
              match(PostgreSQLParser::TIES);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          break;
        }

        case 2: {
          setState(8399);
          row_or_rows();
          setState(8403);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case PostgreSQLParser::ONLY: {
              setState(8400);
              match(PostgreSQLParser::ONLY);
              break;
            }

            case PostgreSQLParser::WITH: {
              setState(8401);
              match(PostgreSQLParser::WITH);
              setState(8402);
              match(PostgreSQLParser::TIES);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Offset_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Offset_clauseContext::Offset_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Offset_clauseContext::OFFSET() {
  return getToken(PostgreSQLParser::OFFSET, 0);
}

PostgreSQLParser::Select_offset_valueContext* PostgreSQLParser::Offset_clauseContext::select_offset_value() {
  return getRuleContext<PostgreSQLParser::Select_offset_valueContext>(0);
}

PostgreSQLParser::Select_fetch_first_valueContext* PostgreSQLParser::Offset_clauseContext::select_fetch_first_value() {
  return getRuleContext<PostgreSQLParser::Select_fetch_first_valueContext>(0);
}

PostgreSQLParser::Row_or_rowsContext* PostgreSQLParser::Offset_clauseContext::row_or_rows() {
  return getRuleContext<PostgreSQLParser::Row_or_rowsContext>(0);
}


size_t PostgreSQLParser::Offset_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOffset_clause;
}


std::any PostgreSQLParser::Offset_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOffset_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Offset_clauseContext* PostgreSQLParser::offset_clause() {
  Offset_clauseContext *_localctx = _tracker.createInstance<Offset_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1016, PostgreSQLParser::RuleOffset_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8409);
    match(PostgreSQLParser::OFFSET);
    setState(8414);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 773, _ctx)) {
    case 1: {
      setState(8410);
      select_offset_value();
      break;
    }

    case 2: {
      setState(8411);
      select_fetch_first_value();
      setState(8412);
      row_or_rows();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_limit_valueContext ------------------------------------------------------------------

PostgreSQLParser::Select_limit_valueContext::Select_limit_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Select_limit_valueContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Select_limit_valueContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}


size_t PostgreSQLParser::Select_limit_valueContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSelect_limit_value;
}


std::any PostgreSQLParser::Select_limit_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSelect_limit_value(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Select_limit_valueContext* PostgreSQLParser::select_limit_value() {
  Select_limit_valueContext *_localctx = _tracker.createInstance<Select_limit_valueContext>(_ctx, getState());
  enterRule(_localctx, 1018, PostgreSQLParser::RuleSelect_limit_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8418);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::OPEN_PAREN:
      case PostgreSQLParser::PLUS:
      case PostgreSQLParser::MINUS:
      case PostgreSQLParser::PARAM:
      case PostgreSQLParser::Operator:
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::SYSTEM_USER:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::ARRAY:
      case PostgreSQLParser::CASE:
      case PostgreSQLParser::CAST:
      case PostgreSQLParser::CURRENT_CATALOG:
      case PostgreSQLParser::CURRENT_DATE:
      case PostgreSQLParser::CURRENT_ROLE:
      case PostgreSQLParser::CURRENT_TIME:
      case PostgreSQLParser::CURRENT_TIMESTAMP:
      case PostgreSQLParser::CURRENT_USER:
      case PostgreSQLParser::DEFAULT:
      case PostgreSQLParser::FALSE_P:
      case PostgreSQLParser::LOCALTIME:
      case PostgreSQLParser::LOCALTIMESTAMP:
      case PostgreSQLParser::NOT:
      case PostgreSQLParser::NULL_P:
      case PostgreSQLParser::SESSION_USER:
      case PostgreSQLParser::TRUE_P:
      case PostgreSQLParser::UNIQUE:
      case PostgreSQLParser::USER:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::BinaryStringConstant:
      case PostgreSQLParser::HexadecimalStringConstant:
      case PostgreSQLParser::Integral:
      case PostgreSQLParser::BinaryIntegral:
      case PostgreSQLParser::OctalIntegral:
      case PostgreSQLParser::HexadecimalIntegral:
      case PostgreSQLParser::Numeric:
      case PostgreSQLParser::PLSQLVARIABLENAME:
      case PostgreSQLParser::EscapeStringConstant: {
        enterOuterAlt(_localctx, 1);
        setState(8416);
        a_expr();
        break;
      }

      case PostgreSQLParser::ALL: {
        enterOuterAlt(_localctx, 2);
        setState(8417);
        match(PostgreSQLParser::ALL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_offset_valueContext ------------------------------------------------------------------

PostgreSQLParser::Select_offset_valueContext::Select_offset_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Select_offset_valueContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}


size_t PostgreSQLParser::Select_offset_valueContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSelect_offset_value;
}


std::any PostgreSQLParser::Select_offset_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSelect_offset_value(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Select_offset_valueContext* PostgreSQLParser::select_offset_value() {
  Select_offset_valueContext *_localctx = _tracker.createInstance<Select_offset_valueContext>(_ctx, getState());
  enterRule(_localctx, 1020, PostgreSQLParser::RuleSelect_offset_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8420);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_fetch_first_valueContext ------------------------------------------------------------------

PostgreSQLParser::Select_fetch_first_valueContext::Select_fetch_first_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::C_exprContext* PostgreSQLParser::Select_fetch_first_valueContext::c_expr() {
  return getRuleContext<PostgreSQLParser::C_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Select_fetch_first_valueContext::PLUS() {
  return getToken(PostgreSQLParser::PLUS, 0);
}

PostgreSQLParser::I_or_f_constContext* PostgreSQLParser::Select_fetch_first_valueContext::i_or_f_const() {
  return getRuleContext<PostgreSQLParser::I_or_f_constContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Select_fetch_first_valueContext::MINUS() {
  return getToken(PostgreSQLParser::MINUS, 0);
}


size_t PostgreSQLParser::Select_fetch_first_valueContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSelect_fetch_first_value;
}


std::any PostgreSQLParser::Select_fetch_first_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSelect_fetch_first_value(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Select_fetch_first_valueContext* PostgreSQLParser::select_fetch_first_value() {
  Select_fetch_first_valueContext *_localctx = _tracker.createInstance<Select_fetch_first_valueContext>(_ctx, getState());
  enterRule(_localctx, 1022, PostgreSQLParser::RuleSelect_fetch_first_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8427);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::OPEN_PAREN:
      case PostgreSQLParser::PARAM:
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::SYSTEM_USER:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::ARRAY:
      case PostgreSQLParser::CASE:
      case PostgreSQLParser::CAST:
      case PostgreSQLParser::CURRENT_CATALOG:
      case PostgreSQLParser::CURRENT_DATE:
      case PostgreSQLParser::CURRENT_ROLE:
      case PostgreSQLParser::CURRENT_TIME:
      case PostgreSQLParser::CURRENT_TIMESTAMP:
      case PostgreSQLParser::CURRENT_USER:
      case PostgreSQLParser::DEFAULT:
      case PostgreSQLParser::FALSE_P:
      case PostgreSQLParser::LOCALTIME:
      case PostgreSQLParser::LOCALTIMESTAMP:
      case PostgreSQLParser::NULL_P:
      case PostgreSQLParser::SESSION_USER:
      case PostgreSQLParser::TRUE_P:
      case PostgreSQLParser::UNIQUE:
      case PostgreSQLParser::USER:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::BinaryStringConstant:
      case PostgreSQLParser::HexadecimalStringConstant:
      case PostgreSQLParser::Integral:
      case PostgreSQLParser::BinaryIntegral:
      case PostgreSQLParser::OctalIntegral:
      case PostgreSQLParser::HexadecimalIntegral:
      case PostgreSQLParser::Numeric:
      case PostgreSQLParser::PLSQLVARIABLENAME:
      case PostgreSQLParser::EscapeStringConstant: {
        enterOuterAlt(_localctx, 1);
        setState(8422);
        c_expr();
        break;
      }

      case PostgreSQLParser::PLUS: {
        enterOuterAlt(_localctx, 2);
        setState(8423);
        match(PostgreSQLParser::PLUS);
        setState(8424);
        i_or_f_const();
        break;
      }

      case PostgreSQLParser::MINUS: {
        enterOuterAlt(_localctx, 3);
        setState(8425);
        match(PostgreSQLParser::MINUS);
        setState(8426);
        i_or_f_const();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- I_or_f_constContext ------------------------------------------------------------------

PostgreSQLParser::I_or_f_constContext::I_or_f_constContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::IconstContext* PostgreSQLParser::I_or_f_constContext::iconst() {
  return getRuleContext<PostgreSQLParser::IconstContext>(0);
}

PostgreSQLParser::FconstContext* PostgreSQLParser::I_or_f_constContext::fconst() {
  return getRuleContext<PostgreSQLParser::FconstContext>(0);
}


size_t PostgreSQLParser::I_or_f_constContext::getRuleIndex() const {
  return PostgreSQLParser::RuleI_or_f_const;
}


std::any PostgreSQLParser::I_or_f_constContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitI_or_f_const(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::I_or_f_constContext* PostgreSQLParser::i_or_f_const() {
  I_or_f_constContext *_localctx = _tracker.createInstance<I_or_f_constContext>(_ctx, getState());
  enterRule(_localctx, 1024, PostgreSQLParser::RuleI_or_f_const);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8431);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::Integral:
      case PostgreSQLParser::BinaryIntegral:
      case PostgreSQLParser::OctalIntegral:
      case PostgreSQLParser::HexadecimalIntegral: {
        enterOuterAlt(_localctx, 1);
        setState(8429);
        iconst();
        break;
      }

      case PostgreSQLParser::Numeric: {
        enterOuterAlt(_localctx, 2);
        setState(8430);
        fconst();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Row_or_rowsContext ------------------------------------------------------------------

PostgreSQLParser::Row_or_rowsContext::Row_or_rowsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Row_or_rowsContext::ROW() {
  return getToken(PostgreSQLParser::ROW, 0);
}

tree::TerminalNode* PostgreSQLParser::Row_or_rowsContext::ROWS() {
  return getToken(PostgreSQLParser::ROWS, 0);
}


size_t PostgreSQLParser::Row_or_rowsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRow_or_rows;
}


std::any PostgreSQLParser::Row_or_rowsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRow_or_rows(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Row_or_rowsContext* PostgreSQLParser::row_or_rows() {
  Row_or_rowsContext *_localctx = _tracker.createInstance<Row_or_rowsContext>(_ctx, getState());
  enterRule(_localctx, 1026, PostgreSQLParser::RuleRow_or_rows);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8433);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::ROWS || _la == PostgreSQLParser::ROW)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- First_or_nextContext ------------------------------------------------------------------

PostgreSQLParser::First_or_nextContext::First_or_nextContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::First_or_nextContext::FIRST_P() {
  return getToken(PostgreSQLParser::FIRST_P, 0);
}

tree::TerminalNode* PostgreSQLParser::First_or_nextContext::NEXT() {
  return getToken(PostgreSQLParser::NEXT, 0);
}


size_t PostgreSQLParser::First_or_nextContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFirst_or_next;
}


std::any PostgreSQLParser::First_or_nextContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFirst_or_next(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::First_or_nextContext* PostgreSQLParser::first_or_next() {
  First_or_nextContext *_localctx = _tracker.createInstance<First_or_nextContext>(_ctx, getState());
  enterRule(_localctx, 1028, PostgreSQLParser::RuleFirst_or_next);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8435);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::FIRST_P

    || _la == PostgreSQLParser::NEXT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Group_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Group_clauseContext::Group_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Group_clauseContext::GROUP_P() {
  return getToken(PostgreSQLParser::GROUP_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Group_clauseContext::BY() {
  return getToken(PostgreSQLParser::BY, 0);
}

PostgreSQLParser::Group_by_listContext* PostgreSQLParser::Group_clauseContext::group_by_list() {
  return getRuleContext<PostgreSQLParser::Group_by_listContext>(0);
}


size_t PostgreSQLParser::Group_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleGroup_clause;
}


std::any PostgreSQLParser::Group_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitGroup_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Group_clauseContext* PostgreSQLParser::group_clause() {
  Group_clauseContext *_localctx = _tracker.createInstance<Group_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1030, PostgreSQLParser::RuleGroup_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8437);
    match(PostgreSQLParser::GROUP_P);
    setState(8438);
    match(PostgreSQLParser::BY);
    setState(8439);
    group_by_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Group_by_listContext ------------------------------------------------------------------

PostgreSQLParser::Group_by_listContext::Group_by_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Group_by_itemContext *> PostgreSQLParser::Group_by_listContext::group_by_item() {
  return getRuleContexts<PostgreSQLParser::Group_by_itemContext>();
}

PostgreSQLParser::Group_by_itemContext* PostgreSQLParser::Group_by_listContext::group_by_item(size_t i) {
  return getRuleContext<PostgreSQLParser::Group_by_itemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Group_by_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Group_by_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Group_by_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleGroup_by_list;
}


std::any PostgreSQLParser::Group_by_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitGroup_by_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Group_by_listContext* PostgreSQLParser::group_by_list() {
  Group_by_listContext *_localctx = _tracker.createInstance<Group_by_listContext>(_ctx, getState());
  enterRule(_localctx, 1032, PostgreSQLParser::RuleGroup_by_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8441);
    group_by_item();
    setState(8446);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(8442);
      match(PostgreSQLParser::COMMA);
      setState(8443);
      group_by_item();
      setState(8448);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Group_by_itemContext ------------------------------------------------------------------

PostgreSQLParser::Group_by_itemContext::Group_by_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Empty_grouping_setContext* PostgreSQLParser::Group_by_itemContext::empty_grouping_set() {
  return getRuleContext<PostgreSQLParser::Empty_grouping_setContext>(0);
}

PostgreSQLParser::Cube_clauseContext* PostgreSQLParser::Group_by_itemContext::cube_clause() {
  return getRuleContext<PostgreSQLParser::Cube_clauseContext>(0);
}

PostgreSQLParser::Rollup_clauseContext* PostgreSQLParser::Group_by_itemContext::rollup_clause() {
  return getRuleContext<PostgreSQLParser::Rollup_clauseContext>(0);
}

PostgreSQLParser::Grouping_sets_clauseContext* PostgreSQLParser::Group_by_itemContext::grouping_sets_clause() {
  return getRuleContext<PostgreSQLParser::Grouping_sets_clauseContext>(0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Group_by_itemContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}


size_t PostgreSQLParser::Group_by_itemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleGroup_by_item;
}


std::any PostgreSQLParser::Group_by_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitGroup_by_item(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Group_by_itemContext* PostgreSQLParser::group_by_item() {
  Group_by_itemContext *_localctx = _tracker.createInstance<Group_by_itemContext>(_ctx, getState());
  enterRule(_localctx, 1034, PostgreSQLParser::RuleGroup_by_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8454);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 778, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8449);
      empty_grouping_set();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8450);
      cube_clause();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(8451);
      rollup_clause();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(8452);
      grouping_sets_clause();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(8453);
      a_expr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Empty_grouping_setContext ------------------------------------------------------------------

PostgreSQLParser::Empty_grouping_setContext::Empty_grouping_setContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Empty_grouping_setContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::Empty_grouping_setContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Empty_grouping_setContext::getRuleIndex() const {
  return PostgreSQLParser::RuleEmpty_grouping_set;
}


std::any PostgreSQLParser::Empty_grouping_setContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitEmpty_grouping_set(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Empty_grouping_setContext* PostgreSQLParser::empty_grouping_set() {
  Empty_grouping_setContext *_localctx = _tracker.createInstance<Empty_grouping_setContext>(_ctx, getState());
  enterRule(_localctx, 1036, PostgreSQLParser::RuleEmpty_grouping_set);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8456);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(8457);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rollup_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Rollup_clauseContext::Rollup_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Rollup_clauseContext::ROLLUP() {
  return getToken(PostgreSQLParser::ROLLUP, 0);
}

tree::TerminalNode* PostgreSQLParser::Rollup_clauseContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::Rollup_clauseContext::expr_list() {
  return getRuleContext<PostgreSQLParser::Expr_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Rollup_clauseContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Rollup_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRollup_clause;
}


std::any PostgreSQLParser::Rollup_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRollup_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Rollup_clauseContext* PostgreSQLParser::rollup_clause() {
  Rollup_clauseContext *_localctx = _tracker.createInstance<Rollup_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1038, PostgreSQLParser::RuleRollup_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8459);
    match(PostgreSQLParser::ROLLUP);
    setState(8460);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(8461);
    expr_list();
    setState(8462);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cube_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Cube_clauseContext::Cube_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Cube_clauseContext::CUBE() {
  return getToken(PostgreSQLParser::CUBE, 0);
}

tree::TerminalNode* PostgreSQLParser::Cube_clauseContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::Cube_clauseContext::expr_list() {
  return getRuleContext<PostgreSQLParser::Expr_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Cube_clauseContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Cube_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCube_clause;
}


std::any PostgreSQLParser::Cube_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCube_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Cube_clauseContext* PostgreSQLParser::cube_clause() {
  Cube_clauseContext *_localctx = _tracker.createInstance<Cube_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1040, PostgreSQLParser::RuleCube_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8464);
    match(PostgreSQLParser::CUBE);
    setState(8465);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(8466);
    expr_list();
    setState(8467);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Grouping_sets_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Grouping_sets_clauseContext::Grouping_sets_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Grouping_sets_clauseContext::GROUPING() {
  return getToken(PostgreSQLParser::GROUPING, 0);
}

tree::TerminalNode* PostgreSQLParser::Grouping_sets_clauseContext::SETS() {
  return getToken(PostgreSQLParser::SETS, 0);
}

tree::TerminalNode* PostgreSQLParser::Grouping_sets_clauseContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Group_by_listContext* PostgreSQLParser::Grouping_sets_clauseContext::group_by_list() {
  return getRuleContext<PostgreSQLParser::Group_by_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Grouping_sets_clauseContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Grouping_sets_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleGrouping_sets_clause;
}


std::any PostgreSQLParser::Grouping_sets_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitGrouping_sets_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Grouping_sets_clauseContext* PostgreSQLParser::grouping_sets_clause() {
  Grouping_sets_clauseContext *_localctx = _tracker.createInstance<Grouping_sets_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1042, PostgreSQLParser::RuleGrouping_sets_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8469);
    match(PostgreSQLParser::GROUPING);
    setState(8470);
    match(PostgreSQLParser::SETS);
    setState(8471);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(8472);
    group_by_list();
    setState(8473);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Having_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Having_clauseContext::Having_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Having_clauseContext::HAVING() {
  return getToken(PostgreSQLParser::HAVING, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Having_clauseContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}


size_t PostgreSQLParser::Having_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleHaving_clause;
}


std::any PostgreSQLParser::Having_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitHaving_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Having_clauseContext* PostgreSQLParser::having_clause() {
  Having_clauseContext *_localctx = _tracker.createInstance<Having_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1044, PostgreSQLParser::RuleHaving_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8475);
    match(PostgreSQLParser::HAVING);
    setState(8476);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_locking_clauseContext ------------------------------------------------------------------

PostgreSQLParser::For_locking_clauseContext::For_locking_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::For_locking_itemsContext* PostgreSQLParser::For_locking_clauseContext::for_locking_items() {
  return getRuleContext<PostgreSQLParser::For_locking_itemsContext>(0);
}

tree::TerminalNode* PostgreSQLParser::For_locking_clauseContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

tree::TerminalNode* PostgreSQLParser::For_locking_clauseContext::READ() {
  return getToken(PostgreSQLParser::READ, 0);
}

tree::TerminalNode* PostgreSQLParser::For_locking_clauseContext::ONLY() {
  return getToken(PostgreSQLParser::ONLY, 0);
}


size_t PostgreSQLParser::For_locking_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFor_locking_clause;
}


std::any PostgreSQLParser::For_locking_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFor_locking_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::For_locking_clauseContext* PostgreSQLParser::for_locking_clause() {
  For_locking_clauseContext *_localctx = _tracker.createInstance<For_locking_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1046, PostgreSQLParser::RuleFor_locking_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8482);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 779, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8478);
      for_locking_items();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8479);
      match(PostgreSQLParser::FOR);
      setState(8480);
      match(PostgreSQLParser::READ);
      setState(8481);
      match(PostgreSQLParser::ONLY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_locking_clause_Context ------------------------------------------------------------------

PostgreSQLParser::For_locking_clause_Context::For_locking_clause_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::For_locking_clauseContext* PostgreSQLParser::For_locking_clause_Context::for_locking_clause() {
  return getRuleContext<PostgreSQLParser::For_locking_clauseContext>(0);
}


size_t PostgreSQLParser::For_locking_clause_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleFor_locking_clause_;
}


std::any PostgreSQLParser::For_locking_clause_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFor_locking_clause_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::For_locking_clause_Context* PostgreSQLParser::for_locking_clause_() {
  For_locking_clause_Context *_localctx = _tracker.createInstance<For_locking_clause_Context>(_ctx, getState());
  enterRule(_localctx, 1048, PostgreSQLParser::RuleFor_locking_clause_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8484);
    for_locking_clause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_locking_itemsContext ------------------------------------------------------------------

PostgreSQLParser::For_locking_itemsContext::For_locking_itemsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::For_locking_itemContext *> PostgreSQLParser::For_locking_itemsContext::for_locking_item() {
  return getRuleContexts<PostgreSQLParser::For_locking_itemContext>();
}

PostgreSQLParser::For_locking_itemContext* PostgreSQLParser::For_locking_itemsContext::for_locking_item(size_t i) {
  return getRuleContext<PostgreSQLParser::For_locking_itemContext>(i);
}


size_t PostgreSQLParser::For_locking_itemsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFor_locking_items;
}


std::any PostgreSQLParser::For_locking_itemsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFor_locking_items(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::For_locking_itemsContext* PostgreSQLParser::for_locking_items() {
  For_locking_itemsContext *_localctx = _tracker.createInstance<For_locking_itemsContext>(_ctx, getState());
  enterRule(_localctx, 1050, PostgreSQLParser::RuleFor_locking_items);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8487); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(8486);
      for_locking_item();
      setState(8489); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == PostgreSQLParser::FOR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_locking_itemContext ------------------------------------------------------------------

PostgreSQLParser::For_locking_itemContext::For_locking_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::For_locking_strengthContext* PostgreSQLParser::For_locking_itemContext::for_locking_strength() {
  return getRuleContext<PostgreSQLParser::For_locking_strengthContext>(0);
}

PostgreSQLParser::Locked_rels_listContext* PostgreSQLParser::For_locking_itemContext::locked_rels_list() {
  return getRuleContext<PostgreSQLParser::Locked_rels_listContext>(0);
}

PostgreSQLParser::Nowait_or_skip_Context* PostgreSQLParser::For_locking_itemContext::nowait_or_skip_() {
  return getRuleContext<PostgreSQLParser::Nowait_or_skip_Context>(0);
}


size_t PostgreSQLParser::For_locking_itemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFor_locking_item;
}


std::any PostgreSQLParser::For_locking_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFor_locking_item(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::For_locking_itemContext* PostgreSQLParser::for_locking_item() {
  For_locking_itemContext *_localctx = _tracker.createInstance<For_locking_itemContext>(_ctx, getState());
  enterRule(_localctx, 1052, PostgreSQLParser::RuleFor_locking_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8491);
    for_locking_strength();
    setState(8493);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OF) {
      setState(8492);
      locked_rels_list();
    }
    setState(8496);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::NOWAIT || _la == PostgreSQLParser::SKIP_P) {
      setState(8495);
      nowait_or_skip_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_locking_strengthContext ------------------------------------------------------------------

PostgreSQLParser::For_locking_strengthContext::For_locking_strengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::For_locking_strengthContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

tree::TerminalNode* PostgreSQLParser::For_locking_strengthContext::UPDATE() {
  return getToken(PostgreSQLParser::UPDATE, 0);
}

tree::TerminalNode* PostgreSQLParser::For_locking_strengthContext::SHARE() {
  return getToken(PostgreSQLParser::SHARE, 0);
}

tree::TerminalNode* PostgreSQLParser::For_locking_strengthContext::NO() {
  return getToken(PostgreSQLParser::NO, 0);
}

tree::TerminalNode* PostgreSQLParser::For_locking_strengthContext::KEY() {
  return getToken(PostgreSQLParser::KEY, 0);
}


size_t PostgreSQLParser::For_locking_strengthContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFor_locking_strength;
}


std::any PostgreSQLParser::For_locking_strengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFor_locking_strength(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::For_locking_strengthContext* PostgreSQLParser::for_locking_strength() {
  For_locking_strengthContext *_localctx = _tracker.createInstance<For_locking_strengthContext>(_ctx, getState());
  enterRule(_localctx, 1054, PostgreSQLParser::RuleFor_locking_strength);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8498);
    match(PostgreSQLParser::FOR);
    setState(8508);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::NO:
      case PostgreSQLParser::UPDATE: {
        setState(8501);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::NO) {
          setState(8499);
          match(PostgreSQLParser::NO);
          setState(8500);
          match(PostgreSQLParser::KEY);
        }
        setState(8503);
        match(PostgreSQLParser::UPDATE);
        break;
      }

      case PostgreSQLParser::KEY:
      case PostgreSQLParser::SHARE: {
        setState(8505);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::KEY) {
          setState(8504);
          match(PostgreSQLParser::KEY);
        }
        setState(8507);
        match(PostgreSQLParser::SHARE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Locked_rels_listContext ------------------------------------------------------------------

PostgreSQLParser::Locked_rels_listContext::Locked_rels_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Locked_rels_listContext::OF() {
  return getToken(PostgreSQLParser::OF, 0);
}

PostgreSQLParser::Qualified_name_listContext* PostgreSQLParser::Locked_rels_listContext::qualified_name_list() {
  return getRuleContext<PostgreSQLParser::Qualified_name_listContext>(0);
}


size_t PostgreSQLParser::Locked_rels_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleLocked_rels_list;
}


std::any PostgreSQLParser::Locked_rels_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitLocked_rels_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Locked_rels_listContext* PostgreSQLParser::locked_rels_list() {
  Locked_rels_listContext *_localctx = _tracker.createInstance<Locked_rels_listContext>(_ctx, getState());
  enterRule(_localctx, 1056, PostgreSQLParser::RuleLocked_rels_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8510);
    match(PostgreSQLParser::OF);
    setState(8511);
    qualified_name_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Values_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Values_clauseContext::Values_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Values_clauseContext::VALUES() {
  return getToken(PostgreSQLParser::VALUES, 0);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Values_clauseContext::OPEN_PAREN() {
  return getTokens(PostgreSQLParser::OPEN_PAREN);
}

tree::TerminalNode* PostgreSQLParser::Values_clauseContext::OPEN_PAREN(size_t i) {
  return getToken(PostgreSQLParser::OPEN_PAREN, i);
}

std::vector<PostgreSQLParser::Expr_listContext *> PostgreSQLParser::Values_clauseContext::expr_list() {
  return getRuleContexts<PostgreSQLParser::Expr_listContext>();
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::Values_clauseContext::expr_list(size_t i) {
  return getRuleContext<PostgreSQLParser::Expr_listContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Values_clauseContext::CLOSE_PAREN() {
  return getTokens(PostgreSQLParser::CLOSE_PAREN);
}

tree::TerminalNode* PostgreSQLParser::Values_clauseContext::CLOSE_PAREN(size_t i) {
  return getToken(PostgreSQLParser::CLOSE_PAREN, i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Values_clauseContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Values_clauseContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Values_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleValues_clause;
}


std::any PostgreSQLParser::Values_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitValues_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Values_clauseContext* PostgreSQLParser::values_clause() {
  Values_clauseContext *_localctx = _tracker.createInstance<Values_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1058, PostgreSQLParser::RuleValues_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8513);
    match(PostgreSQLParser::VALUES);
    setState(8514);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(8515);
    expr_list();
    setState(8516);
    match(PostgreSQLParser::CLOSE_PAREN);
    setState(8524);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(8517);
      match(PostgreSQLParser::COMMA);
      setState(8518);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(8519);
      expr_list();
      setState(8520);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(8526);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- From_clauseContext ------------------------------------------------------------------

PostgreSQLParser::From_clauseContext::From_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::From_clauseContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

PostgreSQLParser::From_listContext* PostgreSQLParser::From_clauseContext::from_list() {
  return getRuleContext<PostgreSQLParser::From_listContext>(0);
}


size_t PostgreSQLParser::From_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFrom_clause;
}


std::any PostgreSQLParser::From_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFrom_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::From_clauseContext* PostgreSQLParser::from_clause() {
  From_clauseContext *_localctx = _tracker.createInstance<From_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1060, PostgreSQLParser::RuleFrom_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8527);
    match(PostgreSQLParser::FROM);
    setState(8528);
    from_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- From_listContext ------------------------------------------------------------------

PostgreSQLParser::From_listContext::From_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Table_refContext *> PostgreSQLParser::From_listContext::table_ref() {
  return getRuleContexts<PostgreSQLParser::Table_refContext>();
}

PostgreSQLParser::Table_refContext* PostgreSQLParser::From_listContext::table_ref(size_t i) {
  return getRuleContext<PostgreSQLParser::Table_refContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::From_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::From_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::From_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFrom_list;
}


std::any PostgreSQLParser::From_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFrom_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::From_listContext* PostgreSQLParser::from_list() {
  From_listContext *_localctx = _tracker.createInstance<From_listContext>(_ctx, getState());
  enterRule(_localctx, 1062, PostgreSQLParser::RuleFrom_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8530);
    table_ref();
    setState(8535);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(8531);
      match(PostgreSQLParser::COMMA);
      setState(8532);
      table_ref();
      setState(8537);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_refContext ------------------------------------------------------------------

PostgreSQLParser::Table_refContext::Table_refContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Relation_exprContext* PostgreSQLParser::Table_refContext::relation_expr() {
  return getRuleContext<PostgreSQLParser::Relation_exprContext>(0);
}

PostgreSQLParser::Func_tableContext* PostgreSQLParser::Table_refContext::func_table() {
  return getRuleContext<PostgreSQLParser::Func_tableContext>(0);
}

PostgreSQLParser::XmltableContext* PostgreSQLParser::Table_refContext::xmltable() {
  return getRuleContext<PostgreSQLParser::XmltableContext>(0);
}

PostgreSQLParser::Select_with_parensContext* PostgreSQLParser::Table_refContext::select_with_parens() {
  return getRuleContext<PostgreSQLParser::Select_with_parensContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Table_refContext::LATERAL_P() {
  return getToken(PostgreSQLParser::LATERAL_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Table_refContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

std::vector<PostgreSQLParser::Table_refContext *> PostgreSQLParser::Table_refContext::table_ref() {
  return getRuleContexts<PostgreSQLParser::Table_refContext>();
}

PostgreSQLParser::Table_refContext* PostgreSQLParser::Table_refContext::table_ref(size_t i) {
  return getRuleContext<PostgreSQLParser::Table_refContext>(i);
}

tree::TerminalNode* PostgreSQLParser::Table_refContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Table_refContext::CROSS() {
  return getTokens(PostgreSQLParser::CROSS);
}

tree::TerminalNode* PostgreSQLParser::Table_refContext::CROSS(size_t i) {
  return getToken(PostgreSQLParser::CROSS, i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Table_refContext::JOIN() {
  return getTokens(PostgreSQLParser::JOIN);
}

tree::TerminalNode* PostgreSQLParser::Table_refContext::JOIN(size_t i) {
  return getToken(PostgreSQLParser::JOIN, i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Table_refContext::NATURAL() {
  return getTokens(PostgreSQLParser::NATURAL);
}

tree::TerminalNode* PostgreSQLParser::Table_refContext::NATURAL(size_t i) {
  return getToken(PostgreSQLParser::NATURAL, i);
}

std::vector<PostgreSQLParser::Join_qualContext *> PostgreSQLParser::Table_refContext::join_qual() {
  return getRuleContexts<PostgreSQLParser::Join_qualContext>();
}

PostgreSQLParser::Join_qualContext* PostgreSQLParser::Table_refContext::join_qual(size_t i) {
  return getRuleContext<PostgreSQLParser::Join_qualContext>(i);
}

PostgreSQLParser::Alias_clauseContext* PostgreSQLParser::Table_refContext::alias_clause() {
  return getRuleContext<PostgreSQLParser::Alias_clauseContext>(0);
}

PostgreSQLParser::Tablesample_clauseContext* PostgreSQLParser::Table_refContext::tablesample_clause() {
  return getRuleContext<PostgreSQLParser::Tablesample_clauseContext>(0);
}

PostgreSQLParser::Func_alias_clauseContext* PostgreSQLParser::Table_refContext::func_alias_clause() {
  return getRuleContext<PostgreSQLParser::Func_alias_clauseContext>(0);
}

std::vector<PostgreSQLParser::Join_typeContext *> PostgreSQLParser::Table_refContext::join_type() {
  return getRuleContexts<PostgreSQLParser::Join_typeContext>();
}

PostgreSQLParser::Join_typeContext* PostgreSQLParser::Table_refContext::join_type(size_t i) {
  return getRuleContext<PostgreSQLParser::Join_typeContext>(i);
}


size_t PostgreSQLParser::Table_refContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTable_ref;
}


std::any PostgreSQLParser::Table_refContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTable_ref(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Table_refContext* PostgreSQLParser::table_ref() {
  Table_refContext *_localctx = _tracker.createInstance<Table_refContext>(_ctx, getState());
  enterRule(_localctx, 1064, PostgreSQLParser::RuleTable_ref);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(8596);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 801, _ctx)) {
    case 1: {
      setState(8538);
      relation_expr();
      setState(8540);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 30) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 30)) & 17729624993791) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 553)) & 536870983) != 0)) {
        setState(8539);
        alias_clause();
      }
      setState(8543);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::TABLESAMPLE) {
        setState(8542);
        tablesample_clause();
      }
      break;
    }

    case 2: {
      setState(8545);
      func_table();
      setState(8547);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 30) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 30)) & 17729624993791) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 553)) & 536870983) != 0)) {
        setState(8546);
        func_alias_clause();
      }
      break;
    }

    case 3: {
      setState(8549);
      xmltable();
      setState(8551);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 30) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 30)) & 17729624993791) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 553)) & 536870983) != 0)) {
        setState(8550);
        alias_clause();
      }
      break;
    }

    case 4: {
      setState(8553);
      select_with_parens();
      setState(8555);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 30) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 30)) & 17729624993791) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 553)) & 536870983) != 0)) {
        setState(8554);
        alias_clause();
      }
      break;
    }

    case 5: {
      setState(8557);
      match(PostgreSQLParser::LATERAL_P);
      setState(8570);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 796, _ctx)) {
      case 1: {
        setState(8558);
        xmltable();
        setState(8560);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 30) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 30)) & 17729624993791) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 553)) & 536870983) != 0)) {
          setState(8559);
          alias_clause();
        }
        break;
      }

      case 2: {
        setState(8562);
        func_table();
        setState(8564);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 30) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 30)) & 17729624993791) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 553)) & 536870983) != 0)) {
          setState(8563);
          func_alias_clause();
        }
        break;
      }

      case 3: {
        setState(8566);
        select_with_parens();
        setState(8568);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 30) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 30)) & 17729624993791) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 553)) & 536870983) != 0)) {
          setState(8567);
          alias_clause();
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      setState(8572);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(8573);
      table_ref();
      setState(8590);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case PostgreSQLParser::CROSS: {
          setState(8574);
          match(PostgreSQLParser::CROSS);
          setState(8575);
          match(PostgreSQLParser::JOIN);
          setState(8576);
          table_ref();
          break;
        }

        case PostgreSQLParser::NATURAL: {
          setState(8577);
          match(PostgreSQLParser::NATURAL);
          setState(8579);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (((((_la - 151) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 151)) & 8261) != 0)) {
            setState(8578);
            join_type();
          }
          setState(8581);
          match(PostgreSQLParser::JOIN);
          setState(8582);
          table_ref();
          break;
        }

        case PostgreSQLParser::FULL:
        case PostgreSQLParser::INNER_P:
        case PostgreSQLParser::JOIN:
        case PostgreSQLParser::LEFT:
        case PostgreSQLParser::RIGHT: {
          setState(8584);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (((((_la - 151) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 151)) & 8261) != 0)) {
            setState(8583);
            join_type();
          }
          setState(8586);
          match(PostgreSQLParser::JOIN);
          setState(8587);
          table_ref();
          setState(8588);
          join_qual();
          break;
        }

        case PostgreSQLParser::CLOSE_PAREN: {
          break;
        }

      default:
        break;
      }
      setState(8592);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(8594);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 30) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 30)) & 17729624993791) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 553)) & 536870983) != 0)) {
        setState(8593);
        alias_clause();
      }
      break;
    }

    default:
      break;
    }
    setState(8616);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 805, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(8614);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case PostgreSQLParser::CROSS: {
            setState(8598);
            match(PostgreSQLParser::CROSS);
            setState(8599);
            match(PostgreSQLParser::JOIN);
            setState(8600);
            table_ref();
            break;
          }

          case PostgreSQLParser::NATURAL: {
            setState(8601);
            match(PostgreSQLParser::NATURAL);
            setState(8603);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (((((_la - 151) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 151)) & 8261) != 0)) {
              setState(8602);
              join_type();
            }
            setState(8605);
            match(PostgreSQLParser::JOIN);
            setState(8606);
            table_ref();
            break;
          }

          case PostgreSQLParser::FULL:
          case PostgreSQLParser::INNER_P:
          case PostgreSQLParser::JOIN:
          case PostgreSQLParser::LEFT:
          case PostgreSQLParser::RIGHT: {
            setState(8608);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (((((_la - 151) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 151)) & 8261) != 0)) {
              setState(8607);
              join_type();
            }
            setState(8610);
            match(PostgreSQLParser::JOIN);
            setState(8611);
            table_ref();
            setState(8612);
            join_qual();
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(8618);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 805, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alias_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Alias_clauseContext::Alias_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Alias_clauseContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Alias_clauseContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

tree::TerminalNode* PostgreSQLParser::Alias_clauseContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Name_listContext* PostgreSQLParser::Alias_clauseContext::name_list() {
  return getRuleContext<PostgreSQLParser::Name_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Alias_clauseContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Alias_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAlias_clause;
}


std::any PostgreSQLParser::Alias_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAlias_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Alias_clauseContext* PostgreSQLParser::alias_clause() {
  Alias_clauseContext *_localctx = _tracker.createInstance<Alias_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1066, PostgreSQLParser::RuleAlias_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8620);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::AS) {
      setState(8619);
      match(PostgreSQLParser::AS);
    }
    setState(8622);
    colid();
    setState(8627);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OPEN_PAREN) {
      setState(8623);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(8624);
      name_list();
      setState(8625);
      match(PostgreSQLParser::CLOSE_PAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_alias_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Func_alias_clauseContext::Func_alias_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Alias_clauseContext* PostgreSQLParser::Func_alias_clauseContext::alias_clause() {
  return getRuleContext<PostgreSQLParser::Alias_clauseContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_alias_clauseContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::TablefuncelementlistContext* PostgreSQLParser::Func_alias_clauseContext::tablefuncelementlist() {
  return getRuleContext<PostgreSQLParser::TablefuncelementlistContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_alias_clauseContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_alias_clauseContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Func_alias_clauseContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}


size_t PostgreSQLParser::Func_alias_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunc_alias_clause;
}


std::any PostgreSQLParser::Func_alias_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunc_alias_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Func_alias_clauseContext* PostgreSQLParser::func_alias_clause() {
  Func_alias_clauseContext *_localctx = _tracker.createInstance<Func_alias_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1068, PostgreSQLParser::RuleFunc_alias_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8641);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 810, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8629);
      alias_clause();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8635);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case PostgreSQLParser::AS: {
          setState(8630);
          match(PostgreSQLParser::AS);
          setState(8632);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (((((_la - 30) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 30)) & 137438949375) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 418) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 418)) & -34909494181889) != 0) || ((((_la - 482) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 482)) & 1153132601981008895) != 0) || ((((_la - 553) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 553)) & 536870983) != 0)) {
            setState(8631);
            colid();
          }
          break;
        }

        case PostgreSQLParser::JSON:
        case PostgreSQLParser::JSON_ARRAY:
        case PostgreSQLParser::JSON_ARRAYAGG:
        case PostgreSQLParser::JSON_EXISTS:
        case PostgreSQLParser::JSON_OBJECT:
        case PostgreSQLParser::JSON_OBJECTAGG:
        case PostgreSQLParser::JSON_QUERY:
        case PostgreSQLParser::JSON_SCALAR:
        case PostgreSQLParser::JSON_SERIALIZE:
        case PostgreSQLParser::JSON_TABLE:
        case PostgreSQLParser::JSON_VALUE:
        case PostgreSQLParser::MERGE_ACTION:
        case PostgreSQLParser::ABSENT:
        case PostgreSQLParser::ASENSITIVE:
        case PostgreSQLParser::ATOMIC:
        case PostgreSQLParser::BREADTH:
        case PostgreSQLParser::COMPRESSION:
        case PostgreSQLParser::CONDITIONAL:
        case PostgreSQLParser::DEPTH:
        case PostgreSQLParser::EMPTY_P:
        case PostgreSQLParser::FINALIZE:
        case PostgreSQLParser::INDENT:
        case PostgreSQLParser::KEEP:
        case PostgreSQLParser::KEYS:
        case PostgreSQLParser::NESTED:
        case PostgreSQLParser::OMIT:
        case PostgreSQLParser::PARAMETER:
        case PostgreSQLParser::PATH:
        case PostgreSQLParser::PLAN:
        case PostgreSQLParser::QUOTES:
        case PostgreSQLParser::SCALAR:
        case PostgreSQLParser::SOURCE:
        case PostgreSQLParser::STRING_P:
        case PostgreSQLParser::TARGET:
        case PostgreSQLParser::UNCONDITIONAL:
        case PostgreSQLParser::PERIOD:
        case PostgreSQLParser::OVER:
        case PostgreSQLParser::ABORT_P:
        case PostgreSQLParser::ABSOLUTE_P:
        case PostgreSQLParser::ACCESS:
        case PostgreSQLParser::ACTION:
        case PostgreSQLParser::ADD_P:
        case PostgreSQLParser::ADMIN:
        case PostgreSQLParser::AFTER:
        case PostgreSQLParser::AGGREGATE:
        case PostgreSQLParser::ALSO:
        case PostgreSQLParser::ALTER:
        case PostgreSQLParser::ALWAYS:
        case PostgreSQLParser::ASSERTION:
        case PostgreSQLParser::ASSIGNMENT:
        case PostgreSQLParser::AT:
        case PostgreSQLParser::ATTRIBUTE:
        case PostgreSQLParser::BACKWARD:
        case PostgreSQLParser::BEFORE:
        case PostgreSQLParser::BEGIN_P:
        case PostgreSQLParser::BY:
        case PostgreSQLParser::CACHE:
        case PostgreSQLParser::CALLED:
        case PostgreSQLParser::CASCADE:
        case PostgreSQLParser::CASCADED:
        case PostgreSQLParser::CATALOG:
        case PostgreSQLParser::CHAIN:
        case PostgreSQLParser::CHARACTERISTICS:
        case PostgreSQLParser::CHECKPOINT:
        case PostgreSQLParser::CLASS:
        case PostgreSQLParser::CLOSE:
        case PostgreSQLParser::CLUSTER:
        case PostgreSQLParser::COMMENT:
        case PostgreSQLParser::COMMENTS:
        case PostgreSQLParser::COMMIT:
        case PostgreSQLParser::COMMITTED:
        case PostgreSQLParser::CONFIGURATION:
        case PostgreSQLParser::CONNECTION:
        case PostgreSQLParser::CONSTRAINTS:
        case PostgreSQLParser::CONTENT_P:
        case PostgreSQLParser::CONTINUE_P:
        case PostgreSQLParser::CONVERSION_P:
        case PostgreSQLParser::COPY:
        case PostgreSQLParser::COST:
        case PostgreSQLParser::CSV:
        case PostgreSQLParser::CURSOR:
        case PostgreSQLParser::CYCLE:
        case PostgreSQLParser::DATA_P:
        case PostgreSQLParser::DATABASE:
        case PostgreSQLParser::DAY_P:
        case PostgreSQLParser::DEALLOCATE:
        case PostgreSQLParser::DECLARE:
        case PostgreSQLParser::DEFAULTS:
        case PostgreSQLParser::DEFERRED:
        case PostgreSQLParser::DEFINER:
        case PostgreSQLParser::DELETE_P:
        case PostgreSQLParser::DELIMITER:
        case PostgreSQLParser::DELIMITERS:
        case PostgreSQLParser::DICTIONARY:
        case PostgreSQLParser::DISABLE_P:
        case PostgreSQLParser::DISCARD:
        case PostgreSQLParser::DOCUMENT_P:
        case PostgreSQLParser::DOMAIN_P:
        case PostgreSQLParser::DOUBLE_P:
        case PostgreSQLParser::DROP:
        case PostgreSQLParser::EACH:
        case PostgreSQLParser::ENABLE_P:
        case PostgreSQLParser::ENCODING:
        case PostgreSQLParser::ENCRYPTED:
        case PostgreSQLParser::ENUM_P:
        case PostgreSQLParser::ESCAPE:
        case PostgreSQLParser::EVENT:
        case PostgreSQLParser::EXCLUDE:
        case PostgreSQLParser::EXCLUDING:
        case PostgreSQLParser::EXCLUSIVE:
        case PostgreSQLParser::EXECUTE:
        case PostgreSQLParser::EXPLAIN:
        case PostgreSQLParser::EXTENSION:
        case PostgreSQLParser::EXTERNAL:
        case PostgreSQLParser::FAMILY:
        case PostgreSQLParser::FIRST_P:
        case PostgreSQLParser::FOLLOWING:
        case PostgreSQLParser::FORCE:
        case PostgreSQLParser::FORWARD:
        case PostgreSQLParser::FUNCTION:
        case PostgreSQLParser::FUNCTIONS:
        case PostgreSQLParser::GLOBAL:
        case PostgreSQLParser::GRANTED:
        case PostgreSQLParser::HANDLER:
        case PostgreSQLParser::HEADER_P:
        case PostgreSQLParser::HOLD:
        case PostgreSQLParser::HOUR_P:
        case PostgreSQLParser::IDENTITY_P:
        case PostgreSQLParser::IF_P:
        case PostgreSQLParser::IMMEDIATE:
        case PostgreSQLParser::IMMUTABLE:
        case PostgreSQLParser::IMPLICIT_P:
        case PostgreSQLParser::INCLUDING:
        case PostgreSQLParser::INCREMENT:
        case PostgreSQLParser::INDEX:
        case PostgreSQLParser::INDEXES:
        case PostgreSQLParser::INHERIT:
        case PostgreSQLParser::INHERITS:
        case PostgreSQLParser::INLINE_P:
        case PostgreSQLParser::INSENSITIVE:
        case PostgreSQLParser::INSERT:
        case PostgreSQLParser::INSTEAD:
        case PostgreSQLParser::INVOKER:
        case PostgreSQLParser::ISOLATION:
        case PostgreSQLParser::KEY:
        case PostgreSQLParser::LABEL:
        case PostgreSQLParser::LANGUAGE:
        case PostgreSQLParser::LARGE_P:
        case PostgreSQLParser::LAST_P:
        case PostgreSQLParser::LEAKPROOF:
        case PostgreSQLParser::LEVEL:
        case PostgreSQLParser::LISTEN:
        case PostgreSQLParser::LOAD:
        case PostgreSQLParser::LOCAL:
        case PostgreSQLParser::LOCATION:
        case PostgreSQLParser::LOCK_P:
        case PostgreSQLParser::MAPPING:
        case PostgreSQLParser::MATCH:
        case PostgreSQLParser::MATCHED:
        case PostgreSQLParser::MATERIALIZED:
        case PostgreSQLParser::MAXVALUE:
        case PostgreSQLParser::MERGE:
        case PostgreSQLParser::MINUTE_P:
        case PostgreSQLParser::MINVALUE:
        case PostgreSQLParser::MODE:
        case PostgreSQLParser::MONTH_P:
        case PostgreSQLParser::MOVE:
        case PostgreSQLParser::NAME_P:
        case PostgreSQLParser::NAMES:
        case PostgreSQLParser::NEXT:
        case PostgreSQLParser::NO:
        case PostgreSQLParser::NOTHING:
        case PostgreSQLParser::NOTIFY:
        case PostgreSQLParser::NOWAIT:
        case PostgreSQLParser::NULLS_P:
        case PostgreSQLParser::OBJECT_P:
        case PostgreSQLParser::OF:
        case PostgreSQLParser::OFF:
        case PostgreSQLParser::OIDS:
        case PostgreSQLParser::OPERATOR:
        case PostgreSQLParser::OPTION:
        case PostgreSQLParser::OPTIONS:
        case PostgreSQLParser::OWNED:
        case PostgreSQLParser::OWNER:
        case PostgreSQLParser::PARSER:
        case PostgreSQLParser::PARTIAL:
        case PostgreSQLParser::PARTITION:
        case PostgreSQLParser::PASSING:
        case PostgreSQLParser::PASSWORD:
        case PostgreSQLParser::PLANS:
        case PostgreSQLParser::PRECEDING:
        case PostgreSQLParser::PREPARE:
        case PostgreSQLParser::PREPARED:
        case PostgreSQLParser::PRESERVE:
        case PostgreSQLParser::PRIOR:
        case PostgreSQLParser::PRIVILEGES:
        case PostgreSQLParser::PROCEDURAL:
        case PostgreSQLParser::PROCEDURE:
        case PostgreSQLParser::PROGRAM:
        case PostgreSQLParser::QUOTE:
        case PostgreSQLParser::RANGE:
        case PostgreSQLParser::READ:
        case PostgreSQLParser::REASSIGN:
        case PostgreSQLParser::RECURSIVE:
        case PostgreSQLParser::REF:
        case PostgreSQLParser::REFRESH:
        case PostgreSQLParser::REINDEX:
        case PostgreSQLParser::RELATIVE_P:
        case PostgreSQLParser::RELEASE:
        case PostgreSQLParser::RENAME:
        case PostgreSQLParser::REPEATABLE:
        case PostgreSQLParser::REPLACE:
        case PostgreSQLParser::REPLICA:
        case PostgreSQLParser::RESET:
        case PostgreSQLParser::RESTART:
        case PostgreSQLParser::RESTRICT:
        case PostgreSQLParser::RETURNS:
        case PostgreSQLParser::REVOKE:
        case PostgreSQLParser::ROLE:
        case PostgreSQLParser::ROLLBACK:
        case PostgreSQLParser::ROWS:
        case PostgreSQLParser::RULE:
        case PostgreSQLParser::SAVEPOINT:
        case PostgreSQLParser::SCHEMA:
        case PostgreSQLParser::SCROLL:
        case PostgreSQLParser::SEARCH:
        case PostgreSQLParser::SECOND_P:
        case PostgreSQLParser::SECURITY:
        case PostgreSQLParser::SEQUENCE:
        case PostgreSQLParser::SEQUENCES:
        case PostgreSQLParser::SERIALIZABLE:
        case PostgreSQLParser::SERVER:
        case PostgreSQLParser::SESSION:
        case PostgreSQLParser::SET:
        case PostgreSQLParser::SHARE:
        case PostgreSQLParser::SHOW:
        case PostgreSQLParser::SIMPLE:
        case PostgreSQLParser::SNAPSHOT:
        case PostgreSQLParser::STABLE:
        case PostgreSQLParser::STANDALONE_P:
        case PostgreSQLParser::START:
        case PostgreSQLParser::STATEMENT:
        case PostgreSQLParser::STATISTICS:
        case PostgreSQLParser::STDIN:
        case PostgreSQLParser::STDOUT:
        case PostgreSQLParser::STORAGE:
        case PostgreSQLParser::STRICT_P:
        case PostgreSQLParser::STRIP_P:
        case PostgreSQLParser::SYSID:
        case PostgreSQLParser::SYSTEM_P:
        case PostgreSQLParser::TABLES:
        case PostgreSQLParser::TABLESPACE:
        case PostgreSQLParser::TEMP:
        case PostgreSQLParser::TEMPLATE:
        case PostgreSQLParser::TEMPORARY:
        case PostgreSQLParser::TEXT_P:
        case PostgreSQLParser::TRANSACTION:
        case PostgreSQLParser::TRIGGER:
        case PostgreSQLParser::TRUNCATE:
        case PostgreSQLParser::TRUSTED:
        case PostgreSQLParser::TYPE_P:
        case PostgreSQLParser::TYPES_P:
        case PostgreSQLParser::UNBOUNDED:
        case PostgreSQLParser::UNCOMMITTED:
        case PostgreSQLParser::UNENCRYPTED:
        case PostgreSQLParser::UNKNOWN:
        case PostgreSQLParser::UNLISTEN:
        case PostgreSQLParser::UNLOGGED:
        case PostgreSQLParser::UNTIL:
        case PostgreSQLParser::UPDATE:
        case PostgreSQLParser::VACUUM:
        case PostgreSQLParser::VALID:
        case PostgreSQLParser::VALIDATE:
        case PostgreSQLParser::VALIDATOR:
        case PostgreSQLParser::VARYING:
        case PostgreSQLParser::VERSION_P:
        case PostgreSQLParser::VIEW:
        case PostgreSQLParser::VOLATILE:
        case PostgreSQLParser::WHITESPACE_P:
        case PostgreSQLParser::WITHOUT:
        case PostgreSQLParser::WORK:
        case PostgreSQLParser::WRAPPER:
        case PostgreSQLParser::WRITE:
        case PostgreSQLParser::XML_P:
        case PostgreSQLParser::YEAR_P:
        case PostgreSQLParser::YES_P:
        case PostgreSQLParser::ZONE:
        case PostgreSQLParser::BETWEEN:
        case PostgreSQLParser::BIGINT:
        case PostgreSQLParser::BIT:
        case PostgreSQLParser::BOOLEAN_P:
        case PostgreSQLParser::CHAR_P:
        case PostgreSQLParser::CHARACTER:
        case PostgreSQLParser::COALESCE:
        case PostgreSQLParser::DEC:
        case PostgreSQLParser::DECIMAL_P:
        case PostgreSQLParser::EXISTS:
        case PostgreSQLParser::EXTRACT:
        case PostgreSQLParser::FLOAT_P:
        case PostgreSQLParser::GREATEST:
        case PostgreSQLParser::INOUT:
        case PostgreSQLParser::INT_P:
        case PostgreSQLParser::INTEGER:
        case PostgreSQLParser::INTERVAL:
        case PostgreSQLParser::LEAST:
        case PostgreSQLParser::NATIONAL:
        case PostgreSQLParser::NCHAR:
        case PostgreSQLParser::NONE:
        case PostgreSQLParser::NULLIF:
        case PostgreSQLParser::NUMERIC:
        case PostgreSQLParser::OVERLAY:
        case PostgreSQLParser::POSITION:
        case PostgreSQLParser::PRECISION:
        case PostgreSQLParser::REAL:
        case PostgreSQLParser::ROW:
        case PostgreSQLParser::SETOF:
        case PostgreSQLParser::SMALLINT:
        case PostgreSQLParser::SUBSTRING:
        case PostgreSQLParser::TIME:
        case PostgreSQLParser::TIMESTAMP:
        case PostgreSQLParser::TREAT:
        case PostgreSQLParser::TRIM:
        case PostgreSQLParser::VALUES:
        case PostgreSQLParser::VARCHAR:
        case PostgreSQLParser::XMLATTRIBUTES:
        case PostgreSQLParser::XMLCONCAT:
        case PostgreSQLParser::XMLELEMENT:
        case PostgreSQLParser::XMLEXISTS:
        case PostgreSQLParser::XMLFOREST:
        case PostgreSQLParser::XMLPARSE:
        case PostgreSQLParser::XMLPI:
        case PostgreSQLParser::XMLROOT:
        case PostgreSQLParser::XMLSERIALIZE:
        case PostgreSQLParser::CALL:
        case PostgreSQLParser::CURRENT_P:
        case PostgreSQLParser::ATTACH:
        case PostgreSQLParser::DETACH:
        case PostgreSQLParser::EXPRESSION:
        case PostgreSQLParser::GENERATED:
        case PostgreSQLParser::LOGGED:
        case PostgreSQLParser::STORED:
        case PostgreSQLParser::INCLUDE:
        case PostgreSQLParser::ROUTINE:
        case PostgreSQLParser::TRANSFORM:
        case PostgreSQLParser::IMPORT_P:
        case PostgreSQLParser::POLICY:
        case PostgreSQLParser::METHOD:
        case PostgreSQLParser::REFERENCING:
        case PostgreSQLParser::NEW:
        case PostgreSQLParser::OLD:
        case PostgreSQLParser::VALUE_P:
        case PostgreSQLParser::SUBSCRIPTION:
        case PostgreSQLParser::PUBLICATION:
        case PostgreSQLParser::OUT_P:
        case PostgreSQLParser::ROUTINES:
        case PostgreSQLParser::SCHEMAS:
        case PostgreSQLParser::PROCEDURES:
        case PostgreSQLParser::INPUT_P:
        case PostgreSQLParser::SUPPORT:
        case PostgreSQLParser::PARALLEL:
        case PostgreSQLParser::SQL_P:
        case PostgreSQLParser::DEPENDS:
        case PostgreSQLParser::OVERRIDING:
        case PostgreSQLParser::CONFLICT:
        case PostgreSQLParser::SKIP_P:
        case PostgreSQLParser::LOCKED:
        case PostgreSQLParser::TIES:
        case PostgreSQLParser::ROLLUP:
        case PostgreSQLParser::CUBE:
        case PostgreSQLParser::GROUPING:
        case PostgreSQLParser::SETS:
        case PostgreSQLParser::ORDINALITY:
        case PostgreSQLParser::XMLTABLE:
        case PostgreSQLParser::COLUMNS:
        case PostgreSQLParser::XMLNAMESPACES:
        case PostgreSQLParser::NORMALIZED:
        case PostgreSQLParser::WITHIN:
        case PostgreSQLParser::FILTER:
        case PostgreSQLParser::GROUPS:
        case PostgreSQLParser::OTHERS:
        case PostgreSQLParser::NFC:
        case PostgreSQLParser::NFD:
        case PostgreSQLParser::NFKC:
        case PostgreSQLParser::NFKD:
        case PostgreSQLParser::UESCAPE:
        case PostgreSQLParser::VIEWS:
        case PostgreSQLParser::NORMALIZE:
        case PostgreSQLParser::ERROR:
        case PostgreSQLParser::RETURN:
        case PostgreSQLParser::FORMAT:
        case PostgreSQLParser::Identifier:
        case PostgreSQLParser::QuotedIdentifier:
        case PostgreSQLParser::UnicodeQuotedIdentifier:
        case PostgreSQLParser::PLSQLVARIABLENAME: {
          setState(8634);
          colid();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(8637);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(8638);
      tablefuncelementlist();
      setState(8639);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_typeContext ------------------------------------------------------------------

PostgreSQLParser::Join_typeContext::Join_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Join_typeContext::FULL() {
  return getToken(PostgreSQLParser::FULL, 0);
}

tree::TerminalNode* PostgreSQLParser::Join_typeContext::LEFT() {
  return getToken(PostgreSQLParser::LEFT, 0);
}

tree::TerminalNode* PostgreSQLParser::Join_typeContext::RIGHT() {
  return getToken(PostgreSQLParser::RIGHT, 0);
}

tree::TerminalNode* PostgreSQLParser::Join_typeContext::INNER_P() {
  return getToken(PostgreSQLParser::INNER_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Join_typeContext::OUTER_P() {
  return getToken(PostgreSQLParser::OUTER_P, 0);
}


size_t PostgreSQLParser::Join_typeContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJoin_type;
}


std::any PostgreSQLParser::Join_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJoin_type(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Join_typeContext* PostgreSQLParser::join_type() {
  Join_typeContext *_localctx = _tracker.createInstance<Join_typeContext>(_ctx, getState());
  enterRule(_localctx, 1070, PostgreSQLParser::RuleJoin_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8643);
    _la = _input->LA(1);
    if (!(((((_la - 151) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 151)) & 8261) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(8645);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OUTER_P) {
      setState(8644);
      match(PostgreSQLParser::OUTER_P);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_qualContext ------------------------------------------------------------------

PostgreSQLParser::Join_qualContext::Join_qualContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Join_qualContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

tree::TerminalNode* PostgreSQLParser::Join_qualContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Name_listContext* PostgreSQLParser::Join_qualContext::name_list() {
  return getRuleContext<PostgreSQLParser::Name_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Join_qualContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::Join_qualContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Join_qualContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}


size_t PostgreSQLParser::Join_qualContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJoin_qual;
}


std::any PostgreSQLParser::Join_qualContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJoin_qual(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Join_qualContext* PostgreSQLParser::join_qual() {
  Join_qualContext *_localctx = _tracker.createInstance<Join_qualContext>(_ctx, getState());
  enterRule(_localctx, 1072, PostgreSQLParser::RuleJoin_qual);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8654);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::USING: {
        enterOuterAlt(_localctx, 1);
        setState(8647);
        match(PostgreSQLParser::USING);
        setState(8648);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(8649);
        name_list();
        setState(8650);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::ON: {
        enterOuterAlt(_localctx, 2);
        setState(8652);
        match(PostgreSQLParser::ON);
        setState(8653);
        a_expr();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Relation_exprContext ------------------------------------------------------------------

PostgreSQLParser::Relation_exprContext::Relation_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::Relation_exprContext::qualified_name() {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Relation_exprContext::STAR() {
  return getToken(PostgreSQLParser::STAR, 0);
}

tree::TerminalNode* PostgreSQLParser::Relation_exprContext::ONLY() {
  return getToken(PostgreSQLParser::ONLY, 0);
}

tree::TerminalNode* PostgreSQLParser::Relation_exprContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::Relation_exprContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Relation_exprContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRelation_expr;
}


std::any PostgreSQLParser::Relation_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRelation_expr(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Relation_exprContext* PostgreSQLParser::relation_expr() {
  Relation_exprContext *_localctx = _tracker.createInstance<Relation_exprContext>(_ctx, getState());
  enterRule(_localctx, 1074, PostgreSQLParser::RuleRelation_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8668);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 1);
        setState(8656);
        qualified_name();
        setState(8658);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::STAR) {
          setState(8657);
          match(PostgreSQLParser::STAR);
        }
        break;
      }

      case PostgreSQLParser::ONLY: {
        enterOuterAlt(_localctx, 2);
        setState(8660);
        match(PostgreSQLParser::ONLY);
        setState(8666);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case PostgreSQLParser::JSON:
          case PostgreSQLParser::JSON_ARRAY:
          case PostgreSQLParser::JSON_ARRAYAGG:
          case PostgreSQLParser::JSON_EXISTS:
          case PostgreSQLParser::JSON_OBJECT:
          case PostgreSQLParser::JSON_OBJECTAGG:
          case PostgreSQLParser::JSON_QUERY:
          case PostgreSQLParser::JSON_SCALAR:
          case PostgreSQLParser::JSON_SERIALIZE:
          case PostgreSQLParser::JSON_TABLE:
          case PostgreSQLParser::JSON_VALUE:
          case PostgreSQLParser::MERGE_ACTION:
          case PostgreSQLParser::ABSENT:
          case PostgreSQLParser::ASENSITIVE:
          case PostgreSQLParser::ATOMIC:
          case PostgreSQLParser::BREADTH:
          case PostgreSQLParser::COMPRESSION:
          case PostgreSQLParser::CONDITIONAL:
          case PostgreSQLParser::DEPTH:
          case PostgreSQLParser::EMPTY_P:
          case PostgreSQLParser::FINALIZE:
          case PostgreSQLParser::INDENT:
          case PostgreSQLParser::KEEP:
          case PostgreSQLParser::KEYS:
          case PostgreSQLParser::NESTED:
          case PostgreSQLParser::OMIT:
          case PostgreSQLParser::PARAMETER:
          case PostgreSQLParser::PATH:
          case PostgreSQLParser::PLAN:
          case PostgreSQLParser::QUOTES:
          case PostgreSQLParser::SCALAR:
          case PostgreSQLParser::SOURCE:
          case PostgreSQLParser::STRING_P:
          case PostgreSQLParser::TARGET:
          case PostgreSQLParser::UNCONDITIONAL:
          case PostgreSQLParser::PERIOD:
          case PostgreSQLParser::OVER:
          case PostgreSQLParser::ABORT_P:
          case PostgreSQLParser::ABSOLUTE_P:
          case PostgreSQLParser::ACCESS:
          case PostgreSQLParser::ACTION:
          case PostgreSQLParser::ADD_P:
          case PostgreSQLParser::ADMIN:
          case PostgreSQLParser::AFTER:
          case PostgreSQLParser::AGGREGATE:
          case PostgreSQLParser::ALSO:
          case PostgreSQLParser::ALTER:
          case PostgreSQLParser::ALWAYS:
          case PostgreSQLParser::ASSERTION:
          case PostgreSQLParser::ASSIGNMENT:
          case PostgreSQLParser::AT:
          case PostgreSQLParser::ATTRIBUTE:
          case PostgreSQLParser::BACKWARD:
          case PostgreSQLParser::BEFORE:
          case PostgreSQLParser::BEGIN_P:
          case PostgreSQLParser::BY:
          case PostgreSQLParser::CACHE:
          case PostgreSQLParser::CALLED:
          case PostgreSQLParser::CASCADE:
          case PostgreSQLParser::CASCADED:
          case PostgreSQLParser::CATALOG:
          case PostgreSQLParser::CHAIN:
          case PostgreSQLParser::CHARACTERISTICS:
          case PostgreSQLParser::CHECKPOINT:
          case PostgreSQLParser::CLASS:
          case PostgreSQLParser::CLOSE:
          case PostgreSQLParser::CLUSTER:
          case PostgreSQLParser::COMMENT:
          case PostgreSQLParser::COMMENTS:
          case PostgreSQLParser::COMMIT:
          case PostgreSQLParser::COMMITTED:
          case PostgreSQLParser::CONFIGURATION:
          case PostgreSQLParser::CONNECTION:
          case PostgreSQLParser::CONSTRAINTS:
          case PostgreSQLParser::CONTENT_P:
          case PostgreSQLParser::CONTINUE_P:
          case PostgreSQLParser::CONVERSION_P:
          case PostgreSQLParser::COPY:
          case PostgreSQLParser::COST:
          case PostgreSQLParser::CSV:
          case PostgreSQLParser::CURSOR:
          case PostgreSQLParser::CYCLE:
          case PostgreSQLParser::DATA_P:
          case PostgreSQLParser::DATABASE:
          case PostgreSQLParser::DAY_P:
          case PostgreSQLParser::DEALLOCATE:
          case PostgreSQLParser::DECLARE:
          case PostgreSQLParser::DEFAULTS:
          case PostgreSQLParser::DEFERRED:
          case PostgreSQLParser::DEFINER:
          case PostgreSQLParser::DELETE_P:
          case PostgreSQLParser::DELIMITER:
          case PostgreSQLParser::DELIMITERS:
          case PostgreSQLParser::DICTIONARY:
          case PostgreSQLParser::DISABLE_P:
          case PostgreSQLParser::DISCARD:
          case PostgreSQLParser::DOCUMENT_P:
          case PostgreSQLParser::DOMAIN_P:
          case PostgreSQLParser::DOUBLE_P:
          case PostgreSQLParser::DROP:
          case PostgreSQLParser::EACH:
          case PostgreSQLParser::ENABLE_P:
          case PostgreSQLParser::ENCODING:
          case PostgreSQLParser::ENCRYPTED:
          case PostgreSQLParser::ENUM_P:
          case PostgreSQLParser::ESCAPE:
          case PostgreSQLParser::EVENT:
          case PostgreSQLParser::EXCLUDE:
          case PostgreSQLParser::EXCLUDING:
          case PostgreSQLParser::EXCLUSIVE:
          case PostgreSQLParser::EXECUTE:
          case PostgreSQLParser::EXPLAIN:
          case PostgreSQLParser::EXTENSION:
          case PostgreSQLParser::EXTERNAL:
          case PostgreSQLParser::FAMILY:
          case PostgreSQLParser::FIRST_P:
          case PostgreSQLParser::FOLLOWING:
          case PostgreSQLParser::FORCE:
          case PostgreSQLParser::FORWARD:
          case PostgreSQLParser::FUNCTION:
          case PostgreSQLParser::FUNCTIONS:
          case PostgreSQLParser::GLOBAL:
          case PostgreSQLParser::GRANTED:
          case PostgreSQLParser::HANDLER:
          case PostgreSQLParser::HEADER_P:
          case PostgreSQLParser::HOLD:
          case PostgreSQLParser::HOUR_P:
          case PostgreSQLParser::IDENTITY_P:
          case PostgreSQLParser::IF_P:
          case PostgreSQLParser::IMMEDIATE:
          case PostgreSQLParser::IMMUTABLE:
          case PostgreSQLParser::IMPLICIT_P:
          case PostgreSQLParser::INCLUDING:
          case PostgreSQLParser::INCREMENT:
          case PostgreSQLParser::INDEX:
          case PostgreSQLParser::INDEXES:
          case PostgreSQLParser::INHERIT:
          case PostgreSQLParser::INHERITS:
          case PostgreSQLParser::INLINE_P:
          case PostgreSQLParser::INSENSITIVE:
          case PostgreSQLParser::INSERT:
          case PostgreSQLParser::INSTEAD:
          case PostgreSQLParser::INVOKER:
          case PostgreSQLParser::ISOLATION:
          case PostgreSQLParser::KEY:
          case PostgreSQLParser::LABEL:
          case PostgreSQLParser::LANGUAGE:
          case PostgreSQLParser::LARGE_P:
          case PostgreSQLParser::LAST_P:
          case PostgreSQLParser::LEAKPROOF:
          case PostgreSQLParser::LEVEL:
          case PostgreSQLParser::LISTEN:
          case PostgreSQLParser::LOAD:
          case PostgreSQLParser::LOCAL:
          case PostgreSQLParser::LOCATION:
          case PostgreSQLParser::LOCK_P:
          case PostgreSQLParser::MAPPING:
          case PostgreSQLParser::MATCH:
          case PostgreSQLParser::MATCHED:
          case PostgreSQLParser::MATERIALIZED:
          case PostgreSQLParser::MAXVALUE:
          case PostgreSQLParser::MERGE:
          case PostgreSQLParser::MINUTE_P:
          case PostgreSQLParser::MINVALUE:
          case PostgreSQLParser::MODE:
          case PostgreSQLParser::MONTH_P:
          case PostgreSQLParser::MOVE:
          case PostgreSQLParser::NAME_P:
          case PostgreSQLParser::NAMES:
          case PostgreSQLParser::NEXT:
          case PostgreSQLParser::NO:
          case PostgreSQLParser::NOTHING:
          case PostgreSQLParser::NOTIFY:
          case PostgreSQLParser::NOWAIT:
          case PostgreSQLParser::NULLS_P:
          case PostgreSQLParser::OBJECT_P:
          case PostgreSQLParser::OF:
          case PostgreSQLParser::OFF:
          case PostgreSQLParser::OIDS:
          case PostgreSQLParser::OPERATOR:
          case PostgreSQLParser::OPTION:
          case PostgreSQLParser::OPTIONS:
          case PostgreSQLParser::OWNED:
          case PostgreSQLParser::OWNER:
          case PostgreSQLParser::PARSER:
          case PostgreSQLParser::PARTIAL:
          case PostgreSQLParser::PARTITION:
          case PostgreSQLParser::PASSING:
          case PostgreSQLParser::PASSWORD:
          case PostgreSQLParser::PLANS:
          case PostgreSQLParser::PRECEDING:
          case PostgreSQLParser::PREPARE:
          case PostgreSQLParser::PREPARED:
          case PostgreSQLParser::PRESERVE:
          case PostgreSQLParser::PRIOR:
          case PostgreSQLParser::PRIVILEGES:
          case PostgreSQLParser::PROCEDURAL:
          case PostgreSQLParser::PROCEDURE:
          case PostgreSQLParser::PROGRAM:
          case PostgreSQLParser::QUOTE:
          case PostgreSQLParser::RANGE:
          case PostgreSQLParser::READ:
          case PostgreSQLParser::REASSIGN:
          case PostgreSQLParser::RECURSIVE:
          case PostgreSQLParser::REF:
          case PostgreSQLParser::REFRESH:
          case PostgreSQLParser::REINDEX:
          case PostgreSQLParser::RELATIVE_P:
          case PostgreSQLParser::RELEASE:
          case PostgreSQLParser::RENAME:
          case PostgreSQLParser::REPEATABLE:
          case PostgreSQLParser::REPLACE:
          case PostgreSQLParser::REPLICA:
          case PostgreSQLParser::RESET:
          case PostgreSQLParser::RESTART:
          case PostgreSQLParser::RESTRICT:
          case PostgreSQLParser::RETURNS:
          case PostgreSQLParser::REVOKE:
          case PostgreSQLParser::ROLE:
          case PostgreSQLParser::ROLLBACK:
          case PostgreSQLParser::ROWS:
          case PostgreSQLParser::RULE:
          case PostgreSQLParser::SAVEPOINT:
          case PostgreSQLParser::SCHEMA:
          case PostgreSQLParser::SCROLL:
          case PostgreSQLParser::SEARCH:
          case PostgreSQLParser::SECOND_P:
          case PostgreSQLParser::SECURITY:
          case PostgreSQLParser::SEQUENCE:
          case PostgreSQLParser::SEQUENCES:
          case PostgreSQLParser::SERIALIZABLE:
          case PostgreSQLParser::SERVER:
          case PostgreSQLParser::SESSION:
          case PostgreSQLParser::SET:
          case PostgreSQLParser::SHARE:
          case PostgreSQLParser::SHOW:
          case PostgreSQLParser::SIMPLE:
          case PostgreSQLParser::SNAPSHOT:
          case PostgreSQLParser::STABLE:
          case PostgreSQLParser::STANDALONE_P:
          case PostgreSQLParser::START:
          case PostgreSQLParser::STATEMENT:
          case PostgreSQLParser::STATISTICS:
          case PostgreSQLParser::STDIN:
          case PostgreSQLParser::STDOUT:
          case PostgreSQLParser::STORAGE:
          case PostgreSQLParser::STRICT_P:
          case PostgreSQLParser::STRIP_P:
          case PostgreSQLParser::SYSID:
          case PostgreSQLParser::SYSTEM_P:
          case PostgreSQLParser::TABLES:
          case PostgreSQLParser::TABLESPACE:
          case PostgreSQLParser::TEMP:
          case PostgreSQLParser::TEMPLATE:
          case PostgreSQLParser::TEMPORARY:
          case PostgreSQLParser::TEXT_P:
          case PostgreSQLParser::TRANSACTION:
          case PostgreSQLParser::TRIGGER:
          case PostgreSQLParser::TRUNCATE:
          case PostgreSQLParser::TRUSTED:
          case PostgreSQLParser::TYPE_P:
          case PostgreSQLParser::TYPES_P:
          case PostgreSQLParser::UNBOUNDED:
          case PostgreSQLParser::UNCOMMITTED:
          case PostgreSQLParser::UNENCRYPTED:
          case PostgreSQLParser::UNKNOWN:
          case PostgreSQLParser::UNLISTEN:
          case PostgreSQLParser::UNLOGGED:
          case PostgreSQLParser::UNTIL:
          case PostgreSQLParser::UPDATE:
          case PostgreSQLParser::VACUUM:
          case PostgreSQLParser::VALID:
          case PostgreSQLParser::VALIDATE:
          case PostgreSQLParser::VALIDATOR:
          case PostgreSQLParser::VARYING:
          case PostgreSQLParser::VERSION_P:
          case PostgreSQLParser::VIEW:
          case PostgreSQLParser::VOLATILE:
          case PostgreSQLParser::WHITESPACE_P:
          case PostgreSQLParser::WITHOUT:
          case PostgreSQLParser::WORK:
          case PostgreSQLParser::WRAPPER:
          case PostgreSQLParser::WRITE:
          case PostgreSQLParser::XML_P:
          case PostgreSQLParser::YEAR_P:
          case PostgreSQLParser::YES_P:
          case PostgreSQLParser::ZONE:
          case PostgreSQLParser::BETWEEN:
          case PostgreSQLParser::BIGINT:
          case PostgreSQLParser::BIT:
          case PostgreSQLParser::BOOLEAN_P:
          case PostgreSQLParser::CHAR_P:
          case PostgreSQLParser::CHARACTER:
          case PostgreSQLParser::COALESCE:
          case PostgreSQLParser::DEC:
          case PostgreSQLParser::DECIMAL_P:
          case PostgreSQLParser::EXISTS:
          case PostgreSQLParser::EXTRACT:
          case PostgreSQLParser::FLOAT_P:
          case PostgreSQLParser::GREATEST:
          case PostgreSQLParser::INOUT:
          case PostgreSQLParser::INT_P:
          case PostgreSQLParser::INTEGER:
          case PostgreSQLParser::INTERVAL:
          case PostgreSQLParser::LEAST:
          case PostgreSQLParser::NATIONAL:
          case PostgreSQLParser::NCHAR:
          case PostgreSQLParser::NONE:
          case PostgreSQLParser::NULLIF:
          case PostgreSQLParser::NUMERIC:
          case PostgreSQLParser::OVERLAY:
          case PostgreSQLParser::POSITION:
          case PostgreSQLParser::PRECISION:
          case PostgreSQLParser::REAL:
          case PostgreSQLParser::ROW:
          case PostgreSQLParser::SETOF:
          case PostgreSQLParser::SMALLINT:
          case PostgreSQLParser::SUBSTRING:
          case PostgreSQLParser::TIME:
          case PostgreSQLParser::TIMESTAMP:
          case PostgreSQLParser::TREAT:
          case PostgreSQLParser::TRIM:
          case PostgreSQLParser::VALUES:
          case PostgreSQLParser::VARCHAR:
          case PostgreSQLParser::XMLATTRIBUTES:
          case PostgreSQLParser::XMLCONCAT:
          case PostgreSQLParser::XMLELEMENT:
          case PostgreSQLParser::XMLEXISTS:
          case PostgreSQLParser::XMLFOREST:
          case PostgreSQLParser::XMLPARSE:
          case PostgreSQLParser::XMLPI:
          case PostgreSQLParser::XMLROOT:
          case PostgreSQLParser::XMLSERIALIZE:
          case PostgreSQLParser::CALL:
          case PostgreSQLParser::CURRENT_P:
          case PostgreSQLParser::ATTACH:
          case PostgreSQLParser::DETACH:
          case PostgreSQLParser::EXPRESSION:
          case PostgreSQLParser::GENERATED:
          case PostgreSQLParser::LOGGED:
          case PostgreSQLParser::STORED:
          case PostgreSQLParser::INCLUDE:
          case PostgreSQLParser::ROUTINE:
          case PostgreSQLParser::TRANSFORM:
          case PostgreSQLParser::IMPORT_P:
          case PostgreSQLParser::POLICY:
          case PostgreSQLParser::METHOD:
          case PostgreSQLParser::REFERENCING:
          case PostgreSQLParser::NEW:
          case PostgreSQLParser::OLD:
          case PostgreSQLParser::VALUE_P:
          case PostgreSQLParser::SUBSCRIPTION:
          case PostgreSQLParser::PUBLICATION:
          case PostgreSQLParser::OUT_P:
          case PostgreSQLParser::ROUTINES:
          case PostgreSQLParser::SCHEMAS:
          case PostgreSQLParser::PROCEDURES:
          case PostgreSQLParser::INPUT_P:
          case PostgreSQLParser::SUPPORT:
          case PostgreSQLParser::PARALLEL:
          case PostgreSQLParser::SQL_P:
          case PostgreSQLParser::DEPENDS:
          case PostgreSQLParser::OVERRIDING:
          case PostgreSQLParser::CONFLICT:
          case PostgreSQLParser::SKIP_P:
          case PostgreSQLParser::LOCKED:
          case PostgreSQLParser::TIES:
          case PostgreSQLParser::ROLLUP:
          case PostgreSQLParser::CUBE:
          case PostgreSQLParser::GROUPING:
          case PostgreSQLParser::SETS:
          case PostgreSQLParser::ORDINALITY:
          case PostgreSQLParser::XMLTABLE:
          case PostgreSQLParser::COLUMNS:
          case PostgreSQLParser::XMLNAMESPACES:
          case PostgreSQLParser::NORMALIZED:
          case PostgreSQLParser::WITHIN:
          case PostgreSQLParser::FILTER:
          case PostgreSQLParser::GROUPS:
          case PostgreSQLParser::OTHERS:
          case PostgreSQLParser::NFC:
          case PostgreSQLParser::NFD:
          case PostgreSQLParser::NFKC:
          case PostgreSQLParser::NFKD:
          case PostgreSQLParser::UESCAPE:
          case PostgreSQLParser::VIEWS:
          case PostgreSQLParser::NORMALIZE:
          case PostgreSQLParser::ERROR:
          case PostgreSQLParser::RETURN:
          case PostgreSQLParser::FORMAT:
          case PostgreSQLParser::Identifier:
          case PostgreSQLParser::QuotedIdentifier:
          case PostgreSQLParser::UnicodeQuotedIdentifier:
          case PostgreSQLParser::PLSQLVARIABLENAME: {
            setState(8661);
            qualified_name();
            break;
          }

          case PostgreSQLParser::OPEN_PAREN: {
            setState(8662);
            match(PostgreSQLParser::OPEN_PAREN);
            setState(8663);
            qualified_name();
            setState(8664);
            match(PostgreSQLParser::CLOSE_PAREN);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Relation_expr_listContext ------------------------------------------------------------------

PostgreSQLParser::Relation_expr_listContext::Relation_expr_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Relation_exprContext *> PostgreSQLParser::Relation_expr_listContext::relation_expr() {
  return getRuleContexts<PostgreSQLParser::Relation_exprContext>();
}

PostgreSQLParser::Relation_exprContext* PostgreSQLParser::Relation_expr_listContext::relation_expr(size_t i) {
  return getRuleContext<PostgreSQLParser::Relation_exprContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Relation_expr_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Relation_expr_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Relation_expr_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRelation_expr_list;
}


std::any PostgreSQLParser::Relation_expr_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRelation_expr_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Relation_expr_listContext* PostgreSQLParser::relation_expr_list() {
  Relation_expr_listContext *_localctx = _tracker.createInstance<Relation_expr_listContext>(_ctx, getState());
  enterRule(_localctx, 1076, PostgreSQLParser::RuleRelation_expr_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8670);
    relation_expr();
    setState(8675);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(8671);
      match(PostgreSQLParser::COMMA);
      setState(8672);
      relation_expr();
      setState(8677);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Relation_expr_opt_aliasContext ------------------------------------------------------------------

PostgreSQLParser::Relation_expr_opt_aliasContext::Relation_expr_opt_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Relation_exprContext* PostgreSQLParser::Relation_expr_opt_aliasContext::relation_expr() {
  return getRuleContext<PostgreSQLParser::Relation_exprContext>(0);
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Relation_expr_opt_aliasContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Relation_expr_opt_aliasContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}


size_t PostgreSQLParser::Relation_expr_opt_aliasContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRelation_expr_opt_alias;
}


std::any PostgreSQLParser::Relation_expr_opt_aliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRelation_expr_opt_alias(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Relation_expr_opt_aliasContext* PostgreSQLParser::relation_expr_opt_alias() {
  Relation_expr_opt_aliasContext *_localctx = _tracker.createInstance<Relation_expr_opt_aliasContext>(_ctx, getState());
  enterRule(_localctx, 1078, PostgreSQLParser::RuleRelation_expr_opt_alias);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8678);
    relation_expr();
    setState(8683);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 818, _ctx)) {
    case 1: {
      setState(8680);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::AS) {
        setState(8679);
        match(PostgreSQLParser::AS);
      }
      setState(8682);
      colid();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tablesample_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Tablesample_clauseContext::Tablesample_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Tablesample_clauseContext::TABLESAMPLE() {
  return getToken(PostgreSQLParser::TABLESAMPLE, 0);
}

PostgreSQLParser::Func_nameContext* PostgreSQLParser::Tablesample_clauseContext::func_name() {
  return getRuleContext<PostgreSQLParser::Func_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Tablesample_clauseContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::Tablesample_clauseContext::expr_list() {
  return getRuleContext<PostgreSQLParser::Expr_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Tablesample_clauseContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::Repeatable_clause_Context* PostgreSQLParser::Tablesample_clauseContext::repeatable_clause_() {
  return getRuleContext<PostgreSQLParser::Repeatable_clause_Context>(0);
}


size_t PostgreSQLParser::Tablesample_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTablesample_clause;
}


std::any PostgreSQLParser::Tablesample_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTablesample_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Tablesample_clauseContext* PostgreSQLParser::tablesample_clause() {
  Tablesample_clauseContext *_localctx = _tracker.createInstance<Tablesample_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1080, PostgreSQLParser::RuleTablesample_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8685);
    match(PostgreSQLParser::TABLESAMPLE);
    setState(8686);
    func_name();
    setState(8687);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(8688);
    expr_list();
    setState(8689);
    match(PostgreSQLParser::CLOSE_PAREN);
    setState(8691);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::REPEATABLE) {
      setState(8690);
      repeatable_clause_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Repeatable_clause_Context ------------------------------------------------------------------

PostgreSQLParser::Repeatable_clause_Context::Repeatable_clause_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Repeatable_clause_Context::REPEATABLE() {
  return getToken(PostgreSQLParser::REPEATABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Repeatable_clause_Context::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Repeatable_clause_Context::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Repeatable_clause_Context::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Repeatable_clause_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleRepeatable_clause_;
}


std::any PostgreSQLParser::Repeatable_clause_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRepeatable_clause_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Repeatable_clause_Context* PostgreSQLParser::repeatable_clause_() {
  Repeatable_clause_Context *_localctx = _tracker.createInstance<Repeatable_clause_Context>(_ctx, getState());
  enterRule(_localctx, 1082, PostgreSQLParser::RuleRepeatable_clause_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8693);
    match(PostgreSQLParser::REPEATABLE);
    setState(8694);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(8695);
    a_expr();
    setState(8696);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_tableContext ------------------------------------------------------------------

PostgreSQLParser::Func_tableContext::Func_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Func_expr_windowlessContext* PostgreSQLParser::Func_tableContext::func_expr_windowless() {
  return getRuleContext<PostgreSQLParser::Func_expr_windowlessContext>(0);
}

PostgreSQLParser::Ordinality_Context* PostgreSQLParser::Func_tableContext::ordinality_() {
  return getRuleContext<PostgreSQLParser::Ordinality_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_tableContext::ROWS() {
  return getToken(PostgreSQLParser::ROWS, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_tableContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_tableContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Rowsfrom_listContext* PostgreSQLParser::Func_tableContext::rowsfrom_list() {
  return getRuleContext<PostgreSQLParser::Rowsfrom_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_tableContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Func_tableContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunc_table;
}


std::any PostgreSQLParser::Func_tableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunc_table(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Func_tableContext* PostgreSQLParser::func_table() {
  Func_tableContext *_localctx = _tracker.createInstance<Func_tableContext>(_ctx, getState());
  enterRule(_localctx, 1084, PostgreSQLParser::RuleFunc_table);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8710);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 822, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8698);
      func_expr_windowless();
      setState(8700);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 820, _ctx)) {
      case 1: {
        setState(8699);
        ordinality_();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8702);
      match(PostgreSQLParser::ROWS);
      setState(8703);
      match(PostgreSQLParser::FROM);
      setState(8704);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(8705);
      rowsfrom_list();
      setState(8706);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(8708);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 821, _ctx)) {
      case 1: {
        setState(8707);
        ordinality_();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rowsfrom_itemContext ------------------------------------------------------------------

PostgreSQLParser::Rowsfrom_itemContext::Rowsfrom_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Func_expr_windowlessContext* PostgreSQLParser::Rowsfrom_itemContext::func_expr_windowless() {
  return getRuleContext<PostgreSQLParser::Func_expr_windowlessContext>(0);
}

PostgreSQLParser::Col_def_list_Context* PostgreSQLParser::Rowsfrom_itemContext::col_def_list_() {
  return getRuleContext<PostgreSQLParser::Col_def_list_Context>(0);
}


size_t PostgreSQLParser::Rowsfrom_itemContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRowsfrom_item;
}


std::any PostgreSQLParser::Rowsfrom_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRowsfrom_item(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Rowsfrom_itemContext* PostgreSQLParser::rowsfrom_item() {
  Rowsfrom_itemContext *_localctx = _tracker.createInstance<Rowsfrom_itemContext>(_ctx, getState());
  enterRule(_localctx, 1086, PostgreSQLParser::RuleRowsfrom_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8712);
    func_expr_windowless();
    setState(8714);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::AS) {
      setState(8713);
      col_def_list_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rowsfrom_listContext ------------------------------------------------------------------

PostgreSQLParser::Rowsfrom_listContext::Rowsfrom_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Rowsfrom_itemContext *> PostgreSQLParser::Rowsfrom_listContext::rowsfrom_item() {
  return getRuleContexts<PostgreSQLParser::Rowsfrom_itemContext>();
}

PostgreSQLParser::Rowsfrom_itemContext* PostgreSQLParser::Rowsfrom_listContext::rowsfrom_item(size_t i) {
  return getRuleContext<PostgreSQLParser::Rowsfrom_itemContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Rowsfrom_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Rowsfrom_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Rowsfrom_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRowsfrom_list;
}


std::any PostgreSQLParser::Rowsfrom_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRowsfrom_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Rowsfrom_listContext* PostgreSQLParser::rowsfrom_list() {
  Rowsfrom_listContext *_localctx = _tracker.createInstance<Rowsfrom_listContext>(_ctx, getState());
  enterRule(_localctx, 1088, PostgreSQLParser::RuleRowsfrom_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8716);
    rowsfrom_item();
    setState(8721);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(8717);
      match(PostgreSQLParser::COMMA);
      setState(8718);
      rowsfrom_item();
      setState(8723);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Col_def_list_Context ------------------------------------------------------------------

PostgreSQLParser::Col_def_list_Context::Col_def_list_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Col_def_list_Context::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_def_list_Context::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::TablefuncelementlistContext* PostgreSQLParser::Col_def_list_Context::tablefuncelementlist() {
  return getRuleContext<PostgreSQLParser::TablefuncelementlistContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Col_def_list_Context::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Col_def_list_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleCol_def_list_;
}


std::any PostgreSQLParser::Col_def_list_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCol_def_list_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Col_def_list_Context* PostgreSQLParser::col_def_list_() {
  Col_def_list_Context *_localctx = _tracker.createInstance<Col_def_list_Context>(_ctx, getState());
  enterRule(_localctx, 1090, PostgreSQLParser::RuleCol_def_list_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8724);
    match(PostgreSQLParser::AS);
    setState(8725);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(8726);
    tablefuncelementlist();
    setState(8727);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ordinality_Context ------------------------------------------------------------------

PostgreSQLParser::Ordinality_Context::Ordinality_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Ordinality_Context::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

tree::TerminalNode* PostgreSQLParser::Ordinality_Context::ORDINALITY() {
  return getToken(PostgreSQLParser::ORDINALITY, 0);
}


size_t PostgreSQLParser::Ordinality_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleOrdinality_;
}


std::any PostgreSQLParser::Ordinality_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOrdinality_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Ordinality_Context* PostgreSQLParser::ordinality_() {
  Ordinality_Context *_localctx = _tracker.createInstance<Ordinality_Context>(_ctx, getState());
  enterRule(_localctx, 1092, PostgreSQLParser::RuleOrdinality_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8729);
    match(PostgreSQLParser::WITH);
    setState(8730);
    match(PostgreSQLParser::ORDINALITY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Where_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Where_clauseContext::Where_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Where_clauseContext::WHERE() {
  return getToken(PostgreSQLParser::WHERE, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Where_clauseContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}


size_t PostgreSQLParser::Where_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleWhere_clause;
}


std::any PostgreSQLParser::Where_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitWhere_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Where_clauseContext* PostgreSQLParser::where_clause() {
  Where_clauseContext *_localctx = _tracker.createInstance<Where_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1094, PostgreSQLParser::RuleWhere_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8732);
    match(PostgreSQLParser::WHERE);
    setState(8733);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Where_or_current_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Where_or_current_clauseContext::Where_or_current_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Where_or_current_clauseContext::WHERE() {
  return getToken(PostgreSQLParser::WHERE, 0);
}

tree::TerminalNode* PostgreSQLParser::Where_or_current_clauseContext::CURRENT_P() {
  return getToken(PostgreSQLParser::CURRENT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Where_or_current_clauseContext::OF() {
  return getToken(PostgreSQLParser::OF, 0);
}

PostgreSQLParser::Cursor_nameContext* PostgreSQLParser::Where_or_current_clauseContext::cursor_name() {
  return getRuleContext<PostgreSQLParser::Cursor_nameContext>(0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Where_or_current_clauseContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}


size_t PostgreSQLParser::Where_or_current_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleWhere_or_current_clause;
}


std::any PostgreSQLParser::Where_or_current_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitWhere_or_current_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Where_or_current_clauseContext* PostgreSQLParser::where_or_current_clause() {
  Where_or_current_clauseContext *_localctx = _tracker.createInstance<Where_or_current_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1096, PostgreSQLParser::RuleWhere_or_current_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8735);
    match(PostgreSQLParser::WHERE);
    setState(8740);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 825, _ctx)) {
    case 1: {
      setState(8736);
      match(PostgreSQLParser::CURRENT_P);
      setState(8737);
      match(PostgreSQLParser::OF);
      setState(8738);
      cursor_name();
      break;
    }

    case 2: {
      setState(8739);
      a_expr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OpttablefuncelementlistContext ------------------------------------------------------------------

PostgreSQLParser::OpttablefuncelementlistContext::OpttablefuncelementlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::TablefuncelementlistContext* PostgreSQLParser::OpttablefuncelementlistContext::tablefuncelementlist() {
  return getRuleContext<PostgreSQLParser::TablefuncelementlistContext>(0);
}


size_t PostgreSQLParser::OpttablefuncelementlistContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOpttablefuncelementlist;
}


std::any PostgreSQLParser::OpttablefuncelementlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOpttablefuncelementlist(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::OpttablefuncelementlistContext* PostgreSQLParser::opttablefuncelementlist() {
  OpttablefuncelementlistContext *_localctx = _tracker.createInstance<OpttablefuncelementlistContext>(_ctx, getState());
  enterRule(_localctx, 1098, PostgreSQLParser::RuleOpttablefuncelementlist);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8742);
    tablefuncelementlist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablefuncelementlistContext ------------------------------------------------------------------

PostgreSQLParser::TablefuncelementlistContext::TablefuncelementlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::TablefuncelementContext *> PostgreSQLParser::TablefuncelementlistContext::tablefuncelement() {
  return getRuleContexts<PostgreSQLParser::TablefuncelementContext>();
}

PostgreSQLParser::TablefuncelementContext* PostgreSQLParser::TablefuncelementlistContext::tablefuncelement(size_t i) {
  return getRuleContext<PostgreSQLParser::TablefuncelementContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::TablefuncelementlistContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::TablefuncelementlistContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::TablefuncelementlistContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTablefuncelementlist;
}


std::any PostgreSQLParser::TablefuncelementlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTablefuncelementlist(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TablefuncelementlistContext* PostgreSQLParser::tablefuncelementlist() {
  TablefuncelementlistContext *_localctx = _tracker.createInstance<TablefuncelementlistContext>(_ctx, getState());
  enterRule(_localctx, 1100, PostgreSQLParser::RuleTablefuncelementlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8744);
    tablefuncelement();
    setState(8749);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(8745);
      match(PostgreSQLParser::COMMA);
      setState(8746);
      tablefuncelement();
      setState(8751);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablefuncelementContext ------------------------------------------------------------------

PostgreSQLParser::TablefuncelementContext::TablefuncelementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::TablefuncelementContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::TablefuncelementContext::typename_() {
  return getRuleContext<PostgreSQLParser::TypenameContext>(0);
}

PostgreSQLParser::Collate_clause_Context* PostgreSQLParser::TablefuncelementContext::collate_clause_() {
  return getRuleContext<PostgreSQLParser::Collate_clause_Context>(0);
}


size_t PostgreSQLParser::TablefuncelementContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTablefuncelement;
}


std::any PostgreSQLParser::TablefuncelementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTablefuncelement(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TablefuncelementContext* PostgreSQLParser::tablefuncelement() {
  TablefuncelementContext *_localctx = _tracker.createInstance<TablefuncelementContext>(_ctx, getState());
  enterRule(_localctx, 1102, PostgreSQLParser::RuleTablefuncelement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8752);
    colid();
    setState(8753);
    typename_();
    setState(8755);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::COLLATE) {
      setState(8754);
      collate_clause_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XmltableContext ------------------------------------------------------------------

PostgreSQLParser::XmltableContext::XmltableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::XmltableContext::XMLTABLE() {
  return getToken(PostgreSQLParser::XMLTABLE, 0);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::XmltableContext::OPEN_PAREN() {
  return getTokens(PostgreSQLParser::OPEN_PAREN);
}

tree::TerminalNode* PostgreSQLParser::XmltableContext::OPEN_PAREN(size_t i) {
  return getToken(PostgreSQLParser::OPEN_PAREN, i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::XmltableContext::CLOSE_PAREN() {
  return getTokens(PostgreSQLParser::CLOSE_PAREN);
}

tree::TerminalNode* PostgreSQLParser::XmltableContext::CLOSE_PAREN(size_t i) {
  return getToken(PostgreSQLParser::CLOSE_PAREN, i);
}

PostgreSQLParser::C_exprContext* PostgreSQLParser::XmltableContext::c_expr() {
  return getRuleContext<PostgreSQLParser::C_exprContext>(0);
}

PostgreSQLParser::Xmlexists_argumentContext* PostgreSQLParser::XmltableContext::xmlexists_argument() {
  return getRuleContext<PostgreSQLParser::Xmlexists_argumentContext>(0);
}

tree::TerminalNode* PostgreSQLParser::XmltableContext::COLUMNS() {
  return getToken(PostgreSQLParser::COLUMNS, 0);
}

PostgreSQLParser::Xmltable_column_listContext* PostgreSQLParser::XmltableContext::xmltable_column_list() {
  return getRuleContext<PostgreSQLParser::Xmltable_column_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::XmltableContext::XMLNAMESPACES() {
  return getToken(PostgreSQLParser::XMLNAMESPACES, 0);
}

PostgreSQLParser::Xml_namespace_listContext* PostgreSQLParser::XmltableContext::xml_namespace_list() {
  return getRuleContext<PostgreSQLParser::Xml_namespace_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::XmltableContext::COMMA() {
  return getToken(PostgreSQLParser::COMMA, 0);
}


size_t PostgreSQLParser::XmltableContext::getRuleIndex() const {
  return PostgreSQLParser::RuleXmltable;
}


std::any PostgreSQLParser::XmltableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitXmltable(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::XmltableContext* PostgreSQLParser::xmltable() {
  XmltableContext *_localctx = _tracker.createInstance<XmltableContext>(_ctx, getState());
  enterRule(_localctx, 1104, PostgreSQLParser::RuleXmltable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8757);
    match(PostgreSQLParser::XMLTABLE);
    setState(8758);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(8774);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 828, _ctx)) {
    case 1: {
      setState(8759);
      c_expr();
      setState(8760);
      xmlexists_argument();
      setState(8761);
      match(PostgreSQLParser::COLUMNS);
      setState(8762);
      xmltable_column_list();
      break;
    }

    case 2: {
      setState(8764);
      match(PostgreSQLParser::XMLNAMESPACES);
      setState(8765);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(8766);
      xml_namespace_list();
      setState(8767);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(8768);
      match(PostgreSQLParser::COMMA);
      setState(8769);
      c_expr();
      setState(8770);
      xmlexists_argument();
      setState(8771);
      match(PostgreSQLParser::COLUMNS);
      setState(8772);
      xmltable_column_list();
      break;
    }

    default:
      break;
    }
    setState(8776);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xmltable_column_listContext ------------------------------------------------------------------

PostgreSQLParser::Xmltable_column_listContext::Xmltable_column_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Xmltable_column_elContext *> PostgreSQLParser::Xmltable_column_listContext::xmltable_column_el() {
  return getRuleContexts<PostgreSQLParser::Xmltable_column_elContext>();
}

PostgreSQLParser::Xmltable_column_elContext* PostgreSQLParser::Xmltable_column_listContext::xmltable_column_el(size_t i) {
  return getRuleContext<PostgreSQLParser::Xmltable_column_elContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Xmltable_column_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Xmltable_column_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Xmltable_column_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleXmltable_column_list;
}


std::any PostgreSQLParser::Xmltable_column_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitXmltable_column_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Xmltable_column_listContext* PostgreSQLParser::xmltable_column_list() {
  Xmltable_column_listContext *_localctx = _tracker.createInstance<Xmltable_column_listContext>(_ctx, getState());
  enterRule(_localctx, 1106, PostgreSQLParser::RuleXmltable_column_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8778);
    xmltable_column_el();
    setState(8783);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(8779);
      match(PostgreSQLParser::COMMA);
      setState(8780);
      xmltable_column_el();
      setState(8785);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xmltable_column_elContext ------------------------------------------------------------------

PostgreSQLParser::Xmltable_column_elContext::Xmltable_column_elContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Xmltable_column_elContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::Xmltable_column_elContext::typename_() {
  return getRuleContext<PostgreSQLParser::TypenameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Xmltable_column_elContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

tree::TerminalNode* PostgreSQLParser::Xmltable_column_elContext::ORDINALITY() {
  return getToken(PostgreSQLParser::ORDINALITY, 0);
}

PostgreSQLParser::Xmltable_column_option_listContext* PostgreSQLParser::Xmltable_column_elContext::xmltable_column_option_list() {
  return getRuleContext<PostgreSQLParser::Xmltable_column_option_listContext>(0);
}


size_t PostgreSQLParser::Xmltable_column_elContext::getRuleIndex() const {
  return PostgreSQLParser::RuleXmltable_column_el;
}


std::any PostgreSQLParser::Xmltable_column_elContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitXmltable_column_el(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Xmltable_column_elContext* PostgreSQLParser::xmltable_column_el() {
  Xmltable_column_elContext *_localctx = _tracker.createInstance<Xmltable_column_elContext>(_ctx, getState());
  enterRule(_localctx, 1108, PostgreSQLParser::RuleXmltable_column_el);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8786);
    colid();
    setState(8793);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        setState(8787);
        typename_();
        setState(8789);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 91) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 91)) & 50331649) != 0) || ((((_la - 554) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 554)) & 268435491) != 0)) {
          setState(8788);
          xmltable_column_option_list();
        }
        break;
      }

      case PostgreSQLParser::FOR: {
        setState(8791);
        match(PostgreSQLParser::FOR);
        setState(8792);
        match(PostgreSQLParser::ORDINALITY);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xmltable_column_option_listContext ------------------------------------------------------------------

PostgreSQLParser::Xmltable_column_option_listContext::Xmltable_column_option_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Xmltable_column_option_elContext *> PostgreSQLParser::Xmltable_column_option_listContext::xmltable_column_option_el() {
  return getRuleContexts<PostgreSQLParser::Xmltable_column_option_elContext>();
}

PostgreSQLParser::Xmltable_column_option_elContext* PostgreSQLParser::Xmltable_column_option_listContext::xmltable_column_option_el(size_t i) {
  return getRuleContext<PostgreSQLParser::Xmltable_column_option_elContext>(i);
}


size_t PostgreSQLParser::Xmltable_column_option_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleXmltable_column_option_list;
}


std::any PostgreSQLParser::Xmltable_column_option_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitXmltable_column_option_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Xmltable_column_option_listContext* PostgreSQLParser::xmltable_column_option_list() {
  Xmltable_column_option_listContext *_localctx = _tracker.createInstance<Xmltable_column_option_listContext>(_ctx, getState());
  enterRule(_localctx, 1110, PostgreSQLParser::RuleXmltable_column_option_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8796); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(8795);
      xmltable_column_option_el();
      setState(8798); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 91) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 91)) & 50331649) != 0) || ((((_la - 554) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 554)) & 268435491) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xmltable_column_option_elContext ------------------------------------------------------------------

PostgreSQLParser::Xmltable_column_option_elContext::Xmltable_column_option_elContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Xmltable_column_option_elContext::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Xmltable_column_option_elContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

PostgreSQLParser::IdentifierContext* PostgreSQLParser::Xmltable_column_option_elContext::identifier() {
  return getRuleContext<PostgreSQLParser::IdentifierContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Xmltable_column_option_elContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::Xmltable_column_option_elContext::NULL_P() {
  return getToken(PostgreSQLParser::NULL_P, 0);
}


size_t PostgreSQLParser::Xmltable_column_option_elContext::getRuleIndex() const {
  return PostgreSQLParser::RuleXmltable_column_option_el;
}


std::any PostgreSQLParser::Xmltable_column_option_elContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitXmltable_column_option_el(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Xmltable_column_option_elContext* PostgreSQLParser::xmltable_column_option_el() {
  Xmltable_column_option_elContext *_localctx = _tracker.createInstance<Xmltable_column_option_elContext>(_ctx, getState());
  enterRule(_localctx, 1112, PostgreSQLParser::RuleXmltable_column_option_el);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8808);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::DEFAULT: {
        enterOuterAlt(_localctx, 1);
        setState(8800);
        match(PostgreSQLParser::DEFAULT);
        setState(8801);
        a_expr();
        break;
      }

      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 2);
        setState(8802);
        identifier();
        setState(8803);
        a_expr();
        break;
      }

      case PostgreSQLParser::NOT: {
        enterOuterAlt(_localctx, 3);
        setState(8805);
        match(PostgreSQLParser::NOT);
        setState(8806);
        match(PostgreSQLParser::NULL_P);
        break;
      }

      case PostgreSQLParser::NULL_P: {
        enterOuterAlt(_localctx, 4);
        setState(8807);
        match(PostgreSQLParser::NULL_P);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xml_namespace_listContext ------------------------------------------------------------------

PostgreSQLParser::Xml_namespace_listContext::Xml_namespace_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Xml_namespace_elContext *> PostgreSQLParser::Xml_namespace_listContext::xml_namespace_el() {
  return getRuleContexts<PostgreSQLParser::Xml_namespace_elContext>();
}

PostgreSQLParser::Xml_namespace_elContext* PostgreSQLParser::Xml_namespace_listContext::xml_namespace_el(size_t i) {
  return getRuleContext<PostgreSQLParser::Xml_namespace_elContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Xml_namespace_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Xml_namespace_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Xml_namespace_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleXml_namespace_list;
}


std::any PostgreSQLParser::Xml_namespace_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitXml_namespace_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Xml_namespace_listContext* PostgreSQLParser::xml_namespace_list() {
  Xml_namespace_listContext *_localctx = _tracker.createInstance<Xml_namespace_listContext>(_ctx, getState());
  enterRule(_localctx, 1114, PostgreSQLParser::RuleXml_namespace_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8810);
    xml_namespace_el();
    setState(8815);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(8811);
      match(PostgreSQLParser::COMMA);
      setState(8812);
      xml_namespace_el();
      setState(8817);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xml_namespace_elContext ------------------------------------------------------------------

PostgreSQLParser::Xml_namespace_elContext::Xml_namespace_elContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::B_exprContext* PostgreSQLParser::Xml_namespace_elContext::b_expr() {
  return getRuleContext<PostgreSQLParser::B_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Xml_namespace_elContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

PostgreSQLParser::ColLabelContext* PostgreSQLParser::Xml_namespace_elContext::colLabel() {
  return getRuleContext<PostgreSQLParser::ColLabelContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Xml_namespace_elContext::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}


size_t PostgreSQLParser::Xml_namespace_elContext::getRuleIndex() const {
  return PostgreSQLParser::RuleXml_namespace_el;
}


std::any PostgreSQLParser::Xml_namespace_elContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitXml_namespace_el(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Xml_namespace_elContext* PostgreSQLParser::xml_namespace_el() {
  Xml_namespace_elContext *_localctx = _tracker.createInstance<Xml_namespace_elContext>(_ctx, getState());
  enterRule(_localctx, 1116, PostgreSQLParser::RuleXml_namespace_el);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8824);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 835, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8818);
      b_expr(0);
      setState(8819);
      match(PostgreSQLParser::AS);
      setState(8820);
      colLabel();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8822);
      match(PostgreSQLParser::DEFAULT);
      setState(8823);
      b_expr(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypenameContext ------------------------------------------------------------------

PostgreSQLParser::TypenameContext::TypenameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::SimpletypenameContext* PostgreSQLParser::TypenameContext::simpletypename() {
  return getRuleContext<PostgreSQLParser::SimpletypenameContext>(0);
}

PostgreSQLParser::Opt_array_boundsContext* PostgreSQLParser::TypenameContext::opt_array_bounds() {
  return getRuleContext<PostgreSQLParser::Opt_array_boundsContext>(0);
}

tree::TerminalNode* PostgreSQLParser::TypenameContext::ARRAY() {
  return getToken(PostgreSQLParser::ARRAY, 0);
}

tree::TerminalNode* PostgreSQLParser::TypenameContext::SETOF() {
  return getToken(PostgreSQLParser::SETOF, 0);
}

tree::TerminalNode* PostgreSQLParser::TypenameContext::OPEN_BRACKET() {
  return getToken(PostgreSQLParser::OPEN_BRACKET, 0);
}

PostgreSQLParser::IconstContext* PostgreSQLParser::TypenameContext::iconst() {
  return getRuleContext<PostgreSQLParser::IconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::TypenameContext::CLOSE_BRACKET() {
  return getToken(PostgreSQLParser::CLOSE_BRACKET, 0);
}


size_t PostgreSQLParser::TypenameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTypename;
}


std::any PostgreSQLParser::TypenameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTypename(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::typename_() {
  TypenameContext *_localctx = _tracker.createInstance<TypenameContext>(_ctx, getState());
  enterRule(_localctx, 1118, PostgreSQLParser::RuleTypename);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8827);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::SETOF) {
      setState(8826);
      match(PostgreSQLParser::SETOF);
    }
    setState(8829);
    simpletypename();
    setState(8838);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 838, _ctx)) {
    case 1: {
      setState(8830);
      opt_array_bounds();
      break;
    }

    case 2: {
      setState(8831);
      match(PostgreSQLParser::ARRAY);
      setState(8836);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 837, _ctx)) {
      case 1: {
        setState(8832);
        match(PostgreSQLParser::OPEN_BRACKET);
        setState(8833);
        iconst();
        setState(8834);
        match(PostgreSQLParser::CLOSE_BRACKET);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_array_boundsContext ------------------------------------------------------------------

PostgreSQLParser::Opt_array_boundsContext::Opt_array_boundsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Opt_array_boundsContext::OPEN_BRACKET() {
  return getTokens(PostgreSQLParser::OPEN_BRACKET);
}

tree::TerminalNode* PostgreSQLParser::Opt_array_boundsContext::OPEN_BRACKET(size_t i) {
  return getToken(PostgreSQLParser::OPEN_BRACKET, i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Opt_array_boundsContext::CLOSE_BRACKET() {
  return getTokens(PostgreSQLParser::CLOSE_BRACKET);
}

tree::TerminalNode* PostgreSQLParser::Opt_array_boundsContext::CLOSE_BRACKET(size_t i) {
  return getToken(PostgreSQLParser::CLOSE_BRACKET, i);
}

std::vector<PostgreSQLParser::IconstContext *> PostgreSQLParser::Opt_array_boundsContext::iconst() {
  return getRuleContexts<PostgreSQLParser::IconstContext>();
}

PostgreSQLParser::IconstContext* PostgreSQLParser::Opt_array_boundsContext::iconst(size_t i) {
  return getRuleContext<PostgreSQLParser::IconstContext>(i);
}


size_t PostgreSQLParser::Opt_array_boundsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOpt_array_bounds;
}


std::any PostgreSQLParser::Opt_array_boundsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOpt_array_bounds(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Opt_array_boundsContext* PostgreSQLParser::opt_array_bounds() {
  Opt_array_boundsContext *_localctx = _tracker.createInstance<Opt_array_boundsContext>(_ctx, getState());
  enterRule(_localctx, 1120, PostgreSQLParser::RuleOpt_array_bounds);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(8847);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 840, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(8840);
        match(PostgreSQLParser::OPEN_BRACKET);
        setState(8842);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 576) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 576)) & 15) != 0)) {
          setState(8841);
          iconst();
        }
        setState(8844);
        match(PostgreSQLParser::CLOSE_BRACKET); 
      }
      setState(8849);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 840, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpletypenameContext ------------------------------------------------------------------

PostgreSQLParser::SimpletypenameContext::SimpletypenameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::GenerictypeContext* PostgreSQLParser::SimpletypenameContext::generictype() {
  return getRuleContext<PostgreSQLParser::GenerictypeContext>(0);
}

PostgreSQLParser::NumericContext* PostgreSQLParser::SimpletypenameContext::numeric() {
  return getRuleContext<PostgreSQLParser::NumericContext>(0);
}

PostgreSQLParser::BitContext* PostgreSQLParser::SimpletypenameContext::bit() {
  return getRuleContext<PostgreSQLParser::BitContext>(0);
}

PostgreSQLParser::CharacterContext* PostgreSQLParser::SimpletypenameContext::character() {
  return getRuleContext<PostgreSQLParser::CharacterContext>(0);
}

PostgreSQLParser::ConstdatetimeContext* PostgreSQLParser::SimpletypenameContext::constdatetime() {
  return getRuleContext<PostgreSQLParser::ConstdatetimeContext>(0);
}

PostgreSQLParser::ConstintervalContext* PostgreSQLParser::SimpletypenameContext::constinterval() {
  return getRuleContext<PostgreSQLParser::ConstintervalContext>(0);
}

tree::TerminalNode* PostgreSQLParser::SimpletypenameContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::IconstContext* PostgreSQLParser::SimpletypenameContext::iconst() {
  return getRuleContext<PostgreSQLParser::IconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::SimpletypenameContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::Interval_Context* PostgreSQLParser::SimpletypenameContext::interval_() {
  return getRuleContext<PostgreSQLParser::Interval_Context>(0);
}

PostgreSQLParser::JsonTypeContext* PostgreSQLParser::SimpletypenameContext::jsonType() {
  return getRuleContext<PostgreSQLParser::JsonTypeContext>(0);
}


size_t PostgreSQLParser::SimpletypenameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSimpletypename;
}


std::any PostgreSQLParser::SimpletypenameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSimpletypename(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::SimpletypenameContext* PostgreSQLParser::simpletypename() {
  SimpletypenameContext *_localctx = _tracker.createInstance<SimpletypenameContext>(_ctx, getState());
  enterRule(_localctx, 1122, PostgreSQLParser::RuleSimpletypename);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8866);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 843, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8850);
      generictype();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8851);
      numeric();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(8852);
      bit();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(8853);
      character();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(8854);
      constdatetime();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(8855);
      constinterval();
      setState(8863);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 842, _ctx)) {
      case 1: {
        setState(8857);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 841, _ctx)) {
        case 1: {
          setState(8856);
          interval_();
          break;
        }

        default:
          break;
        }
        break;
      }

      case 2: {
        setState(8859);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(8860);
        iconst();
        setState(8861);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(8865);
      jsonType();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConsttypenameContext ------------------------------------------------------------------

PostgreSQLParser::ConsttypenameContext::ConsttypenameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::NumericContext* PostgreSQLParser::ConsttypenameContext::numeric() {
  return getRuleContext<PostgreSQLParser::NumericContext>(0);
}

PostgreSQLParser::ConstbitContext* PostgreSQLParser::ConsttypenameContext::constbit() {
  return getRuleContext<PostgreSQLParser::ConstbitContext>(0);
}

PostgreSQLParser::ConstcharacterContext* PostgreSQLParser::ConsttypenameContext::constcharacter() {
  return getRuleContext<PostgreSQLParser::ConstcharacterContext>(0);
}

PostgreSQLParser::ConstdatetimeContext* PostgreSQLParser::ConsttypenameContext::constdatetime() {
  return getRuleContext<PostgreSQLParser::ConstdatetimeContext>(0);
}

PostgreSQLParser::JsonTypeContext* PostgreSQLParser::ConsttypenameContext::jsonType() {
  return getRuleContext<PostgreSQLParser::JsonTypeContext>(0);
}


size_t PostgreSQLParser::ConsttypenameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleConsttypename;
}


std::any PostgreSQLParser::ConsttypenameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitConsttypename(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ConsttypenameContext* PostgreSQLParser::consttypename() {
  ConsttypenameContext *_localctx = _tracker.createInstance<ConsttypenameContext>(_ctx, getState());
  enterRule(_localctx, 1124, PostgreSQLParser::RuleConsttypename);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8873);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::SMALLINT: {
        enterOuterAlt(_localctx, 1);
        setState(8868);
        numeric();
        break;
      }

      case PostgreSQLParser::BIT: {
        enterOuterAlt(_localctx, 2);
        setState(8869);
        constbit();
        break;
      }

      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::VARCHAR: {
        enterOuterAlt(_localctx, 3);
        setState(8870);
        constcharacter();
        break;
      }

      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP: {
        enterOuterAlt(_localctx, 4);
        setState(8871);
        constdatetime();
        break;
      }

      case PostgreSQLParser::JSON: {
        enterOuterAlt(_localctx, 5);
        setState(8872);
        jsonType();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenerictypeContext ------------------------------------------------------------------

PostgreSQLParser::GenerictypeContext::GenerictypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Type_function_nameContext* PostgreSQLParser::GenerictypeContext::type_function_name() {
  return getRuleContext<PostgreSQLParser::Type_function_nameContext>(0);
}

PostgreSQLParser::AttrsContext* PostgreSQLParser::GenerictypeContext::attrs() {
  return getRuleContext<PostgreSQLParser::AttrsContext>(0);
}

PostgreSQLParser::Type_modifiers_Context* PostgreSQLParser::GenerictypeContext::type_modifiers_() {
  return getRuleContext<PostgreSQLParser::Type_modifiers_Context>(0);
}


size_t PostgreSQLParser::GenerictypeContext::getRuleIndex() const {
  return PostgreSQLParser::RuleGenerictype;
}


std::any PostgreSQLParser::GenerictypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitGenerictype(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::GenerictypeContext* PostgreSQLParser::generictype() {
  GenerictypeContext *_localctx = _tracker.createInstance<GenerictypeContext>(_ctx, getState());
  enterRule(_localctx, 1126, PostgreSQLParser::RuleGenerictype);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8875);
    type_function_name();
    setState(8877);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 845, _ctx)) {
    case 1: {
      setState(8876);
      attrs();
      break;
    }

    default:
      break;
    }
    setState(8880);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 846, _ctx)) {
    case 1: {
      setState(8879);
      type_modifiers_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_modifiers_Context ------------------------------------------------------------------

PostgreSQLParser::Type_modifiers_Context::Type_modifiers_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Type_modifiers_Context::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::Type_modifiers_Context::expr_list() {
  return getRuleContext<PostgreSQLParser::Expr_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Type_modifiers_Context::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Type_modifiers_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleType_modifiers_;
}


std::any PostgreSQLParser::Type_modifiers_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitType_modifiers_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Type_modifiers_Context* PostgreSQLParser::type_modifiers_() {
  Type_modifiers_Context *_localctx = _tracker.createInstance<Type_modifiers_Context>(_ctx, getState());
  enterRule(_localctx, 1128, PostgreSQLParser::RuleType_modifiers_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8882);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(8883);
    expr_list();
    setState(8884);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericContext ------------------------------------------------------------------

PostgreSQLParser::NumericContext::NumericContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::NumericContext::INT_P() {
  return getToken(PostgreSQLParser::INT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::NumericContext::INTEGER() {
  return getToken(PostgreSQLParser::INTEGER, 0);
}

tree::TerminalNode* PostgreSQLParser::NumericContext::SMALLINT() {
  return getToken(PostgreSQLParser::SMALLINT, 0);
}

tree::TerminalNode* PostgreSQLParser::NumericContext::BIGINT() {
  return getToken(PostgreSQLParser::BIGINT, 0);
}

tree::TerminalNode* PostgreSQLParser::NumericContext::REAL() {
  return getToken(PostgreSQLParser::REAL, 0);
}

tree::TerminalNode* PostgreSQLParser::NumericContext::FLOAT_P() {
  return getToken(PostgreSQLParser::FLOAT_P, 0);
}

PostgreSQLParser::Float_Context* PostgreSQLParser::NumericContext::float_() {
  return getRuleContext<PostgreSQLParser::Float_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::NumericContext::DOUBLE_P() {
  return getToken(PostgreSQLParser::DOUBLE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::NumericContext::PRECISION() {
  return getToken(PostgreSQLParser::PRECISION, 0);
}

tree::TerminalNode* PostgreSQLParser::NumericContext::DECIMAL_P() {
  return getToken(PostgreSQLParser::DECIMAL_P, 0);
}

PostgreSQLParser::Type_modifiers_Context* PostgreSQLParser::NumericContext::type_modifiers_() {
  return getRuleContext<PostgreSQLParser::Type_modifiers_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::NumericContext::DEC() {
  return getToken(PostgreSQLParser::DEC, 0);
}

tree::TerminalNode* PostgreSQLParser::NumericContext::NUMERIC() {
  return getToken(PostgreSQLParser::NUMERIC, 0);
}

tree::TerminalNode* PostgreSQLParser::NumericContext::BOOLEAN_P() {
  return getToken(PostgreSQLParser::BOOLEAN_P, 0);
}


size_t PostgreSQLParser::NumericContext::getRuleIndex() const {
  return PostgreSQLParser::RuleNumeric;
}


std::any PostgreSQLParser::NumericContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitNumeric(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::NumericContext* PostgreSQLParser::numeric() {
  NumericContext *_localctx = _tracker.createInstance<NumericContext>(_ctx, getState());
  enterRule(_localctx, 1130, PostgreSQLParser::RuleNumeric);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8910);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::INT_P: {
        enterOuterAlt(_localctx, 1);
        setState(8886);
        match(PostgreSQLParser::INT_P);
        break;
      }

      case PostgreSQLParser::INTEGER: {
        enterOuterAlt(_localctx, 2);
        setState(8887);
        match(PostgreSQLParser::INTEGER);
        break;
      }

      case PostgreSQLParser::SMALLINT: {
        enterOuterAlt(_localctx, 3);
        setState(8888);
        match(PostgreSQLParser::SMALLINT);
        break;
      }

      case PostgreSQLParser::BIGINT: {
        enterOuterAlt(_localctx, 4);
        setState(8889);
        match(PostgreSQLParser::BIGINT);
        break;
      }

      case PostgreSQLParser::REAL: {
        enterOuterAlt(_localctx, 5);
        setState(8890);
        match(PostgreSQLParser::REAL);
        break;
      }

      case PostgreSQLParser::FLOAT_P: {
        enterOuterAlt(_localctx, 6);
        setState(8891);
        match(PostgreSQLParser::FLOAT_P);
        setState(8893);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 847, _ctx)) {
        case 1: {
          setState(8892);
          float_();
          break;
        }

        default:
          break;
        }
        break;
      }

      case PostgreSQLParser::DOUBLE_P: {
        enterOuterAlt(_localctx, 7);
        setState(8895);
        match(PostgreSQLParser::DOUBLE_P);
        setState(8896);
        match(PostgreSQLParser::PRECISION);
        break;
      }

      case PostgreSQLParser::DECIMAL_P: {
        enterOuterAlt(_localctx, 8);
        setState(8897);
        match(PostgreSQLParser::DECIMAL_P);
        setState(8899);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 848, _ctx)) {
        case 1: {
          setState(8898);
          type_modifiers_();
          break;
        }

        default:
          break;
        }
        break;
      }

      case PostgreSQLParser::DEC: {
        enterOuterAlt(_localctx, 9);
        setState(8901);
        match(PostgreSQLParser::DEC);
        setState(8903);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 849, _ctx)) {
        case 1: {
          setState(8902);
          type_modifiers_();
          break;
        }

        default:
          break;
        }
        break;
      }

      case PostgreSQLParser::NUMERIC: {
        enterOuterAlt(_localctx, 10);
        setState(8905);
        match(PostgreSQLParser::NUMERIC);
        setState(8907);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 850, _ctx)) {
        case 1: {
          setState(8906);
          type_modifiers_();
          break;
        }

        default:
          break;
        }
        break;
      }

      case PostgreSQLParser::BOOLEAN_P: {
        enterOuterAlt(_localctx, 11);
        setState(8909);
        match(PostgreSQLParser::BOOLEAN_P);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Float_Context ------------------------------------------------------------------

PostgreSQLParser::Float_Context::Float_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Float_Context::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::IconstContext* PostgreSQLParser::Float_Context::iconst() {
  return getRuleContext<PostgreSQLParser::IconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Float_Context::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Float_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleFloat_;
}


std::any PostgreSQLParser::Float_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFloat_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Float_Context* PostgreSQLParser::float_() {
  Float_Context *_localctx = _tracker.createInstance<Float_Context>(_ctx, getState());
  enterRule(_localctx, 1132, PostgreSQLParser::RuleFloat_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8912);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(8913);
    iconst();
    setState(8914);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitContext ------------------------------------------------------------------

PostgreSQLParser::BitContext::BitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::BitwithlengthContext* PostgreSQLParser::BitContext::bitwithlength() {
  return getRuleContext<PostgreSQLParser::BitwithlengthContext>(0);
}

PostgreSQLParser::BitwithoutlengthContext* PostgreSQLParser::BitContext::bitwithoutlength() {
  return getRuleContext<PostgreSQLParser::BitwithoutlengthContext>(0);
}


size_t PostgreSQLParser::BitContext::getRuleIndex() const {
  return PostgreSQLParser::RuleBit;
}


std::any PostgreSQLParser::BitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitBit(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::BitContext* PostgreSQLParser::bit() {
  BitContext *_localctx = _tracker.createInstance<BitContext>(_ctx, getState());
  enterRule(_localctx, 1134, PostgreSQLParser::RuleBit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8918);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 852, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8916);
      bitwithlength();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8917);
      bitwithoutlength();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstbitContext ------------------------------------------------------------------

PostgreSQLParser::ConstbitContext::ConstbitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::BitwithlengthContext* PostgreSQLParser::ConstbitContext::bitwithlength() {
  return getRuleContext<PostgreSQLParser::BitwithlengthContext>(0);
}

PostgreSQLParser::BitwithoutlengthContext* PostgreSQLParser::ConstbitContext::bitwithoutlength() {
  return getRuleContext<PostgreSQLParser::BitwithoutlengthContext>(0);
}


size_t PostgreSQLParser::ConstbitContext::getRuleIndex() const {
  return PostgreSQLParser::RuleConstbit;
}


std::any PostgreSQLParser::ConstbitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitConstbit(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ConstbitContext* PostgreSQLParser::constbit() {
  ConstbitContext *_localctx = _tracker.createInstance<ConstbitContext>(_ctx, getState());
  enterRule(_localctx, 1136, PostgreSQLParser::RuleConstbit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8922);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 853, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8920);
      bitwithlength();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8921);
      bitwithoutlength();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitwithlengthContext ------------------------------------------------------------------

PostgreSQLParser::BitwithlengthContext::BitwithlengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::BitwithlengthContext::BIT() {
  return getToken(PostgreSQLParser::BIT, 0);
}

tree::TerminalNode* PostgreSQLParser::BitwithlengthContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::BitwithlengthContext::expr_list() {
  return getRuleContext<PostgreSQLParser::Expr_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::BitwithlengthContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::Varying_Context* PostgreSQLParser::BitwithlengthContext::varying_() {
  return getRuleContext<PostgreSQLParser::Varying_Context>(0);
}


size_t PostgreSQLParser::BitwithlengthContext::getRuleIndex() const {
  return PostgreSQLParser::RuleBitwithlength;
}


std::any PostgreSQLParser::BitwithlengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitBitwithlength(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::BitwithlengthContext* PostgreSQLParser::bitwithlength() {
  BitwithlengthContext *_localctx = _tracker.createInstance<BitwithlengthContext>(_ctx, getState());
  enterRule(_localctx, 1138, PostgreSQLParser::RuleBitwithlength);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8924);
    match(PostgreSQLParser::BIT);
    setState(8926);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::VARYING) {
      setState(8925);
      varying_();
    }
    setState(8928);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(8929);
    expr_list();
    setState(8930);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitwithoutlengthContext ------------------------------------------------------------------

PostgreSQLParser::BitwithoutlengthContext::BitwithoutlengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::BitwithoutlengthContext::BIT() {
  return getToken(PostgreSQLParser::BIT, 0);
}

PostgreSQLParser::Varying_Context* PostgreSQLParser::BitwithoutlengthContext::varying_() {
  return getRuleContext<PostgreSQLParser::Varying_Context>(0);
}


size_t PostgreSQLParser::BitwithoutlengthContext::getRuleIndex() const {
  return PostgreSQLParser::RuleBitwithoutlength;
}


std::any PostgreSQLParser::BitwithoutlengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitBitwithoutlength(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::BitwithoutlengthContext* PostgreSQLParser::bitwithoutlength() {
  BitwithoutlengthContext *_localctx = _tracker.createInstance<BitwithoutlengthContext>(_ctx, getState());
  enterRule(_localctx, 1140, PostgreSQLParser::RuleBitwithoutlength);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8932);
    match(PostgreSQLParser::BIT);
    setState(8934);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 855, _ctx)) {
    case 1: {
      setState(8933);
      varying_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharacterContext ------------------------------------------------------------------

PostgreSQLParser::CharacterContext::CharacterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Character_cContext* PostgreSQLParser::CharacterContext::character_c() {
  return getRuleContext<PostgreSQLParser::Character_cContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CharacterContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::IconstContext* PostgreSQLParser::CharacterContext::iconst() {
  return getRuleContext<PostgreSQLParser::IconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::CharacterContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::CharacterContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCharacter;
}


std::any PostgreSQLParser::CharacterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCharacter(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::CharacterContext* PostgreSQLParser::character() {
  CharacterContext *_localctx = _tracker.createInstance<CharacterContext>(_ctx, getState());
  enterRule(_localctx, 1142, PostgreSQLParser::RuleCharacter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8936);
    character_c();
    setState(8941);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 856, _ctx)) {
    case 1: {
      setState(8937);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(8938);
      iconst();
      setState(8939);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstcharacterContext ------------------------------------------------------------------

PostgreSQLParser::ConstcharacterContext::ConstcharacterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Character_cContext* PostgreSQLParser::ConstcharacterContext::character_c() {
  return getRuleContext<PostgreSQLParser::Character_cContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ConstcharacterContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::IconstContext* PostgreSQLParser::ConstcharacterContext::iconst() {
  return getRuleContext<PostgreSQLParser::IconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ConstcharacterContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::ConstcharacterContext::getRuleIndex() const {
  return PostgreSQLParser::RuleConstcharacter;
}


std::any PostgreSQLParser::ConstcharacterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitConstcharacter(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ConstcharacterContext* PostgreSQLParser::constcharacter() {
  ConstcharacterContext *_localctx = _tracker.createInstance<ConstcharacterContext>(_ctx, getState());
  enterRule(_localctx, 1144, PostgreSQLParser::RuleConstcharacter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8943);
    character_c();
    setState(8948);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OPEN_PAREN) {
      setState(8944);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(8945);
      iconst();
      setState(8946);
      match(PostgreSQLParser::CLOSE_PAREN);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Character_cContext ------------------------------------------------------------------

PostgreSQLParser::Character_cContext::Character_cContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Character_cContext::CHARACTER() {
  return getToken(PostgreSQLParser::CHARACTER, 0);
}

tree::TerminalNode* PostgreSQLParser::Character_cContext::CHAR_P() {
  return getToken(PostgreSQLParser::CHAR_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Character_cContext::NCHAR() {
  return getToken(PostgreSQLParser::NCHAR, 0);
}

PostgreSQLParser::Varying_Context* PostgreSQLParser::Character_cContext::varying_() {
  return getRuleContext<PostgreSQLParser::Varying_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::Character_cContext::VARCHAR() {
  return getToken(PostgreSQLParser::VARCHAR, 0);
}

tree::TerminalNode* PostgreSQLParser::Character_cContext::NATIONAL() {
  return getToken(PostgreSQLParser::NATIONAL, 0);
}


size_t PostgreSQLParser::Character_cContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCharacter_c;
}


std::any PostgreSQLParser::Character_cContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCharacter_c(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Character_cContext* PostgreSQLParser::character_c() {
  Character_cContext *_localctx = _tracker.createInstance<Character_cContext>(_ctx, getState());
  enterRule(_localctx, 1146, PostgreSQLParser::RuleCharacter_c);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8960);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::NCHAR: {
        enterOuterAlt(_localctx, 1);
        setState(8950);
        _la = _input->LA(1);
        if (!(((((_la - 422) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 422)) & 32771) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(8952);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 858, _ctx)) {
        case 1: {
          setState(8951);
          varying_();
          break;
        }

        default:
          break;
        }
        break;
      }

      case PostgreSQLParser::VARCHAR: {
        enterOuterAlt(_localctx, 2);
        setState(8954);
        match(PostgreSQLParser::VARCHAR);
        break;
      }

      case PostgreSQLParser::NATIONAL: {
        enterOuterAlt(_localctx, 3);
        setState(8955);
        match(PostgreSQLParser::NATIONAL);
        setState(8956);
        _la = _input->LA(1);
        if (!(_la == PostgreSQLParser::CHAR_P

        || _la == PostgreSQLParser::CHARACTER)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(8958);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 859, _ctx)) {
        case 1: {
          setState(8957);
          varying_();
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Varying_Context ------------------------------------------------------------------

PostgreSQLParser::Varying_Context::Varying_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Varying_Context::VARYING() {
  return getToken(PostgreSQLParser::VARYING, 0);
}


size_t PostgreSQLParser::Varying_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleVarying_;
}


std::any PostgreSQLParser::Varying_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitVarying_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Varying_Context* PostgreSQLParser::varying_() {
  Varying_Context *_localctx = _tracker.createInstance<Varying_Context>(_ctx, getState());
  enterRule(_localctx, 1148, PostgreSQLParser::RuleVarying_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8962);
    match(PostgreSQLParser::VARYING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstdatetimeContext ------------------------------------------------------------------

PostgreSQLParser::ConstdatetimeContext::ConstdatetimeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::ConstdatetimeContext::TIMESTAMP() {
  return getToken(PostgreSQLParser::TIMESTAMP, 0);
}

tree::TerminalNode* PostgreSQLParser::ConstdatetimeContext::TIME() {
  return getToken(PostgreSQLParser::TIME, 0);
}

tree::TerminalNode* PostgreSQLParser::ConstdatetimeContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::IconstContext* PostgreSQLParser::ConstdatetimeContext::iconst() {
  return getRuleContext<PostgreSQLParser::IconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ConstdatetimeContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::Timezone_Context* PostgreSQLParser::ConstdatetimeContext::timezone_() {
  return getRuleContext<PostgreSQLParser::Timezone_Context>(0);
}


size_t PostgreSQLParser::ConstdatetimeContext::getRuleIndex() const {
  return PostgreSQLParser::RuleConstdatetime;
}


std::any PostgreSQLParser::ConstdatetimeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitConstdatetime(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ConstdatetimeContext* PostgreSQLParser::constdatetime() {
  ConstdatetimeContext *_localctx = _tracker.createInstance<ConstdatetimeContext>(_ctx, getState());
  enterRule(_localctx, 1150, PostgreSQLParser::RuleConstdatetime);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8964);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::TIME

    || _la == PostgreSQLParser::TIMESTAMP)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(8969);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 861, _ctx)) {
    case 1: {
      setState(8965);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(8966);
      iconst();
      setState(8967);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    default:
      break;
    }
    setState(8972);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 862, _ctx)) {
    case 1: {
      setState(8971);
      timezone_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstintervalContext ------------------------------------------------------------------

PostgreSQLParser::ConstintervalContext::ConstintervalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::ConstintervalContext::INTERVAL() {
  return getToken(PostgreSQLParser::INTERVAL, 0);
}


size_t PostgreSQLParser::ConstintervalContext::getRuleIndex() const {
  return PostgreSQLParser::RuleConstinterval;
}


std::any PostgreSQLParser::ConstintervalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitConstinterval(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ConstintervalContext* PostgreSQLParser::constinterval() {
  ConstintervalContext *_localctx = _tracker.createInstance<ConstintervalContext>(_ctx, getState());
  enterRule(_localctx, 1152, PostgreSQLParser::RuleConstinterval);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8974);
    match(PostgreSQLParser::INTERVAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timezone_Context ------------------------------------------------------------------

PostgreSQLParser::Timezone_Context::Timezone_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Timezone_Context::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

tree::TerminalNode* PostgreSQLParser::Timezone_Context::TIME() {
  return getToken(PostgreSQLParser::TIME, 0);
}

tree::TerminalNode* PostgreSQLParser::Timezone_Context::ZONE() {
  return getToken(PostgreSQLParser::ZONE, 0);
}

tree::TerminalNode* PostgreSQLParser::Timezone_Context::WITHOUT() {
  return getToken(PostgreSQLParser::WITHOUT, 0);
}


size_t PostgreSQLParser::Timezone_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleTimezone_;
}


std::any PostgreSQLParser::Timezone_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTimezone_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Timezone_Context* PostgreSQLParser::timezone_() {
  Timezone_Context *_localctx = _tracker.createInstance<Timezone_Context>(_ctx, getState());
  enterRule(_localctx, 1154, PostgreSQLParser::RuleTimezone_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8982);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::WITH: {
        enterOuterAlt(_localctx, 1);
        setState(8976);
        match(PostgreSQLParser::WITH);
        setState(8977);
        match(PostgreSQLParser::TIME);
        setState(8978);
        match(PostgreSQLParser::ZONE);
        break;
      }

      case PostgreSQLParser::WITHOUT: {
        enterOuterAlt(_localctx, 2);
        setState(8979);
        match(PostgreSQLParser::WITHOUT);
        setState(8980);
        match(PostgreSQLParser::TIME);
        setState(8981);
        match(PostgreSQLParser::ZONE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Interval_Context ------------------------------------------------------------------

PostgreSQLParser::Interval_Context::Interval_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Interval_Context::YEAR_P() {
  return getToken(PostgreSQLParser::YEAR_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Interval_Context::MONTH_P() {
  return getToken(PostgreSQLParser::MONTH_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Interval_Context::DAY_P() {
  return getToken(PostgreSQLParser::DAY_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Interval_Context::HOUR_P() {
  return getToken(PostgreSQLParser::HOUR_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Interval_Context::MINUTE_P() {
  return getToken(PostgreSQLParser::MINUTE_P, 0);
}

PostgreSQLParser::Interval_secondContext* PostgreSQLParser::Interval_Context::interval_second() {
  return getRuleContext<PostgreSQLParser::Interval_secondContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Interval_Context::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}


size_t PostgreSQLParser::Interval_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleInterval_;
}


std::any PostgreSQLParser::Interval_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitInterval_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Interval_Context* PostgreSQLParser::interval_() {
  Interval_Context *_localctx = _tracker.createInstance<Interval_Context>(_ctx, getState());
  enterRule(_localctx, 1156, PostgreSQLParser::RuleInterval_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9009);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 866, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8984);
      match(PostgreSQLParser::YEAR_P);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8985);
      match(PostgreSQLParser::MONTH_P);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(8986);
      match(PostgreSQLParser::DAY_P);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(8987);
      match(PostgreSQLParser::HOUR_P);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(8988);
      match(PostgreSQLParser::MINUTE_P);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(8989);
      interval_second();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(8990);
      match(PostgreSQLParser::YEAR_P);
      setState(8991);
      match(PostgreSQLParser::TO);
      setState(8992);
      match(PostgreSQLParser::MONTH_P);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(8993);
      match(PostgreSQLParser::DAY_P);
      setState(8994);
      match(PostgreSQLParser::TO);
      setState(8998);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case PostgreSQLParser::HOUR_P: {
          setState(8995);
          match(PostgreSQLParser::HOUR_P);
          break;
        }

        case PostgreSQLParser::MINUTE_P: {
          setState(8996);
          match(PostgreSQLParser::MINUTE_P);
          break;
        }

        case PostgreSQLParser::SECOND_P: {
          setState(8997);
          interval_second();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(9000);
      match(PostgreSQLParser::HOUR_P);
      setState(9001);
      match(PostgreSQLParser::TO);
      setState(9004);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case PostgreSQLParser::MINUTE_P: {
          setState(9002);
          match(PostgreSQLParser::MINUTE_P);
          break;
        }

        case PostgreSQLParser::SECOND_P: {
          setState(9003);
          interval_second();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(9006);
      match(PostgreSQLParser::MINUTE_P);
      setState(9007);
      match(PostgreSQLParser::TO);
      setState(9008);
      interval_second();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Interval_secondContext ------------------------------------------------------------------

PostgreSQLParser::Interval_secondContext::Interval_secondContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Interval_secondContext::SECOND_P() {
  return getToken(PostgreSQLParser::SECOND_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Interval_secondContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::IconstContext* PostgreSQLParser::Interval_secondContext::iconst() {
  return getRuleContext<PostgreSQLParser::IconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Interval_secondContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Interval_secondContext::getRuleIndex() const {
  return PostgreSQLParser::RuleInterval_second;
}


std::any PostgreSQLParser::Interval_secondContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitInterval_second(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Interval_secondContext* PostgreSQLParser::interval_second() {
  Interval_secondContext *_localctx = _tracker.createInstance<Interval_secondContext>(_ctx, getState());
  enterRule(_localctx, 1158, PostgreSQLParser::RuleInterval_second);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9011);
    match(PostgreSQLParser::SECOND_P);
    setState(9016);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 867, _ctx)) {
    case 1: {
      setState(9012);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(9013);
      iconst();
      setState(9014);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JsonTypeContext ------------------------------------------------------------------

PostgreSQLParser::JsonTypeContext::JsonTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::JsonTypeContext::JSON() {
  return getToken(PostgreSQLParser::JSON, 0);
}


size_t PostgreSQLParser::JsonTypeContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJsonType;
}


std::any PostgreSQLParser::JsonTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJsonType(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::JsonTypeContext* PostgreSQLParser::jsonType() {
  JsonTypeContext *_localctx = _tracker.createInstance<JsonTypeContext>(_ctx, getState());
  enterRule(_localctx, 1160, PostgreSQLParser::RuleJsonType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9018);
    match(PostgreSQLParser::JSON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Escape_Context ------------------------------------------------------------------

PostgreSQLParser::Escape_Context::Escape_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Escape_Context::ESCAPE() {
  return getToken(PostgreSQLParser::ESCAPE, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Escape_Context::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}


size_t PostgreSQLParser::Escape_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleEscape_;
}


std::any PostgreSQLParser::Escape_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitEscape_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Escape_Context* PostgreSQLParser::escape_() {
  Escape_Context *_localctx = _tracker.createInstance<Escape_Context>(_ctx, getState());
  enterRule(_localctx, 1162, PostgreSQLParser::RuleEscape_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9020);
    match(PostgreSQLParser::ESCAPE);
    setState(9021);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_exprContext ------------------------------------------------------------------

PostgreSQLParser::A_exprContext::A_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::A_expr_qualContext* PostgreSQLParser::A_exprContext::a_expr_qual() {
  return getRuleContext<PostgreSQLParser::A_expr_qualContext>(0);
}


size_t PostgreSQLParser::A_exprContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr;
}


std::any PostgreSQLParser::A_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::a_expr() {
  A_exprContext *_localctx = _tracker.createInstance<A_exprContext>(_ctx, getState());
  enterRule(_localctx, 1164, PostgreSQLParser::RuleA_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9023);
    a_expr_qual();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_qualContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_qualContext::A_expr_qualContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::A_expr_lesslessContext* PostgreSQLParser::A_expr_qualContext::a_expr_lessless() {
  return getRuleContext<PostgreSQLParser::A_expr_lesslessContext>(0);
}

PostgreSQLParser::Qual_opContext* PostgreSQLParser::A_expr_qualContext::qual_op() {
  return getRuleContext<PostgreSQLParser::Qual_opContext>(0);
}


size_t PostgreSQLParser::A_expr_qualContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_qual;
}


std::any PostgreSQLParser::A_expr_qualContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_qual(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_qualContext* PostgreSQLParser::a_expr_qual() {
  A_expr_qualContext *_localctx = _tracker.createInstance<A_expr_qualContext>(_ctx, getState());
  enterRule(_localctx, 1166, PostgreSQLParser::RuleA_expr_qual);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9025);
    a_expr_lessless();
    setState(9029);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 868, _ctx)) {
    case 1: {
      setState(9026);

      if (!(this->OnlyAcceptableOps())) throw FailedPredicateException(this, "this.OnlyAcceptableOps()");
      setState(9027);
      qual_op();
      break;
    }

    case 2: {
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_lesslessContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_lesslessContext::A_expr_lesslessContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::A_expr_orContext *> PostgreSQLParser::A_expr_lesslessContext::a_expr_or() {
  return getRuleContexts<PostgreSQLParser::A_expr_orContext>();
}

PostgreSQLParser::A_expr_orContext* PostgreSQLParser::A_expr_lesslessContext::a_expr_or(size_t i) {
  return getRuleContext<PostgreSQLParser::A_expr_orContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::A_expr_lesslessContext::LESS_LESS() {
  return getTokens(PostgreSQLParser::LESS_LESS);
}

tree::TerminalNode* PostgreSQLParser::A_expr_lesslessContext::LESS_LESS(size_t i) {
  return getToken(PostgreSQLParser::LESS_LESS, i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::A_expr_lesslessContext::GREATER_GREATER() {
  return getTokens(PostgreSQLParser::GREATER_GREATER);
}

tree::TerminalNode* PostgreSQLParser::A_expr_lesslessContext::GREATER_GREATER(size_t i) {
  return getToken(PostgreSQLParser::GREATER_GREATER, i);
}


size_t PostgreSQLParser::A_expr_lesslessContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_lessless;
}


std::any PostgreSQLParser::A_expr_lesslessContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_lessless(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_lesslessContext* PostgreSQLParser::a_expr_lessless() {
  A_expr_lesslessContext *_localctx = _tracker.createInstance<A_expr_lesslessContext>(_ctx, getState());
  enterRule(_localctx, 1168, PostgreSQLParser::RuleA_expr_lessless);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9031);
    a_expr_or();
    setState(9036);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 869, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(9032);
        _la = _input->LA(1);
        if (!(_la == PostgreSQLParser::LESS_LESS

        || _la == PostgreSQLParser::GREATER_GREATER)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(9033);
        a_expr_or(); 
      }
      setState(9038);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 869, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_orContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_orContext::A_expr_orContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::A_expr_andContext *> PostgreSQLParser::A_expr_orContext::a_expr_and() {
  return getRuleContexts<PostgreSQLParser::A_expr_andContext>();
}

PostgreSQLParser::A_expr_andContext* PostgreSQLParser::A_expr_orContext::a_expr_and(size_t i) {
  return getRuleContext<PostgreSQLParser::A_expr_andContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::A_expr_orContext::OR() {
  return getTokens(PostgreSQLParser::OR);
}

tree::TerminalNode* PostgreSQLParser::A_expr_orContext::OR(size_t i) {
  return getToken(PostgreSQLParser::OR, i);
}


size_t PostgreSQLParser::A_expr_orContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_or;
}


std::any PostgreSQLParser::A_expr_orContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_or(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_orContext* PostgreSQLParser::a_expr_or() {
  A_expr_orContext *_localctx = _tracker.createInstance<A_expr_orContext>(_ctx, getState());
  enterRule(_localctx, 1170, PostgreSQLParser::RuleA_expr_or);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9039);
    a_expr_and();
    setState(9044);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 870, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(9040);
        match(PostgreSQLParser::OR);
        setState(9041);
        a_expr_and(); 
      }
      setState(9046);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 870, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_andContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_andContext::A_expr_andContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::A_expr_betweenContext *> PostgreSQLParser::A_expr_andContext::a_expr_between() {
  return getRuleContexts<PostgreSQLParser::A_expr_betweenContext>();
}

PostgreSQLParser::A_expr_betweenContext* PostgreSQLParser::A_expr_andContext::a_expr_between(size_t i) {
  return getRuleContext<PostgreSQLParser::A_expr_betweenContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::A_expr_andContext::AND() {
  return getTokens(PostgreSQLParser::AND);
}

tree::TerminalNode* PostgreSQLParser::A_expr_andContext::AND(size_t i) {
  return getToken(PostgreSQLParser::AND, i);
}


size_t PostgreSQLParser::A_expr_andContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_and;
}


std::any PostgreSQLParser::A_expr_andContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_and(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_andContext* PostgreSQLParser::a_expr_and() {
  A_expr_andContext *_localctx = _tracker.createInstance<A_expr_andContext>(_ctx, getState());
  enterRule(_localctx, 1172, PostgreSQLParser::RuleA_expr_and);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9047);
    a_expr_between();
    setState(9052);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 871, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(9048);
        match(PostgreSQLParser::AND);
        setState(9049);
        a_expr_between(); 
      }
      setState(9054);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 871, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_betweenContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_betweenContext::A_expr_betweenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::A_expr_inContext *> PostgreSQLParser::A_expr_betweenContext::a_expr_in() {
  return getRuleContexts<PostgreSQLParser::A_expr_inContext>();
}

PostgreSQLParser::A_expr_inContext* PostgreSQLParser::A_expr_betweenContext::a_expr_in(size_t i) {
  return getRuleContext<PostgreSQLParser::A_expr_inContext>(i);
}

tree::TerminalNode* PostgreSQLParser::A_expr_betweenContext::BETWEEN() {
  return getToken(PostgreSQLParser::BETWEEN, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_betweenContext::AND() {
  return getToken(PostgreSQLParser::AND, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_betweenContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_betweenContext::SYMMETRIC() {
  return getToken(PostgreSQLParser::SYMMETRIC, 0);
}


size_t PostgreSQLParser::A_expr_betweenContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_between;
}


std::any PostgreSQLParser::A_expr_betweenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_between(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_betweenContext* PostgreSQLParser::a_expr_between() {
  A_expr_betweenContext *_localctx = _tracker.createInstance<A_expr_betweenContext>(_ctx, getState());
  enterRule(_localctx, 1174, PostgreSQLParser::RuleA_expr_between);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9055);
    a_expr_in();
    setState(9067);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 874, _ctx)) {
    case 1: {
      setState(9057);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::NOT) {
        setState(9056);
        match(PostgreSQLParser::NOT);
      }
      setState(9059);
      match(PostgreSQLParser::BETWEEN);
      setState(9061);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::SYMMETRIC) {
        setState(9060);
        match(PostgreSQLParser::SYMMETRIC);
      }
      setState(9063);
      a_expr_in();
      setState(9064);
      match(PostgreSQLParser::AND);
      setState(9065);
      a_expr_in();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_inContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_inContext::A_expr_inContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::A_expr_unary_notContext* PostgreSQLParser::A_expr_inContext::a_expr_unary_not() {
  return getRuleContext<PostgreSQLParser::A_expr_unary_notContext>(0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_inContext::IN_P() {
  return getToken(PostgreSQLParser::IN_P, 0);
}

PostgreSQLParser::In_exprContext* PostgreSQLParser::A_expr_inContext::in_expr() {
  return getRuleContext<PostgreSQLParser::In_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_inContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}


size_t PostgreSQLParser::A_expr_inContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_in;
}


std::any PostgreSQLParser::A_expr_inContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_in(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_inContext* PostgreSQLParser::a_expr_in() {
  A_expr_inContext *_localctx = _tracker.createInstance<A_expr_inContext>(_ctx, getState());
  enterRule(_localctx, 1176, PostgreSQLParser::RuleA_expr_in);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9069);
    a_expr_unary_not();
    setState(9075);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 876, _ctx)) {
    case 1: {
      setState(9071);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::NOT) {
        setState(9070);
        match(PostgreSQLParser::NOT);
      }
      setState(9073);
      match(PostgreSQLParser::IN_P);
      setState(9074);
      in_expr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_unary_notContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_unary_notContext::A_expr_unary_notContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::A_expr_isnullContext* PostgreSQLParser::A_expr_unary_notContext::a_expr_isnull() {
  return getRuleContext<PostgreSQLParser::A_expr_isnullContext>(0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_unary_notContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}


size_t PostgreSQLParser::A_expr_unary_notContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_unary_not;
}


std::any PostgreSQLParser::A_expr_unary_notContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_unary_not(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_unary_notContext* PostgreSQLParser::a_expr_unary_not() {
  A_expr_unary_notContext *_localctx = _tracker.createInstance<A_expr_unary_notContext>(_ctx, getState());
  enterRule(_localctx, 1178, PostgreSQLParser::RuleA_expr_unary_not);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9078);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::NOT) {
      setState(9077);
      match(PostgreSQLParser::NOT);
    }
    setState(9080);
    a_expr_isnull();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_isnullContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_isnullContext::A_expr_isnullContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::A_expr_is_notContext* PostgreSQLParser::A_expr_isnullContext::a_expr_is_not() {
  return getRuleContext<PostgreSQLParser::A_expr_is_notContext>(0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_isnullContext::ISNULL() {
  return getToken(PostgreSQLParser::ISNULL, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_isnullContext::NOTNULL() {
  return getToken(PostgreSQLParser::NOTNULL, 0);
}


size_t PostgreSQLParser::A_expr_isnullContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_isnull;
}


std::any PostgreSQLParser::A_expr_isnullContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_isnull(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_isnullContext* PostgreSQLParser::a_expr_isnull() {
  A_expr_isnullContext *_localctx = _tracker.createInstance<A_expr_isnullContext>(_ctx, getState());
  enterRule(_localctx, 1180, PostgreSQLParser::RuleA_expr_isnull);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9082);
    a_expr_is_not();
    setState(9084);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 878, _ctx)) {
    case 1: {
      setState(9083);
      _la = _input->LA(1);
      if (!(_la == PostgreSQLParser::ISNULL

      || _la == PostgreSQLParser::NOTNULL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_is_notContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_is_notContext::A_expr_is_notContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::A_expr_compareContext* PostgreSQLParser::A_expr_is_notContext::a_expr_compare() {
  return getRuleContext<PostgreSQLParser::A_expr_compareContext>(0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_is_notContext::IS() {
  return getToken(PostgreSQLParser::IS, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_is_notContext::NULL_P() {
  return getToken(PostgreSQLParser::NULL_P, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_is_notContext::TRUE_P() {
  return getToken(PostgreSQLParser::TRUE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_is_notContext::FALSE_P() {
  return getToken(PostgreSQLParser::FALSE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_is_notContext::UNKNOWN() {
  return getToken(PostgreSQLParser::UNKNOWN, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_is_notContext::DISTINCT() {
  return getToken(PostgreSQLParser::DISTINCT, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_is_notContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::A_expr_is_notContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_is_notContext::OF() {
  return getToken(PostgreSQLParser::OF, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_is_notContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Type_listContext* PostgreSQLParser::A_expr_is_notContext::type_list() {
  return getRuleContext<PostgreSQLParser::Type_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_is_notContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_is_notContext::DOCUMENT_P() {
  return getToken(PostgreSQLParser::DOCUMENT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_is_notContext::NORMALIZED() {
  return getToken(PostgreSQLParser::NORMALIZED, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_is_notContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

PostgreSQLParser::Unicode_normal_formContext* PostgreSQLParser::A_expr_is_notContext::unicode_normal_form() {
  return getRuleContext<PostgreSQLParser::Unicode_normal_formContext>(0);
}


size_t PostgreSQLParser::A_expr_is_notContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_is_not;
}


std::any PostgreSQLParser::A_expr_is_notContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_is_not(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_is_notContext* PostgreSQLParser::a_expr_is_not() {
  A_expr_is_notContext *_localctx = _tracker.createInstance<A_expr_is_notContext>(_ctx, getState());
  enterRule(_localctx, 1182, PostgreSQLParser::RuleA_expr_is_not);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9086);
    a_expr_compare();
    setState(9110);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 882, _ctx)) {
    case 1: {
      setState(9087);
      match(PostgreSQLParser::IS);
      setState(9089);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::NOT) {
        setState(9088);
        match(PostgreSQLParser::NOT);
      }
      setState(9108);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case PostgreSQLParser::NULL_P: {
          setState(9091);
          match(PostgreSQLParser::NULL_P);
          break;
        }

        case PostgreSQLParser::TRUE_P: {
          setState(9092);
          match(PostgreSQLParser::TRUE_P);
          break;
        }

        case PostgreSQLParser::FALSE_P: {
          setState(9093);
          match(PostgreSQLParser::FALSE_P);
          break;
        }

        case PostgreSQLParser::UNKNOWN: {
          setState(9094);
          match(PostgreSQLParser::UNKNOWN);
          break;
        }

        case PostgreSQLParser::DISTINCT: {
          setState(9095);
          match(PostgreSQLParser::DISTINCT);
          setState(9096);
          match(PostgreSQLParser::FROM);
          setState(9097);
          a_expr();
          break;
        }

        case PostgreSQLParser::OF: {
          setState(9098);
          match(PostgreSQLParser::OF);
          setState(9099);
          match(PostgreSQLParser::OPEN_PAREN);
          setState(9100);
          type_list();
          setState(9101);
          match(PostgreSQLParser::CLOSE_PAREN);
          break;
        }

        case PostgreSQLParser::DOCUMENT_P: {
          setState(9103);
          match(PostgreSQLParser::DOCUMENT_P);
          break;
        }

        case PostgreSQLParser::NORMALIZED:
        case PostgreSQLParser::NFC:
        case PostgreSQLParser::NFD:
        case PostgreSQLParser::NFKC:
        case PostgreSQLParser::NFKD: {
          setState(9105);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (((((_la - 521) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 521)) & 15) != 0)) {
            setState(9104);
            unicode_normal_form();
          }
          setState(9107);
          match(PostgreSQLParser::NORMALIZED);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_compareContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_compareContext::A_expr_compareContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::A_expr_likeContext *> PostgreSQLParser::A_expr_compareContext::a_expr_like() {
  return getRuleContexts<PostgreSQLParser::A_expr_likeContext>();
}

PostgreSQLParser::A_expr_likeContext* PostgreSQLParser::A_expr_compareContext::a_expr_like(size_t i) {
  return getRuleContext<PostgreSQLParser::A_expr_likeContext>(i);
}

PostgreSQLParser::Subquery_OpContext* PostgreSQLParser::A_expr_compareContext::subquery_Op() {
  return getRuleContext<PostgreSQLParser::Subquery_OpContext>(0);
}

PostgreSQLParser::Sub_typeContext* PostgreSQLParser::A_expr_compareContext::sub_type() {
  return getRuleContext<PostgreSQLParser::Sub_typeContext>(0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_compareContext::LT() {
  return getToken(PostgreSQLParser::LT, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_compareContext::GT() {
  return getToken(PostgreSQLParser::GT, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_compareContext::EQUAL() {
  return getToken(PostgreSQLParser::EQUAL, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_compareContext::LESS_EQUALS() {
  return getToken(PostgreSQLParser::LESS_EQUALS, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_compareContext::GREATER_EQUALS() {
  return getToken(PostgreSQLParser::GREATER_EQUALS, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_compareContext::NOT_EQUALS() {
  return getToken(PostgreSQLParser::NOT_EQUALS, 0);
}

PostgreSQLParser::Select_with_parensContext* PostgreSQLParser::A_expr_compareContext::select_with_parens() {
  return getRuleContext<PostgreSQLParser::Select_with_parensContext>(0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_compareContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::A_expr_compareContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_compareContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::A_expr_compareContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_compare;
}


std::any PostgreSQLParser::A_expr_compareContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_compare(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_compareContext* PostgreSQLParser::a_expr_compare() {
  A_expr_compareContext *_localctx = _tracker.createInstance<A_expr_compareContext>(_ctx, getState());
  enterRule(_localctx, 1184, PostgreSQLParser::RuleA_expr_compare);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9112);
    a_expr_like();
    setState(9124);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 884, _ctx)) {
    case 1: {
      setState(9113);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 44237824) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(9114);
      a_expr_like();
      break;
    }

    case 2: {
      setState(9115);
      subquery_Op();
      setState(9116);
      sub_type();
      setState(9122);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 883, _ctx)) {
      case 1: {
        setState(9117);
        select_with_parens();
        break;
      }

      case 2: {
        setState(9118);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9119);
        a_expr();
        setState(9120);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_likeContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_likeContext::A_expr_likeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::A_expr_qual_opContext *> PostgreSQLParser::A_expr_likeContext::a_expr_qual_op() {
  return getRuleContexts<PostgreSQLParser::A_expr_qual_opContext>();
}

PostgreSQLParser::A_expr_qual_opContext* PostgreSQLParser::A_expr_likeContext::a_expr_qual_op(size_t i) {
  return getRuleContext<PostgreSQLParser::A_expr_qual_opContext>(i);
}

tree::TerminalNode* PostgreSQLParser::A_expr_likeContext::LIKE() {
  return getToken(PostgreSQLParser::LIKE, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_likeContext::ILIKE() {
  return getToken(PostgreSQLParser::ILIKE, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_likeContext::SIMILAR() {
  return getToken(PostgreSQLParser::SIMILAR, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_likeContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_likeContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

PostgreSQLParser::Escape_Context* PostgreSQLParser::A_expr_likeContext::escape_() {
  return getRuleContext<PostgreSQLParser::Escape_Context>(0);
}


size_t PostgreSQLParser::A_expr_likeContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_like;
}


std::any PostgreSQLParser::A_expr_likeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_like(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_likeContext* PostgreSQLParser::a_expr_like() {
  A_expr_likeContext *_localctx = _tracker.createInstance<A_expr_likeContext>(_ctx, getState());
  enterRule(_localctx, 1186, PostgreSQLParser::RuleA_expr_like);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9126);
    a_expr_qual_op();
    setState(9140);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 888, _ctx)) {
    case 1: {
      setState(9128);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == PostgreSQLParser::NOT) {
        setState(9127);
        match(PostgreSQLParser::NOT);
      }
      setState(9134);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case PostgreSQLParser::LIKE: {
          setState(9130);
          match(PostgreSQLParser::LIKE);
          break;
        }

        case PostgreSQLParser::ILIKE: {
          setState(9131);
          match(PostgreSQLParser::ILIKE);
          break;
        }

        case PostgreSQLParser::SIMILAR: {
          setState(9132);
          match(PostgreSQLParser::SIMILAR);
          setState(9133);
          match(PostgreSQLParser::TO);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(9136);
      a_expr_qual_op();
      setState(9138);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 887, _ctx)) {
      case 1: {
        setState(9137);
        escape_();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_qual_opContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_qual_opContext::A_expr_qual_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::A_expr_unary_qualopContext *> PostgreSQLParser::A_expr_qual_opContext::a_expr_unary_qualop() {
  return getRuleContexts<PostgreSQLParser::A_expr_unary_qualopContext>();
}

PostgreSQLParser::A_expr_unary_qualopContext* PostgreSQLParser::A_expr_qual_opContext::a_expr_unary_qualop(size_t i) {
  return getRuleContext<PostgreSQLParser::A_expr_unary_qualopContext>(i);
}

std::vector<PostgreSQLParser::Qual_opContext *> PostgreSQLParser::A_expr_qual_opContext::qual_op() {
  return getRuleContexts<PostgreSQLParser::Qual_opContext>();
}

PostgreSQLParser::Qual_opContext* PostgreSQLParser::A_expr_qual_opContext::qual_op(size_t i) {
  return getRuleContext<PostgreSQLParser::Qual_opContext>(i);
}


size_t PostgreSQLParser::A_expr_qual_opContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_qual_op;
}


std::any PostgreSQLParser::A_expr_qual_opContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_qual_op(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_qual_opContext* PostgreSQLParser::a_expr_qual_op() {
  A_expr_qual_opContext *_localctx = _tracker.createInstance<A_expr_qual_opContext>(_ctx, getState());
  enterRule(_localctx, 1188, PostgreSQLParser::RuleA_expr_qual_op);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9142);
    a_expr_unary_qualop();
    setState(9148);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 889, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(9143);
        qual_op();
        setState(9144);
        a_expr_unary_qualop(); 
      }
      setState(9150);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 889, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_unary_qualopContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_unary_qualopContext::A_expr_unary_qualopContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::A_expr_addContext* PostgreSQLParser::A_expr_unary_qualopContext::a_expr_add() {
  return getRuleContext<PostgreSQLParser::A_expr_addContext>(0);
}

PostgreSQLParser::Qual_opContext* PostgreSQLParser::A_expr_unary_qualopContext::qual_op() {
  return getRuleContext<PostgreSQLParser::Qual_opContext>(0);
}


size_t PostgreSQLParser::A_expr_unary_qualopContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_unary_qualop;
}


std::any PostgreSQLParser::A_expr_unary_qualopContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_unary_qualop(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_unary_qualopContext* PostgreSQLParser::a_expr_unary_qualop() {
  A_expr_unary_qualopContext *_localctx = _tracker.createInstance<A_expr_unary_qualopContext>(_ctx, getState());
  enterRule(_localctx, 1190, PostgreSQLParser::RuleA_expr_unary_qualop);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9152);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 890, _ctx)) {
    case 1: {
      setState(9151);
      qual_op();
      break;
    }

    default:
      break;
    }
    setState(9154);
    a_expr_add();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_addContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_addContext::A_expr_addContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::A_expr_mulContext *> PostgreSQLParser::A_expr_addContext::a_expr_mul() {
  return getRuleContexts<PostgreSQLParser::A_expr_mulContext>();
}

PostgreSQLParser::A_expr_mulContext* PostgreSQLParser::A_expr_addContext::a_expr_mul(size_t i) {
  return getRuleContext<PostgreSQLParser::A_expr_mulContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::A_expr_addContext::MINUS() {
  return getTokens(PostgreSQLParser::MINUS);
}

tree::TerminalNode* PostgreSQLParser::A_expr_addContext::MINUS(size_t i) {
  return getToken(PostgreSQLParser::MINUS, i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::A_expr_addContext::PLUS() {
  return getTokens(PostgreSQLParser::PLUS);
}

tree::TerminalNode* PostgreSQLParser::A_expr_addContext::PLUS(size_t i) {
  return getToken(PostgreSQLParser::PLUS, i);
}


size_t PostgreSQLParser::A_expr_addContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_add;
}


std::any PostgreSQLParser::A_expr_addContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_add(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_addContext* PostgreSQLParser::a_expr_add() {
  A_expr_addContext *_localctx = _tracker.createInstance<A_expr_addContext>(_ctx, getState());
  enterRule(_localctx, 1192, PostgreSQLParser::RuleA_expr_add);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9156);
    a_expr_mul();
    setState(9161);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 891, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(9157);
        _la = _input->LA(1);
        if (!(_la == PostgreSQLParser::PLUS

        || _la == PostgreSQLParser::MINUS)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(9158);
        a_expr_mul(); 
      }
      setState(9163);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 891, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_mulContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_mulContext::A_expr_mulContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::A_expr_caretContext *> PostgreSQLParser::A_expr_mulContext::a_expr_caret() {
  return getRuleContexts<PostgreSQLParser::A_expr_caretContext>();
}

PostgreSQLParser::A_expr_caretContext* PostgreSQLParser::A_expr_mulContext::a_expr_caret(size_t i) {
  return getRuleContext<PostgreSQLParser::A_expr_caretContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::A_expr_mulContext::STAR() {
  return getTokens(PostgreSQLParser::STAR);
}

tree::TerminalNode* PostgreSQLParser::A_expr_mulContext::STAR(size_t i) {
  return getToken(PostgreSQLParser::STAR, i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::A_expr_mulContext::SLASH() {
  return getTokens(PostgreSQLParser::SLASH);
}

tree::TerminalNode* PostgreSQLParser::A_expr_mulContext::SLASH(size_t i) {
  return getToken(PostgreSQLParser::SLASH, i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::A_expr_mulContext::PERCENT() {
  return getTokens(PostgreSQLParser::PERCENT);
}

tree::TerminalNode* PostgreSQLParser::A_expr_mulContext::PERCENT(size_t i) {
  return getToken(PostgreSQLParser::PERCENT, i);
}


size_t PostgreSQLParser::A_expr_mulContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_mul;
}


std::any PostgreSQLParser::A_expr_mulContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_mul(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_mulContext* PostgreSQLParser::a_expr_mul() {
  A_expr_mulContext *_localctx = _tracker.createInstance<A_expr_mulContext>(_ctx, getState());
  enterRule(_localctx, 1194, PostgreSQLParser::RuleA_expr_mul);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9164);
    a_expr_caret();
    setState(9169);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 892, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(9165);
        _la = _input->LA(1);
        if (!((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 134234624) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(9166);
        a_expr_caret(); 
      }
      setState(9171);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 892, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_caretContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_caretContext::A_expr_caretContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::A_expr_unary_signContext *> PostgreSQLParser::A_expr_caretContext::a_expr_unary_sign() {
  return getRuleContexts<PostgreSQLParser::A_expr_unary_signContext>();
}

PostgreSQLParser::A_expr_unary_signContext* PostgreSQLParser::A_expr_caretContext::a_expr_unary_sign(size_t i) {
  return getRuleContext<PostgreSQLParser::A_expr_unary_signContext>(i);
}

tree::TerminalNode* PostgreSQLParser::A_expr_caretContext::CARET() {
  return getToken(PostgreSQLParser::CARET, 0);
}


size_t PostgreSQLParser::A_expr_caretContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_caret;
}


std::any PostgreSQLParser::A_expr_caretContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_caret(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_caretContext* PostgreSQLParser::a_expr_caret() {
  A_expr_caretContext *_localctx = _tracker.createInstance<A_expr_caretContext>(_ctx, getState());
  enterRule(_localctx, 1196, PostgreSQLParser::RuleA_expr_caret);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9172);
    a_expr_unary_sign();
    setState(9175);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 893, _ctx)) {
    case 1: {
      setState(9173);
      match(PostgreSQLParser::CARET);
      setState(9174);
      a_expr_unary_sign();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_unary_signContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_unary_signContext::A_expr_unary_signContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::A_expr_at_time_zoneContext* PostgreSQLParser::A_expr_unary_signContext::a_expr_at_time_zone() {
  return getRuleContext<PostgreSQLParser::A_expr_at_time_zoneContext>(0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_unary_signContext::MINUS() {
  return getToken(PostgreSQLParser::MINUS, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_unary_signContext::PLUS() {
  return getToken(PostgreSQLParser::PLUS, 0);
}


size_t PostgreSQLParser::A_expr_unary_signContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_unary_sign;
}


std::any PostgreSQLParser::A_expr_unary_signContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_unary_sign(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_unary_signContext* PostgreSQLParser::a_expr_unary_sign() {
  A_expr_unary_signContext *_localctx = _tracker.createInstance<A_expr_unary_signContext>(_ctx, getState());
  enterRule(_localctx, 1198, PostgreSQLParser::RuleA_expr_unary_sign);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9178);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::PLUS

    || _la == PostgreSQLParser::MINUS) {
      setState(9177);
      _la = _input->LA(1);
      if (!(_la == PostgreSQLParser::PLUS

      || _la == PostgreSQLParser::MINUS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(9180);
    a_expr_at_time_zone();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_at_time_zoneContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_at_time_zoneContext::A_expr_at_time_zoneContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::A_expr_collateContext* PostgreSQLParser::A_expr_at_time_zoneContext::a_expr_collate() {
  return getRuleContext<PostgreSQLParser::A_expr_collateContext>(0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_at_time_zoneContext::AT() {
  return getToken(PostgreSQLParser::AT, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_at_time_zoneContext::TIME() {
  return getToken(PostgreSQLParser::TIME, 0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_at_time_zoneContext::ZONE() {
  return getToken(PostgreSQLParser::ZONE, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::A_expr_at_time_zoneContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}


size_t PostgreSQLParser::A_expr_at_time_zoneContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_at_time_zone;
}


std::any PostgreSQLParser::A_expr_at_time_zoneContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_at_time_zone(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_at_time_zoneContext* PostgreSQLParser::a_expr_at_time_zone() {
  A_expr_at_time_zoneContext *_localctx = _tracker.createInstance<A_expr_at_time_zoneContext>(_ctx, getState());
  enterRule(_localctx, 1200, PostgreSQLParser::RuleA_expr_at_time_zone);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9182);
    a_expr_collate();
    setState(9187);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 895, _ctx)) {
    case 1: {
      setState(9183);
      match(PostgreSQLParser::AT);
      setState(9184);
      match(PostgreSQLParser::TIME);
      setState(9185);
      match(PostgreSQLParser::ZONE);
      setState(9186);
      a_expr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_collateContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_collateContext::A_expr_collateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::A_expr_typecastContext* PostgreSQLParser::A_expr_collateContext::a_expr_typecast() {
  return getRuleContext<PostgreSQLParser::A_expr_typecastContext>(0);
}

tree::TerminalNode* PostgreSQLParser::A_expr_collateContext::COLLATE() {
  return getToken(PostgreSQLParser::COLLATE, 0);
}

PostgreSQLParser::Any_nameContext* PostgreSQLParser::A_expr_collateContext::any_name() {
  return getRuleContext<PostgreSQLParser::Any_nameContext>(0);
}


size_t PostgreSQLParser::A_expr_collateContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_collate;
}


std::any PostgreSQLParser::A_expr_collateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_collate(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_collateContext* PostgreSQLParser::a_expr_collate() {
  A_expr_collateContext *_localctx = _tracker.createInstance<A_expr_collateContext>(_ctx, getState());
  enterRule(_localctx, 1202, PostgreSQLParser::RuleA_expr_collate);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9189);
    a_expr_typecast();
    setState(9192);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 896, _ctx)) {
    case 1: {
      setState(9190);
      match(PostgreSQLParser::COLLATE);
      setState(9191);
      any_name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- A_expr_typecastContext ------------------------------------------------------------------

PostgreSQLParser::A_expr_typecastContext::A_expr_typecastContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::C_exprContext* PostgreSQLParser::A_expr_typecastContext::c_expr() {
  return getRuleContext<PostgreSQLParser::C_exprContext>(0);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::A_expr_typecastContext::TYPECAST() {
  return getTokens(PostgreSQLParser::TYPECAST);
}

tree::TerminalNode* PostgreSQLParser::A_expr_typecastContext::TYPECAST(size_t i) {
  return getToken(PostgreSQLParser::TYPECAST, i);
}

std::vector<PostgreSQLParser::TypenameContext *> PostgreSQLParser::A_expr_typecastContext::typename_() {
  return getRuleContexts<PostgreSQLParser::TypenameContext>();
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::A_expr_typecastContext::typename_(size_t i) {
  return getRuleContext<PostgreSQLParser::TypenameContext>(i);
}


size_t PostgreSQLParser::A_expr_typecastContext::getRuleIndex() const {
  return PostgreSQLParser::RuleA_expr_typecast;
}


std::any PostgreSQLParser::A_expr_typecastContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitA_expr_typecast(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::A_expr_typecastContext* PostgreSQLParser::a_expr_typecast() {
  A_expr_typecastContext *_localctx = _tracker.createInstance<A_expr_typecastContext>(_ctx, getState());
  enterRule(_localctx, 1204, PostgreSQLParser::RuleA_expr_typecast);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9194);
    c_expr();
    setState(9199);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 897, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(9195);
        match(PostgreSQLParser::TYPECAST);
        setState(9196);
        typename_(); 
      }
      setState(9201);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 897, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- B_exprContext ------------------------------------------------------------------

PostgreSQLParser::B_exprContext::B_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::C_exprContext* PostgreSQLParser::B_exprContext::c_expr() {
  return getRuleContext<PostgreSQLParser::C_exprContext>(0);
}

std::vector<PostgreSQLParser::B_exprContext *> PostgreSQLParser::B_exprContext::b_expr() {
  return getRuleContexts<PostgreSQLParser::B_exprContext>();
}

PostgreSQLParser::B_exprContext* PostgreSQLParser::B_exprContext::b_expr(size_t i) {
  return getRuleContext<PostgreSQLParser::B_exprContext>(i);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::PLUS() {
  return getToken(PostgreSQLParser::PLUS, 0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::MINUS() {
  return getToken(PostgreSQLParser::MINUS, 0);
}

PostgreSQLParser::Qual_opContext* PostgreSQLParser::B_exprContext::qual_op() {
  return getRuleContext<PostgreSQLParser::Qual_opContext>(0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::CARET() {
  return getToken(PostgreSQLParser::CARET, 0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::STAR() {
  return getToken(PostgreSQLParser::STAR, 0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::SLASH() {
  return getToken(PostgreSQLParser::SLASH, 0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::PERCENT() {
  return getToken(PostgreSQLParser::PERCENT, 0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::LT() {
  return getToken(PostgreSQLParser::LT, 0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::GT() {
  return getToken(PostgreSQLParser::GT, 0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::EQUAL() {
  return getToken(PostgreSQLParser::EQUAL, 0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::LESS_EQUALS() {
  return getToken(PostgreSQLParser::LESS_EQUALS, 0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::GREATER_EQUALS() {
  return getToken(PostgreSQLParser::GREATER_EQUALS, 0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::NOT_EQUALS() {
  return getToken(PostgreSQLParser::NOT_EQUALS, 0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::TYPECAST() {
  return getToken(PostgreSQLParser::TYPECAST, 0);
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::B_exprContext::typename_() {
  return getRuleContext<PostgreSQLParser::TypenameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::IS() {
  return getToken(PostgreSQLParser::IS, 0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::DISTINCT() {
  return getToken(PostgreSQLParser::DISTINCT, 0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::OF() {
  return getToken(PostgreSQLParser::OF, 0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Type_listContext* PostgreSQLParser::B_exprContext::type_list() {
  return getRuleContext<PostgreSQLParser::Type_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::DOCUMENT_P() {
  return getToken(PostgreSQLParser::DOCUMENT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::B_exprContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}


size_t PostgreSQLParser::B_exprContext::getRuleIndex() const {
  return PostgreSQLParser::RuleB_expr;
}


std::any PostgreSQLParser::B_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitB_expr(this);
  else
    return visitor->visitChildren(this);
}


PostgreSQLParser::B_exprContext* PostgreSQLParser::b_expr() {
   return b_expr(0);
}

PostgreSQLParser::B_exprContext* PostgreSQLParser::b_expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  PostgreSQLParser::B_exprContext *_localctx = _tracker.createInstance<B_exprContext>(_ctx, parentState);
  PostgreSQLParser::B_exprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 1206;
  enterRecursionRule(_localctx, 1206, PostgreSQLParser::RuleB_expr, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9209);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 898, _ctx)) {
    case 1: {
      setState(9203);
      c_expr();
      break;
    }

    case 2: {
      setState(9204);
      _la = _input->LA(1);
      if (!(_la == PostgreSQLParser::PLUS

      || _la == PostgreSQLParser::MINUS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(9205);
      b_expr(9);
      break;
    }

    case 3: {
      setState(9206);
      qual_op();
      setState(9207);
      b_expr(3);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(9250);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 902, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(9248);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 901, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<B_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleB_expr);
          setState(9211);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(9212);
          match(PostgreSQLParser::CARET);
          setState(9213);
          b_expr(9);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<B_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleB_expr);
          setState(9214);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(9215);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 134234624) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(9216);
          b_expr(8);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<B_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleB_expr);
          setState(9217);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(9218);
          _la = _input->LA(1);
          if (!(_la == PostgreSQLParser::PLUS

          || _la == PostgreSQLParser::MINUS)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(9219);
          b_expr(7);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<B_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleB_expr);
          setState(9220);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(9221);
          qual_op();
          setState(9222);
          b_expr(6);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<B_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleB_expr);
          setState(9224);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(9225);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 44237824) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(9226);
          b_expr(5);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<B_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleB_expr);
          setState(9227);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(9228);
          match(PostgreSQLParser::TYPECAST);
          setState(9229);
          typename_();
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<B_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleB_expr);
          setState(9230);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(9231);
          qual_op();
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<B_exprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleB_expr);
          setState(9232);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(9233);
          match(PostgreSQLParser::IS);
          setState(9235);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == PostgreSQLParser::NOT) {
            setState(9234);
            match(PostgreSQLParser::NOT);
          }
          setState(9246);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case PostgreSQLParser::DISTINCT: {
              setState(9237);
              match(PostgreSQLParser::DISTINCT);
              setState(9238);
              match(PostgreSQLParser::FROM);
              setState(9239);
              b_expr(0);
              break;
            }

            case PostgreSQLParser::OF: {
              setState(9240);
              match(PostgreSQLParser::OF);
              setState(9241);
              match(PostgreSQLParser::OPEN_PAREN);
              setState(9242);
              type_list();
              setState(9243);
              match(PostgreSQLParser::CLOSE_PAREN);
              break;
            }

            case PostgreSQLParser::DOCUMENT_P: {
              setState(9245);
              match(PostgreSQLParser::DOCUMENT_P);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          break;
        }

        default:
          break;
        } 
      }
      setState(9252);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 902, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- C_exprContext ------------------------------------------------------------------

PostgreSQLParser::C_exprContext::C_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t PostgreSQLParser::C_exprContext::getRuleIndex() const {
  return PostgreSQLParser::RuleC_expr;
}

void PostgreSQLParser::C_exprContext::copyFrom(C_exprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- C_expr_existsContext ------------------------------------------------------------------

tree::TerminalNode* PostgreSQLParser::C_expr_existsContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

PostgreSQLParser::Select_with_parensContext* PostgreSQLParser::C_expr_existsContext::select_with_parens() {
  return getRuleContext<PostgreSQLParser::Select_with_parensContext>(0);
}

PostgreSQLParser::C_expr_existsContext::C_expr_existsContext(C_exprContext *ctx) { copyFrom(ctx); }


std::any PostgreSQLParser::C_expr_existsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitC_expr_exists(this);
  else
    return visitor->visitChildren(this);
}
//----------------- C_expr_caseContext ------------------------------------------------------------------

PostgreSQLParser::Case_exprContext* PostgreSQLParser::C_expr_caseContext::case_expr() {
  return getRuleContext<PostgreSQLParser::Case_exprContext>(0);
}

PostgreSQLParser::C_expr_caseContext::C_expr_caseContext(C_exprContext *ctx) { copyFrom(ctx); }


std::any PostgreSQLParser::C_expr_caseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitC_expr_case(this);
  else
    return visitor->visitChildren(this);
}
//----------------- C_expr_exprContext ------------------------------------------------------------------

tree::TerminalNode* PostgreSQLParser::C_expr_exprContext::ARRAY() {
  return getToken(PostgreSQLParser::ARRAY, 0);
}

PostgreSQLParser::Select_with_parensContext* PostgreSQLParser::C_expr_exprContext::select_with_parens() {
  return getRuleContext<PostgreSQLParser::Select_with_parensContext>(0);
}

PostgreSQLParser::Array_exprContext* PostgreSQLParser::C_expr_exprContext::array_expr() {
  return getRuleContext<PostgreSQLParser::Array_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::C_expr_exprContext::PARAM() {
  return getToken(PostgreSQLParser::PARAM, 0);
}

PostgreSQLParser::Opt_indirectionContext* PostgreSQLParser::C_expr_exprContext::opt_indirection() {
  return getRuleContext<PostgreSQLParser::Opt_indirectionContext>(0);
}

tree::TerminalNode* PostgreSQLParser::C_expr_exprContext::GROUPING() {
  return getToken(PostgreSQLParser::GROUPING, 0);
}

tree::TerminalNode* PostgreSQLParser::C_expr_exprContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::C_expr_exprContext::expr_list() {
  return getRuleContext<PostgreSQLParser::Expr_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::C_expr_exprContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::C_expr_exprContext::UNIQUE() {
  return getToken(PostgreSQLParser::UNIQUE, 0);
}

PostgreSQLParser::ColumnrefContext* PostgreSQLParser::C_expr_exprContext::columnref() {
  return getRuleContext<PostgreSQLParser::ColumnrefContext>(0);
}

PostgreSQLParser::AexprconstContext* PostgreSQLParser::C_expr_exprContext::aexprconst() {
  return getRuleContext<PostgreSQLParser::AexprconstContext>(0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::C_expr_exprContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

PostgreSQLParser::Func_exprContext* PostgreSQLParser::C_expr_exprContext::func_expr() {
  return getRuleContext<PostgreSQLParser::Func_exprContext>(0);
}

PostgreSQLParser::IndirectionContext* PostgreSQLParser::C_expr_exprContext::indirection() {
  return getRuleContext<PostgreSQLParser::IndirectionContext>(0);
}

PostgreSQLParser::Explicit_rowContext* PostgreSQLParser::C_expr_exprContext::explicit_row() {
  return getRuleContext<PostgreSQLParser::Explicit_rowContext>(0);
}

PostgreSQLParser::Implicit_rowContext* PostgreSQLParser::C_expr_exprContext::implicit_row() {
  return getRuleContext<PostgreSQLParser::Implicit_rowContext>(0);
}

std::vector<PostgreSQLParser::RowContext *> PostgreSQLParser::C_expr_exprContext::row() {
  return getRuleContexts<PostgreSQLParser::RowContext>();
}

PostgreSQLParser::RowContext* PostgreSQLParser::C_expr_exprContext::row(size_t i) {
  return getRuleContext<PostgreSQLParser::RowContext>(i);
}

tree::TerminalNode* PostgreSQLParser::C_expr_exprContext::OVERLAPS() {
  return getToken(PostgreSQLParser::OVERLAPS, 0);
}

tree::TerminalNode* PostgreSQLParser::C_expr_exprContext::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}

PostgreSQLParser::C_expr_exprContext::C_expr_exprContext(C_exprContext *ctx) { copyFrom(ctx); }


std::any PostgreSQLParser::C_expr_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitC_expr_expr(this);
  else
    return visitor->visitChildren(this);
}
PostgreSQLParser::C_exprContext* PostgreSQLParser::c_expr() {
  C_exprContext *_localctx = _tracker.createInstance<C_exprContext>(_ctx, getState());
  enterRule(_localctx, 1208, PostgreSQLParser::RuleC_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9289);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 905, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<PostgreSQLParser::C_expr_existsContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(9253);
      match(PostgreSQLParser::EXISTS);
      setState(9254);
      select_with_parens();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<PostgreSQLParser::C_expr_exprContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(9255);
      match(PostgreSQLParser::ARRAY);
      setState(9258);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case PostgreSQLParser::OPEN_PAREN: {
          setState(9256);
          select_with_parens();
          break;
        }

        case PostgreSQLParser::OPEN_BRACKET: {
          setState(9257);
          array_expr();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<PostgreSQLParser::C_expr_exprContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(9260);
      match(PostgreSQLParser::PARAM);
      setState(9261);
      opt_indirection();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<PostgreSQLParser::C_expr_exprContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(9262);
      match(PostgreSQLParser::GROUPING);
      setState(9263);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(9264);
      expr_list();
      setState(9265);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<PostgreSQLParser::C_expr_exprContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(9267);
      match(PostgreSQLParser::UNIQUE);
      setState(9268);
      select_with_parens();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<PostgreSQLParser::C_expr_exprContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(9269);
      columnref();
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<PostgreSQLParser::C_expr_exprContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(9270);
      aexprconst();
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<PostgreSQLParser::C_expr_exprContext>(_localctx);
      enterOuterAlt(_localctx, 8);
      setState(9271);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(9272);
      antlrcpp::downCast<C_expr_exprContext *>(_localctx)->a_expr_in_parens = a_expr();
      setState(9273);
      match(PostgreSQLParser::CLOSE_PAREN);
      setState(9274);
      opt_indirection();
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<PostgreSQLParser::C_expr_caseContext>(_localctx);
      enterOuterAlt(_localctx, 9);
      setState(9276);
      case_expr();
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<PostgreSQLParser::C_expr_exprContext>(_localctx);
      enterOuterAlt(_localctx, 10);
      setState(9277);
      func_expr();
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<PostgreSQLParser::C_expr_exprContext>(_localctx);
      enterOuterAlt(_localctx, 11);
      setState(9278);
      select_with_parens();
      setState(9280);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 904, _ctx)) {
      case 1: {
        setState(9279);
        indirection();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 12: {
      _localctx = _tracker.createInstance<PostgreSQLParser::C_expr_exprContext>(_localctx);
      enterOuterAlt(_localctx, 12);
      setState(9282);
      explicit_row();
      break;
    }

    case 13: {
      _localctx = _tracker.createInstance<PostgreSQLParser::C_expr_exprContext>(_localctx);
      enterOuterAlt(_localctx, 13);
      setState(9283);
      implicit_row();
      break;
    }

    case 14: {
      _localctx = _tracker.createInstance<PostgreSQLParser::C_expr_exprContext>(_localctx);
      enterOuterAlt(_localctx, 14);
      setState(9284);
      row();
      setState(9285);
      match(PostgreSQLParser::OVERLAPS);
      setState(9286);
      row();
      break;
    }

    case 15: {
      _localctx = _tracker.createInstance<PostgreSQLParser::C_expr_exprContext>(_localctx);
      enterOuterAlt(_localctx, 15);
      setState(9288);
      match(PostgreSQLParser::DEFAULT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PlsqlvariablenameContext ------------------------------------------------------------------

PostgreSQLParser::PlsqlvariablenameContext::PlsqlvariablenameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::PlsqlvariablenameContext::PLSQLVARIABLENAME() {
  return getToken(PostgreSQLParser::PLSQLVARIABLENAME, 0);
}


size_t PostgreSQLParser::PlsqlvariablenameContext::getRuleIndex() const {
  return PostgreSQLParser::RulePlsqlvariablename;
}


std::any PostgreSQLParser::PlsqlvariablenameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitPlsqlvariablename(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::PlsqlvariablenameContext* PostgreSQLParser::plsqlvariablename() {
  PlsqlvariablenameContext *_localctx = _tracker.createInstance<PlsqlvariablenameContext>(_ctx, getState());
  enterRule(_localctx, 1210, PostgreSQLParser::RulePlsqlvariablename);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9291);
    match(PostgreSQLParser::PLSQLVARIABLENAME);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_applicationContext ------------------------------------------------------------------

PostgreSQLParser::Func_applicationContext::Func_applicationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Func_nameContext* PostgreSQLParser::Func_applicationContext::func_name() {
  return getRuleContext<PostgreSQLParser::Func_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_applicationContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_applicationContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::Func_arg_listContext* PostgreSQLParser::Func_applicationContext::func_arg_list() {
  return getRuleContext<PostgreSQLParser::Func_arg_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_applicationContext::VARIADIC() {
  return getToken(PostgreSQLParser::VARIADIC, 0);
}

PostgreSQLParser::Func_arg_exprContext* PostgreSQLParser::Func_applicationContext::func_arg_expr() {
  return getRuleContext<PostgreSQLParser::Func_arg_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_applicationContext::STAR() {
  return getToken(PostgreSQLParser::STAR, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_applicationContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_applicationContext::DISTINCT() {
  return getToken(PostgreSQLParser::DISTINCT, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_applicationContext::COMMA() {
  return getToken(PostgreSQLParser::COMMA, 0);
}

PostgreSQLParser::Sort_clause_Context* PostgreSQLParser::Func_applicationContext::sort_clause_() {
  return getRuleContext<PostgreSQLParser::Sort_clause_Context>(0);
}


size_t PostgreSQLParser::Func_applicationContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunc_application;
}


std::any PostgreSQLParser::Func_applicationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunc_application(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Func_applicationContext* PostgreSQLParser::func_application() {
  Func_applicationContext *_localctx = _tracker.createInstance<Func_applicationContext>(_ctx, getState());
  enterRule(_localctx, 1212, PostgreSQLParser::RuleFunc_application);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9293);
    func_name();
    setState(9294);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(9316);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::OPEN_PAREN:
      case PostgreSQLParser::PLUS:
      case PostgreSQLParser::MINUS:
      case PostgreSQLParser::PARAM:
      case PostgreSQLParser::Operator:
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::SYSTEM_USER:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::ARRAY:
      case PostgreSQLParser::CASE:
      case PostgreSQLParser::CAST:
      case PostgreSQLParser::CURRENT_CATALOG:
      case PostgreSQLParser::CURRENT_DATE:
      case PostgreSQLParser::CURRENT_ROLE:
      case PostgreSQLParser::CURRENT_TIME:
      case PostgreSQLParser::CURRENT_TIMESTAMP:
      case PostgreSQLParser::CURRENT_USER:
      case PostgreSQLParser::DEFAULT:
      case PostgreSQLParser::FALSE_P:
      case PostgreSQLParser::LOCALTIME:
      case PostgreSQLParser::LOCALTIMESTAMP:
      case PostgreSQLParser::NOT:
      case PostgreSQLParser::NULL_P:
      case PostgreSQLParser::SESSION_USER:
      case PostgreSQLParser::TRUE_P:
      case PostgreSQLParser::UNIQUE:
      case PostgreSQLParser::USER:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::BinaryStringConstant:
      case PostgreSQLParser::HexadecimalStringConstant:
      case PostgreSQLParser::Integral:
      case PostgreSQLParser::BinaryIntegral:
      case PostgreSQLParser::OctalIntegral:
      case PostgreSQLParser::HexadecimalIntegral:
      case PostgreSQLParser::Numeric:
      case PostgreSQLParser::PLSQLVARIABLENAME:
      case PostgreSQLParser::EscapeStringConstant: {
        setState(9295);
        func_arg_list();
        setState(9299);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::COMMA) {
          setState(9296);
          match(PostgreSQLParser::COMMA);
          setState(9297);
          match(PostgreSQLParser::VARIADIC);
          setState(9298);
          func_arg_expr();
        }
        setState(9302);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::ORDER) {
          setState(9301);
          sort_clause_();
        }
        break;
      }

      case PostgreSQLParser::VARIADIC: {
        setState(9304);
        match(PostgreSQLParser::VARIADIC);
        setState(9305);
        func_arg_expr();
        setState(9307);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::ORDER) {
          setState(9306);
          sort_clause_();
        }
        break;
      }

      case PostgreSQLParser::ALL:
      case PostgreSQLParser::DISTINCT: {
        setState(9309);
        _la = _input->LA(1);
        if (!(_la == PostgreSQLParser::ALL

        || _la == PostgreSQLParser::DISTINCT)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(9310);
        func_arg_list();
        setState(9312);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::ORDER) {
          setState(9311);
          sort_clause_();
        }
        break;
      }

      case PostgreSQLParser::STAR: {
        setState(9314);
        match(PostgreSQLParser::STAR);
        break;
      }

      case PostgreSQLParser::CLOSE_PAREN: {
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(9318);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_exprContext ------------------------------------------------------------------

PostgreSQLParser::Func_exprContext::Func_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Func_applicationContext* PostgreSQLParser::Func_exprContext::func_application() {
  return getRuleContext<PostgreSQLParser::Func_applicationContext>(0);
}

PostgreSQLParser::Within_group_clauseContext* PostgreSQLParser::Func_exprContext::within_group_clause() {
  return getRuleContext<PostgreSQLParser::Within_group_clauseContext>(0);
}

PostgreSQLParser::Filter_clauseContext* PostgreSQLParser::Func_exprContext::filter_clause() {
  return getRuleContext<PostgreSQLParser::Filter_clauseContext>(0);
}

PostgreSQLParser::Over_clauseContext* PostgreSQLParser::Func_exprContext::over_clause() {
  return getRuleContext<PostgreSQLParser::Over_clauseContext>(0);
}

PostgreSQLParser::Func_expr_common_subexprContext* PostgreSQLParser::Func_exprContext::func_expr_common_subexpr() {
  return getRuleContext<PostgreSQLParser::Func_expr_common_subexprContext>(0);
}


size_t PostgreSQLParser::Func_exprContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunc_expr;
}


std::any PostgreSQLParser::Func_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunc_expr(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Func_exprContext* PostgreSQLParser::func_expr() {
  Func_exprContext *_localctx = _tracker.createInstance<Func_exprContext>(_ctx, getState());
  enterRule(_localctx, 1214, PostgreSQLParser::RuleFunc_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9331);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 914, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9320);
      func_application();
      setState(9322);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 911, _ctx)) {
      case 1: {
        setState(9321);
        within_group_clause();
        break;
      }

      default:
        break;
      }
      setState(9325);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 912, _ctx)) {
      case 1: {
        setState(9324);
        filter_clause();
        break;
      }

      default:
        break;
      }
      setState(9328);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 913, _ctx)) {
      case 1: {
        setState(9327);
        over_clause();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9330);
      func_expr_common_subexpr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_expr_windowlessContext ------------------------------------------------------------------

PostgreSQLParser::Func_expr_windowlessContext::Func_expr_windowlessContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Func_applicationContext* PostgreSQLParser::Func_expr_windowlessContext::func_application() {
  return getRuleContext<PostgreSQLParser::Func_applicationContext>(0);
}

PostgreSQLParser::Func_expr_common_subexprContext* PostgreSQLParser::Func_expr_windowlessContext::func_expr_common_subexpr() {
  return getRuleContext<PostgreSQLParser::Func_expr_common_subexprContext>(0);
}


size_t PostgreSQLParser::Func_expr_windowlessContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunc_expr_windowless;
}


std::any PostgreSQLParser::Func_expr_windowlessContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunc_expr_windowless(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Func_expr_windowlessContext* PostgreSQLParser::func_expr_windowless() {
  Func_expr_windowlessContext *_localctx = _tracker.createInstance<Func_expr_windowlessContext>(_ctx, getState());
  enterRule(_localctx, 1216, PostgreSQLParser::RuleFunc_expr_windowless);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9335);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 915, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9333);
      func_application();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9334);
      func_expr_common_subexpr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_expr_common_subexprContext ------------------------------------------------------------------

PostgreSQLParser::Func_expr_common_subexprContext::Func_expr_common_subexprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::COLLATION() {
  return getToken(PostgreSQLParser::COLLATION, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

std::vector<PostgreSQLParser::A_exprContext *> PostgreSQLParser::Func_expr_common_subexprContext::a_expr() {
  return getRuleContexts<PostgreSQLParser::A_exprContext>();
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Func_expr_common_subexprContext::a_expr(size_t i) {
  return getRuleContext<PostgreSQLParser::A_exprContext>(i);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::CURRENT_DATE() {
  return getToken(PostgreSQLParser::CURRENT_DATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::CURRENT_TIME() {
  return getToken(PostgreSQLParser::CURRENT_TIME, 0);
}

PostgreSQLParser::IconstContext* PostgreSQLParser::Func_expr_common_subexprContext::iconst() {
  return getRuleContext<PostgreSQLParser::IconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::CURRENT_TIMESTAMP() {
  return getToken(PostgreSQLParser::CURRENT_TIMESTAMP, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::LOCALTIME() {
  return getToken(PostgreSQLParser::LOCALTIME, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::LOCALTIMESTAMP() {
  return getToken(PostgreSQLParser::LOCALTIMESTAMP, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::CURRENT_ROLE() {
  return getToken(PostgreSQLParser::CURRENT_ROLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::CURRENT_USER() {
  return getToken(PostgreSQLParser::CURRENT_USER, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::SESSION_USER() {
  return getToken(PostgreSQLParser::SESSION_USER, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::SYSTEM_USER() {
  return getToken(PostgreSQLParser::SYSTEM_USER, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::USER() {
  return getToken(PostgreSQLParser::USER, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::CURRENT_CATALOG() {
  return getToken(PostgreSQLParser::CURRENT_CATALOG, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::CURRENT_SCHEMA() {
  return getToken(PostgreSQLParser::CURRENT_SCHEMA, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::CAST() {
  return getToken(PostgreSQLParser::CAST, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::Func_expr_common_subexprContext::typename_() {
  return getRuleContext<PostgreSQLParser::TypenameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::EXTRACT() {
  return getToken(PostgreSQLParser::EXTRACT, 0);
}

PostgreSQLParser::Extract_listContext* PostgreSQLParser::Func_expr_common_subexprContext::extract_list() {
  return getRuleContext<PostgreSQLParser::Extract_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::NORMALIZE() {
  return getToken(PostgreSQLParser::NORMALIZE, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::COMMA() {
  return getToken(PostgreSQLParser::COMMA, 0);
}

PostgreSQLParser::Unicode_normal_formContext* PostgreSQLParser::Func_expr_common_subexprContext::unicode_normal_form() {
  return getRuleContext<PostgreSQLParser::Unicode_normal_formContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::OVERLAY() {
  return getToken(PostgreSQLParser::OVERLAY, 0);
}

PostgreSQLParser::Overlay_listContext* PostgreSQLParser::Func_expr_common_subexprContext::overlay_list() {
  return getRuleContext<PostgreSQLParser::Overlay_listContext>(0);
}

PostgreSQLParser::Func_arg_listContext* PostgreSQLParser::Func_expr_common_subexprContext::func_arg_list() {
  return getRuleContext<PostgreSQLParser::Func_arg_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::POSITION() {
  return getToken(PostgreSQLParser::POSITION, 0);
}

PostgreSQLParser::Position_listContext* PostgreSQLParser::Func_expr_common_subexprContext::position_list() {
  return getRuleContext<PostgreSQLParser::Position_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::SUBSTRING() {
  return getToken(PostgreSQLParser::SUBSTRING, 0);
}

PostgreSQLParser::Substr_listContext* PostgreSQLParser::Func_expr_common_subexprContext::substr_list() {
  return getRuleContext<PostgreSQLParser::Substr_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::TREAT() {
  return getToken(PostgreSQLParser::TREAT, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::TRIM() {
  return getToken(PostgreSQLParser::TRIM, 0);
}

PostgreSQLParser::Trim_listContext* PostgreSQLParser::Func_expr_common_subexprContext::trim_list() {
  return getRuleContext<PostgreSQLParser::Trim_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::BOTH() {
  return getToken(PostgreSQLParser::BOTH, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::LEADING() {
  return getToken(PostgreSQLParser::LEADING, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::TRAILING() {
  return getToken(PostgreSQLParser::TRAILING, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::NULLIF() {
  return getToken(PostgreSQLParser::NULLIF, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::COALESCE() {
  return getToken(PostgreSQLParser::COALESCE, 0);
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::Func_expr_common_subexprContext::expr_list() {
  return getRuleContext<PostgreSQLParser::Expr_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::GREATEST() {
  return getToken(PostgreSQLParser::GREATEST, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::LEAST() {
  return getToken(PostgreSQLParser::LEAST, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::XMLCONCAT() {
  return getToken(PostgreSQLParser::XMLCONCAT, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::XMLELEMENT() {
  return getToken(PostgreSQLParser::XMLELEMENT, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::NAME_P() {
  return getToken(PostgreSQLParser::NAME_P, 0);
}

PostgreSQLParser::ColLabelContext* PostgreSQLParser::Func_expr_common_subexprContext::colLabel() {
  return getRuleContext<PostgreSQLParser::ColLabelContext>(0);
}

PostgreSQLParser::Xml_attributesContext* PostgreSQLParser::Func_expr_common_subexprContext::xml_attributes() {
  return getRuleContext<PostgreSQLParser::Xml_attributesContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::XMLEXISTS() {
  return getToken(PostgreSQLParser::XMLEXISTS, 0);
}

PostgreSQLParser::C_exprContext* PostgreSQLParser::Func_expr_common_subexprContext::c_expr() {
  return getRuleContext<PostgreSQLParser::C_exprContext>(0);
}

PostgreSQLParser::Xmlexists_argumentContext* PostgreSQLParser::Func_expr_common_subexprContext::xmlexists_argument() {
  return getRuleContext<PostgreSQLParser::Xmlexists_argumentContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::XMLFOREST() {
  return getToken(PostgreSQLParser::XMLFOREST, 0);
}

PostgreSQLParser::Xml_attribute_listContext* PostgreSQLParser::Func_expr_common_subexprContext::xml_attribute_list() {
  return getRuleContext<PostgreSQLParser::Xml_attribute_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::XMLPARSE() {
  return getToken(PostgreSQLParser::XMLPARSE, 0);
}

PostgreSQLParser::Document_or_contentContext* PostgreSQLParser::Func_expr_common_subexprContext::document_or_content() {
  return getRuleContext<PostgreSQLParser::Document_or_contentContext>(0);
}

PostgreSQLParser::Xml_whitespace_optionContext* PostgreSQLParser::Func_expr_common_subexprContext::xml_whitespace_option() {
  return getRuleContext<PostgreSQLParser::Xml_whitespace_optionContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::XMLPI() {
  return getToken(PostgreSQLParser::XMLPI, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::XMLROOT() {
  return getToken(PostgreSQLParser::XMLROOT, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::XML_P() {
  return getToken(PostgreSQLParser::XML_P, 0);
}

PostgreSQLParser::Xml_root_versionContext* PostgreSQLParser::Func_expr_common_subexprContext::xml_root_version() {
  return getRuleContext<PostgreSQLParser::Xml_root_versionContext>(0);
}

PostgreSQLParser::Xml_root_standalone_Context* PostgreSQLParser::Func_expr_common_subexprContext::xml_root_standalone_() {
  return getRuleContext<PostgreSQLParser::Xml_root_standalone_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::XMLSERIALIZE() {
  return getToken(PostgreSQLParser::XMLSERIALIZE, 0);
}

PostgreSQLParser::SimpletypenameContext* PostgreSQLParser::Func_expr_common_subexprContext::simpletypename() {
  return getRuleContext<PostgreSQLParser::SimpletypenameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::JSON_OBJECT() {
  return getToken(PostgreSQLParser::JSON_OBJECT, 0);
}

PostgreSQLParser::Json_name_and_value_listContext* PostgreSQLParser::Func_expr_common_subexprContext::json_name_and_value_list() {
  return getRuleContext<PostgreSQLParser::Json_name_and_value_listContext>(0);
}

PostgreSQLParser::Json_object_constructor_null_clauseContext* PostgreSQLParser::Func_expr_common_subexprContext::json_object_constructor_null_clause() {
  return getRuleContext<PostgreSQLParser::Json_object_constructor_null_clauseContext>(0);
}

PostgreSQLParser::Json_key_uniqueness_constraintContext* PostgreSQLParser::Func_expr_common_subexprContext::json_key_uniqueness_constraint() {
  return getRuleContext<PostgreSQLParser::Json_key_uniqueness_constraintContext>(0);
}

PostgreSQLParser::Json_returning_clauseContext* PostgreSQLParser::Func_expr_common_subexprContext::json_returning_clause() {
  return getRuleContext<PostgreSQLParser::Json_returning_clauseContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::JSON_ARRAY() {
  return getToken(PostgreSQLParser::JSON_ARRAY, 0);
}

PostgreSQLParser::Json_value_expr_listContext* PostgreSQLParser::Func_expr_common_subexprContext::json_value_expr_list() {
  return getRuleContext<PostgreSQLParser::Json_value_expr_listContext>(0);
}

PostgreSQLParser::Select_no_parensContext* PostgreSQLParser::Func_expr_common_subexprContext::select_no_parens() {
  return getRuleContext<PostgreSQLParser::Select_no_parensContext>(0);
}

PostgreSQLParser::Json_array_constructor_null_clauseContext* PostgreSQLParser::Func_expr_common_subexprContext::json_array_constructor_null_clause() {
  return getRuleContext<PostgreSQLParser::Json_array_constructor_null_clauseContext>(0);
}

PostgreSQLParser::Json_format_clauseContext* PostgreSQLParser::Func_expr_common_subexprContext::json_format_clause() {
  return getRuleContext<PostgreSQLParser::Json_format_clauseContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::JSON() {
  return getToken(PostgreSQLParser::JSON, 0);
}

PostgreSQLParser::Json_value_exprContext* PostgreSQLParser::Func_expr_common_subexprContext::json_value_expr() {
  return getRuleContext<PostgreSQLParser::Json_value_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::JSON_SCALAR() {
  return getToken(PostgreSQLParser::JSON_SCALAR, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::JSON_SERIALIZE() {
  return getToken(PostgreSQLParser::JSON_SERIALIZE, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::MERGE_ACTION() {
  return getToken(PostgreSQLParser::MERGE_ACTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::JSON_QUERY() {
  return getToken(PostgreSQLParser::JSON_QUERY, 0);
}

PostgreSQLParser::Json_wrapper_behaviorContext* PostgreSQLParser::Func_expr_common_subexprContext::json_wrapper_behavior() {
  return getRuleContext<PostgreSQLParser::Json_wrapper_behaviorContext>(0);
}

PostgreSQLParser::Json_passing_clauseContext* PostgreSQLParser::Func_expr_common_subexprContext::json_passing_clause() {
  return getRuleContext<PostgreSQLParser::Json_passing_clauseContext>(0);
}

PostgreSQLParser::Json_quotes_clauseContext* PostgreSQLParser::Func_expr_common_subexprContext::json_quotes_clause() {
  return getRuleContext<PostgreSQLParser::Json_quotes_clauseContext>(0);
}

PostgreSQLParser::Json_behavior_clauseContext* PostgreSQLParser::Func_expr_common_subexprContext::json_behavior_clause() {
  return getRuleContext<PostgreSQLParser::Json_behavior_clauseContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::JSON_EXISTS() {
  return getToken(PostgreSQLParser::JSON_EXISTS, 0);
}

PostgreSQLParser::Json_on_error_clauseContext* PostgreSQLParser::Func_expr_common_subexprContext::json_on_error_clause() {
  return getRuleContext<PostgreSQLParser::Json_on_error_clauseContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_expr_common_subexprContext::JSON_VALUE() {
  return getToken(PostgreSQLParser::JSON_VALUE, 0);
}


size_t PostgreSQLParser::Func_expr_common_subexprContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunc_expr_common_subexpr;
}


std::any PostgreSQLParser::Func_expr_common_subexprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunc_expr_common_subexpr(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Func_expr_common_subexprContext* PostgreSQLParser::func_expr_common_subexpr() {
  Func_expr_common_subexprContext *_localctx = _tracker.createInstance<Func_expr_common_subexprContext>(_ctx, getState());
  enterRule(_localctx, 1218, PostgreSQLParser::RuleFunc_expr_common_subexpr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9643);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::COLLATION: {
        enterOuterAlt(_localctx, 1);
        setState(9337);
        match(PostgreSQLParser::COLLATION);
        setState(9338);
        match(PostgreSQLParser::FOR);
        setState(9339);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9340);
        a_expr();
        setState(9341);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::CURRENT_DATE: {
        enterOuterAlt(_localctx, 2);
        setState(9343);
        match(PostgreSQLParser::CURRENT_DATE);
        break;
      }

      case PostgreSQLParser::CURRENT_TIME: {
        enterOuterAlt(_localctx, 3);
        setState(9344);
        match(PostgreSQLParser::CURRENT_TIME);
        setState(9349);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 916, _ctx)) {
        case 1: {
          setState(9345);
          match(PostgreSQLParser::OPEN_PAREN);
          setState(9346);
          iconst();
          setState(9347);
          match(PostgreSQLParser::CLOSE_PAREN);
          break;
        }

        default:
          break;
        }
        break;
      }

      case PostgreSQLParser::CURRENT_TIMESTAMP: {
        enterOuterAlt(_localctx, 4);
        setState(9351);
        match(PostgreSQLParser::CURRENT_TIMESTAMP);
        setState(9356);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 917, _ctx)) {
        case 1: {
          setState(9352);
          match(PostgreSQLParser::OPEN_PAREN);
          setState(9353);
          iconst();
          setState(9354);
          match(PostgreSQLParser::CLOSE_PAREN);
          break;
        }

        default:
          break;
        }
        break;
      }

      case PostgreSQLParser::LOCALTIME: {
        enterOuterAlt(_localctx, 5);
        setState(9358);
        match(PostgreSQLParser::LOCALTIME);
        setState(9363);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 918, _ctx)) {
        case 1: {
          setState(9359);
          match(PostgreSQLParser::OPEN_PAREN);
          setState(9360);
          iconst();
          setState(9361);
          match(PostgreSQLParser::CLOSE_PAREN);
          break;
        }

        default:
          break;
        }
        break;
      }

      case PostgreSQLParser::LOCALTIMESTAMP: {
        enterOuterAlt(_localctx, 6);
        setState(9365);
        match(PostgreSQLParser::LOCALTIMESTAMP);
        setState(9370);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 919, _ctx)) {
        case 1: {
          setState(9366);
          match(PostgreSQLParser::OPEN_PAREN);
          setState(9367);
          iconst();
          setState(9368);
          match(PostgreSQLParser::CLOSE_PAREN);
          break;
        }

        default:
          break;
        }
        break;
      }

      case PostgreSQLParser::CURRENT_ROLE: {
        enterOuterAlt(_localctx, 7);
        setState(9372);
        match(PostgreSQLParser::CURRENT_ROLE);
        break;
      }

      case PostgreSQLParser::CURRENT_USER: {
        enterOuterAlt(_localctx, 8);
        setState(9373);
        match(PostgreSQLParser::CURRENT_USER);
        break;
      }

      case PostgreSQLParser::SESSION_USER: {
        enterOuterAlt(_localctx, 9);
        setState(9374);
        match(PostgreSQLParser::SESSION_USER);
        break;
      }

      case PostgreSQLParser::SYSTEM_USER: {
        enterOuterAlt(_localctx, 10);
        setState(9375);
        match(PostgreSQLParser::SYSTEM_USER);
        break;
      }

      case PostgreSQLParser::USER: {
        enterOuterAlt(_localctx, 11);
        setState(9376);
        match(PostgreSQLParser::USER);
        break;
      }

      case PostgreSQLParser::CURRENT_CATALOG: {
        enterOuterAlt(_localctx, 12);
        setState(9377);
        match(PostgreSQLParser::CURRENT_CATALOG);
        break;
      }

      case PostgreSQLParser::CURRENT_SCHEMA: {
        enterOuterAlt(_localctx, 13);
        setState(9378);
        match(PostgreSQLParser::CURRENT_SCHEMA);
        break;
      }

      case PostgreSQLParser::CAST: {
        enterOuterAlt(_localctx, 14);
        setState(9379);
        match(PostgreSQLParser::CAST);
        setState(9380);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9381);
        a_expr();
        setState(9382);
        match(PostgreSQLParser::AS);
        setState(9383);
        typename_();
        setState(9384);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::EXTRACT: {
        enterOuterAlt(_localctx, 15);
        setState(9386);
        match(PostgreSQLParser::EXTRACT);
        setState(9387);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9389);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::DAY_P

        || _la == PostgreSQLParser::HOUR_P || _la == PostgreSQLParser::MINUTE_P

        || _la == PostgreSQLParser::MONTH_P || _la == PostgreSQLParser::SECOND_P

        || _la == PostgreSQLParser::YEAR_P || ((((_la - 554) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 554)) & 68987922979) != 0)) {
          setState(9388);
          extract_list();
        }
        setState(9391);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::NORMALIZE: {
        enterOuterAlt(_localctx, 16);
        setState(9392);
        match(PostgreSQLParser::NORMALIZE);
        setState(9393);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9394);
        a_expr();
        setState(9397);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::COMMA) {
          setState(9395);
          match(PostgreSQLParser::COMMA);
          setState(9396);
          unicode_normal_form();
        }
        setState(9399);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::OVERLAY: {
        enterOuterAlt(_localctx, 17);
        setState(9401);
        match(PostgreSQLParser::OVERLAY);
        setState(9402);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9407);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 923, _ctx)) {
        case 1: {
          setState(9403);
          overlay_list();
          break;
        }

        case 2: {
          setState(9405);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if ((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & -268423164) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & -9214927770107198969) != 0) || ((((_la - 134) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 134)) & -1011) != 0) || ((((_la - 198) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 198)) & -1) != 0) || ((((_la - 262) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 262)) & -1) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 326)) & -129) != 0) || ((((_la - 390) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 390)) & -1) != 0) || ((((_la - 454) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 454)) & -2305843284091601405) != 0) || ((((_la - 518) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 518)) & -4880034784790705153) != 0) || _la == PostgreSQLParser::PLSQLVARIABLENAME

          || _la == PostgreSQLParser::EscapeStringConstant) {
            setState(9404);
            func_arg_list();
          }
          break;
        }

        default:
          break;
        }
        setState(9409);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::POSITION: {
        enterOuterAlt(_localctx, 18);
        setState(9410);
        match(PostgreSQLParser::POSITION);
        setState(9411);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9413);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & -268423164) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & -9217179569920884217) != 0) || ((((_la - 134) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 134)) & -1011) != 0) || ((((_la - 198) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 198)) & -1) != 0) || ((((_la - 262) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 262)) & -1) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 326)) & -129) != 0) || ((((_la - 390) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 390)) & -1) != 0) || ((((_la - 454) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 454)) & -2305843284091601405) != 0) || ((((_la - 518) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 518)) & -4880034784790705153) != 0) || _la == PostgreSQLParser::PLSQLVARIABLENAME

        || _la == PostgreSQLParser::EscapeStringConstant) {
          setState(9412);
          position_list();
        }
        setState(9415);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::SUBSTRING: {
        enterOuterAlt(_localctx, 19);
        setState(9416);
        match(PostgreSQLParser::SUBSTRING);
        setState(9417);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9422);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 926, _ctx)) {
        case 1: {
          setState(9418);
          substr_list();
          break;
        }

        case 2: {
          setState(9420);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if ((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & -268423164) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & -9214927770107198969) != 0) || ((((_la - 134) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 134)) & -1011) != 0) || ((((_la - 198) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 198)) & -1) != 0) || ((((_la - 262) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 262)) & -1) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 326)) & -129) != 0) || ((((_la - 390) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 390)) & -1) != 0) || ((((_la - 454) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 454)) & -2305843284091601405) != 0) || ((((_la - 518) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 518)) & -4880034784790705153) != 0) || _la == PostgreSQLParser::PLSQLVARIABLENAME

          || _la == PostgreSQLParser::EscapeStringConstant) {
            setState(9419);
            func_arg_list();
          }
          break;
        }

        default:
          break;
        }
        setState(9424);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::TREAT: {
        enterOuterAlt(_localctx, 20);
        setState(9425);
        match(PostgreSQLParser::TREAT);
        setState(9426);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9427);
        a_expr();
        setState(9428);
        match(PostgreSQLParser::AS);
        setState(9429);
        typename_();
        setState(9430);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::TRIM: {
        enterOuterAlt(_localctx, 21);
        setState(9432);
        match(PostgreSQLParser::TRIM);
        setState(9433);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9435);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 77) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 77)) & 72057611217797121) != 0)) {
          setState(9434);
          _la = _input->LA(1);
          if (!(((((_la - 77) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 77)) & 72057611217797121) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(9437);
        trim_list();
        setState(9438);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::NULLIF: {
        enterOuterAlt(_localctx, 22);
        setState(9440);
        match(PostgreSQLParser::NULLIF);
        setState(9441);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9442);
        a_expr();
        setState(9443);
        match(PostgreSQLParser::COMMA);
        setState(9444);
        a_expr();
        setState(9445);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::COALESCE: {
        enterOuterAlt(_localctx, 23);
        setState(9447);
        match(PostgreSQLParser::COALESCE);
        setState(9448);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9449);
        expr_list();
        setState(9450);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::GREATEST: {
        enterOuterAlt(_localctx, 24);
        setState(9452);
        match(PostgreSQLParser::GREATEST);
        setState(9453);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9454);
        expr_list();
        setState(9455);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::LEAST: {
        enterOuterAlt(_localctx, 25);
        setState(9457);
        match(PostgreSQLParser::LEAST);
        setState(9458);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9459);
        expr_list();
        setState(9460);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::XMLCONCAT: {
        enterOuterAlt(_localctx, 26);
        setState(9462);
        match(PostgreSQLParser::XMLCONCAT);
        setState(9463);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9464);
        expr_list();
        setState(9465);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::XMLELEMENT: {
        enterOuterAlt(_localctx, 27);
        setState(9467);
        match(PostgreSQLParser::XMLELEMENT);
        setState(9468);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9469);
        match(PostgreSQLParser::NAME_P);
        setState(9470);
        colLabel();
        setState(9476);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::COMMA) {
          setState(9471);
          match(PostgreSQLParser::COMMA);
          setState(9474);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 928, _ctx)) {
          case 1: {
            setState(9472);
            xml_attributes();
            break;
          }

          case 2: {
            setState(9473);
            expr_list();
            break;
          }

          default:
            break;
          }
        }
        setState(9478);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::XMLEXISTS: {
        enterOuterAlt(_localctx, 28);
        setState(9480);
        match(PostgreSQLParser::XMLEXISTS);
        setState(9481);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9482);
        c_expr();
        setState(9483);
        xmlexists_argument();
        setState(9484);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::XMLFOREST: {
        enterOuterAlt(_localctx, 29);
        setState(9486);
        match(PostgreSQLParser::XMLFOREST);
        setState(9487);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9488);
        xml_attribute_list();
        setState(9489);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::XMLPARSE: {
        enterOuterAlt(_localctx, 30);
        setState(9491);
        match(PostgreSQLParser::XMLPARSE);
        setState(9492);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9493);
        document_or_content();
        setState(9494);
        a_expr();
        setState(9496);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::PRESERVE

        || _la == PostgreSQLParser::STRIP_P) {
          setState(9495);
          xml_whitespace_option();
        }
        setState(9498);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::XMLPI: {
        enterOuterAlt(_localctx, 31);
        setState(9500);
        match(PostgreSQLParser::XMLPI);
        setState(9501);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9502);
        match(PostgreSQLParser::NAME_P);
        setState(9503);
        colLabel();
        setState(9506);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::COMMA) {
          setState(9504);
          match(PostgreSQLParser::COMMA);
          setState(9505);
          a_expr();
        }
        setState(9508);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::XMLROOT: {
        enterOuterAlt(_localctx, 32);
        setState(9510);
        match(PostgreSQLParser::XMLROOT);
        setState(9511);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9512);
        match(PostgreSQLParser::XML_P);
        setState(9513);
        a_expr();
        setState(9514);
        match(PostgreSQLParser::COMMA);
        setState(9515);
        xml_root_version();
        setState(9517);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::COMMA) {
          setState(9516);
          xml_root_standalone_();
        }
        setState(9519);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::XMLSERIALIZE: {
        enterOuterAlt(_localctx, 33);
        setState(9521);
        match(PostgreSQLParser::XMLSERIALIZE);
        setState(9522);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9523);
        document_or_content();
        setState(9524);
        a_expr();
        setState(9525);
        match(PostgreSQLParser::AS);
        setState(9526);
        simpletypename();
        setState(9527);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::JSON_OBJECT: {
        enterOuterAlt(_localctx, 34);
        setState(9529);
        match(PostgreSQLParser::JSON_OBJECT);
        setState(9530);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9545);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 937, _ctx)) {
        case 1: {
          setState(9531);
          func_arg_list();
          break;
        }

        case 2: {
          setState(9532);
          json_name_and_value_list(0);
          setState(9534);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == PostgreSQLParser::ABSENT || _la == PostgreSQLParser::NULL_P) {
            setState(9533);
            json_object_constructor_null_clause();
          }
          setState(9537);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == PostgreSQLParser::WITH || _la == PostgreSQLParser::WITHOUT) {
            setState(9536);
            json_key_uniqueness_constraint();
          }
          setState(9540);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == PostgreSQLParser::RETURNING) {
            setState(9539);
            json_returning_clause();
          }
          break;
        }

        case 3: {
          setState(9543);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == PostgreSQLParser::RETURNING) {
            setState(9542);
            json_returning_clause();
          }
          break;
        }

        default:
          break;
        }
        setState(9547);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::JSON_ARRAY: {
        enterOuterAlt(_localctx, 35);
        setState(9548);
        match(PostgreSQLParser::JSON_ARRAY);
        setState(9549);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9567);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 943, _ctx)) {
        case 1: {
          setState(9550);
          json_value_expr_list(0);
          setState(9552);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == PostgreSQLParser::ABSENT || _la == PostgreSQLParser::NULL_P) {
            setState(9551);
            json_array_constructor_null_clause();
          }
          setState(9555);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == PostgreSQLParser::RETURNING) {
            setState(9554);
            json_returning_clause();
          }
          break;
        }

        case 2: {
          setState(9557);
          select_no_parens();
          setState(9559);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == PostgreSQLParser::FORMAT_LA) {
            setState(9558);
            json_format_clause();
          }
          setState(9562);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == PostgreSQLParser::RETURNING) {
            setState(9561);
            json_returning_clause();
          }
          break;
        }

        case 3: {
          setState(9565);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == PostgreSQLParser::RETURNING) {
            setState(9564);
            json_returning_clause();
          }
          break;
        }

        default:
          break;
        }
        setState(9569);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::JSON: {
        enterOuterAlt(_localctx, 36);
        setState(9570);
        match(PostgreSQLParser::JSON);
        setState(9571);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9572);
        json_value_expr();
        setState(9574);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::WITH || _la == PostgreSQLParser::WITHOUT) {
          setState(9573);
          json_key_uniqueness_constraint();
        }
        setState(9576);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::JSON_SCALAR: {
        enterOuterAlt(_localctx, 37);
        setState(9578);
        match(PostgreSQLParser::JSON_SCALAR);
        setState(9579);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9580);
        a_expr();
        setState(9581);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::JSON_SERIALIZE: {
        enterOuterAlt(_localctx, 38);
        setState(9583);
        match(PostgreSQLParser::JSON_SERIALIZE);
        setState(9584);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9585);
        json_value_expr();
        setState(9587);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::RETURNING) {
          setState(9586);
          json_returning_clause();
        }
        setState(9589);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::MERGE_ACTION: {
        enterOuterAlt(_localctx, 39);
        setState(9591);
        match(PostgreSQLParser::MERGE_ACTION);
        setState(9592);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9593);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::JSON_QUERY: {
        enterOuterAlt(_localctx, 40);
        setState(9594);
        match(PostgreSQLParser::JSON_QUERY);
        setState(9595);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9596);
        json_value_expr();
        setState(9597);
        match(PostgreSQLParser::COMMA);
        setState(9598);
        a_expr();
        setState(9600);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::PASSING) {
          setState(9599);
          json_passing_clause();
        }
        setState(9603);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::RETURNING) {
          setState(9602);
          json_returning_clause();
        }
        setState(9605);
        json_wrapper_behavior();
        setState(9607);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::KEEP

        || _la == PostgreSQLParser::OMIT) {
          setState(9606);
          json_quotes_clause();
        }
        setState(9610);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::EMPTY_P || ((((_la - 91) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 91)) & 8796126576769) != 0) || _la == PostgreSQLParser::UNKNOWN || _la == PostgreSQLParser::ERROR) {
          setState(9609);
          json_behavior_clause();
        }
        setState(9612);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::JSON_EXISTS: {
        enterOuterAlt(_localctx, 41);
        setState(9614);
        match(PostgreSQLParser::JSON_EXISTS);
        setState(9615);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9616);
        json_value_expr();
        setState(9617);
        match(PostgreSQLParser::COMMA);
        setState(9618);
        a_expr();
        setState(9620);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::PASSING) {
          setState(9619);
          json_passing_clause();
        }
        setState(9623);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::EMPTY_P || ((((_la - 91) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 91)) & 8796126576769) != 0) || _la == PostgreSQLParser::UNKNOWN || _la == PostgreSQLParser::ERROR) {
          setState(9622);
          json_on_error_clause();
        }
        setState(9625);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::JSON_VALUE: {
        enterOuterAlt(_localctx, 42);
        setState(9627);
        match(PostgreSQLParser::JSON_VALUE);
        setState(9628);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9629);
        json_value_expr();
        setState(9630);
        match(PostgreSQLParser::COMMA);
        setState(9631);
        a_expr();
        setState(9633);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::PASSING) {
          setState(9632);
          json_passing_clause();
        }
        setState(9636);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::RETURNING) {
          setState(9635);
          json_returning_clause();
        }
        setState(9639);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::EMPTY_P || ((((_la - 91) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 91)) & 8796126576769) != 0) || _la == PostgreSQLParser::UNKNOWN || _la == PostgreSQLParser::ERROR) {
          setState(9638);
          json_behavior_clause();
        }
        setState(9641);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xml_root_versionContext ------------------------------------------------------------------

PostgreSQLParser::Xml_root_versionContext::Xml_root_versionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Xml_root_versionContext::VERSION_P() {
  return getToken(PostgreSQLParser::VERSION_P, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Xml_root_versionContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Xml_root_versionContext::NO() {
  return getToken(PostgreSQLParser::NO, 0);
}

tree::TerminalNode* PostgreSQLParser::Xml_root_versionContext::VALUE_P() {
  return getToken(PostgreSQLParser::VALUE_P, 0);
}


size_t PostgreSQLParser::Xml_root_versionContext::getRuleIndex() const {
  return PostgreSQLParser::RuleXml_root_version;
}


std::any PostgreSQLParser::Xml_root_versionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitXml_root_version(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Xml_root_versionContext* PostgreSQLParser::xml_root_version() {
  Xml_root_versionContext *_localctx = _tracker.createInstance<Xml_root_versionContext>(_ctx, getState());
  enterRule(_localctx, 1220, PostgreSQLParser::RuleXml_root_version);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9650);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 956, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9645);
      match(PostgreSQLParser::VERSION_P);
      setState(9646);
      a_expr();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9647);
      match(PostgreSQLParser::VERSION_P);
      setState(9648);
      match(PostgreSQLParser::NO);
      setState(9649);
      match(PostgreSQLParser::VALUE_P);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xml_root_standalone_Context ------------------------------------------------------------------

PostgreSQLParser::Xml_root_standalone_Context::Xml_root_standalone_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Xml_root_standalone_Context::COMMA() {
  return getToken(PostgreSQLParser::COMMA, 0);
}

tree::TerminalNode* PostgreSQLParser::Xml_root_standalone_Context::STANDALONE_P() {
  return getToken(PostgreSQLParser::STANDALONE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Xml_root_standalone_Context::YES_P() {
  return getToken(PostgreSQLParser::YES_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Xml_root_standalone_Context::NO() {
  return getToken(PostgreSQLParser::NO, 0);
}

tree::TerminalNode* PostgreSQLParser::Xml_root_standalone_Context::VALUE_P() {
  return getToken(PostgreSQLParser::VALUE_P, 0);
}


size_t PostgreSQLParser::Xml_root_standalone_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleXml_root_standalone_;
}


std::any PostgreSQLParser::Xml_root_standalone_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitXml_root_standalone_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Xml_root_standalone_Context* PostgreSQLParser::xml_root_standalone_() {
  Xml_root_standalone_Context *_localctx = _tracker.createInstance<Xml_root_standalone_Context>(_ctx, getState());
  enterRule(_localctx, 1222, PostgreSQLParser::RuleXml_root_standalone_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9662);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 957, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9652);
      match(PostgreSQLParser::COMMA);
      setState(9653);
      match(PostgreSQLParser::STANDALONE_P);
      setState(9654);
      match(PostgreSQLParser::YES_P);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9655);
      match(PostgreSQLParser::COMMA);
      setState(9656);
      match(PostgreSQLParser::STANDALONE_P);
      setState(9657);
      match(PostgreSQLParser::NO);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(9658);
      match(PostgreSQLParser::COMMA);
      setState(9659);
      match(PostgreSQLParser::STANDALONE_P);
      setState(9660);
      match(PostgreSQLParser::NO);
      setState(9661);
      match(PostgreSQLParser::VALUE_P);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xml_attributesContext ------------------------------------------------------------------

PostgreSQLParser::Xml_attributesContext::Xml_attributesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Xml_attributesContext::XMLATTRIBUTES() {
  return getToken(PostgreSQLParser::XMLATTRIBUTES, 0);
}

tree::TerminalNode* PostgreSQLParser::Xml_attributesContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Xml_attribute_listContext* PostgreSQLParser::Xml_attributesContext::xml_attribute_list() {
  return getRuleContext<PostgreSQLParser::Xml_attribute_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Xml_attributesContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Xml_attributesContext::getRuleIndex() const {
  return PostgreSQLParser::RuleXml_attributes;
}


std::any PostgreSQLParser::Xml_attributesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitXml_attributes(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Xml_attributesContext* PostgreSQLParser::xml_attributes() {
  Xml_attributesContext *_localctx = _tracker.createInstance<Xml_attributesContext>(_ctx, getState());
  enterRule(_localctx, 1224, PostgreSQLParser::RuleXml_attributes);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9664);
    match(PostgreSQLParser::XMLATTRIBUTES);
    setState(9665);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(9666);
    xml_attribute_list();
    setState(9667);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xml_attribute_listContext ------------------------------------------------------------------

PostgreSQLParser::Xml_attribute_listContext::Xml_attribute_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Xml_attribute_elContext *> PostgreSQLParser::Xml_attribute_listContext::xml_attribute_el() {
  return getRuleContexts<PostgreSQLParser::Xml_attribute_elContext>();
}

PostgreSQLParser::Xml_attribute_elContext* PostgreSQLParser::Xml_attribute_listContext::xml_attribute_el(size_t i) {
  return getRuleContext<PostgreSQLParser::Xml_attribute_elContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Xml_attribute_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Xml_attribute_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Xml_attribute_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleXml_attribute_list;
}


std::any PostgreSQLParser::Xml_attribute_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitXml_attribute_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Xml_attribute_listContext* PostgreSQLParser::xml_attribute_list() {
  Xml_attribute_listContext *_localctx = _tracker.createInstance<Xml_attribute_listContext>(_ctx, getState());
  enterRule(_localctx, 1226, PostgreSQLParser::RuleXml_attribute_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9669);
    xml_attribute_el();
    setState(9674);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(9670);
      match(PostgreSQLParser::COMMA);
      setState(9671);
      xml_attribute_el();
      setState(9676);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xml_attribute_elContext ------------------------------------------------------------------

PostgreSQLParser::Xml_attribute_elContext::Xml_attribute_elContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Xml_attribute_elContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Xml_attribute_elContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

PostgreSQLParser::ColLabelContext* PostgreSQLParser::Xml_attribute_elContext::colLabel() {
  return getRuleContext<PostgreSQLParser::ColLabelContext>(0);
}


size_t PostgreSQLParser::Xml_attribute_elContext::getRuleIndex() const {
  return PostgreSQLParser::RuleXml_attribute_el;
}


std::any PostgreSQLParser::Xml_attribute_elContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitXml_attribute_el(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Xml_attribute_elContext* PostgreSQLParser::xml_attribute_el() {
  Xml_attribute_elContext *_localctx = _tracker.createInstance<Xml_attribute_elContext>(_ctx, getState());
  enterRule(_localctx, 1228, PostgreSQLParser::RuleXml_attribute_el);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9677);
    a_expr();
    setState(9680);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::AS) {
      setState(9678);
      match(PostgreSQLParser::AS);
      setState(9679);
      colLabel();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Document_or_contentContext ------------------------------------------------------------------

PostgreSQLParser::Document_or_contentContext::Document_or_contentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Document_or_contentContext::DOCUMENT_P() {
  return getToken(PostgreSQLParser::DOCUMENT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Document_or_contentContext::CONTENT_P() {
  return getToken(PostgreSQLParser::CONTENT_P, 0);
}


size_t PostgreSQLParser::Document_or_contentContext::getRuleIndex() const {
  return PostgreSQLParser::RuleDocument_or_content;
}


std::any PostgreSQLParser::Document_or_contentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitDocument_or_content(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Document_or_contentContext* PostgreSQLParser::document_or_content() {
  Document_or_contentContext *_localctx = _tracker.createInstance<Document_or_contentContext>(_ctx, getState());
  enterRule(_localctx, 1230, PostgreSQLParser::RuleDocument_or_content);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9682);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::CONTENT_P

    || _la == PostgreSQLParser::DOCUMENT_P)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xml_whitespace_optionContext ------------------------------------------------------------------

PostgreSQLParser::Xml_whitespace_optionContext::Xml_whitespace_optionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Xml_whitespace_optionContext::PRESERVE() {
  return getToken(PostgreSQLParser::PRESERVE, 0);
}

tree::TerminalNode* PostgreSQLParser::Xml_whitespace_optionContext::WHITESPACE_P() {
  return getToken(PostgreSQLParser::WHITESPACE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Xml_whitespace_optionContext::STRIP_P() {
  return getToken(PostgreSQLParser::STRIP_P, 0);
}


size_t PostgreSQLParser::Xml_whitespace_optionContext::getRuleIndex() const {
  return PostgreSQLParser::RuleXml_whitespace_option;
}


std::any PostgreSQLParser::Xml_whitespace_optionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitXml_whitespace_option(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Xml_whitespace_optionContext* PostgreSQLParser::xml_whitespace_option() {
  Xml_whitespace_optionContext *_localctx = _tracker.createInstance<Xml_whitespace_optionContext>(_ctx, getState());
  enterRule(_localctx, 1232, PostgreSQLParser::RuleXml_whitespace_option);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9688);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::PRESERVE: {
        enterOuterAlt(_localctx, 1);
        setState(9684);
        match(PostgreSQLParser::PRESERVE);
        setState(9685);
        match(PostgreSQLParser::WHITESPACE_P);
        break;
      }

      case PostgreSQLParser::STRIP_P: {
        enterOuterAlt(_localctx, 2);
        setState(9686);
        match(PostgreSQLParser::STRIP_P);
        setState(9687);
        match(PostgreSQLParser::WHITESPACE_P);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xmlexists_argumentContext ------------------------------------------------------------------

PostgreSQLParser::Xmlexists_argumentContext::Xmlexists_argumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Xmlexists_argumentContext::PASSING() {
  return getToken(PostgreSQLParser::PASSING, 0);
}

PostgreSQLParser::C_exprContext* PostgreSQLParser::Xmlexists_argumentContext::c_expr() {
  return getRuleContext<PostgreSQLParser::C_exprContext>(0);
}

std::vector<PostgreSQLParser::Xml_passing_mechContext *> PostgreSQLParser::Xmlexists_argumentContext::xml_passing_mech() {
  return getRuleContexts<PostgreSQLParser::Xml_passing_mechContext>();
}

PostgreSQLParser::Xml_passing_mechContext* PostgreSQLParser::Xmlexists_argumentContext::xml_passing_mech(size_t i) {
  return getRuleContext<PostgreSQLParser::Xml_passing_mechContext>(i);
}


size_t PostgreSQLParser::Xmlexists_argumentContext::getRuleIndex() const {
  return PostgreSQLParser::RuleXmlexists_argument;
}


std::any PostgreSQLParser::Xmlexists_argumentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitXmlexists_argument(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Xmlexists_argumentContext* PostgreSQLParser::xmlexists_argument() {
  Xmlexists_argumentContext *_localctx = _tracker.createInstance<Xmlexists_argumentContext>(_ctx, getState());
  enterRule(_localctx, 1234, PostgreSQLParser::RuleXmlexists_argument);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9705);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 961, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9690);
      match(PostgreSQLParser::PASSING);
      setState(9691);
      c_expr();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9692);
      match(PostgreSQLParser::PASSING);
      setState(9693);
      c_expr();
      setState(9694);
      xml_passing_mech();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(9696);
      match(PostgreSQLParser::PASSING);
      setState(9697);
      xml_passing_mech();
      setState(9698);
      c_expr();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(9700);
      match(PostgreSQLParser::PASSING);
      setState(9701);
      xml_passing_mech();
      setState(9702);
      c_expr();
      setState(9703);
      xml_passing_mech();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Xml_passing_mechContext ------------------------------------------------------------------

PostgreSQLParser::Xml_passing_mechContext::Xml_passing_mechContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Xml_passing_mechContext::BY() {
  return getToken(PostgreSQLParser::BY, 0);
}

tree::TerminalNode* PostgreSQLParser::Xml_passing_mechContext::REF() {
  return getToken(PostgreSQLParser::REF, 0);
}

tree::TerminalNode* PostgreSQLParser::Xml_passing_mechContext::VALUE_P() {
  return getToken(PostgreSQLParser::VALUE_P, 0);
}


size_t PostgreSQLParser::Xml_passing_mechContext::getRuleIndex() const {
  return PostgreSQLParser::RuleXml_passing_mech;
}


std::any PostgreSQLParser::Xml_passing_mechContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitXml_passing_mech(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Xml_passing_mechContext* PostgreSQLParser::xml_passing_mech() {
  Xml_passing_mechContext *_localctx = _tracker.createInstance<Xml_passing_mechContext>(_ctx, getState());
  enterRule(_localctx, 1236, PostgreSQLParser::RuleXml_passing_mech);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9707);
    match(PostgreSQLParser::BY);
    setState(9708);
    _la = _input->LA(1);
    if (!(_la == PostgreSQLParser::REF || _la == PostgreSQLParser::VALUE_P)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Within_group_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Within_group_clauseContext::Within_group_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Within_group_clauseContext::WITHIN() {
  return getToken(PostgreSQLParser::WITHIN, 0);
}

tree::TerminalNode* PostgreSQLParser::Within_group_clauseContext::GROUP_P() {
  return getToken(PostgreSQLParser::GROUP_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Within_group_clauseContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Sort_clauseContext* PostgreSQLParser::Within_group_clauseContext::sort_clause() {
  return getRuleContext<PostgreSQLParser::Sort_clauseContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Within_group_clauseContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Within_group_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleWithin_group_clause;
}


std::any PostgreSQLParser::Within_group_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitWithin_group_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Within_group_clauseContext* PostgreSQLParser::within_group_clause() {
  Within_group_clauseContext *_localctx = _tracker.createInstance<Within_group_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1238, PostgreSQLParser::RuleWithin_group_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9710);
    match(PostgreSQLParser::WITHIN);
    setState(9711);
    match(PostgreSQLParser::GROUP_P);
    setState(9712);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(9713);
    sort_clause();
    setState(9714);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Filter_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Filter_clauseContext::Filter_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Filter_clauseContext::FILTER() {
  return getToken(PostgreSQLParser::FILTER, 0);
}

tree::TerminalNode* PostgreSQLParser::Filter_clauseContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::Filter_clauseContext::WHERE() {
  return getToken(PostgreSQLParser::WHERE, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Filter_clauseContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Filter_clauseContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Filter_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFilter_clause;
}


std::any PostgreSQLParser::Filter_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFilter_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Filter_clauseContext* PostgreSQLParser::filter_clause() {
  Filter_clauseContext *_localctx = _tracker.createInstance<Filter_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1240, PostgreSQLParser::RuleFilter_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9716);
    match(PostgreSQLParser::FILTER);
    setState(9717);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(9718);
    match(PostgreSQLParser::WHERE);
    setState(9719);
    a_expr();
    setState(9720);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Window_clauseContext::Window_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Window_clauseContext::WINDOW() {
  return getToken(PostgreSQLParser::WINDOW, 0);
}

PostgreSQLParser::Window_definition_listContext* PostgreSQLParser::Window_clauseContext::window_definition_list() {
  return getRuleContext<PostgreSQLParser::Window_definition_listContext>(0);
}


size_t PostgreSQLParser::Window_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleWindow_clause;
}


std::any PostgreSQLParser::Window_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitWindow_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Window_clauseContext* PostgreSQLParser::window_clause() {
  Window_clauseContext *_localctx = _tracker.createInstance<Window_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1242, PostgreSQLParser::RuleWindow_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9722);
    match(PostgreSQLParser::WINDOW);
    setState(9723);
    window_definition_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_definition_listContext ------------------------------------------------------------------

PostgreSQLParser::Window_definition_listContext::Window_definition_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Window_definitionContext *> PostgreSQLParser::Window_definition_listContext::window_definition() {
  return getRuleContexts<PostgreSQLParser::Window_definitionContext>();
}

PostgreSQLParser::Window_definitionContext* PostgreSQLParser::Window_definition_listContext::window_definition(size_t i) {
  return getRuleContext<PostgreSQLParser::Window_definitionContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Window_definition_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Window_definition_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Window_definition_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleWindow_definition_list;
}


std::any PostgreSQLParser::Window_definition_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitWindow_definition_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Window_definition_listContext* PostgreSQLParser::window_definition_list() {
  Window_definition_listContext *_localctx = _tracker.createInstance<Window_definition_listContext>(_ctx, getState());
  enterRule(_localctx, 1244, PostgreSQLParser::RuleWindow_definition_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9725);
    window_definition();
    setState(9730);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(9726);
      match(PostgreSQLParser::COMMA);
      setState(9727);
      window_definition();
      setState(9732);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_definitionContext ------------------------------------------------------------------

PostgreSQLParser::Window_definitionContext::Window_definitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Window_definitionContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Window_definitionContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

PostgreSQLParser::Window_specificationContext* PostgreSQLParser::Window_definitionContext::window_specification() {
  return getRuleContext<PostgreSQLParser::Window_specificationContext>(0);
}


size_t PostgreSQLParser::Window_definitionContext::getRuleIndex() const {
  return PostgreSQLParser::RuleWindow_definition;
}


std::any PostgreSQLParser::Window_definitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitWindow_definition(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Window_definitionContext* PostgreSQLParser::window_definition() {
  Window_definitionContext *_localctx = _tracker.createInstance<Window_definitionContext>(_ctx, getState());
  enterRule(_localctx, 1246, PostgreSQLParser::RuleWindow_definition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9733);
    colid();
    setState(9734);
    match(PostgreSQLParser::AS);
    setState(9735);
    window_specification();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Over_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Over_clauseContext::Over_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Over_clauseContext::OVER() {
  return getToken(PostgreSQLParser::OVER, 0);
}

PostgreSQLParser::Window_specificationContext* PostgreSQLParser::Over_clauseContext::window_specification() {
  return getRuleContext<PostgreSQLParser::Window_specificationContext>(0);
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Over_clauseContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}


size_t PostgreSQLParser::Over_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOver_clause;
}


std::any PostgreSQLParser::Over_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOver_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Over_clauseContext* PostgreSQLParser::over_clause() {
  Over_clauseContext *_localctx = _tracker.createInstance<Over_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1248, PostgreSQLParser::RuleOver_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9737);
    match(PostgreSQLParser::OVER);
    setState(9740);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::OPEN_PAREN: {
        setState(9738);
        window_specification();
        break;
      }

      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        setState(9739);
        colid();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_specificationContext ------------------------------------------------------------------

PostgreSQLParser::Window_specificationContext::Window_specificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Window_specificationContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::Window_specificationContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::Existing_window_name_Context* PostgreSQLParser::Window_specificationContext::existing_window_name_() {
  return getRuleContext<PostgreSQLParser::Existing_window_name_Context>(0);
}

PostgreSQLParser::Partition_clause_Context* PostgreSQLParser::Window_specificationContext::partition_clause_() {
  return getRuleContext<PostgreSQLParser::Partition_clause_Context>(0);
}

PostgreSQLParser::Sort_clause_Context* PostgreSQLParser::Window_specificationContext::sort_clause_() {
  return getRuleContext<PostgreSQLParser::Sort_clause_Context>(0);
}

PostgreSQLParser::Frame_clause_Context* PostgreSQLParser::Window_specificationContext::frame_clause_() {
  return getRuleContext<PostgreSQLParser::Frame_clause_Context>(0);
}


size_t PostgreSQLParser::Window_specificationContext::getRuleIndex() const {
  return PostgreSQLParser::RuleWindow_specification;
}


std::any PostgreSQLParser::Window_specificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitWindow_specification(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Window_specificationContext* PostgreSQLParser::window_specification() {
  Window_specificationContext *_localctx = _tracker.createInstance<Window_specificationContext>(_ctx, getState());
  enterRule(_localctx, 1250, PostgreSQLParser::RuleWindow_specification);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9742);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(9744);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 964, _ctx)) {
    case 1: {
      setState(9743);
      existing_window_name_();
      break;
    }

    default:
      break;
    }
    setState(9747);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::PARTITION) {
      setState(9746);
      partition_clause_();
    }
    setState(9750);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::ORDER) {
      setState(9749);
      sort_clause_();
    }
    setState(9753);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::RANGE

    || _la == PostgreSQLParser::ROWS || _la == PostgreSQLParser::GROUPS) {
      setState(9752);
      frame_clause_();
    }
    setState(9755);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Existing_window_name_Context ------------------------------------------------------------------

PostgreSQLParser::Existing_window_name_Context::Existing_window_name_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Existing_window_name_Context::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}


size_t PostgreSQLParser::Existing_window_name_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleExisting_window_name_;
}


std::any PostgreSQLParser::Existing_window_name_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitExisting_window_name_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Existing_window_name_Context* PostgreSQLParser::existing_window_name_() {
  Existing_window_name_Context *_localctx = _tracker.createInstance<Existing_window_name_Context>(_ctx, getState());
  enterRule(_localctx, 1252, PostgreSQLParser::RuleExisting_window_name_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9757);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Partition_clause_Context ------------------------------------------------------------------

PostgreSQLParser::Partition_clause_Context::Partition_clause_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Partition_clause_Context::PARTITION() {
  return getToken(PostgreSQLParser::PARTITION, 0);
}

tree::TerminalNode* PostgreSQLParser::Partition_clause_Context::BY() {
  return getToken(PostgreSQLParser::BY, 0);
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::Partition_clause_Context::expr_list() {
  return getRuleContext<PostgreSQLParser::Expr_listContext>(0);
}


size_t PostgreSQLParser::Partition_clause_Context::getRuleIndex() const {
  return PostgreSQLParser::RulePartition_clause_;
}


std::any PostgreSQLParser::Partition_clause_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitPartition_clause_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Partition_clause_Context* PostgreSQLParser::partition_clause_() {
  Partition_clause_Context *_localctx = _tracker.createInstance<Partition_clause_Context>(_ctx, getState());
  enterRule(_localctx, 1254, PostgreSQLParser::RulePartition_clause_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9759);
    match(PostgreSQLParser::PARTITION);
    setState(9760);
    match(PostgreSQLParser::BY);
    setState(9761);
    expr_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_clause_Context ------------------------------------------------------------------

PostgreSQLParser::Frame_clause_Context::Frame_clause_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Frame_clause_Context::RANGE() {
  return getToken(PostgreSQLParser::RANGE, 0);
}

PostgreSQLParser::Frame_extentContext* PostgreSQLParser::Frame_clause_Context::frame_extent() {
  return getRuleContext<PostgreSQLParser::Frame_extentContext>(0);
}

PostgreSQLParser::Window_exclusion_clause_Context* PostgreSQLParser::Frame_clause_Context::window_exclusion_clause_() {
  return getRuleContext<PostgreSQLParser::Window_exclusion_clause_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::Frame_clause_Context::ROWS() {
  return getToken(PostgreSQLParser::ROWS, 0);
}

tree::TerminalNode* PostgreSQLParser::Frame_clause_Context::GROUPS() {
  return getToken(PostgreSQLParser::GROUPS, 0);
}


size_t PostgreSQLParser::Frame_clause_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleFrame_clause_;
}


std::any PostgreSQLParser::Frame_clause_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFrame_clause_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Frame_clause_Context* PostgreSQLParser::frame_clause_() {
  Frame_clause_Context *_localctx = _tracker.createInstance<Frame_clause_Context>(_ctx, getState());
  enterRule(_localctx, 1256, PostgreSQLParser::RuleFrame_clause_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9778);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::RANGE: {
        enterOuterAlt(_localctx, 1);
        setState(9763);
        match(PostgreSQLParser::RANGE);
        setState(9764);
        frame_extent();
        setState(9766);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::EXCLUDE) {
          setState(9765);
          window_exclusion_clause_();
        }
        break;
      }

      case PostgreSQLParser::ROWS: {
        enterOuterAlt(_localctx, 2);
        setState(9768);
        match(PostgreSQLParser::ROWS);
        setState(9769);
        frame_extent();
        setState(9771);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::EXCLUDE) {
          setState(9770);
          window_exclusion_clause_();
        }
        break;
      }

      case PostgreSQLParser::GROUPS: {
        enterOuterAlt(_localctx, 3);
        setState(9773);
        match(PostgreSQLParser::GROUPS);
        setState(9774);
        frame_extent();
        setState(9776);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::EXCLUDE) {
          setState(9775);
          window_exclusion_clause_();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_extentContext ------------------------------------------------------------------

PostgreSQLParser::Frame_extentContext::Frame_extentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Frame_boundContext *> PostgreSQLParser::Frame_extentContext::frame_bound() {
  return getRuleContexts<PostgreSQLParser::Frame_boundContext>();
}

PostgreSQLParser::Frame_boundContext* PostgreSQLParser::Frame_extentContext::frame_bound(size_t i) {
  return getRuleContext<PostgreSQLParser::Frame_boundContext>(i);
}

tree::TerminalNode* PostgreSQLParser::Frame_extentContext::BETWEEN() {
  return getToken(PostgreSQLParser::BETWEEN, 0);
}

tree::TerminalNode* PostgreSQLParser::Frame_extentContext::AND() {
  return getToken(PostgreSQLParser::AND, 0);
}


size_t PostgreSQLParser::Frame_extentContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFrame_extent;
}


std::any PostgreSQLParser::Frame_extentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFrame_extent(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Frame_extentContext* PostgreSQLParser::frame_extent() {
  Frame_extentContext *_localctx = _tracker.createInstance<Frame_extentContext>(_ctx, getState());
  enterRule(_localctx, 1258, PostgreSQLParser::RuleFrame_extent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9786);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 972, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9780);
      frame_bound();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9781);
      match(PostgreSQLParser::BETWEEN);
      setState(9782);
      frame_bound();
      setState(9783);
      match(PostgreSQLParser::AND);
      setState(9784);
      frame_bound();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_boundContext ------------------------------------------------------------------

PostgreSQLParser::Frame_boundContext::Frame_boundContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Frame_boundContext::UNBOUNDED() {
  return getToken(PostgreSQLParser::UNBOUNDED, 0);
}

tree::TerminalNode* PostgreSQLParser::Frame_boundContext::PRECEDING() {
  return getToken(PostgreSQLParser::PRECEDING, 0);
}

tree::TerminalNode* PostgreSQLParser::Frame_boundContext::FOLLOWING() {
  return getToken(PostgreSQLParser::FOLLOWING, 0);
}

tree::TerminalNode* PostgreSQLParser::Frame_boundContext::CURRENT_P() {
  return getToken(PostgreSQLParser::CURRENT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Frame_boundContext::ROW() {
  return getToken(PostgreSQLParser::ROW, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Frame_boundContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}


size_t PostgreSQLParser::Frame_boundContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFrame_bound;
}


std::any PostgreSQLParser::Frame_boundContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFrame_bound(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Frame_boundContext* PostgreSQLParser::frame_bound() {
  Frame_boundContext *_localctx = _tracker.createInstance<Frame_boundContext>(_ctx, getState());
  enterRule(_localctx, 1260, PostgreSQLParser::RuleFrame_bound);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9795);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 973, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9788);
      match(PostgreSQLParser::UNBOUNDED);
      setState(9789);
      _la = _input->LA(1);
      if (!(_la == PostgreSQLParser::FOLLOWING || _la == PostgreSQLParser::PRECEDING)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9790);
      match(PostgreSQLParser::CURRENT_P);
      setState(9791);
      match(PostgreSQLParser::ROW);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(9792);
      a_expr();
      setState(9793);
      _la = _input->LA(1);
      if (!(_la == PostgreSQLParser::FOLLOWING || _la == PostgreSQLParser::PRECEDING)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_exclusion_clause_Context ------------------------------------------------------------------

PostgreSQLParser::Window_exclusion_clause_Context::Window_exclusion_clause_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Window_exclusion_clause_Context::EXCLUDE() {
  return getToken(PostgreSQLParser::EXCLUDE, 0);
}

tree::TerminalNode* PostgreSQLParser::Window_exclusion_clause_Context::CURRENT_P() {
  return getToken(PostgreSQLParser::CURRENT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Window_exclusion_clause_Context::ROW() {
  return getToken(PostgreSQLParser::ROW, 0);
}

tree::TerminalNode* PostgreSQLParser::Window_exclusion_clause_Context::GROUP_P() {
  return getToken(PostgreSQLParser::GROUP_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Window_exclusion_clause_Context::TIES() {
  return getToken(PostgreSQLParser::TIES, 0);
}

tree::TerminalNode* PostgreSQLParser::Window_exclusion_clause_Context::NO() {
  return getToken(PostgreSQLParser::NO, 0);
}

tree::TerminalNode* PostgreSQLParser::Window_exclusion_clause_Context::OTHERS() {
  return getToken(PostgreSQLParser::OTHERS, 0);
}


size_t PostgreSQLParser::Window_exclusion_clause_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleWindow_exclusion_clause_;
}


std::any PostgreSQLParser::Window_exclusion_clause_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitWindow_exclusion_clause_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Window_exclusion_clause_Context* PostgreSQLParser::window_exclusion_clause_() {
  Window_exclusion_clause_Context *_localctx = _tracker.createInstance<Window_exclusion_clause_Context>(_ctx, getState());
  enterRule(_localctx, 1262, PostgreSQLParser::RuleWindow_exclusion_clause_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9797);
    match(PostgreSQLParser::EXCLUDE);
    setState(9804);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::CURRENT_P: {
        setState(9798);
        match(PostgreSQLParser::CURRENT_P);
        setState(9799);
        match(PostgreSQLParser::ROW);
        break;
      }

      case PostgreSQLParser::GROUP_P: {
        setState(9800);
        match(PostgreSQLParser::GROUP_P);
        break;
      }

      case PostgreSQLParser::TIES: {
        setState(9801);
        match(PostgreSQLParser::TIES);
        break;
      }

      case PostgreSQLParser::NO: {
        setState(9802);
        match(PostgreSQLParser::NO);
        setState(9803);
        match(PostgreSQLParser::OTHERS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RowContext ------------------------------------------------------------------

PostgreSQLParser::RowContext::RowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::RowContext::ROW() {
  return getToken(PostgreSQLParser::ROW, 0);
}

tree::TerminalNode* PostgreSQLParser::RowContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::RowContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::RowContext::expr_list() {
  return getRuleContext<PostgreSQLParser::Expr_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::RowContext::COMMA() {
  return getToken(PostgreSQLParser::COMMA, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::RowContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}


size_t PostgreSQLParser::RowContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRow;
}


std::any PostgreSQLParser::RowContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRow(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RowContext* PostgreSQLParser::row() {
  RowContext *_localctx = _tracker.createInstance<RowContext>(_ctx, getState());
  enterRule(_localctx, 1264, PostgreSQLParser::RuleRow);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9818);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::ROW: {
        enterOuterAlt(_localctx, 1);
        setState(9806);
        match(PostgreSQLParser::ROW);
        setState(9807);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9809);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & -268423164) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & -9214927770107198969) != 0) || ((((_la - 134) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 134)) & -1011) != 0) || ((((_la - 198) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 198)) & -1) != 0) || ((((_la - 262) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 262)) & -1) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 326)) & -129) != 0) || ((((_la - 390) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 390)) & -1) != 0) || ((((_la - 454) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 454)) & -2305843284091601405) != 0) || ((((_la - 518) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 518)) & -4880034784790705153) != 0) || _la == PostgreSQLParser::PLSQLVARIABLENAME

        || _la == PostgreSQLParser::EscapeStringConstant) {
          setState(9808);
          expr_list();
        }
        setState(9811);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::OPEN_PAREN: {
        enterOuterAlt(_localctx, 2);
        setState(9812);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9813);
        expr_list();
        setState(9814);
        match(PostgreSQLParser::COMMA);
        setState(9815);
        a_expr();
        setState(9816);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Explicit_rowContext ------------------------------------------------------------------

PostgreSQLParser::Explicit_rowContext::Explicit_rowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Explicit_rowContext::ROW() {
  return getToken(PostgreSQLParser::ROW, 0);
}

tree::TerminalNode* PostgreSQLParser::Explicit_rowContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::Explicit_rowContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::Explicit_rowContext::expr_list() {
  return getRuleContext<PostgreSQLParser::Expr_listContext>(0);
}


size_t PostgreSQLParser::Explicit_rowContext::getRuleIndex() const {
  return PostgreSQLParser::RuleExplicit_row;
}


std::any PostgreSQLParser::Explicit_rowContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitExplicit_row(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Explicit_rowContext* PostgreSQLParser::explicit_row() {
  Explicit_rowContext *_localctx = _tracker.createInstance<Explicit_rowContext>(_ctx, getState());
  enterRule(_localctx, 1266, PostgreSQLParser::RuleExplicit_row);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9820);
    match(PostgreSQLParser::ROW);
    setState(9821);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(9823);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -268423164) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -9214927770107198969) != 0) || ((((_la - 134) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 134)) & -1011) != 0) || ((((_la - 198) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 198)) & -1) != 0) || ((((_la - 262) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 262)) & -1) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & -129) != 0) || ((((_la - 390) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 390)) & -1) != 0) || ((((_la - 454) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 454)) & -2305843284091601405) != 0) || ((((_la - 518) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 518)) & -4880034784790705153) != 0) || _la == PostgreSQLParser::PLSQLVARIABLENAME

    || _la == PostgreSQLParser::EscapeStringConstant) {
      setState(9822);
      expr_list();
    }
    setState(9825);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Implicit_rowContext ------------------------------------------------------------------

PostgreSQLParser::Implicit_rowContext::Implicit_rowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Implicit_rowContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::Implicit_rowContext::expr_list() {
  return getRuleContext<PostgreSQLParser::Expr_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Implicit_rowContext::COMMA() {
  return getToken(PostgreSQLParser::COMMA, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Implicit_rowContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Implicit_rowContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Implicit_rowContext::getRuleIndex() const {
  return PostgreSQLParser::RuleImplicit_row;
}


std::any PostgreSQLParser::Implicit_rowContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitImplicit_row(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Implicit_rowContext* PostgreSQLParser::implicit_row() {
  Implicit_rowContext *_localctx = _tracker.createInstance<Implicit_rowContext>(_ctx, getState());
  enterRule(_localctx, 1268, PostgreSQLParser::RuleImplicit_row);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9827);
    match(PostgreSQLParser::OPEN_PAREN);
    setState(9828);
    expr_list();
    setState(9829);
    match(PostgreSQLParser::COMMA);
    setState(9830);
    a_expr();
    setState(9831);
    match(PostgreSQLParser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sub_typeContext ------------------------------------------------------------------

PostgreSQLParser::Sub_typeContext::Sub_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Sub_typeContext::ANY() {
  return getToken(PostgreSQLParser::ANY, 0);
}

tree::TerminalNode* PostgreSQLParser::Sub_typeContext::SOME() {
  return getToken(PostgreSQLParser::SOME, 0);
}

tree::TerminalNode* PostgreSQLParser::Sub_typeContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}


size_t PostgreSQLParser::Sub_typeContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSub_type;
}


std::any PostgreSQLParser::Sub_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSub_type(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Sub_typeContext* PostgreSQLParser::sub_type() {
  Sub_typeContext *_localctx = _tracker.createInstance<Sub_typeContext>(_ctx, getState());
  enterRule(_localctx, 1270, PostgreSQLParser::RuleSub_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9833);
    _la = _input->LA(1);
    if (!(((((_la - 68) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 68)) & 1152921504606846993) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- All_opContext ------------------------------------------------------------------

PostgreSQLParser::All_opContext::All_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::All_opContext::Operator() {
  return getToken(PostgreSQLParser::Operator, 0);
}

PostgreSQLParser::MathopContext* PostgreSQLParser::All_opContext::mathop() {
  return getRuleContext<PostgreSQLParser::MathopContext>(0);
}


size_t PostgreSQLParser::All_opContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAll_op;
}


std::any PostgreSQLParser::All_opContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAll_op(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::All_opContext* PostgreSQLParser::all_op() {
  All_opContext *_localctx = _tracker.createInstance<All_opContext>(_ctx, getState());
  enterRule(_localctx, 1272, PostgreSQLParser::RuleAll_op);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9837);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::Operator: {
        enterOuterAlt(_localctx, 1);
        setState(9835);
        match(PostgreSQLParser::Operator);
        break;
      }

      case PostgreSQLParser::STAR:
      case PostgreSQLParser::EQUAL:
      case PostgreSQLParser::PLUS:
      case PostgreSQLParser::MINUS:
      case PostgreSQLParser::SLASH:
      case PostgreSQLParser::CARET:
      case PostgreSQLParser::LT:
      case PostgreSQLParser::GT:
      case PostgreSQLParser::LESS_EQUALS:
      case PostgreSQLParser::GREATER_EQUALS:
      case PostgreSQLParser::NOT_EQUALS:
      case PostgreSQLParser::PERCENT: {
        enterOuterAlt(_localctx, 2);
        setState(9836);
        mathop();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MathopContext ------------------------------------------------------------------

PostgreSQLParser::MathopContext::MathopContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::MathopContext::PLUS() {
  return getToken(PostgreSQLParser::PLUS, 0);
}

tree::TerminalNode* PostgreSQLParser::MathopContext::MINUS() {
  return getToken(PostgreSQLParser::MINUS, 0);
}

tree::TerminalNode* PostgreSQLParser::MathopContext::STAR() {
  return getToken(PostgreSQLParser::STAR, 0);
}

tree::TerminalNode* PostgreSQLParser::MathopContext::SLASH() {
  return getToken(PostgreSQLParser::SLASH, 0);
}

tree::TerminalNode* PostgreSQLParser::MathopContext::PERCENT() {
  return getToken(PostgreSQLParser::PERCENT, 0);
}

tree::TerminalNode* PostgreSQLParser::MathopContext::CARET() {
  return getToken(PostgreSQLParser::CARET, 0);
}

tree::TerminalNode* PostgreSQLParser::MathopContext::LT() {
  return getToken(PostgreSQLParser::LT, 0);
}

tree::TerminalNode* PostgreSQLParser::MathopContext::GT() {
  return getToken(PostgreSQLParser::GT, 0);
}

tree::TerminalNode* PostgreSQLParser::MathopContext::EQUAL() {
  return getToken(PostgreSQLParser::EQUAL, 0);
}

tree::TerminalNode* PostgreSQLParser::MathopContext::LESS_EQUALS() {
  return getToken(PostgreSQLParser::LESS_EQUALS, 0);
}

tree::TerminalNode* PostgreSQLParser::MathopContext::GREATER_EQUALS() {
  return getToken(PostgreSQLParser::GREATER_EQUALS, 0);
}

tree::TerminalNode* PostgreSQLParser::MathopContext::NOT_EQUALS() {
  return getToken(PostgreSQLParser::NOT_EQUALS, 0);
}


size_t PostgreSQLParser::MathopContext::getRuleIndex() const {
  return PostgreSQLParser::RuleMathop;
}


std::any PostgreSQLParser::MathopContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitMathop(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::MathopContext* PostgreSQLParser::mathop() {
  MathopContext *_localctx = _tracker.createInstance<MathopContext>(_ctx, getState());
  enterRule(_localctx, 1274, PostgreSQLParser::RuleMathop);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9839);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 178517504) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Qual_opContext ------------------------------------------------------------------

PostgreSQLParser::Qual_opContext::Qual_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Qual_opContext::Operator() {
  return getToken(PostgreSQLParser::Operator, 0);
}

tree::TerminalNode* PostgreSQLParser::Qual_opContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

tree::TerminalNode* PostgreSQLParser::Qual_opContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Any_operatorContext* PostgreSQLParser::Qual_opContext::any_operator() {
  return getRuleContext<PostgreSQLParser::Any_operatorContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Qual_opContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Qual_opContext::getRuleIndex() const {
  return PostgreSQLParser::RuleQual_op;
}


std::any PostgreSQLParser::Qual_opContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitQual_op(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Qual_opContext* PostgreSQLParser::qual_op() {
  Qual_opContext *_localctx = _tracker.createInstance<Qual_opContext>(_ctx, getState());
  enterRule(_localctx, 1276, PostgreSQLParser::RuleQual_op);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9847);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::Operator: {
        enterOuterAlt(_localctx, 1);
        setState(9841);
        match(PostgreSQLParser::Operator);
        break;
      }

      case PostgreSQLParser::OPERATOR: {
        enterOuterAlt(_localctx, 2);
        setState(9842);
        match(PostgreSQLParser::OPERATOR);
        setState(9843);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9844);
        any_operator();
        setState(9845);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Qual_all_opContext ------------------------------------------------------------------

PostgreSQLParser::Qual_all_opContext::Qual_all_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::All_opContext* PostgreSQLParser::Qual_all_opContext::all_op() {
  return getRuleContext<PostgreSQLParser::All_opContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Qual_all_opContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

tree::TerminalNode* PostgreSQLParser::Qual_all_opContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Any_operatorContext* PostgreSQLParser::Qual_all_opContext::any_operator() {
  return getRuleContext<PostgreSQLParser::Any_operatorContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Qual_all_opContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}


size_t PostgreSQLParser::Qual_all_opContext::getRuleIndex() const {
  return PostgreSQLParser::RuleQual_all_op;
}


std::any PostgreSQLParser::Qual_all_opContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitQual_all_op(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Qual_all_opContext* PostgreSQLParser::qual_all_op() {
  Qual_all_opContext *_localctx = _tracker.createInstance<Qual_all_opContext>(_ctx, getState());
  enterRule(_localctx, 1278, PostgreSQLParser::RuleQual_all_op);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9855);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::STAR:
      case PostgreSQLParser::EQUAL:
      case PostgreSQLParser::PLUS:
      case PostgreSQLParser::MINUS:
      case PostgreSQLParser::SLASH:
      case PostgreSQLParser::CARET:
      case PostgreSQLParser::LT:
      case PostgreSQLParser::GT:
      case PostgreSQLParser::LESS_EQUALS:
      case PostgreSQLParser::GREATER_EQUALS:
      case PostgreSQLParser::NOT_EQUALS:
      case PostgreSQLParser::PERCENT:
      case PostgreSQLParser::Operator: {
        enterOuterAlt(_localctx, 1);
        setState(9849);
        all_op();
        break;
      }

      case PostgreSQLParser::OPERATOR: {
        enterOuterAlt(_localctx, 2);
        setState(9850);
        match(PostgreSQLParser::OPERATOR);
        setState(9851);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(9852);
        any_operator();
        setState(9853);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subquery_OpContext ------------------------------------------------------------------

PostgreSQLParser::Subquery_OpContext::Subquery_OpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::All_opContext* PostgreSQLParser::Subquery_OpContext::all_op() {
  return getRuleContext<PostgreSQLParser::All_opContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Subquery_OpContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

tree::TerminalNode* PostgreSQLParser::Subquery_OpContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Any_operatorContext* PostgreSQLParser::Subquery_OpContext::any_operator() {
  return getRuleContext<PostgreSQLParser::Any_operatorContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Subquery_OpContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* PostgreSQLParser::Subquery_OpContext::LIKE() {
  return getToken(PostgreSQLParser::LIKE, 0);
}

tree::TerminalNode* PostgreSQLParser::Subquery_OpContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::Subquery_OpContext::ILIKE() {
  return getToken(PostgreSQLParser::ILIKE, 0);
}


size_t PostgreSQLParser::Subquery_OpContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSubquery_Op;
}


std::any PostgreSQLParser::Subquery_OpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSubquery_Op(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Subquery_OpContext* PostgreSQLParser::subquery_Op() {
  Subquery_OpContext *_localctx = _tracker.createInstance<Subquery_OpContext>(_ctx, getState());
  enterRule(_localctx, 1280, PostgreSQLParser::RuleSubquery_Op);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9869);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 981, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9857);
      all_op();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9858);
      match(PostgreSQLParser::OPERATOR);
      setState(9859);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(9860);
      any_operator();
      setState(9861);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(9863);
      match(PostgreSQLParser::LIKE);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(9864);
      match(PostgreSQLParser::NOT);
      setState(9865);
      match(PostgreSQLParser::LIKE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(9866);
      match(PostgreSQLParser::ILIKE);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(9867);
      match(PostgreSQLParser::NOT);
      setState(9868);
      match(PostgreSQLParser::ILIKE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_listContext ------------------------------------------------------------------

PostgreSQLParser::Expr_listContext::Expr_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::A_exprContext *> PostgreSQLParser::Expr_listContext::a_expr() {
  return getRuleContexts<PostgreSQLParser::A_exprContext>();
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Expr_listContext::a_expr(size_t i) {
  return getRuleContext<PostgreSQLParser::A_exprContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Expr_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Expr_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Expr_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleExpr_list;
}


std::any PostgreSQLParser::Expr_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitExpr_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::expr_list() {
  Expr_listContext *_localctx = _tracker.createInstance<Expr_listContext>(_ctx, getState());
  enterRule(_localctx, 1282, PostgreSQLParser::RuleExpr_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9871);
    a_expr();
    setState(9876);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 982, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(9872);
        match(PostgreSQLParser::COMMA);
        setState(9873);
        a_expr(); 
      }
      setState(9878);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 982, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_arg_listContext ------------------------------------------------------------------

PostgreSQLParser::Func_arg_listContext::Func_arg_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Func_arg_exprContext *> PostgreSQLParser::Func_arg_listContext::func_arg_expr() {
  return getRuleContexts<PostgreSQLParser::Func_arg_exprContext>();
}

PostgreSQLParser::Func_arg_exprContext* PostgreSQLParser::Func_arg_listContext::func_arg_expr(size_t i) {
  return getRuleContext<PostgreSQLParser::Func_arg_exprContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Func_arg_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Func_arg_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Func_arg_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunc_arg_list;
}


std::any PostgreSQLParser::Func_arg_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunc_arg_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Func_arg_listContext* PostgreSQLParser::func_arg_list() {
  Func_arg_listContext *_localctx = _tracker.createInstance<Func_arg_listContext>(_ctx, getState());
  enterRule(_localctx, 1284, PostgreSQLParser::RuleFunc_arg_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(9879);
    func_arg_expr();
    setState(9884);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 983, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(9880);
        match(PostgreSQLParser::COMMA);
        setState(9881);
        func_arg_expr(); 
      }
      setState(9886);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 983, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_arg_exprContext ------------------------------------------------------------------

PostgreSQLParser::Func_arg_exprContext::Func_arg_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Func_arg_exprContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

PostgreSQLParser::Param_nameContext* PostgreSQLParser::Func_arg_exprContext::param_name() {
  return getRuleContext<PostgreSQLParser::Param_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Func_arg_exprContext::COLON_EQUALS() {
  return getToken(PostgreSQLParser::COLON_EQUALS, 0);
}

tree::TerminalNode* PostgreSQLParser::Func_arg_exprContext::EQUALS_GREATER() {
  return getToken(PostgreSQLParser::EQUALS_GREATER, 0);
}


size_t PostgreSQLParser::Func_arg_exprContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunc_arg_expr;
}


std::any PostgreSQLParser::Func_arg_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunc_arg_expr(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Func_arg_exprContext* PostgreSQLParser::func_arg_expr() {
  Func_arg_exprContext *_localctx = _tracker.createInstance<Func_arg_exprContext>(_ctx, getState());
  enterRule(_localctx, 1286, PostgreSQLParser::RuleFunc_arg_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9892);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 984, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9887);
      a_expr();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9888);
      param_name();
      setState(9889);
      _la = _input->LA(1);
      if (!(_la == PostgreSQLParser::COLON_EQUALS

      || _la == PostgreSQLParser::EQUALS_GREATER)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(9890);
      a_expr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_listContext ------------------------------------------------------------------

PostgreSQLParser::Type_listContext::Type_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::TypenameContext *> PostgreSQLParser::Type_listContext::typename_() {
  return getRuleContexts<PostgreSQLParser::TypenameContext>();
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::Type_listContext::typename_(size_t i) {
  return getRuleContext<PostgreSQLParser::TypenameContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Type_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Type_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Type_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleType_list;
}


std::any PostgreSQLParser::Type_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitType_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Type_listContext* PostgreSQLParser::type_list() {
  Type_listContext *_localctx = _tracker.createInstance<Type_listContext>(_ctx, getState());
  enterRule(_localctx, 1288, PostgreSQLParser::RuleType_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9894);
    typename_();
    setState(9899);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(9895);
      match(PostgreSQLParser::COMMA);
      setState(9896);
      typename_();
      setState(9901);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_exprContext ------------------------------------------------------------------

PostgreSQLParser::Array_exprContext::Array_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Array_exprContext::OPEN_BRACKET() {
  return getToken(PostgreSQLParser::OPEN_BRACKET, 0);
}

tree::TerminalNode* PostgreSQLParser::Array_exprContext::CLOSE_BRACKET() {
  return getToken(PostgreSQLParser::CLOSE_BRACKET, 0);
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::Array_exprContext::expr_list() {
  return getRuleContext<PostgreSQLParser::Expr_listContext>(0);
}

PostgreSQLParser::Array_expr_listContext* PostgreSQLParser::Array_exprContext::array_expr_list() {
  return getRuleContext<PostgreSQLParser::Array_expr_listContext>(0);
}


size_t PostgreSQLParser::Array_exprContext::getRuleIndex() const {
  return PostgreSQLParser::RuleArray_expr;
}


std::any PostgreSQLParser::Array_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitArray_expr(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Array_exprContext* PostgreSQLParser::array_expr() {
  Array_exprContext *_localctx = _tracker.createInstance<Array_exprContext>(_ctx, getState());
  enterRule(_localctx, 1290, PostgreSQLParser::RuleArray_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9902);
    match(PostgreSQLParser::OPEN_BRACKET);
    setState(9905);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::OPEN_PAREN:
      case PostgreSQLParser::PLUS:
      case PostgreSQLParser::MINUS:
      case PostgreSQLParser::PARAM:
      case PostgreSQLParser::Operator:
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::SYSTEM_USER:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::ARRAY:
      case PostgreSQLParser::CASE:
      case PostgreSQLParser::CAST:
      case PostgreSQLParser::CURRENT_CATALOG:
      case PostgreSQLParser::CURRENT_DATE:
      case PostgreSQLParser::CURRENT_ROLE:
      case PostgreSQLParser::CURRENT_TIME:
      case PostgreSQLParser::CURRENT_TIMESTAMP:
      case PostgreSQLParser::CURRENT_USER:
      case PostgreSQLParser::DEFAULT:
      case PostgreSQLParser::FALSE_P:
      case PostgreSQLParser::LOCALTIME:
      case PostgreSQLParser::LOCALTIMESTAMP:
      case PostgreSQLParser::NOT:
      case PostgreSQLParser::NULL_P:
      case PostgreSQLParser::SESSION_USER:
      case PostgreSQLParser::TRUE_P:
      case PostgreSQLParser::UNIQUE:
      case PostgreSQLParser::USER:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::BinaryStringConstant:
      case PostgreSQLParser::HexadecimalStringConstant:
      case PostgreSQLParser::Integral:
      case PostgreSQLParser::BinaryIntegral:
      case PostgreSQLParser::OctalIntegral:
      case PostgreSQLParser::HexadecimalIntegral:
      case PostgreSQLParser::Numeric:
      case PostgreSQLParser::PLSQLVARIABLENAME:
      case PostgreSQLParser::EscapeStringConstant: {
        setState(9903);
        expr_list();
        break;
      }

      case PostgreSQLParser::OPEN_BRACKET: {
        setState(9904);
        array_expr_list();
        break;
      }

      case PostgreSQLParser::CLOSE_BRACKET: {
        break;
      }

    default:
      break;
    }
    setState(9907);
    match(PostgreSQLParser::CLOSE_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_expr_listContext ------------------------------------------------------------------

PostgreSQLParser::Array_expr_listContext::Array_expr_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Array_exprContext *> PostgreSQLParser::Array_expr_listContext::array_expr() {
  return getRuleContexts<PostgreSQLParser::Array_exprContext>();
}

PostgreSQLParser::Array_exprContext* PostgreSQLParser::Array_expr_listContext::array_expr(size_t i) {
  return getRuleContext<PostgreSQLParser::Array_exprContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Array_expr_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Array_expr_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Array_expr_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleArray_expr_list;
}


std::any PostgreSQLParser::Array_expr_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitArray_expr_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Array_expr_listContext* PostgreSQLParser::array_expr_list() {
  Array_expr_listContext *_localctx = _tracker.createInstance<Array_expr_listContext>(_ctx, getState());
  enterRule(_localctx, 1292, PostgreSQLParser::RuleArray_expr_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9909);
    array_expr();
    setState(9914);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(9910);
      match(PostgreSQLParser::COMMA);
      setState(9911);
      array_expr();
      setState(9916);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Extract_listContext ------------------------------------------------------------------

PostgreSQLParser::Extract_listContext::Extract_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Extract_argContext* PostgreSQLParser::Extract_listContext::extract_arg() {
  return getRuleContext<PostgreSQLParser::Extract_argContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Extract_listContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Extract_listContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}


size_t PostgreSQLParser::Extract_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleExtract_list;
}


std::any PostgreSQLParser::Extract_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitExtract_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Extract_listContext* PostgreSQLParser::extract_list() {
  Extract_listContext *_localctx = _tracker.createInstance<Extract_listContext>(_ctx, getState());
  enterRule(_localctx, 1294, PostgreSQLParser::RuleExtract_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9917);
    extract_arg();
    setState(9918);
    match(PostgreSQLParser::FROM);
    setState(9919);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Extract_argContext ------------------------------------------------------------------

PostgreSQLParser::Extract_argContext::Extract_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::IdentifierContext* PostgreSQLParser::Extract_argContext::identifier() {
  return getRuleContext<PostgreSQLParser::IdentifierContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Extract_argContext::YEAR_P() {
  return getToken(PostgreSQLParser::YEAR_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Extract_argContext::MONTH_P() {
  return getToken(PostgreSQLParser::MONTH_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Extract_argContext::DAY_P() {
  return getToken(PostgreSQLParser::DAY_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Extract_argContext::HOUR_P() {
  return getToken(PostgreSQLParser::HOUR_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Extract_argContext::MINUTE_P() {
  return getToken(PostgreSQLParser::MINUTE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Extract_argContext::SECOND_P() {
  return getToken(PostgreSQLParser::SECOND_P, 0);
}

PostgreSQLParser::SconstContext* PostgreSQLParser::Extract_argContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}


size_t PostgreSQLParser::Extract_argContext::getRuleIndex() const {
  return PostgreSQLParser::RuleExtract_arg;
}


std::any PostgreSQLParser::Extract_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitExtract_arg(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Extract_argContext* PostgreSQLParser::extract_arg() {
  Extract_argContext *_localctx = _tracker.createInstance<Extract_argContext>(_ctx, getState());
  enterRule(_localctx, 1296, PostgreSQLParser::RuleExtract_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9929);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 1);
        setState(9921);
        identifier();
        break;
      }

      case PostgreSQLParser::YEAR_P: {
        enterOuterAlt(_localctx, 2);
        setState(9922);
        match(PostgreSQLParser::YEAR_P);
        break;
      }

      case PostgreSQLParser::MONTH_P: {
        enterOuterAlt(_localctx, 3);
        setState(9923);
        match(PostgreSQLParser::MONTH_P);
        break;
      }

      case PostgreSQLParser::DAY_P: {
        enterOuterAlt(_localctx, 4);
        setState(9924);
        match(PostgreSQLParser::DAY_P);
        break;
      }

      case PostgreSQLParser::HOUR_P: {
        enterOuterAlt(_localctx, 5);
        setState(9925);
        match(PostgreSQLParser::HOUR_P);
        break;
      }

      case PostgreSQLParser::MINUTE_P: {
        enterOuterAlt(_localctx, 6);
        setState(9926);
        match(PostgreSQLParser::MINUTE_P);
        break;
      }

      case PostgreSQLParser::SECOND_P: {
        enterOuterAlt(_localctx, 7);
        setState(9927);
        match(PostgreSQLParser::SECOND_P);
        break;
      }

      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::EscapeStringConstant: {
        enterOuterAlt(_localctx, 8);
        setState(9928);
        sconst();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unicode_normal_formContext ------------------------------------------------------------------

PostgreSQLParser::Unicode_normal_formContext::Unicode_normal_formContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Unicode_normal_formContext::NFC() {
  return getToken(PostgreSQLParser::NFC, 0);
}

tree::TerminalNode* PostgreSQLParser::Unicode_normal_formContext::NFD() {
  return getToken(PostgreSQLParser::NFD, 0);
}

tree::TerminalNode* PostgreSQLParser::Unicode_normal_formContext::NFKC() {
  return getToken(PostgreSQLParser::NFKC, 0);
}

tree::TerminalNode* PostgreSQLParser::Unicode_normal_formContext::NFKD() {
  return getToken(PostgreSQLParser::NFKD, 0);
}


size_t PostgreSQLParser::Unicode_normal_formContext::getRuleIndex() const {
  return PostgreSQLParser::RuleUnicode_normal_form;
}


std::any PostgreSQLParser::Unicode_normal_formContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitUnicode_normal_form(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Unicode_normal_formContext* PostgreSQLParser::unicode_normal_form() {
  Unicode_normal_formContext *_localctx = _tracker.createInstance<Unicode_normal_formContext>(_ctx, getState());
  enterRule(_localctx, 1298, PostgreSQLParser::RuleUnicode_normal_form);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9931);
    _la = _input->LA(1);
    if (!(((((_la - 521) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 521)) & 15) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Overlay_listContext ------------------------------------------------------------------

PostgreSQLParser::Overlay_listContext::Overlay_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::A_exprContext *> PostgreSQLParser::Overlay_listContext::a_expr() {
  return getRuleContexts<PostgreSQLParser::A_exprContext>();
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Overlay_listContext::a_expr(size_t i) {
  return getRuleContext<PostgreSQLParser::A_exprContext>(i);
}

tree::TerminalNode* PostgreSQLParser::Overlay_listContext::PLACING() {
  return getToken(PostgreSQLParser::PLACING, 0);
}

tree::TerminalNode* PostgreSQLParser::Overlay_listContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

tree::TerminalNode* PostgreSQLParser::Overlay_listContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}


size_t PostgreSQLParser::Overlay_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOverlay_list;
}


std::any PostgreSQLParser::Overlay_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOverlay_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Overlay_listContext* PostgreSQLParser::overlay_list() {
  Overlay_listContext *_localctx = _tracker.createInstance<Overlay_listContext>(_ctx, getState());
  enterRule(_localctx, 1300, PostgreSQLParser::RuleOverlay_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9933);
    a_expr();
    setState(9934);
    match(PostgreSQLParser::PLACING);
    setState(9935);
    a_expr();
    setState(9936);
    match(PostgreSQLParser::FROM);
    setState(9937);
    a_expr();
    setState(9940);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::FOR) {
      setState(9938);
      match(PostgreSQLParser::FOR);
      setState(9939);
      a_expr();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Position_listContext ------------------------------------------------------------------

PostgreSQLParser::Position_listContext::Position_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::B_exprContext *> PostgreSQLParser::Position_listContext::b_expr() {
  return getRuleContexts<PostgreSQLParser::B_exprContext>();
}

PostgreSQLParser::B_exprContext* PostgreSQLParser::Position_listContext::b_expr(size_t i) {
  return getRuleContext<PostgreSQLParser::B_exprContext>(i);
}

tree::TerminalNode* PostgreSQLParser::Position_listContext::IN_P() {
  return getToken(PostgreSQLParser::IN_P, 0);
}


size_t PostgreSQLParser::Position_listContext::getRuleIndex() const {
  return PostgreSQLParser::RulePosition_list;
}


std::any PostgreSQLParser::Position_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitPosition_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Position_listContext* PostgreSQLParser::position_list() {
  Position_listContext *_localctx = _tracker.createInstance<Position_listContext>(_ctx, getState());
  enterRule(_localctx, 1302, PostgreSQLParser::RulePosition_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9942);
    b_expr(0);
    setState(9943);
    match(PostgreSQLParser::IN_P);
    setState(9944);
    b_expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Substr_listContext ------------------------------------------------------------------

PostgreSQLParser::Substr_listContext::Substr_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::A_exprContext *> PostgreSQLParser::Substr_listContext::a_expr() {
  return getRuleContexts<PostgreSQLParser::A_exprContext>();
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Substr_listContext::a_expr(size_t i) {
  return getRuleContext<PostgreSQLParser::A_exprContext>(i);
}

tree::TerminalNode* PostgreSQLParser::Substr_listContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

tree::TerminalNode* PostgreSQLParser::Substr_listContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

tree::TerminalNode* PostgreSQLParser::Substr_listContext::SIMILAR() {
  return getToken(PostgreSQLParser::SIMILAR, 0);
}

tree::TerminalNode* PostgreSQLParser::Substr_listContext::ESCAPE() {
  return getToken(PostgreSQLParser::ESCAPE, 0);
}


size_t PostgreSQLParser::Substr_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSubstr_list;
}


std::any PostgreSQLParser::Substr_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSubstr_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Substr_listContext* PostgreSQLParser::substr_list() {
  Substr_listContext *_localctx = _tracker.createInstance<Substr_listContext>(_ctx, getState());
  enterRule(_localctx, 1304, PostgreSQLParser::RuleSubstr_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9972);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 990, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9946);
      a_expr();
      setState(9947);
      match(PostgreSQLParser::FROM);
      setState(9948);
      a_expr();
      setState(9949);
      match(PostgreSQLParser::FOR);
      setState(9950);
      a_expr();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9952);
      a_expr();
      setState(9953);
      match(PostgreSQLParser::FOR);
      setState(9954);
      a_expr();
      setState(9955);
      match(PostgreSQLParser::FROM);
      setState(9956);
      a_expr();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(9958);
      a_expr();
      setState(9959);
      match(PostgreSQLParser::FROM);
      setState(9960);
      a_expr();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(9962);
      a_expr();
      setState(9963);
      match(PostgreSQLParser::FOR);
      setState(9964);
      a_expr();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(9966);
      a_expr();
      setState(9967);
      match(PostgreSQLParser::SIMILAR);
      setState(9968);
      a_expr();
      setState(9969);
      match(PostgreSQLParser::ESCAPE);
      setState(9970);
      a_expr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trim_listContext ------------------------------------------------------------------

PostgreSQLParser::Trim_listContext::Trim_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Trim_listContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Trim_listContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::Trim_listContext::expr_list() {
  return getRuleContext<PostgreSQLParser::Expr_listContext>(0);
}


size_t PostgreSQLParser::Trim_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTrim_list;
}


std::any PostgreSQLParser::Trim_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTrim_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Trim_listContext* PostgreSQLParser::trim_list() {
  Trim_listContext *_localctx = _tracker.createInstance<Trim_listContext>(_ctx, getState());
  enterRule(_localctx, 1306, PostgreSQLParser::RuleTrim_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9981);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 991, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(9974);
      a_expr();
      setState(9975);
      match(PostgreSQLParser::FROM);
      setState(9976);
      expr_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(9978);
      match(PostgreSQLParser::FROM);
      setState(9979);
      expr_list();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(9980);
      expr_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- In_exprContext ------------------------------------------------------------------

PostgreSQLParser::In_exprContext::In_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t PostgreSQLParser::In_exprContext::getRuleIndex() const {
  return PostgreSQLParser::RuleIn_expr;
}

void PostgreSQLParser::In_exprContext::copyFrom(In_exprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- In_expr_listContext ------------------------------------------------------------------

tree::TerminalNode* PostgreSQLParser::In_expr_listContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Expr_listContext* PostgreSQLParser::In_expr_listContext::expr_list() {
  return getRuleContext<PostgreSQLParser::Expr_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::In_expr_listContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::In_expr_listContext::In_expr_listContext(In_exprContext *ctx) { copyFrom(ctx); }


std::any PostgreSQLParser::In_expr_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitIn_expr_list(this);
  else
    return visitor->visitChildren(this);
}
//----------------- In_expr_selectContext ------------------------------------------------------------------

PostgreSQLParser::Select_with_parensContext* PostgreSQLParser::In_expr_selectContext::select_with_parens() {
  return getRuleContext<PostgreSQLParser::Select_with_parensContext>(0);
}

PostgreSQLParser::In_expr_selectContext::In_expr_selectContext(In_exprContext *ctx) { copyFrom(ctx); }


std::any PostgreSQLParser::In_expr_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitIn_expr_select(this);
  else
    return visitor->visitChildren(this);
}
PostgreSQLParser::In_exprContext* PostgreSQLParser::in_expr() {
  In_exprContext *_localctx = _tracker.createInstance<In_exprContext>(_ctx, getState());
  enterRule(_localctx, 1308, PostgreSQLParser::RuleIn_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9988);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 992, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<PostgreSQLParser::In_expr_selectContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(9983);
      select_with_parens();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<PostgreSQLParser::In_expr_listContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(9984);
      match(PostgreSQLParser::OPEN_PAREN);
      setState(9985);
      expr_list();
      setState(9986);
      match(PostgreSQLParser::CLOSE_PAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_exprContext ------------------------------------------------------------------

PostgreSQLParser::Case_exprContext::Case_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Case_exprContext::CASE() {
  return getToken(PostgreSQLParser::CASE, 0);
}

PostgreSQLParser::When_clause_listContext* PostgreSQLParser::Case_exprContext::when_clause_list() {
  return getRuleContext<PostgreSQLParser::When_clause_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Case_exprContext::END_P() {
  return getToken(PostgreSQLParser::END_P, 0);
}

PostgreSQLParser::Case_argContext* PostgreSQLParser::Case_exprContext::case_arg() {
  return getRuleContext<PostgreSQLParser::Case_argContext>(0);
}

PostgreSQLParser::Case_defaultContext* PostgreSQLParser::Case_exprContext::case_default() {
  return getRuleContext<PostgreSQLParser::Case_defaultContext>(0);
}


size_t PostgreSQLParser::Case_exprContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCase_expr;
}


std::any PostgreSQLParser::Case_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCase_expr(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Case_exprContext* PostgreSQLParser::case_expr() {
  Case_exprContext *_localctx = _tracker.createInstance<Case_exprContext>(_ctx, getState());
  enterRule(_localctx, 1310, PostgreSQLParser::RuleCase_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9990);
    match(PostgreSQLParser::CASE);
    setState(9992);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -268423164) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -9214927770107198969) != 0) || ((((_la - 134) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 134)) & -1011) != 0) || ((((_la - 198) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 198)) & -1) != 0) || ((((_la - 262) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 262)) & -1) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 326)) & -129) != 0) || ((((_la - 390) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 390)) & -1) != 0) || ((((_la - 454) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 454)) & -2305843284091601405) != 0) || ((((_la - 518) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 518)) & -4880034784790705153) != 0) || _la == PostgreSQLParser::PLSQLVARIABLENAME

    || _la == PostgreSQLParser::EscapeStringConstant) {
      setState(9991);
      case_arg();
    }
    setState(9994);
    when_clause_list();
    setState(9996);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::ELSE) {
      setState(9995);
      case_default();
    }
    setState(9998);
    match(PostgreSQLParser::END_P);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- When_clause_listContext ------------------------------------------------------------------

PostgreSQLParser::When_clause_listContext::When_clause_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::When_clauseContext *> PostgreSQLParser::When_clause_listContext::when_clause() {
  return getRuleContexts<PostgreSQLParser::When_clauseContext>();
}

PostgreSQLParser::When_clauseContext* PostgreSQLParser::When_clause_listContext::when_clause(size_t i) {
  return getRuleContext<PostgreSQLParser::When_clauseContext>(i);
}


size_t PostgreSQLParser::When_clause_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleWhen_clause_list;
}


std::any PostgreSQLParser::When_clause_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitWhen_clause_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::When_clause_listContext* PostgreSQLParser::when_clause_list() {
  When_clause_listContext *_localctx = _tracker.createInstance<When_clause_listContext>(_ctx, getState());
  enterRule(_localctx, 1312, PostgreSQLParser::RuleWhen_clause_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10001); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(10000);
      when_clause();
      setState(10003); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == PostgreSQLParser::WHEN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- When_clauseContext ------------------------------------------------------------------

PostgreSQLParser::When_clauseContext::When_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::When_clauseContext::WHEN() {
  return getToken(PostgreSQLParser::WHEN, 0);
}

std::vector<PostgreSQLParser::A_exprContext *> PostgreSQLParser::When_clauseContext::a_expr() {
  return getRuleContexts<PostgreSQLParser::A_exprContext>();
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::When_clauseContext::a_expr(size_t i) {
  return getRuleContext<PostgreSQLParser::A_exprContext>(i);
}

tree::TerminalNode* PostgreSQLParser::When_clauseContext::THEN() {
  return getToken(PostgreSQLParser::THEN, 0);
}


size_t PostgreSQLParser::When_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleWhen_clause;
}


std::any PostgreSQLParser::When_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitWhen_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::When_clauseContext* PostgreSQLParser::when_clause() {
  When_clauseContext *_localctx = _tracker.createInstance<When_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1314, PostgreSQLParser::RuleWhen_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10005);
    match(PostgreSQLParser::WHEN);
    setState(10006);
    a_expr();
    setState(10007);
    match(PostgreSQLParser::THEN);
    setState(10008);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_defaultContext ------------------------------------------------------------------

PostgreSQLParser::Case_defaultContext::Case_defaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Case_defaultContext::ELSE() {
  return getToken(PostgreSQLParser::ELSE, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Case_defaultContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}


size_t PostgreSQLParser::Case_defaultContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCase_default;
}


std::any PostgreSQLParser::Case_defaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCase_default(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Case_defaultContext* PostgreSQLParser::case_default() {
  Case_defaultContext *_localctx = _tracker.createInstance<Case_defaultContext>(_ctx, getState());
  enterRule(_localctx, 1316, PostgreSQLParser::RuleCase_default);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10010);
    match(PostgreSQLParser::ELSE);
    setState(10011);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_argContext ------------------------------------------------------------------

PostgreSQLParser::Case_argContext::Case_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Case_argContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}


size_t PostgreSQLParser::Case_argContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCase_arg;
}


std::any PostgreSQLParser::Case_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCase_arg(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Case_argContext* PostgreSQLParser::case_arg() {
  Case_argContext *_localctx = _tracker.createInstance<Case_argContext>(_ctx, getState());
  enterRule(_localctx, 1318, PostgreSQLParser::RuleCase_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10013);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnrefContext ------------------------------------------------------------------

PostgreSQLParser::ColumnrefContext::ColumnrefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::ColumnrefContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

PostgreSQLParser::IndirectionContext* PostgreSQLParser::ColumnrefContext::indirection() {
  return getRuleContext<PostgreSQLParser::IndirectionContext>(0);
}


size_t PostgreSQLParser::ColumnrefContext::getRuleIndex() const {
  return PostgreSQLParser::RuleColumnref;
}


std::any PostgreSQLParser::ColumnrefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitColumnref(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ColumnrefContext* PostgreSQLParser::columnref() {
  ColumnrefContext *_localctx = _tracker.createInstance<ColumnrefContext>(_ctx, getState());
  enterRule(_localctx, 1320, PostgreSQLParser::RuleColumnref);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10015);
    colid();
    setState(10017);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 996, _ctx)) {
    case 1: {
      setState(10016);
      indirection();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Indirection_elContext ------------------------------------------------------------------

PostgreSQLParser::Indirection_elContext::Indirection_elContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Indirection_elContext::DOT() {
  return getToken(PostgreSQLParser::DOT, 0);
}

PostgreSQLParser::Attr_nameContext* PostgreSQLParser::Indirection_elContext::attr_name() {
  return getRuleContext<PostgreSQLParser::Attr_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Indirection_elContext::STAR() {
  return getToken(PostgreSQLParser::STAR, 0);
}

tree::TerminalNode* PostgreSQLParser::Indirection_elContext::OPEN_BRACKET() {
  return getToken(PostgreSQLParser::OPEN_BRACKET, 0);
}

tree::TerminalNode* PostgreSQLParser::Indirection_elContext::CLOSE_BRACKET() {
  return getToken(PostgreSQLParser::CLOSE_BRACKET, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Indirection_elContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Indirection_elContext::COLON() {
  return getToken(PostgreSQLParser::COLON, 0);
}

std::vector<PostgreSQLParser::Slice_bound_Context *> PostgreSQLParser::Indirection_elContext::slice_bound_() {
  return getRuleContexts<PostgreSQLParser::Slice_bound_Context>();
}

PostgreSQLParser::Slice_bound_Context* PostgreSQLParser::Indirection_elContext::slice_bound_(size_t i) {
  return getRuleContext<PostgreSQLParser::Slice_bound_Context>(i);
}


size_t PostgreSQLParser::Indirection_elContext::getRuleIndex() const {
  return PostgreSQLParser::RuleIndirection_el;
}


std::any PostgreSQLParser::Indirection_elContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitIndirection_el(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Indirection_elContext* PostgreSQLParser::indirection_el() {
  Indirection_elContext *_localctx = _tracker.createInstance<Indirection_elContext>(_ctx, getState());
  enterRule(_localctx, 1322, PostgreSQLParser::RuleIndirection_el);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10036);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::DOT: {
        enterOuterAlt(_localctx, 1);
        setState(10019);
        match(PostgreSQLParser::DOT);
        setState(10022);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case PostgreSQLParser::JSON:
          case PostgreSQLParser::JSON_ARRAY:
          case PostgreSQLParser::JSON_ARRAYAGG:
          case PostgreSQLParser::JSON_EXISTS:
          case PostgreSQLParser::JSON_OBJECT:
          case PostgreSQLParser::JSON_OBJECTAGG:
          case PostgreSQLParser::JSON_QUERY:
          case PostgreSQLParser::JSON_SCALAR:
          case PostgreSQLParser::JSON_SERIALIZE:
          case PostgreSQLParser::JSON_TABLE:
          case PostgreSQLParser::JSON_VALUE:
          case PostgreSQLParser::MERGE_ACTION:
          case PostgreSQLParser::SYSTEM_USER:
          case PostgreSQLParser::ABSENT:
          case PostgreSQLParser::ASENSITIVE:
          case PostgreSQLParser::ATOMIC:
          case PostgreSQLParser::BREADTH:
          case PostgreSQLParser::COMPRESSION:
          case PostgreSQLParser::CONDITIONAL:
          case PostgreSQLParser::DEPTH:
          case PostgreSQLParser::EMPTY_P:
          case PostgreSQLParser::FINALIZE:
          case PostgreSQLParser::INDENT:
          case PostgreSQLParser::KEEP:
          case PostgreSQLParser::KEYS:
          case PostgreSQLParser::NESTED:
          case PostgreSQLParser::OMIT:
          case PostgreSQLParser::PARAMETER:
          case PostgreSQLParser::PATH:
          case PostgreSQLParser::PLAN:
          case PostgreSQLParser::QUOTES:
          case PostgreSQLParser::SCALAR:
          case PostgreSQLParser::SOURCE:
          case PostgreSQLParser::STRING_P:
          case PostgreSQLParser::TARGET:
          case PostgreSQLParser::UNCONDITIONAL:
          case PostgreSQLParser::PERIOD:
          case PostgreSQLParser::ALL:
          case PostgreSQLParser::ANALYSE:
          case PostgreSQLParser::ANALYZE:
          case PostgreSQLParser::AND:
          case PostgreSQLParser::ANY:
          case PostgreSQLParser::ARRAY:
          case PostgreSQLParser::AS:
          case PostgreSQLParser::ASC:
          case PostgreSQLParser::ASYMMETRIC:
          case PostgreSQLParser::BOTH:
          case PostgreSQLParser::CASE:
          case PostgreSQLParser::CAST:
          case PostgreSQLParser::CHECK:
          case PostgreSQLParser::COLLATE:
          case PostgreSQLParser::COLUMN:
          case PostgreSQLParser::CONSTRAINT:
          case PostgreSQLParser::CREATE:
          case PostgreSQLParser::CURRENT_CATALOG:
          case PostgreSQLParser::CURRENT_DATE:
          case PostgreSQLParser::CURRENT_ROLE:
          case PostgreSQLParser::CURRENT_TIME:
          case PostgreSQLParser::CURRENT_TIMESTAMP:
          case PostgreSQLParser::CURRENT_USER:
          case PostgreSQLParser::DEFAULT:
          case PostgreSQLParser::DEFERRABLE:
          case PostgreSQLParser::DESC:
          case PostgreSQLParser::DISTINCT:
          case PostgreSQLParser::DO:
          case PostgreSQLParser::ELSE:
          case PostgreSQLParser::EXCEPT:
          case PostgreSQLParser::FALSE_P:
          case PostgreSQLParser::FETCH:
          case PostgreSQLParser::FOR:
          case PostgreSQLParser::FOREIGN:
          case PostgreSQLParser::FROM:
          case PostgreSQLParser::GRANT:
          case PostgreSQLParser::GROUP_P:
          case PostgreSQLParser::HAVING:
          case PostgreSQLParser::IN_P:
          case PostgreSQLParser::INITIALLY:
          case PostgreSQLParser::INTERSECT:
          case PostgreSQLParser::INTO:
          case PostgreSQLParser::LATERAL_P:
          case PostgreSQLParser::LEADING:
          case PostgreSQLParser::LIMIT:
          case PostgreSQLParser::LOCALTIME:
          case PostgreSQLParser::LOCALTIMESTAMP:
          case PostgreSQLParser::NOT:
          case PostgreSQLParser::NULL_P:
          case PostgreSQLParser::OFFSET:
          case PostgreSQLParser::ON:
          case PostgreSQLParser::ONLY:
          case PostgreSQLParser::OR:
          case PostgreSQLParser::ORDER:
          case PostgreSQLParser::PLACING:
          case PostgreSQLParser::PRIMARY:
          case PostgreSQLParser::REFERENCES:
          case PostgreSQLParser::RETURNING:
          case PostgreSQLParser::SELECT:
          case PostgreSQLParser::SESSION_USER:
          case PostgreSQLParser::SOME:
          case PostgreSQLParser::SYMMETRIC:
          case PostgreSQLParser::TABLE:
          case PostgreSQLParser::THEN:
          case PostgreSQLParser::TO:
          case PostgreSQLParser::TRAILING:
          case PostgreSQLParser::TRUE_P:
          case PostgreSQLParser::UNION:
          case PostgreSQLParser::UNIQUE:
          case PostgreSQLParser::USER:
          case PostgreSQLParser::USING:
          case PostgreSQLParser::VARIADIC:
          case PostgreSQLParser::WHEN:
          case PostgreSQLParser::WHERE:
          case PostgreSQLParser::WINDOW:
          case PostgreSQLParser::WITH:
          case PostgreSQLParser::AUTHORIZATION:
          case PostgreSQLParser::BINARY:
          case PostgreSQLParser::COLLATION:
          case PostgreSQLParser::CONCURRENTLY:
          case PostgreSQLParser::CROSS:
          case PostgreSQLParser::CURRENT_SCHEMA:
          case PostgreSQLParser::FREEZE:
          case PostgreSQLParser::FULL:
          case PostgreSQLParser::ILIKE:
          case PostgreSQLParser::INNER_P:
          case PostgreSQLParser::IS:
          case PostgreSQLParser::ISNULL:
          case PostgreSQLParser::JOIN:
          case PostgreSQLParser::LEFT:
          case PostgreSQLParser::LIKE:
          case PostgreSQLParser::NATURAL:
          case PostgreSQLParser::NOTNULL:
          case PostgreSQLParser::OUTER_P:
          case PostgreSQLParser::OVER:
          case PostgreSQLParser::OVERLAPS:
          case PostgreSQLParser::RIGHT:
          case PostgreSQLParser::SIMILAR:
          case PostgreSQLParser::VERBOSE:
          case PostgreSQLParser::ABORT_P:
          case PostgreSQLParser::ABSOLUTE_P:
          case PostgreSQLParser::ACCESS:
          case PostgreSQLParser::ACTION:
          case PostgreSQLParser::ADD_P:
          case PostgreSQLParser::ADMIN:
          case PostgreSQLParser::AFTER:
          case PostgreSQLParser::AGGREGATE:
          case PostgreSQLParser::ALSO:
          case PostgreSQLParser::ALTER:
          case PostgreSQLParser::ALWAYS:
          case PostgreSQLParser::ASSERTION:
          case PostgreSQLParser::ASSIGNMENT:
          case PostgreSQLParser::AT:
          case PostgreSQLParser::ATTRIBUTE:
          case PostgreSQLParser::BACKWARD:
          case PostgreSQLParser::BEFORE:
          case PostgreSQLParser::BEGIN_P:
          case PostgreSQLParser::BY:
          case PostgreSQLParser::CACHE:
          case PostgreSQLParser::CALLED:
          case PostgreSQLParser::CASCADE:
          case PostgreSQLParser::CASCADED:
          case PostgreSQLParser::CATALOG:
          case PostgreSQLParser::CHAIN:
          case PostgreSQLParser::CHARACTERISTICS:
          case PostgreSQLParser::CHECKPOINT:
          case PostgreSQLParser::CLASS:
          case PostgreSQLParser::CLOSE:
          case PostgreSQLParser::CLUSTER:
          case PostgreSQLParser::COMMENT:
          case PostgreSQLParser::COMMENTS:
          case PostgreSQLParser::COMMIT:
          case PostgreSQLParser::COMMITTED:
          case PostgreSQLParser::CONFIGURATION:
          case PostgreSQLParser::CONNECTION:
          case PostgreSQLParser::CONSTRAINTS:
          case PostgreSQLParser::CONTENT_P:
          case PostgreSQLParser::CONTINUE_P:
          case PostgreSQLParser::CONVERSION_P:
          case PostgreSQLParser::COPY:
          case PostgreSQLParser::COST:
          case PostgreSQLParser::CSV:
          case PostgreSQLParser::CURSOR:
          case PostgreSQLParser::CYCLE:
          case PostgreSQLParser::DATA_P:
          case PostgreSQLParser::DATABASE:
          case PostgreSQLParser::DAY_P:
          case PostgreSQLParser::DEALLOCATE:
          case PostgreSQLParser::DECLARE:
          case PostgreSQLParser::DEFAULTS:
          case PostgreSQLParser::DEFERRED:
          case PostgreSQLParser::DEFINER:
          case PostgreSQLParser::DELETE_P:
          case PostgreSQLParser::DELIMITER:
          case PostgreSQLParser::DELIMITERS:
          case PostgreSQLParser::DICTIONARY:
          case PostgreSQLParser::DISABLE_P:
          case PostgreSQLParser::DISCARD:
          case PostgreSQLParser::DOCUMENT_P:
          case PostgreSQLParser::DOMAIN_P:
          case PostgreSQLParser::DOUBLE_P:
          case PostgreSQLParser::DROP:
          case PostgreSQLParser::EACH:
          case PostgreSQLParser::ENABLE_P:
          case PostgreSQLParser::ENCODING:
          case PostgreSQLParser::ENCRYPTED:
          case PostgreSQLParser::ENUM_P:
          case PostgreSQLParser::ESCAPE:
          case PostgreSQLParser::EVENT:
          case PostgreSQLParser::EXCLUDE:
          case PostgreSQLParser::EXCLUDING:
          case PostgreSQLParser::EXCLUSIVE:
          case PostgreSQLParser::EXECUTE:
          case PostgreSQLParser::EXPLAIN:
          case PostgreSQLParser::EXTENSION:
          case PostgreSQLParser::EXTERNAL:
          case PostgreSQLParser::FAMILY:
          case PostgreSQLParser::FIRST_P:
          case PostgreSQLParser::FOLLOWING:
          case PostgreSQLParser::FORCE:
          case PostgreSQLParser::FORWARD:
          case PostgreSQLParser::FUNCTION:
          case PostgreSQLParser::FUNCTIONS:
          case PostgreSQLParser::GLOBAL:
          case PostgreSQLParser::GRANTED:
          case PostgreSQLParser::HANDLER:
          case PostgreSQLParser::HEADER_P:
          case PostgreSQLParser::HOLD:
          case PostgreSQLParser::HOUR_P:
          case PostgreSQLParser::IDENTITY_P:
          case PostgreSQLParser::IF_P:
          case PostgreSQLParser::IMMEDIATE:
          case PostgreSQLParser::IMMUTABLE:
          case PostgreSQLParser::IMPLICIT_P:
          case PostgreSQLParser::INCLUDING:
          case PostgreSQLParser::INCREMENT:
          case PostgreSQLParser::INDEX:
          case PostgreSQLParser::INDEXES:
          case PostgreSQLParser::INHERIT:
          case PostgreSQLParser::INHERITS:
          case PostgreSQLParser::INLINE_P:
          case PostgreSQLParser::INSENSITIVE:
          case PostgreSQLParser::INSERT:
          case PostgreSQLParser::INSTEAD:
          case PostgreSQLParser::INVOKER:
          case PostgreSQLParser::ISOLATION:
          case PostgreSQLParser::KEY:
          case PostgreSQLParser::LABEL:
          case PostgreSQLParser::LANGUAGE:
          case PostgreSQLParser::LARGE_P:
          case PostgreSQLParser::LAST_P:
          case PostgreSQLParser::LEAKPROOF:
          case PostgreSQLParser::LEVEL:
          case PostgreSQLParser::LISTEN:
          case PostgreSQLParser::LOAD:
          case PostgreSQLParser::LOCAL:
          case PostgreSQLParser::LOCATION:
          case PostgreSQLParser::LOCK_P:
          case PostgreSQLParser::MAPPING:
          case PostgreSQLParser::MATCH:
          case PostgreSQLParser::MATCHED:
          case PostgreSQLParser::MATERIALIZED:
          case PostgreSQLParser::MAXVALUE:
          case PostgreSQLParser::MERGE:
          case PostgreSQLParser::MINUTE_P:
          case PostgreSQLParser::MINVALUE:
          case PostgreSQLParser::MODE:
          case PostgreSQLParser::MONTH_P:
          case PostgreSQLParser::MOVE:
          case PostgreSQLParser::NAME_P:
          case PostgreSQLParser::NAMES:
          case PostgreSQLParser::NEXT:
          case PostgreSQLParser::NO:
          case PostgreSQLParser::NOTHING:
          case PostgreSQLParser::NOTIFY:
          case PostgreSQLParser::NOWAIT:
          case PostgreSQLParser::NULLS_P:
          case PostgreSQLParser::OBJECT_P:
          case PostgreSQLParser::OF:
          case PostgreSQLParser::OFF:
          case PostgreSQLParser::OIDS:
          case PostgreSQLParser::OPERATOR:
          case PostgreSQLParser::OPTION:
          case PostgreSQLParser::OPTIONS:
          case PostgreSQLParser::OWNED:
          case PostgreSQLParser::OWNER:
          case PostgreSQLParser::PARSER:
          case PostgreSQLParser::PARTIAL:
          case PostgreSQLParser::PARTITION:
          case PostgreSQLParser::PASSING:
          case PostgreSQLParser::PASSWORD:
          case PostgreSQLParser::PLANS:
          case PostgreSQLParser::PRECEDING:
          case PostgreSQLParser::PREPARE:
          case PostgreSQLParser::PREPARED:
          case PostgreSQLParser::PRESERVE:
          case PostgreSQLParser::PRIOR:
          case PostgreSQLParser::PRIVILEGES:
          case PostgreSQLParser::PROCEDURAL:
          case PostgreSQLParser::PROCEDURE:
          case PostgreSQLParser::PROGRAM:
          case PostgreSQLParser::QUOTE:
          case PostgreSQLParser::RANGE:
          case PostgreSQLParser::READ:
          case PostgreSQLParser::REASSIGN:
          case PostgreSQLParser::RECURSIVE:
          case PostgreSQLParser::REF:
          case PostgreSQLParser::REFRESH:
          case PostgreSQLParser::REINDEX:
          case PostgreSQLParser::RELATIVE_P:
          case PostgreSQLParser::RELEASE:
          case PostgreSQLParser::RENAME:
          case PostgreSQLParser::REPEATABLE:
          case PostgreSQLParser::REPLACE:
          case PostgreSQLParser::REPLICA:
          case PostgreSQLParser::RESET:
          case PostgreSQLParser::RESTART:
          case PostgreSQLParser::RESTRICT:
          case PostgreSQLParser::RETURNS:
          case PostgreSQLParser::REVOKE:
          case PostgreSQLParser::ROLE:
          case PostgreSQLParser::ROLLBACK:
          case PostgreSQLParser::ROWS:
          case PostgreSQLParser::RULE:
          case PostgreSQLParser::SAVEPOINT:
          case PostgreSQLParser::SCHEMA:
          case PostgreSQLParser::SCROLL:
          case PostgreSQLParser::SEARCH:
          case PostgreSQLParser::SECOND_P:
          case PostgreSQLParser::SECURITY:
          case PostgreSQLParser::SEQUENCE:
          case PostgreSQLParser::SEQUENCES:
          case PostgreSQLParser::SERIALIZABLE:
          case PostgreSQLParser::SERVER:
          case PostgreSQLParser::SESSION:
          case PostgreSQLParser::SET:
          case PostgreSQLParser::SHARE:
          case PostgreSQLParser::SHOW:
          case PostgreSQLParser::SIMPLE:
          case PostgreSQLParser::SNAPSHOT:
          case PostgreSQLParser::STABLE:
          case PostgreSQLParser::STANDALONE_P:
          case PostgreSQLParser::START:
          case PostgreSQLParser::STATEMENT:
          case PostgreSQLParser::STATISTICS:
          case PostgreSQLParser::STDIN:
          case PostgreSQLParser::STDOUT:
          case PostgreSQLParser::STORAGE:
          case PostgreSQLParser::STRICT_P:
          case PostgreSQLParser::STRIP_P:
          case PostgreSQLParser::SYSID:
          case PostgreSQLParser::SYSTEM_P:
          case PostgreSQLParser::TABLES:
          case PostgreSQLParser::TABLESPACE:
          case PostgreSQLParser::TEMP:
          case PostgreSQLParser::TEMPLATE:
          case PostgreSQLParser::TEMPORARY:
          case PostgreSQLParser::TEXT_P:
          case PostgreSQLParser::TRANSACTION:
          case PostgreSQLParser::TRIGGER:
          case PostgreSQLParser::TRUNCATE:
          case PostgreSQLParser::TRUSTED:
          case PostgreSQLParser::TYPE_P:
          case PostgreSQLParser::TYPES_P:
          case PostgreSQLParser::UNBOUNDED:
          case PostgreSQLParser::UNCOMMITTED:
          case PostgreSQLParser::UNENCRYPTED:
          case PostgreSQLParser::UNKNOWN:
          case PostgreSQLParser::UNLISTEN:
          case PostgreSQLParser::UNLOGGED:
          case PostgreSQLParser::UNTIL:
          case PostgreSQLParser::UPDATE:
          case PostgreSQLParser::VACUUM:
          case PostgreSQLParser::VALID:
          case PostgreSQLParser::VALIDATE:
          case PostgreSQLParser::VALIDATOR:
          case PostgreSQLParser::VARYING:
          case PostgreSQLParser::VERSION_P:
          case PostgreSQLParser::VIEW:
          case PostgreSQLParser::VOLATILE:
          case PostgreSQLParser::WHITESPACE_P:
          case PostgreSQLParser::WITHOUT:
          case PostgreSQLParser::WORK:
          case PostgreSQLParser::WRAPPER:
          case PostgreSQLParser::WRITE:
          case PostgreSQLParser::XML_P:
          case PostgreSQLParser::YEAR_P:
          case PostgreSQLParser::YES_P:
          case PostgreSQLParser::ZONE:
          case PostgreSQLParser::BETWEEN:
          case PostgreSQLParser::BIGINT:
          case PostgreSQLParser::BIT:
          case PostgreSQLParser::BOOLEAN_P:
          case PostgreSQLParser::CHAR_P:
          case PostgreSQLParser::CHARACTER:
          case PostgreSQLParser::COALESCE:
          case PostgreSQLParser::DEC:
          case PostgreSQLParser::DECIMAL_P:
          case PostgreSQLParser::EXISTS:
          case PostgreSQLParser::EXTRACT:
          case PostgreSQLParser::FLOAT_P:
          case PostgreSQLParser::GREATEST:
          case PostgreSQLParser::INOUT:
          case PostgreSQLParser::INT_P:
          case PostgreSQLParser::INTEGER:
          case PostgreSQLParser::INTERVAL:
          case PostgreSQLParser::LEAST:
          case PostgreSQLParser::NATIONAL:
          case PostgreSQLParser::NCHAR:
          case PostgreSQLParser::NONE:
          case PostgreSQLParser::NULLIF:
          case PostgreSQLParser::NUMERIC:
          case PostgreSQLParser::OVERLAY:
          case PostgreSQLParser::POSITION:
          case PostgreSQLParser::PRECISION:
          case PostgreSQLParser::REAL:
          case PostgreSQLParser::ROW:
          case PostgreSQLParser::SETOF:
          case PostgreSQLParser::SMALLINT:
          case PostgreSQLParser::SUBSTRING:
          case PostgreSQLParser::TIME:
          case PostgreSQLParser::TIMESTAMP:
          case PostgreSQLParser::TREAT:
          case PostgreSQLParser::TRIM:
          case PostgreSQLParser::VALUES:
          case PostgreSQLParser::VARCHAR:
          case PostgreSQLParser::XMLATTRIBUTES:
          case PostgreSQLParser::XMLCONCAT:
          case PostgreSQLParser::XMLELEMENT:
          case PostgreSQLParser::XMLEXISTS:
          case PostgreSQLParser::XMLFOREST:
          case PostgreSQLParser::XMLPARSE:
          case PostgreSQLParser::XMLPI:
          case PostgreSQLParser::XMLROOT:
          case PostgreSQLParser::XMLSERIALIZE:
          case PostgreSQLParser::CALL:
          case PostgreSQLParser::CURRENT_P:
          case PostgreSQLParser::ATTACH:
          case PostgreSQLParser::DETACH:
          case PostgreSQLParser::EXPRESSION:
          case PostgreSQLParser::GENERATED:
          case PostgreSQLParser::LOGGED:
          case PostgreSQLParser::STORED:
          case PostgreSQLParser::INCLUDE:
          case PostgreSQLParser::ROUTINE:
          case PostgreSQLParser::TRANSFORM:
          case PostgreSQLParser::IMPORT_P:
          case PostgreSQLParser::POLICY:
          case PostgreSQLParser::METHOD:
          case PostgreSQLParser::REFERENCING:
          case PostgreSQLParser::NEW:
          case PostgreSQLParser::OLD:
          case PostgreSQLParser::VALUE_P:
          case PostgreSQLParser::SUBSCRIPTION:
          case PostgreSQLParser::PUBLICATION:
          case PostgreSQLParser::OUT_P:
          case PostgreSQLParser::END_P:
          case PostgreSQLParser::ROUTINES:
          case PostgreSQLParser::SCHEMAS:
          case PostgreSQLParser::PROCEDURES:
          case PostgreSQLParser::INPUT_P:
          case PostgreSQLParser::SUPPORT:
          case PostgreSQLParser::PARALLEL:
          case PostgreSQLParser::SQL_P:
          case PostgreSQLParser::DEPENDS:
          case PostgreSQLParser::OVERRIDING:
          case PostgreSQLParser::CONFLICT:
          case PostgreSQLParser::SKIP_P:
          case PostgreSQLParser::LOCKED:
          case PostgreSQLParser::TIES:
          case PostgreSQLParser::ROLLUP:
          case PostgreSQLParser::CUBE:
          case PostgreSQLParser::GROUPING:
          case PostgreSQLParser::SETS:
          case PostgreSQLParser::TABLESAMPLE:
          case PostgreSQLParser::ORDINALITY:
          case PostgreSQLParser::XMLTABLE:
          case PostgreSQLParser::COLUMNS:
          case PostgreSQLParser::XMLNAMESPACES:
          case PostgreSQLParser::NORMALIZED:
          case PostgreSQLParser::WITHIN:
          case PostgreSQLParser::FILTER:
          case PostgreSQLParser::GROUPS:
          case PostgreSQLParser::OTHERS:
          case PostgreSQLParser::NFC:
          case PostgreSQLParser::NFD:
          case PostgreSQLParser::NFKC:
          case PostgreSQLParser::NFKD:
          case PostgreSQLParser::UESCAPE:
          case PostgreSQLParser::VIEWS:
          case PostgreSQLParser::NORMALIZE:
          case PostgreSQLParser::ERROR:
          case PostgreSQLParser::EXIT:
          case PostgreSQLParser::RETURN:
          case PostgreSQLParser::FORMAT:
          case PostgreSQLParser::Identifier:
          case PostgreSQLParser::QuotedIdentifier:
          case PostgreSQLParser::UnicodeQuotedIdentifier:
          case PostgreSQLParser::PLSQLVARIABLENAME: {
            setState(10020);
            attr_name();
            break;
          }

          case PostgreSQLParser::STAR: {
            setState(10021);
            match(PostgreSQLParser::STAR);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case PostgreSQLParser::OPEN_BRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(10024);
        match(PostgreSQLParser::OPEN_BRACKET);
        setState(10033);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1000, _ctx)) {
        case 1: {
          setState(10025);
          a_expr();
          break;
        }

        case 2: {
          setState(10027);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if ((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & -268423164) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & -9214927770107198969) != 0) || ((((_la - 134) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 134)) & -1011) != 0) || ((((_la - 198) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 198)) & -1) != 0) || ((((_la - 262) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 262)) & -1) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 326)) & -129) != 0) || ((((_la - 390) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 390)) & -1) != 0) || ((((_la - 454) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 454)) & -2305843284091601405) != 0) || ((((_la - 518) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 518)) & -4880034784790705153) != 0) || _la == PostgreSQLParser::PLSQLVARIABLENAME

          || _la == PostgreSQLParser::EscapeStringConstant) {
            setState(10026);
            slice_bound_();
          }
          setState(10029);
          match(PostgreSQLParser::COLON);
          setState(10031);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if ((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & -268423164) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & -9214927770107198969) != 0) || ((((_la - 134) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 134)) & -1011) != 0) || ((((_la - 198) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 198)) & -1) != 0) || ((((_la - 262) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 262)) & -1) != 0) || ((((_la - 326) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 326)) & -129) != 0) || ((((_la - 390) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 390)) & -1) != 0) || ((((_la - 454) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 454)) & -2305843284091601405) != 0) || ((((_la - 518) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 518)) & -4880034784790705153) != 0) || _la == PostgreSQLParser::PLSQLVARIABLENAME

          || _la == PostgreSQLParser::EscapeStringConstant) {
            setState(10030);
            slice_bound_();
          }
          break;
        }

        default:
          break;
        }
        setState(10035);
        match(PostgreSQLParser::CLOSE_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Slice_bound_Context ------------------------------------------------------------------

PostgreSQLParser::Slice_bound_Context::Slice_bound_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Slice_bound_Context::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}


size_t PostgreSQLParser::Slice_bound_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleSlice_bound_;
}


std::any PostgreSQLParser::Slice_bound_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSlice_bound_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Slice_bound_Context* PostgreSQLParser::slice_bound_() {
  Slice_bound_Context *_localctx = _tracker.createInstance<Slice_bound_Context>(_ctx, getState());
  enterRule(_localctx, 1324, PostgreSQLParser::RuleSlice_bound_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10038);
    a_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndirectionContext ------------------------------------------------------------------

PostgreSQLParser::IndirectionContext::IndirectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Indirection_elContext *> PostgreSQLParser::IndirectionContext::indirection_el() {
  return getRuleContexts<PostgreSQLParser::Indirection_elContext>();
}

PostgreSQLParser::Indirection_elContext* PostgreSQLParser::IndirectionContext::indirection_el(size_t i) {
  return getRuleContext<PostgreSQLParser::Indirection_elContext>(i);
}


size_t PostgreSQLParser::IndirectionContext::getRuleIndex() const {
  return PostgreSQLParser::RuleIndirection;
}


std::any PostgreSQLParser::IndirectionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitIndirection(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::IndirectionContext* PostgreSQLParser::indirection() {
  IndirectionContext *_localctx = _tracker.createInstance<IndirectionContext>(_ctx, getState());
  enterRule(_localctx, 1326, PostgreSQLParser::RuleIndirection);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(10041); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(10040);
              indirection_el();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(10043); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1002, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Opt_indirectionContext ------------------------------------------------------------------

PostgreSQLParser::Opt_indirectionContext::Opt_indirectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Indirection_elContext *> PostgreSQLParser::Opt_indirectionContext::indirection_el() {
  return getRuleContexts<PostgreSQLParser::Indirection_elContext>();
}

PostgreSQLParser::Indirection_elContext* PostgreSQLParser::Opt_indirectionContext::indirection_el(size_t i) {
  return getRuleContext<PostgreSQLParser::Indirection_elContext>(i);
}


size_t PostgreSQLParser::Opt_indirectionContext::getRuleIndex() const {
  return PostgreSQLParser::RuleOpt_indirection;
}


std::any PostgreSQLParser::Opt_indirectionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitOpt_indirection(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Opt_indirectionContext* PostgreSQLParser::opt_indirection() {
  Opt_indirectionContext *_localctx = _tracker.createInstance<Opt_indirectionContext>(_ctx, getState());
  enterRule(_localctx, 1328, PostgreSQLParser::RuleOpt_indirection);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(10048);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1003, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(10045);
        indirection_el(); 
      }
      setState(10050);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1003, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Json_passing_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Json_passing_clauseContext::Json_passing_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Json_passing_clauseContext::PASSING() {
  return getToken(PostgreSQLParser::PASSING, 0);
}

PostgreSQLParser::Json_argumentsContext* PostgreSQLParser::Json_passing_clauseContext::json_arguments() {
  return getRuleContext<PostgreSQLParser::Json_argumentsContext>(0);
}


size_t PostgreSQLParser::Json_passing_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_passing_clause;
}


std::any PostgreSQLParser::Json_passing_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_passing_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Json_passing_clauseContext* PostgreSQLParser::json_passing_clause() {
  Json_passing_clauseContext *_localctx = _tracker.createInstance<Json_passing_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1330, PostgreSQLParser::RuleJson_passing_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10051);
    match(PostgreSQLParser::PASSING);
    setState(10052);
    json_arguments(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Json_argumentsContext ------------------------------------------------------------------

PostgreSQLParser::Json_argumentsContext::Json_argumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Json_argumentContext* PostgreSQLParser::Json_argumentsContext::json_argument() {
  return getRuleContext<PostgreSQLParser::Json_argumentContext>(0);
}

PostgreSQLParser::Json_argumentsContext* PostgreSQLParser::Json_argumentsContext::json_arguments() {
  return getRuleContext<PostgreSQLParser::Json_argumentsContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Json_argumentsContext::COMMA() {
  return getToken(PostgreSQLParser::COMMA, 0);
}


size_t PostgreSQLParser::Json_argumentsContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_arguments;
}


std::any PostgreSQLParser::Json_argumentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_arguments(this);
  else
    return visitor->visitChildren(this);
}


PostgreSQLParser::Json_argumentsContext* PostgreSQLParser::json_arguments() {
   return json_arguments(0);
}

PostgreSQLParser::Json_argumentsContext* PostgreSQLParser::json_arguments(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  PostgreSQLParser::Json_argumentsContext *_localctx = _tracker.createInstance<Json_argumentsContext>(_ctx, parentState);
  PostgreSQLParser::Json_argumentsContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 1332;
  enterRecursionRule(_localctx, 1332, PostgreSQLParser::RuleJson_arguments, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(10055);
    json_argument();
    _ctx->stop = _input->LT(-1);
    setState(10062);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1004, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<Json_argumentsContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleJson_arguments);
        setState(10057);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(10058);
        match(PostgreSQLParser::COMMA);
        setState(10059);
        json_argument(); 
      }
      setState(10064);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1004, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Json_argumentContext ------------------------------------------------------------------

PostgreSQLParser::Json_argumentContext::Json_argumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Json_value_exprContext* PostgreSQLParser::Json_argumentContext::json_value_expr() {
  return getRuleContext<PostgreSQLParser::Json_value_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Json_argumentContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

PostgreSQLParser::ColLabelContext* PostgreSQLParser::Json_argumentContext::colLabel() {
  return getRuleContext<PostgreSQLParser::ColLabelContext>(0);
}


size_t PostgreSQLParser::Json_argumentContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_argument;
}


std::any PostgreSQLParser::Json_argumentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_argument(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Json_argumentContext* PostgreSQLParser::json_argument() {
  Json_argumentContext *_localctx = _tracker.createInstance<Json_argumentContext>(_ctx, getState());
  enterRule(_localctx, 1334, PostgreSQLParser::RuleJson_argument);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10065);
    json_value_expr();
    setState(10066);
    match(PostgreSQLParser::AS);
    setState(10067);
    colLabel();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Json_wrapper_behaviorContext ------------------------------------------------------------------

PostgreSQLParser::Json_wrapper_behaviorContext::Json_wrapper_behaviorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Json_wrapper_behaviorContext::WITHOUT() {
  return getToken(PostgreSQLParser::WITHOUT, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_wrapper_behaviorContext::WRAPPER() {
  return getToken(PostgreSQLParser::WRAPPER, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_wrapper_behaviorContext::ARRAY() {
  return getToken(PostgreSQLParser::ARRAY, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_wrapper_behaviorContext::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_wrapper_behaviorContext::CONDITIONAL() {
  return getToken(PostgreSQLParser::CONDITIONAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_wrapper_behaviorContext::UNCONDITIONAL() {
  return getToken(PostgreSQLParser::UNCONDITIONAL, 0);
}


size_t PostgreSQLParser::Json_wrapper_behaviorContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_wrapper_behavior;
}


std::any PostgreSQLParser::Json_wrapper_behaviorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_wrapper_behavior(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Json_wrapper_behaviorContext* PostgreSQLParser::json_wrapper_behavior() {
  Json_wrapper_behaviorContext *_localctx = _tracker.createInstance<Json_wrapper_behaviorContext>(_ctx, getState());
  enterRule(_localctx, 1336, PostgreSQLParser::RuleJson_wrapper_behavior);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10094);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1005, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(10069);
      match(PostgreSQLParser::WITHOUT);
      setState(10070);
      match(PostgreSQLParser::WRAPPER);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(10071);
      match(PostgreSQLParser::WITHOUT);
      setState(10072);
      match(PostgreSQLParser::ARRAY);
      setState(10073);
      match(PostgreSQLParser::WRAPPER);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(10074);
      match(PostgreSQLParser::WITH);
      setState(10075);
      match(PostgreSQLParser::WRAPPER);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(10076);
      match(PostgreSQLParser::WITH);
      setState(10077);
      match(PostgreSQLParser::ARRAY);
      setState(10078);
      match(PostgreSQLParser::WRAPPER);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(10079);
      match(PostgreSQLParser::WITH);
      setState(10080);
      match(PostgreSQLParser::CONDITIONAL);
      setState(10081);
      match(PostgreSQLParser::ARRAY);
      setState(10082);
      match(PostgreSQLParser::WRAPPER);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(10083);
      match(PostgreSQLParser::WITH);
      setState(10084);
      match(PostgreSQLParser::UNCONDITIONAL);
      setState(10085);
      match(PostgreSQLParser::ARRAY);
      setState(10086);
      match(PostgreSQLParser::WRAPPER);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(10087);
      match(PostgreSQLParser::WITH);
      setState(10088);
      match(PostgreSQLParser::CONDITIONAL);
      setState(10089);
      match(PostgreSQLParser::WRAPPER);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(10090);
      match(PostgreSQLParser::WITH);
      setState(10091);
      match(PostgreSQLParser::UNCONDITIONAL);
      setState(10092);
      match(PostgreSQLParser::WRAPPER);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);

      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Json_behaviorContext ------------------------------------------------------------------

PostgreSQLParser::Json_behaviorContext::Json_behaviorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Json_behaviorContext::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Json_behaviorContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

PostgreSQLParser::Json_behavior_typeContext* PostgreSQLParser::Json_behaviorContext::json_behavior_type() {
  return getRuleContext<PostgreSQLParser::Json_behavior_typeContext>(0);
}


size_t PostgreSQLParser::Json_behaviorContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_behavior;
}


std::any PostgreSQLParser::Json_behaviorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_behavior(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Json_behaviorContext* PostgreSQLParser::json_behavior() {
  Json_behaviorContext *_localctx = _tracker.createInstance<Json_behaviorContext>(_ctx, getState());
  enterRule(_localctx, 1338, PostgreSQLParser::RuleJson_behavior);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10099);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::DEFAULT: {
        enterOuterAlt(_localctx, 1);
        setState(10096);
        match(PostgreSQLParser::DEFAULT);
        setState(10097);
        a_expr();
        break;
      }

      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FALSE_P:
      case PostgreSQLParser::NULL_P:
      case PostgreSQLParser::TRUE_P:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::ERROR: {
        enterOuterAlt(_localctx, 2);
        setState(10098);
        json_behavior_type();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Json_behavior_typeContext ------------------------------------------------------------------

PostgreSQLParser::Json_behavior_typeContext::Json_behavior_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Json_behavior_typeContext::ERROR() {
  return getToken(PostgreSQLParser::ERROR, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_behavior_typeContext::NULL_P() {
  return getToken(PostgreSQLParser::NULL_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_behavior_typeContext::TRUE_P() {
  return getToken(PostgreSQLParser::TRUE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_behavior_typeContext::FALSE_P() {
  return getToken(PostgreSQLParser::FALSE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_behavior_typeContext::UNKNOWN() {
  return getToken(PostgreSQLParser::UNKNOWN, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_behavior_typeContext::EMPTY_P() {
  return getToken(PostgreSQLParser::EMPTY_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_behavior_typeContext::ARRAY() {
  return getToken(PostgreSQLParser::ARRAY, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_behavior_typeContext::OBJECT_P() {
  return getToken(PostgreSQLParser::OBJECT_P, 0);
}


size_t PostgreSQLParser::Json_behavior_typeContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_behavior_type;
}


std::any PostgreSQLParser::Json_behavior_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_behavior_type(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Json_behavior_typeContext* PostgreSQLParser::json_behavior_type() {
  Json_behavior_typeContext *_localctx = _tracker.createInstance<Json_behavior_typeContext>(_ctx, getState());
  enterRule(_localctx, 1340, PostgreSQLParser::RuleJson_behavior_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10111);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1007, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(10101);
      match(PostgreSQLParser::ERROR);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(10102);
      match(PostgreSQLParser::NULL_P);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(10103);
      match(PostgreSQLParser::TRUE_P);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(10104);
      match(PostgreSQLParser::FALSE_P);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(10105);
      match(PostgreSQLParser::UNKNOWN);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(10106);
      match(PostgreSQLParser::EMPTY_P);
      setState(10107);
      match(PostgreSQLParser::ARRAY);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(10108);
      match(PostgreSQLParser::EMPTY_P);
      setState(10109);
      match(PostgreSQLParser::OBJECT_P);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(10110);
      match(PostgreSQLParser::EMPTY_P);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Json_behavior_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Json_behavior_clauseContext::Json_behavior_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Json_behaviorContext *> PostgreSQLParser::Json_behavior_clauseContext::json_behavior() {
  return getRuleContexts<PostgreSQLParser::Json_behaviorContext>();
}

PostgreSQLParser::Json_behaviorContext* PostgreSQLParser::Json_behavior_clauseContext::json_behavior(size_t i) {
  return getRuleContext<PostgreSQLParser::Json_behaviorContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Json_behavior_clauseContext::ON() {
  return getTokens(PostgreSQLParser::ON);
}

tree::TerminalNode* PostgreSQLParser::Json_behavior_clauseContext::ON(size_t i) {
  return getToken(PostgreSQLParser::ON, i);
}

tree::TerminalNode* PostgreSQLParser::Json_behavior_clauseContext::EMPTY_P() {
  return getToken(PostgreSQLParser::EMPTY_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_behavior_clauseContext::ERROR() {
  return getToken(PostgreSQLParser::ERROR, 0);
}


size_t PostgreSQLParser::Json_behavior_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_behavior_clause;
}


std::any PostgreSQLParser::Json_behavior_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_behavior_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Json_behavior_clauseContext* PostgreSQLParser::json_behavior_clause() {
  Json_behavior_clauseContext *_localctx = _tracker.createInstance<Json_behavior_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1342, PostgreSQLParser::RuleJson_behavior_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10128);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1008, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(10113);
      json_behavior();
      setState(10114);
      match(PostgreSQLParser::ON);
      setState(10115);
      match(PostgreSQLParser::EMPTY_P);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(10117);
      json_behavior();
      setState(10118);
      match(PostgreSQLParser::ON);
      setState(10119);
      match(PostgreSQLParser::ERROR);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(10121);
      json_behavior();
      setState(10122);
      match(PostgreSQLParser::ON);
      setState(10123);
      match(PostgreSQLParser::EMPTY_P);
      setState(10124);
      json_behavior();
      setState(10125);
      match(PostgreSQLParser::ON);
      setState(10126);
      match(PostgreSQLParser::ERROR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Json_on_error_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Json_on_error_clauseContext::Json_on_error_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Json_behaviorContext* PostgreSQLParser::Json_on_error_clauseContext::json_behavior() {
  return getRuleContext<PostgreSQLParser::Json_behaviorContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Json_on_error_clauseContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_on_error_clauseContext::ERROR() {
  return getToken(PostgreSQLParser::ERROR, 0);
}


size_t PostgreSQLParser::Json_on_error_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_on_error_clause;
}


std::any PostgreSQLParser::Json_on_error_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_on_error_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Json_on_error_clauseContext* PostgreSQLParser::json_on_error_clause() {
  Json_on_error_clauseContext *_localctx = _tracker.createInstance<Json_on_error_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1344, PostgreSQLParser::RuleJson_on_error_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10130);
    json_behavior();
    setState(10131);
    match(PostgreSQLParser::ON);
    setState(10132);
    match(PostgreSQLParser::ERROR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Json_value_exprContext ------------------------------------------------------------------

PostgreSQLParser::Json_value_exprContext::Json_value_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Json_value_exprContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

PostgreSQLParser::Json_format_clauseContext* PostgreSQLParser::Json_value_exprContext::json_format_clause() {
  return getRuleContext<PostgreSQLParser::Json_format_clauseContext>(0);
}


size_t PostgreSQLParser::Json_value_exprContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_value_expr;
}


std::any PostgreSQLParser::Json_value_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_value_expr(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Json_value_exprContext* PostgreSQLParser::json_value_expr() {
  Json_value_exprContext *_localctx = _tracker.createInstance<Json_value_exprContext>(_ctx, getState());
  enterRule(_localctx, 1346, PostgreSQLParser::RuleJson_value_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10134);
    a_expr();
    setState(10136);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1009, _ctx)) {
    case 1: {
      setState(10135);
      json_format_clause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Json_format_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Json_format_clauseContext::Json_format_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Json_format_clauseContext::FORMAT_LA() {
  return getToken(PostgreSQLParser::FORMAT_LA, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_format_clauseContext::JSON() {
  return getToken(PostgreSQLParser::JSON, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_format_clauseContext::ENCODING() {
  return getToken(PostgreSQLParser::ENCODING, 0);
}

PostgreSQLParser::NameContext* PostgreSQLParser::Json_format_clauseContext::name() {
  return getRuleContext<PostgreSQLParser::NameContext>(0);
}


size_t PostgreSQLParser::Json_format_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_format_clause;
}


std::any PostgreSQLParser::Json_format_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_format_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Json_format_clauseContext* PostgreSQLParser::json_format_clause() {
  Json_format_clauseContext *_localctx = _tracker.createInstance<Json_format_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1348, PostgreSQLParser::RuleJson_format_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10144);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1010, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(10138);
      match(PostgreSQLParser::FORMAT_LA);
      setState(10139);
      match(PostgreSQLParser::JSON);
      setState(10140);
      match(PostgreSQLParser::ENCODING);
      setState(10141);
      name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(10142);
      match(PostgreSQLParser::FORMAT_LA);
      setState(10143);
      match(PostgreSQLParser::JSON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Json_quotes_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Json_quotes_clauseContext::Json_quotes_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Json_quotes_clauseContext::KEEP() {
  return getToken(PostgreSQLParser::KEEP, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_quotes_clauseContext::QUOTES() {
  return getToken(PostgreSQLParser::QUOTES, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_quotes_clauseContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_quotes_clauseContext::SCALAR() {
  return getToken(PostgreSQLParser::SCALAR, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_quotes_clauseContext::STRING_P() {
  return getToken(PostgreSQLParser::STRING_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_quotes_clauseContext::OMIT() {
  return getToken(PostgreSQLParser::OMIT, 0);
}


size_t PostgreSQLParser::Json_quotes_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_quotes_clause;
}


std::any PostgreSQLParser::Json_quotes_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_quotes_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Json_quotes_clauseContext* PostgreSQLParser::json_quotes_clause() {
  Json_quotes_clauseContext *_localctx = _tracker.createInstance<Json_quotes_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1350, PostgreSQLParser::RuleJson_quotes_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10160);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1011, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(10146);
      match(PostgreSQLParser::KEEP);
      setState(10147);
      match(PostgreSQLParser::QUOTES);
      setState(10148);
      match(PostgreSQLParser::ON);
      setState(10149);
      match(PostgreSQLParser::SCALAR);
      setState(10150);
      match(PostgreSQLParser::STRING_P);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(10151);
      match(PostgreSQLParser::KEEP);
      setState(10152);
      match(PostgreSQLParser::QUOTES);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(10153);
      match(PostgreSQLParser::OMIT);
      setState(10154);
      match(PostgreSQLParser::QUOTES);
      setState(10155);
      match(PostgreSQLParser::ON);
      setState(10156);
      match(PostgreSQLParser::SCALAR);
      setState(10157);
      match(PostgreSQLParser::STRING_P);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(10158);
      match(PostgreSQLParser::OMIT);
      setState(10159);
      match(PostgreSQLParser::QUOTES);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Json_returning_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Json_returning_clauseContext::Json_returning_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Json_returning_clauseContext::RETURNING() {
  return getToken(PostgreSQLParser::RETURNING, 0);
}

PostgreSQLParser::TypenameContext* PostgreSQLParser::Json_returning_clauseContext::typename_() {
  return getRuleContext<PostgreSQLParser::TypenameContext>(0);
}

PostgreSQLParser::Json_format_clauseContext* PostgreSQLParser::Json_returning_clauseContext::json_format_clause() {
  return getRuleContext<PostgreSQLParser::Json_format_clauseContext>(0);
}


size_t PostgreSQLParser::Json_returning_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_returning_clause;
}


std::any PostgreSQLParser::Json_returning_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_returning_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Json_returning_clauseContext* PostgreSQLParser::json_returning_clause() {
  Json_returning_clauseContext *_localctx = _tracker.createInstance<Json_returning_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1352, PostgreSQLParser::RuleJson_returning_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10162);
    match(PostgreSQLParser::RETURNING);
    setState(10163);
    typename_();
    setState(10165);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::FORMAT_LA) {
      setState(10164);
      json_format_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Json_predicate_type_constraintContext ------------------------------------------------------------------

PostgreSQLParser::Json_predicate_type_constraintContext::Json_predicate_type_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Json_predicate_type_constraintContext::JSON() {
  return getToken(PostgreSQLParser::JSON, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_predicate_type_constraintContext::VALUE_P() {
  return getToken(PostgreSQLParser::VALUE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_predicate_type_constraintContext::ARRAY() {
  return getToken(PostgreSQLParser::ARRAY, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_predicate_type_constraintContext::OBJECT_P() {
  return getToken(PostgreSQLParser::OBJECT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_predicate_type_constraintContext::SCALAR() {
  return getToken(PostgreSQLParser::SCALAR, 0);
}


size_t PostgreSQLParser::Json_predicate_type_constraintContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_predicate_type_constraint;
}


std::any PostgreSQLParser::Json_predicate_type_constraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_predicate_type_constraint(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Json_predicate_type_constraintContext* PostgreSQLParser::json_predicate_type_constraint() {
  Json_predicate_type_constraintContext *_localctx = _tracker.createInstance<Json_predicate_type_constraintContext>(_ctx, getState());
  enterRule(_localctx, 1354, PostgreSQLParser::RuleJson_predicate_type_constraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10176);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1013, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(10167);
      match(PostgreSQLParser::JSON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(10168);
      match(PostgreSQLParser::JSON);
      setState(10169);
      match(PostgreSQLParser::VALUE_P);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(10170);
      match(PostgreSQLParser::JSON);
      setState(10171);
      match(PostgreSQLParser::ARRAY);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(10172);
      match(PostgreSQLParser::JSON);
      setState(10173);
      match(PostgreSQLParser::OBJECT_P);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(10174);
      match(PostgreSQLParser::JSON);
      setState(10175);
      match(PostgreSQLParser::SCALAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Json_key_uniqueness_constraintContext ------------------------------------------------------------------

PostgreSQLParser::Json_key_uniqueness_constraintContext::Json_key_uniqueness_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Json_key_uniqueness_constraintContext::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_key_uniqueness_constraintContext::UNIQUE() {
  return getToken(PostgreSQLParser::UNIQUE, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_key_uniqueness_constraintContext::KEYS() {
  return getToken(PostgreSQLParser::KEYS, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_key_uniqueness_constraintContext::WITHOUT() {
  return getToken(PostgreSQLParser::WITHOUT, 0);
}


size_t PostgreSQLParser::Json_key_uniqueness_constraintContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_key_uniqueness_constraint;
}


std::any PostgreSQLParser::Json_key_uniqueness_constraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_key_uniqueness_constraint(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Json_key_uniqueness_constraintContext* PostgreSQLParser::json_key_uniqueness_constraint() {
  Json_key_uniqueness_constraintContext *_localctx = _tracker.createInstance<Json_key_uniqueness_constraintContext>(_ctx, getState());
  enterRule(_localctx, 1356, PostgreSQLParser::RuleJson_key_uniqueness_constraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10188);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1014, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(10178);
      match(PostgreSQLParser::WITH);
      setState(10179);
      match(PostgreSQLParser::UNIQUE);
      setState(10180);
      match(PostgreSQLParser::KEYS);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(10181);
      match(PostgreSQLParser::WITH);
      setState(10182);
      match(PostgreSQLParser::UNIQUE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(10183);
      match(PostgreSQLParser::WITHOUT);
      setState(10184);
      match(PostgreSQLParser::UNIQUE);
      setState(10185);
      match(PostgreSQLParser::KEYS);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(10186);
      match(PostgreSQLParser::WITHOUT);
      setState(10187);
      match(PostgreSQLParser::UNIQUE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Json_name_and_value_listContext ------------------------------------------------------------------

PostgreSQLParser::Json_name_and_value_listContext::Json_name_and_value_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Json_name_and_valueContext* PostgreSQLParser::Json_name_and_value_listContext::json_name_and_value() {
  return getRuleContext<PostgreSQLParser::Json_name_and_valueContext>(0);
}

PostgreSQLParser::Json_name_and_value_listContext* PostgreSQLParser::Json_name_and_value_listContext::json_name_and_value_list() {
  return getRuleContext<PostgreSQLParser::Json_name_and_value_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Json_name_and_value_listContext::COMMA() {
  return getToken(PostgreSQLParser::COMMA, 0);
}


size_t PostgreSQLParser::Json_name_and_value_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_name_and_value_list;
}


std::any PostgreSQLParser::Json_name_and_value_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_name_and_value_list(this);
  else
    return visitor->visitChildren(this);
}


PostgreSQLParser::Json_name_and_value_listContext* PostgreSQLParser::json_name_and_value_list() {
   return json_name_and_value_list(0);
}

PostgreSQLParser::Json_name_and_value_listContext* PostgreSQLParser::json_name_and_value_list(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  PostgreSQLParser::Json_name_and_value_listContext *_localctx = _tracker.createInstance<Json_name_and_value_listContext>(_ctx, parentState);
  PostgreSQLParser::Json_name_and_value_listContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 1358;
  enterRecursionRule(_localctx, 1358, PostgreSQLParser::RuleJson_name_and_value_list, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(10191);
    json_name_and_value();
    _ctx->stop = _input->LT(-1);
    setState(10198);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1015, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<Json_name_and_value_listContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleJson_name_and_value_list);
        setState(10193);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(10194);
        match(PostgreSQLParser::COMMA);
        setState(10195);
        json_name_and_value(); 
      }
      setState(10200);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1015, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Json_name_and_valueContext ------------------------------------------------------------------

PostgreSQLParser::Json_name_and_valueContext::Json_name_and_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::C_exprContext* PostgreSQLParser::Json_name_and_valueContext::c_expr() {
  return getRuleContext<PostgreSQLParser::C_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Json_name_and_valueContext::VALUE_P() {
  return getToken(PostgreSQLParser::VALUE_P, 0);
}

PostgreSQLParser::Json_value_exprContext* PostgreSQLParser::Json_name_and_valueContext::json_value_expr() {
  return getRuleContext<PostgreSQLParser::Json_value_exprContext>(0);
}

PostgreSQLParser::A_exprContext* PostgreSQLParser::Json_name_and_valueContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Json_name_and_valueContext::COLON() {
  return getToken(PostgreSQLParser::COLON, 0);
}


size_t PostgreSQLParser::Json_name_and_valueContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_name_and_value;
}


std::any PostgreSQLParser::Json_name_and_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_name_and_value(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Json_name_and_valueContext* PostgreSQLParser::json_name_and_value() {
  Json_name_and_valueContext *_localctx = _tracker.createInstance<Json_name_and_valueContext>(_ctx, getState());
  enterRule(_localctx, 1360, PostgreSQLParser::RuleJson_name_and_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10209);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1016, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(10201);
      c_expr();
      setState(10202);
      match(PostgreSQLParser::VALUE_P);
      setState(10203);
      json_value_expr();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(10205);
      a_expr();
      setState(10206);
      match(PostgreSQLParser::COLON);
      setState(10207);
      json_value_expr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Json_object_constructor_null_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Json_object_constructor_null_clauseContext::Json_object_constructor_null_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Json_object_constructor_null_clauseContext::NULL_P() {
  return getTokens(PostgreSQLParser::NULL_P);
}

tree::TerminalNode* PostgreSQLParser::Json_object_constructor_null_clauseContext::NULL_P(size_t i) {
  return getToken(PostgreSQLParser::NULL_P, i);
}

tree::TerminalNode* PostgreSQLParser::Json_object_constructor_null_clauseContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_object_constructor_null_clauseContext::ABSENT() {
  return getToken(PostgreSQLParser::ABSENT, 0);
}


size_t PostgreSQLParser::Json_object_constructor_null_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_object_constructor_null_clause;
}


std::any PostgreSQLParser::Json_object_constructor_null_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_object_constructor_null_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Json_object_constructor_null_clauseContext* PostgreSQLParser::json_object_constructor_null_clause() {
  Json_object_constructor_null_clauseContext *_localctx = _tracker.createInstance<Json_object_constructor_null_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1362, PostgreSQLParser::RuleJson_object_constructor_null_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10217);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::NULL_P: {
        enterOuterAlt(_localctx, 1);
        setState(10211);
        match(PostgreSQLParser::NULL_P);
        setState(10212);
        match(PostgreSQLParser::ON);
        setState(10213);
        match(PostgreSQLParser::NULL_P);
        break;
      }

      case PostgreSQLParser::ABSENT: {
        enterOuterAlt(_localctx, 2);
        setState(10214);
        match(PostgreSQLParser::ABSENT);
        setState(10215);
        match(PostgreSQLParser::ON);
        setState(10216);
        match(PostgreSQLParser::NULL_P);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Json_array_constructor_null_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Json_array_constructor_null_clauseContext::Json_array_constructor_null_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Json_array_constructor_null_clauseContext::NULL_P() {
  return getTokens(PostgreSQLParser::NULL_P);
}

tree::TerminalNode* PostgreSQLParser::Json_array_constructor_null_clauseContext::NULL_P(size_t i) {
  return getToken(PostgreSQLParser::NULL_P, i);
}

tree::TerminalNode* PostgreSQLParser::Json_array_constructor_null_clauseContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_array_constructor_null_clauseContext::ABSENT() {
  return getToken(PostgreSQLParser::ABSENT, 0);
}


size_t PostgreSQLParser::Json_array_constructor_null_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_array_constructor_null_clause;
}


std::any PostgreSQLParser::Json_array_constructor_null_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_array_constructor_null_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Json_array_constructor_null_clauseContext* PostgreSQLParser::json_array_constructor_null_clause() {
  Json_array_constructor_null_clauseContext *_localctx = _tracker.createInstance<Json_array_constructor_null_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1364, PostgreSQLParser::RuleJson_array_constructor_null_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10225);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::NULL_P: {
        enterOuterAlt(_localctx, 1);
        setState(10219);
        match(PostgreSQLParser::NULL_P);
        setState(10220);
        match(PostgreSQLParser::ON);
        setState(10221);
        match(PostgreSQLParser::NULL_P);
        break;
      }

      case PostgreSQLParser::ABSENT: {
        enterOuterAlt(_localctx, 2);
        setState(10222);
        match(PostgreSQLParser::ABSENT);
        setState(10223);
        match(PostgreSQLParser::ON);
        setState(10224);
        match(PostgreSQLParser::NULL_P);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Json_value_expr_listContext ------------------------------------------------------------------

PostgreSQLParser::Json_value_expr_listContext::Json_value_expr_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Json_value_exprContext* PostgreSQLParser::Json_value_expr_listContext::json_value_expr() {
  return getRuleContext<PostgreSQLParser::Json_value_exprContext>(0);
}

PostgreSQLParser::Json_value_expr_listContext* PostgreSQLParser::Json_value_expr_listContext::json_value_expr_list() {
  return getRuleContext<PostgreSQLParser::Json_value_expr_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Json_value_expr_listContext::COMMA() {
  return getToken(PostgreSQLParser::COMMA, 0);
}


size_t PostgreSQLParser::Json_value_expr_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_value_expr_list;
}


std::any PostgreSQLParser::Json_value_expr_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_value_expr_list(this);
  else
    return visitor->visitChildren(this);
}


PostgreSQLParser::Json_value_expr_listContext* PostgreSQLParser::json_value_expr_list() {
   return json_value_expr_list(0);
}

PostgreSQLParser::Json_value_expr_listContext* PostgreSQLParser::json_value_expr_list(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  PostgreSQLParser::Json_value_expr_listContext *_localctx = _tracker.createInstance<Json_value_expr_listContext>(_ctx, parentState);
  PostgreSQLParser::Json_value_expr_listContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 1366;
  enterRecursionRule(_localctx, 1366, PostgreSQLParser::RuleJson_value_expr_list, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(10228);
    json_value_expr();
    _ctx->stop = _input->LT(-1);
    setState(10235);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1019, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<Json_value_expr_listContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleJson_value_expr_list);
        setState(10230);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(10231);
        match(PostgreSQLParser::COMMA);
        setState(10232);
        json_value_expr(); 
      }
      setState(10237);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1019, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Json_aggregate_funcContext ------------------------------------------------------------------

PostgreSQLParser::Json_aggregate_funcContext::Json_aggregate_funcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Json_aggregate_funcContext::JSON_OBJECTAGG() {
  return getToken(PostgreSQLParser::JSON_OBJECTAGG, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_aggregate_funcContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Json_name_and_valueContext* PostgreSQLParser::Json_aggregate_funcContext::json_name_and_value() {
  return getRuleContext<PostgreSQLParser::Json_name_and_valueContext>(0);
}

PostgreSQLParser::Json_returning_clauseContext* PostgreSQLParser::Json_aggregate_funcContext::json_returning_clause() {
  return getRuleContext<PostgreSQLParser::Json_returning_clauseContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Json_aggregate_funcContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::Json_object_constructor_null_clauseContext* PostgreSQLParser::Json_aggregate_funcContext::json_object_constructor_null_clause() {
  return getRuleContext<PostgreSQLParser::Json_object_constructor_null_clauseContext>(0);
}

PostgreSQLParser::Json_key_uniqueness_constraintContext* PostgreSQLParser::Json_aggregate_funcContext::json_key_uniqueness_constraint() {
  return getRuleContext<PostgreSQLParser::Json_key_uniqueness_constraintContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Json_aggregate_funcContext::JSON_ARRAYAGG() {
  return getToken(PostgreSQLParser::JSON_ARRAYAGG, 0);
}

PostgreSQLParser::Json_value_exprContext* PostgreSQLParser::Json_aggregate_funcContext::json_value_expr() {
  return getRuleContext<PostgreSQLParser::Json_value_exprContext>(0);
}

PostgreSQLParser::Json_array_aggregate_order_by_clauseContext* PostgreSQLParser::Json_aggregate_funcContext::json_array_aggregate_order_by_clause() {
  return getRuleContext<PostgreSQLParser::Json_array_aggregate_order_by_clauseContext>(0);
}

PostgreSQLParser::Json_array_constructor_null_clauseContext* PostgreSQLParser::Json_aggregate_funcContext::json_array_constructor_null_clause() {
  return getRuleContext<PostgreSQLParser::Json_array_constructor_null_clauseContext>(0);
}


size_t PostgreSQLParser::Json_aggregate_funcContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_aggregate_func;
}


std::any PostgreSQLParser::Json_aggregate_funcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_aggregate_func(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Json_aggregate_funcContext* PostgreSQLParser::json_aggregate_func() {
  Json_aggregate_funcContext *_localctx = _tracker.createInstance<Json_aggregate_funcContext>(_ctx, getState());
  enterRule(_localctx, 1368, PostgreSQLParser::RuleJson_aggregate_func);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10262);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::JSON_OBJECTAGG: {
        enterOuterAlt(_localctx, 1);
        setState(10238);
        match(PostgreSQLParser::JSON_OBJECTAGG);
        setState(10239);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(10240);
        json_name_and_value();
        setState(10242);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::ABSENT || _la == PostgreSQLParser::NULL_P) {
          setState(10241);
          json_object_constructor_null_clause();
        }
        setState(10245);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::WITH || _la == PostgreSQLParser::WITHOUT) {
          setState(10244);
          json_key_uniqueness_constraint();
        }
        setState(10247);
        json_returning_clause();
        setState(10248);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

      case PostgreSQLParser::JSON_ARRAYAGG: {
        enterOuterAlt(_localctx, 2);
        setState(10250);
        match(PostgreSQLParser::JSON_ARRAYAGG);
        setState(10251);
        match(PostgreSQLParser::OPEN_PAREN);
        setState(10252);
        json_value_expr();
        setState(10254);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::ORDER) {
          setState(10253);
          json_array_aggregate_order_by_clause();
        }
        setState(10257);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == PostgreSQLParser::ABSENT || _la == PostgreSQLParser::NULL_P) {
          setState(10256);
          json_array_constructor_null_clause();
        }
        setState(10259);
        json_returning_clause();
        setState(10260);
        match(PostgreSQLParser::CLOSE_PAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Json_array_aggregate_order_by_clauseContext ------------------------------------------------------------------

PostgreSQLParser::Json_array_aggregate_order_by_clauseContext::Json_array_aggregate_order_by_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Json_array_aggregate_order_by_clauseContext::ORDER() {
  return getToken(PostgreSQLParser::ORDER, 0);
}

tree::TerminalNode* PostgreSQLParser::Json_array_aggregate_order_by_clauseContext::BY() {
  return getToken(PostgreSQLParser::BY, 0);
}

PostgreSQLParser::Sortby_listContext* PostgreSQLParser::Json_array_aggregate_order_by_clauseContext::sortby_list() {
  return getRuleContext<PostgreSQLParser::Sortby_listContext>(0);
}


size_t PostgreSQLParser::Json_array_aggregate_order_by_clauseContext::getRuleIndex() const {
  return PostgreSQLParser::RuleJson_array_aggregate_order_by_clause;
}


std::any PostgreSQLParser::Json_array_aggregate_order_by_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitJson_array_aggregate_order_by_clause(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Json_array_aggregate_order_by_clauseContext* PostgreSQLParser::json_array_aggregate_order_by_clause() {
  Json_array_aggregate_order_by_clauseContext *_localctx = _tracker.createInstance<Json_array_aggregate_order_by_clauseContext>(_ctx, getState());
  enterRule(_localctx, 1370, PostgreSQLParser::RuleJson_array_aggregate_order_by_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10264);
    match(PostgreSQLParser::ORDER);
    setState(10265);
    match(PostgreSQLParser::BY);
    setState(10266);
    sortby_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Target_list_Context ------------------------------------------------------------------

PostgreSQLParser::Target_list_Context::Target_list_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Target_listContext* PostgreSQLParser::Target_list_Context::target_list() {
  return getRuleContext<PostgreSQLParser::Target_listContext>(0);
}


size_t PostgreSQLParser::Target_list_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleTarget_list_;
}


std::any PostgreSQLParser::Target_list_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTarget_list_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Target_list_Context* PostgreSQLParser::target_list_() {
  Target_list_Context *_localctx = _tracker.createInstance<Target_list_Context>(_ctx, getState());
  enterRule(_localctx, 1372, PostgreSQLParser::RuleTarget_list_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10268);
    target_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Target_listContext ------------------------------------------------------------------

PostgreSQLParser::Target_listContext::Target_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Target_elContext *> PostgreSQLParser::Target_listContext::target_el() {
  return getRuleContexts<PostgreSQLParser::Target_elContext>();
}

PostgreSQLParser::Target_elContext* PostgreSQLParser::Target_listContext::target_el(size_t i) {
  return getRuleContext<PostgreSQLParser::Target_elContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Target_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Target_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Target_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTarget_list;
}


std::any PostgreSQLParser::Target_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTarget_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Target_listContext* PostgreSQLParser::target_list() {
  Target_listContext *_localctx = _tracker.createInstance<Target_listContext>(_ctx, getState());
  enterRule(_localctx, 1374, PostgreSQLParser::RuleTarget_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10270);
    target_el();
    setState(10275);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(10271);
      match(PostgreSQLParser::COMMA);
      setState(10272);
      target_el();
      setState(10277);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Target_elContext ------------------------------------------------------------------

PostgreSQLParser::Target_elContext::Target_elContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t PostgreSQLParser::Target_elContext::getRuleIndex() const {
  return PostgreSQLParser::RuleTarget_el;
}

void PostgreSQLParser::Target_elContext::copyFrom(Target_elContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Target_labelContext ------------------------------------------------------------------

PostgreSQLParser::A_exprContext* PostgreSQLParser::Target_labelContext::a_expr() {
  return getRuleContext<PostgreSQLParser::A_exprContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Target_labelContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

PostgreSQLParser::ColLabelContext* PostgreSQLParser::Target_labelContext::colLabel() {
  return getRuleContext<PostgreSQLParser::ColLabelContext>(0);
}

PostgreSQLParser::BareColLabelContext* PostgreSQLParser::Target_labelContext::bareColLabel() {
  return getRuleContext<PostgreSQLParser::BareColLabelContext>(0);
}

PostgreSQLParser::Target_labelContext::Target_labelContext(Target_elContext *ctx) { copyFrom(ctx); }


std::any PostgreSQLParser::Target_labelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTarget_label(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Target_starContext ------------------------------------------------------------------

tree::TerminalNode* PostgreSQLParser::Target_starContext::STAR() {
  return getToken(PostgreSQLParser::STAR, 0);
}

PostgreSQLParser::Target_starContext::Target_starContext(Target_elContext *ctx) { copyFrom(ctx); }


std::any PostgreSQLParser::Target_starContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitTarget_star(this);
  else
    return visitor->visitChildren(this);
}
PostgreSQLParser::Target_elContext* PostgreSQLParser::target_el() {
  Target_elContext *_localctx = _tracker.createInstance<Target_elContext>(_ctx, getState());
  enterRule(_localctx, 1376, PostgreSQLParser::RuleTarget_el);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10286);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::OPEN_PAREN:
      case PostgreSQLParser::PLUS:
      case PostgreSQLParser::MINUS:
      case PostgreSQLParser::PARAM:
      case PostgreSQLParser::Operator:
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::SYSTEM_USER:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::ARRAY:
      case PostgreSQLParser::CASE:
      case PostgreSQLParser::CAST:
      case PostgreSQLParser::CURRENT_CATALOG:
      case PostgreSQLParser::CURRENT_DATE:
      case PostgreSQLParser::CURRENT_ROLE:
      case PostgreSQLParser::CURRENT_TIME:
      case PostgreSQLParser::CURRENT_TIMESTAMP:
      case PostgreSQLParser::CURRENT_USER:
      case PostgreSQLParser::DEFAULT:
      case PostgreSQLParser::FALSE_P:
      case PostgreSQLParser::LOCALTIME:
      case PostgreSQLParser::LOCALTIMESTAMP:
      case PostgreSQLParser::NOT:
      case PostgreSQLParser::NULL_P:
      case PostgreSQLParser::SESSION_USER:
      case PostgreSQLParser::TRUE_P:
      case PostgreSQLParser::UNIQUE:
      case PostgreSQLParser::USER:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::StringConstant:
      case PostgreSQLParser::UnicodeEscapeStringConstant:
      case PostgreSQLParser::BeginDollarStringConstant:
      case PostgreSQLParser::BinaryStringConstant:
      case PostgreSQLParser::HexadecimalStringConstant:
      case PostgreSQLParser::Integral:
      case PostgreSQLParser::BinaryIntegral:
      case PostgreSQLParser::OctalIntegral:
      case PostgreSQLParser::HexadecimalIntegral:
      case PostgreSQLParser::Numeric:
      case PostgreSQLParser::PLSQLVARIABLENAME:
      case PostgreSQLParser::EscapeStringConstant: {
        _localctx = _tracker.createInstance<PostgreSQLParser::Target_labelContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(10278);
        a_expr();
        setState(10283);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case PostgreSQLParser::AS: {
            setState(10279);
            match(PostgreSQLParser::AS);
            setState(10280);
            colLabel();
            break;
          }

          case PostgreSQLParser::JSON:
          case PostgreSQLParser::JSON_ARRAY:
          case PostgreSQLParser::JSON_ARRAYAGG:
          case PostgreSQLParser::JSON_EXISTS:
          case PostgreSQLParser::JSON_OBJECT:
          case PostgreSQLParser::JSON_OBJECTAGG:
          case PostgreSQLParser::JSON_QUERY:
          case PostgreSQLParser::JSON_SCALAR:
          case PostgreSQLParser::JSON_SERIALIZE:
          case PostgreSQLParser::JSON_TABLE:
          case PostgreSQLParser::JSON_VALUE:
          case PostgreSQLParser::MERGE_ACTION:
          case PostgreSQLParser::SYSTEM_USER:
          case PostgreSQLParser::ABSENT:
          case PostgreSQLParser::ASENSITIVE:
          case PostgreSQLParser::ATOMIC:
          case PostgreSQLParser::BREADTH:
          case PostgreSQLParser::COMPRESSION:
          case PostgreSQLParser::CONDITIONAL:
          case PostgreSQLParser::DEPTH:
          case PostgreSQLParser::EMPTY_P:
          case PostgreSQLParser::FINALIZE:
          case PostgreSQLParser::INDENT:
          case PostgreSQLParser::KEEP:
          case PostgreSQLParser::KEYS:
          case PostgreSQLParser::NESTED:
          case PostgreSQLParser::OMIT:
          case PostgreSQLParser::PARAMETER:
          case PostgreSQLParser::PATH:
          case PostgreSQLParser::PLAN:
          case PostgreSQLParser::QUOTES:
          case PostgreSQLParser::SCALAR:
          case PostgreSQLParser::SOURCE:
          case PostgreSQLParser::STRING_P:
          case PostgreSQLParser::TARGET:
          case PostgreSQLParser::UNCONDITIONAL:
          case PostgreSQLParser::PERIOD:
          case PostgreSQLParser::ALL:
          case PostgreSQLParser::ANALYSE:
          case PostgreSQLParser::ANALYZE:
          case PostgreSQLParser::AND:
          case PostgreSQLParser::ANY:
          case PostgreSQLParser::ASC:
          case PostgreSQLParser::ASYMMETRIC:
          case PostgreSQLParser::BOTH:
          case PostgreSQLParser::CASE:
          case PostgreSQLParser::CAST:
          case PostgreSQLParser::CHECK:
          case PostgreSQLParser::COLLATE:
          case PostgreSQLParser::COLUMN:
          case PostgreSQLParser::CONSTRAINT:
          case PostgreSQLParser::CURRENT_CATALOG:
          case PostgreSQLParser::CURRENT_DATE:
          case PostgreSQLParser::CURRENT_ROLE:
          case PostgreSQLParser::CURRENT_TIME:
          case PostgreSQLParser::CURRENT_TIMESTAMP:
          case PostgreSQLParser::CURRENT_USER:
          case PostgreSQLParser::DEFAULT:
          case PostgreSQLParser::DEFERRABLE:
          case PostgreSQLParser::DESC:
          case PostgreSQLParser::DISTINCT:
          case PostgreSQLParser::DO:
          case PostgreSQLParser::ELSE:
          case PostgreSQLParser::FALSE_P:
          case PostgreSQLParser::FOREIGN:
          case PostgreSQLParser::IN_P:
          case PostgreSQLParser::INITIALLY:
          case PostgreSQLParser::LATERAL_P:
          case PostgreSQLParser::LEADING:
          case PostgreSQLParser::LOCALTIME:
          case PostgreSQLParser::LOCALTIMESTAMP:
          case PostgreSQLParser::NOT:
          case PostgreSQLParser::NULL_P:
          case PostgreSQLParser::ONLY:
          case PostgreSQLParser::OR:
          case PostgreSQLParser::PLACING:
          case PostgreSQLParser::PRIMARY:
          case PostgreSQLParser::REFERENCES:
          case PostgreSQLParser::SELECT:
          case PostgreSQLParser::SESSION_USER:
          case PostgreSQLParser::SOME:
          case PostgreSQLParser::SYMMETRIC:
          case PostgreSQLParser::TABLE:
          case PostgreSQLParser::THEN:
          case PostgreSQLParser::TRAILING:
          case PostgreSQLParser::TRUE_P:
          case PostgreSQLParser::UNIQUE:
          case PostgreSQLParser::USER:
          case PostgreSQLParser::USING:
          case PostgreSQLParser::VARIADIC:
          case PostgreSQLParser::WHEN:
          case PostgreSQLParser::AUTHORIZATION:
          case PostgreSQLParser::BINARY:
          case PostgreSQLParser::COLLATION:
          case PostgreSQLParser::CONCURRENTLY:
          case PostgreSQLParser::CROSS:
          case PostgreSQLParser::CURRENT_SCHEMA:
          case PostgreSQLParser::FREEZE:
          case PostgreSQLParser::FULL:
          case PostgreSQLParser::ILIKE:
          case PostgreSQLParser::INNER_P:
          case PostgreSQLParser::IS:
          case PostgreSQLParser::JOIN:
          case PostgreSQLParser::LEFT:
          case PostgreSQLParser::LIKE:
          case PostgreSQLParser::NATURAL:
          case PostgreSQLParser::OUTER_P:
          case PostgreSQLParser::RIGHT:
          case PostgreSQLParser::SIMILAR:
          case PostgreSQLParser::VERBOSE:
          case PostgreSQLParser::ABORT_P:
          case PostgreSQLParser::ABSOLUTE_P:
          case PostgreSQLParser::ACCESS:
          case PostgreSQLParser::ACTION:
          case PostgreSQLParser::ADD_P:
          case PostgreSQLParser::ADMIN:
          case PostgreSQLParser::AFTER:
          case PostgreSQLParser::AGGREGATE:
          case PostgreSQLParser::ALSO:
          case PostgreSQLParser::ALTER:
          case PostgreSQLParser::ALWAYS:
          case PostgreSQLParser::ASSERTION:
          case PostgreSQLParser::ASSIGNMENT:
          case PostgreSQLParser::AT:
          case PostgreSQLParser::ATTRIBUTE:
          case PostgreSQLParser::BACKWARD:
          case PostgreSQLParser::BEFORE:
          case PostgreSQLParser::BEGIN_P:
          case PostgreSQLParser::BY:
          case PostgreSQLParser::CACHE:
          case PostgreSQLParser::CALLED:
          case PostgreSQLParser::CASCADE:
          case PostgreSQLParser::CASCADED:
          case PostgreSQLParser::CATALOG:
          case PostgreSQLParser::CHAIN:
          case PostgreSQLParser::CHARACTERISTICS:
          case PostgreSQLParser::CHECKPOINT:
          case PostgreSQLParser::CLASS:
          case PostgreSQLParser::CLOSE:
          case PostgreSQLParser::CLUSTER:
          case PostgreSQLParser::COMMENT:
          case PostgreSQLParser::COMMENTS:
          case PostgreSQLParser::COMMIT:
          case PostgreSQLParser::COMMITTED:
          case PostgreSQLParser::CONFIGURATION:
          case PostgreSQLParser::CONNECTION:
          case PostgreSQLParser::CONSTRAINTS:
          case PostgreSQLParser::CONTENT_P:
          case PostgreSQLParser::CONTINUE_P:
          case PostgreSQLParser::CONVERSION_P:
          case PostgreSQLParser::COPY:
          case PostgreSQLParser::COST:
          case PostgreSQLParser::CSV:
          case PostgreSQLParser::CURSOR:
          case PostgreSQLParser::CYCLE:
          case PostgreSQLParser::DATA_P:
          case PostgreSQLParser::DATABASE:
          case PostgreSQLParser::DEALLOCATE:
          case PostgreSQLParser::DECLARE:
          case PostgreSQLParser::DEFAULTS:
          case PostgreSQLParser::DEFERRED:
          case PostgreSQLParser::DEFINER:
          case PostgreSQLParser::DELETE_P:
          case PostgreSQLParser::DELIMITER:
          case PostgreSQLParser::DELIMITERS:
          case PostgreSQLParser::DICTIONARY:
          case PostgreSQLParser::DISABLE_P:
          case PostgreSQLParser::DISCARD:
          case PostgreSQLParser::DOCUMENT_P:
          case PostgreSQLParser::DOMAIN_P:
          case PostgreSQLParser::DOUBLE_P:
          case PostgreSQLParser::DROP:
          case PostgreSQLParser::EACH:
          case PostgreSQLParser::ENABLE_P:
          case PostgreSQLParser::ENCODING:
          case PostgreSQLParser::ENCRYPTED:
          case PostgreSQLParser::ENUM_P:
          case PostgreSQLParser::ESCAPE:
          case PostgreSQLParser::EVENT:
          case PostgreSQLParser::EXCLUDE:
          case PostgreSQLParser::EXCLUDING:
          case PostgreSQLParser::EXCLUSIVE:
          case PostgreSQLParser::EXECUTE:
          case PostgreSQLParser::EXPLAIN:
          case PostgreSQLParser::EXTENSION:
          case PostgreSQLParser::EXTERNAL:
          case PostgreSQLParser::FAMILY:
          case PostgreSQLParser::FIRST_P:
          case PostgreSQLParser::FOLLOWING:
          case PostgreSQLParser::FORCE:
          case PostgreSQLParser::FORWARD:
          case PostgreSQLParser::FUNCTION:
          case PostgreSQLParser::FUNCTIONS:
          case PostgreSQLParser::GLOBAL:
          case PostgreSQLParser::GRANTED:
          case PostgreSQLParser::HANDLER:
          case PostgreSQLParser::HEADER_P:
          case PostgreSQLParser::HOLD:
          case PostgreSQLParser::IDENTITY_P:
          case PostgreSQLParser::IF_P:
          case PostgreSQLParser::IMMEDIATE:
          case PostgreSQLParser::IMMUTABLE:
          case PostgreSQLParser::IMPLICIT_P:
          case PostgreSQLParser::INCLUDING:
          case PostgreSQLParser::INCREMENT:
          case PostgreSQLParser::INDEX:
          case PostgreSQLParser::INDEXES:
          case PostgreSQLParser::INHERIT:
          case PostgreSQLParser::INHERITS:
          case PostgreSQLParser::INLINE_P:
          case PostgreSQLParser::INSENSITIVE:
          case PostgreSQLParser::INSERT:
          case PostgreSQLParser::INSTEAD:
          case PostgreSQLParser::INVOKER:
          case PostgreSQLParser::ISOLATION:
          case PostgreSQLParser::KEY:
          case PostgreSQLParser::LABEL:
          case PostgreSQLParser::LANGUAGE:
          case PostgreSQLParser::LARGE_P:
          case PostgreSQLParser::LAST_P:
          case PostgreSQLParser::LEAKPROOF:
          case PostgreSQLParser::LEVEL:
          case PostgreSQLParser::LISTEN:
          case PostgreSQLParser::LOAD:
          case PostgreSQLParser::LOCAL:
          case PostgreSQLParser::LOCATION:
          case PostgreSQLParser::LOCK_P:
          case PostgreSQLParser::MAPPING:
          case PostgreSQLParser::MATCH:
          case PostgreSQLParser::MATCHED:
          case PostgreSQLParser::MATERIALIZED:
          case PostgreSQLParser::MAXVALUE:
          case PostgreSQLParser::MERGE:
          case PostgreSQLParser::MINVALUE:
          case PostgreSQLParser::MODE:
          case PostgreSQLParser::MOVE:
          case PostgreSQLParser::NAME_P:
          case PostgreSQLParser::NAMES:
          case PostgreSQLParser::NEXT:
          case PostgreSQLParser::NO:
          case PostgreSQLParser::NOTHING:
          case PostgreSQLParser::NOTIFY:
          case PostgreSQLParser::NOWAIT:
          case PostgreSQLParser::NULLS_P:
          case PostgreSQLParser::OBJECT_P:
          case PostgreSQLParser::OF:
          case PostgreSQLParser::OFF:
          case PostgreSQLParser::OIDS:
          case PostgreSQLParser::OPERATOR:
          case PostgreSQLParser::OPTION:
          case PostgreSQLParser::OPTIONS:
          case PostgreSQLParser::OWNED:
          case PostgreSQLParser::OWNER:
          case PostgreSQLParser::PARSER:
          case PostgreSQLParser::PARTIAL:
          case PostgreSQLParser::PARTITION:
          case PostgreSQLParser::PASSING:
          case PostgreSQLParser::PASSWORD:
          case PostgreSQLParser::PLANS:
          case PostgreSQLParser::PRECEDING:
          case PostgreSQLParser::PREPARE:
          case PostgreSQLParser::PREPARED:
          case PostgreSQLParser::PRESERVE:
          case PostgreSQLParser::PRIOR:
          case PostgreSQLParser::PRIVILEGES:
          case PostgreSQLParser::PROCEDURAL:
          case PostgreSQLParser::PROCEDURE:
          case PostgreSQLParser::PROGRAM:
          case PostgreSQLParser::QUOTE:
          case PostgreSQLParser::RANGE:
          case PostgreSQLParser::READ:
          case PostgreSQLParser::REASSIGN:
          case PostgreSQLParser::RECURSIVE:
          case PostgreSQLParser::REF:
          case PostgreSQLParser::REFRESH:
          case PostgreSQLParser::REINDEX:
          case PostgreSQLParser::RELATIVE_P:
          case PostgreSQLParser::RELEASE:
          case PostgreSQLParser::RENAME:
          case PostgreSQLParser::REPEATABLE:
          case PostgreSQLParser::REPLACE:
          case PostgreSQLParser::REPLICA:
          case PostgreSQLParser::RESET:
          case PostgreSQLParser::RESTART:
          case PostgreSQLParser::RESTRICT:
          case PostgreSQLParser::RETURNS:
          case PostgreSQLParser::REVOKE:
          case PostgreSQLParser::ROLE:
          case PostgreSQLParser::ROLLBACK:
          case PostgreSQLParser::ROWS:
          case PostgreSQLParser::RULE:
          case PostgreSQLParser::SAVEPOINT:
          case PostgreSQLParser::SCHEMA:
          case PostgreSQLParser::SCROLL:
          case PostgreSQLParser::SEARCH:
          case PostgreSQLParser::SECURITY:
          case PostgreSQLParser::SEQUENCE:
          case PostgreSQLParser::SEQUENCES:
          case PostgreSQLParser::SERIALIZABLE:
          case PostgreSQLParser::SERVER:
          case PostgreSQLParser::SESSION:
          case PostgreSQLParser::SET:
          case PostgreSQLParser::SHARE:
          case PostgreSQLParser::SHOW:
          case PostgreSQLParser::SIMPLE:
          case PostgreSQLParser::SNAPSHOT:
          case PostgreSQLParser::STABLE:
          case PostgreSQLParser::STANDALONE_P:
          case PostgreSQLParser::START:
          case PostgreSQLParser::STATEMENT:
          case PostgreSQLParser::STATISTICS:
          case PostgreSQLParser::STDIN:
          case PostgreSQLParser::STDOUT:
          case PostgreSQLParser::STORAGE:
          case PostgreSQLParser::STRICT_P:
          case PostgreSQLParser::STRIP_P:
          case PostgreSQLParser::SYSID:
          case PostgreSQLParser::SYSTEM_P:
          case PostgreSQLParser::TABLES:
          case PostgreSQLParser::TABLESPACE:
          case PostgreSQLParser::TEMP:
          case PostgreSQLParser::TEMPLATE:
          case PostgreSQLParser::TEMPORARY:
          case PostgreSQLParser::TEXT_P:
          case PostgreSQLParser::TRANSACTION:
          case PostgreSQLParser::TRIGGER:
          case PostgreSQLParser::TRUNCATE:
          case PostgreSQLParser::TRUSTED:
          case PostgreSQLParser::TYPE_P:
          case PostgreSQLParser::TYPES_P:
          case PostgreSQLParser::UNBOUNDED:
          case PostgreSQLParser::UNCOMMITTED:
          case PostgreSQLParser::UNENCRYPTED:
          case PostgreSQLParser::UNKNOWN:
          case PostgreSQLParser::UNLISTEN:
          case PostgreSQLParser::UNLOGGED:
          case PostgreSQLParser::UNTIL:
          case PostgreSQLParser::UPDATE:
          case PostgreSQLParser::VACUUM:
          case PostgreSQLParser::VALID:
          case PostgreSQLParser::VALIDATE:
          case PostgreSQLParser::VALIDATOR:
          case PostgreSQLParser::VERSION_P:
          case PostgreSQLParser::VIEW:
          case PostgreSQLParser::VOLATILE:
          case PostgreSQLParser::WHITESPACE_P:
          case PostgreSQLParser::WORK:
          case PostgreSQLParser::WRAPPER:
          case PostgreSQLParser::WRITE:
          case PostgreSQLParser::XML_P:
          case PostgreSQLParser::YES_P:
          case PostgreSQLParser::ZONE:
          case PostgreSQLParser::BETWEEN:
          case PostgreSQLParser::BIGINT:
          case PostgreSQLParser::BIT:
          case PostgreSQLParser::BOOLEAN_P:
          case PostgreSQLParser::COALESCE:
          case PostgreSQLParser::DEC:
          case PostgreSQLParser::DECIMAL_P:
          case PostgreSQLParser::EXISTS:
          case PostgreSQLParser::EXTRACT:
          case PostgreSQLParser::FLOAT_P:
          case PostgreSQLParser::GREATEST:
          case PostgreSQLParser::INOUT:
          case PostgreSQLParser::INT_P:
          case PostgreSQLParser::INTEGER:
          case PostgreSQLParser::INTERVAL:
          case PostgreSQLParser::LEAST:
          case PostgreSQLParser::NATIONAL:
          case PostgreSQLParser::NCHAR:
          case PostgreSQLParser::NONE:
          case PostgreSQLParser::NULLIF:
          case PostgreSQLParser::NUMERIC:
          case PostgreSQLParser::OVERLAY:
          case PostgreSQLParser::POSITION:
          case PostgreSQLParser::REAL:
          case PostgreSQLParser::ROW:
          case PostgreSQLParser::SETOF:
          case PostgreSQLParser::SMALLINT:
          case PostgreSQLParser::SUBSTRING:
          case PostgreSQLParser::TIME:
          case PostgreSQLParser::TIMESTAMP:
          case PostgreSQLParser::TREAT:
          case PostgreSQLParser::TRIM:
          case PostgreSQLParser::VALUES:
          case PostgreSQLParser::VARCHAR:
          case PostgreSQLParser::XMLATTRIBUTES:
          case PostgreSQLParser::XMLCONCAT:
          case PostgreSQLParser::XMLELEMENT:
          case PostgreSQLParser::XMLEXISTS:
          case PostgreSQLParser::XMLFOREST:
          case PostgreSQLParser::XMLPARSE:
          case PostgreSQLParser::XMLPI:
          case PostgreSQLParser::XMLROOT:
          case PostgreSQLParser::XMLSERIALIZE:
          case PostgreSQLParser::CALL:
          case PostgreSQLParser::CURRENT_P:
          case PostgreSQLParser::ATTACH:
          case PostgreSQLParser::DETACH:
          case PostgreSQLParser::EXPRESSION:
          case PostgreSQLParser::GENERATED:
          case PostgreSQLParser::LOGGED:
          case PostgreSQLParser::STORED:
          case PostgreSQLParser::INCLUDE:
          case PostgreSQLParser::ROUTINE:
          case PostgreSQLParser::TRANSFORM:
          case PostgreSQLParser::IMPORT_P:
          case PostgreSQLParser::POLICY:
          case PostgreSQLParser::METHOD:
          case PostgreSQLParser::REFERENCING:
          case PostgreSQLParser::NEW:
          case PostgreSQLParser::OLD:
          case PostgreSQLParser::VALUE_P:
          case PostgreSQLParser::SUBSCRIPTION:
          case PostgreSQLParser::PUBLICATION:
          case PostgreSQLParser::OUT_P:
          case PostgreSQLParser::END_P:
          case PostgreSQLParser::ROUTINES:
          case PostgreSQLParser::SCHEMAS:
          case PostgreSQLParser::PROCEDURES:
          case PostgreSQLParser::INPUT_P:
          case PostgreSQLParser::SUPPORT:
          case PostgreSQLParser::PARALLEL:
          case PostgreSQLParser::SQL_P:
          case PostgreSQLParser::DEPENDS:
          case PostgreSQLParser::OVERRIDING:
          case PostgreSQLParser::CONFLICT:
          case PostgreSQLParser::SKIP_P:
          case PostgreSQLParser::LOCKED:
          case PostgreSQLParser::TIES:
          case PostgreSQLParser::ROLLUP:
          case PostgreSQLParser::CUBE:
          case PostgreSQLParser::GROUPING:
          case PostgreSQLParser::SETS:
          case PostgreSQLParser::TABLESAMPLE:
          case PostgreSQLParser::ORDINALITY:
          case PostgreSQLParser::XMLTABLE:
          case PostgreSQLParser::COLUMNS:
          case PostgreSQLParser::XMLNAMESPACES:
          case PostgreSQLParser::NORMALIZED:
          case PostgreSQLParser::GROUPS:
          case PostgreSQLParser::OTHERS:
          case PostgreSQLParser::NFC:
          case PostgreSQLParser::NFD:
          case PostgreSQLParser::NFKC:
          case PostgreSQLParser::NFKD:
          case PostgreSQLParser::UESCAPE:
          case PostgreSQLParser::VIEWS:
          case PostgreSQLParser::NORMALIZE:
          case PostgreSQLParser::ERROR:
          case PostgreSQLParser::RETURN:
          case PostgreSQLParser::FORMAT:
          case PostgreSQLParser::Identifier:
          case PostgreSQLParser::QuotedIdentifier:
          case PostgreSQLParser::UnicodeQuotedIdentifier:
          case PostgreSQLParser::PLSQLVARIABLENAME: {
            setState(10281);
            bareColLabel();
            break;
          }

          case PostgreSQLParser::EOF:
          case PostgreSQLParser::CLOSE_PAREN:
          case PostgreSQLParser::COMMA:
          case PostgreSQLParser::SEMI:
          case PostgreSQLParser::FORMAT_LA:
          case PostgreSQLParser::CREATE:
          case PostgreSQLParser::EXCEPT:
          case PostgreSQLParser::FETCH:
          case PostgreSQLParser::FOR:
          case PostgreSQLParser::FROM:
          case PostgreSQLParser::GRANT:
          case PostgreSQLParser::GROUP_P:
          case PostgreSQLParser::HAVING:
          case PostgreSQLParser::INTERSECT:
          case PostgreSQLParser::INTO:
          case PostgreSQLParser::LIMIT:
          case PostgreSQLParser::OFFSET:
          case PostgreSQLParser::ON:
          case PostgreSQLParser::ORDER:
          case PostgreSQLParser::RETURNING:
          case PostgreSQLParser::UNION:
          case PostgreSQLParser::WHERE:
          case PostgreSQLParser::WINDOW:
          case PostgreSQLParser::WITH: {
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case PostgreSQLParser::STAR: {
        _localctx = _tracker.createInstance<PostgreSQLParser::Target_starContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(10285);
        match(PostgreSQLParser::STAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Qualified_name_listContext ------------------------------------------------------------------

PostgreSQLParser::Qualified_name_listContext::Qualified_name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::Qualified_nameContext *> PostgreSQLParser::Qualified_name_listContext::qualified_name() {
  return getRuleContexts<PostgreSQLParser::Qualified_nameContext>();
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::Qualified_name_listContext::qualified_name(size_t i) {
  return getRuleContext<PostgreSQLParser::Qualified_nameContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Qualified_name_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Qualified_name_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Qualified_name_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleQualified_name_list;
}


std::any PostgreSQLParser::Qualified_name_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitQualified_name_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Qualified_name_listContext* PostgreSQLParser::qualified_name_list() {
  Qualified_name_listContext *_localctx = _tracker.createInstance<Qualified_name_listContext>(_ctx, getState());
  enterRule(_localctx, 1378, PostgreSQLParser::RuleQualified_name_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10288);
    qualified_name();
    setState(10293);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(10289);
      match(PostgreSQLParser::COMMA);
      setState(10290);
      qualified_name();
      setState(10295);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Qualified_nameContext ------------------------------------------------------------------

PostgreSQLParser::Qualified_nameContext::Qualified_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Qualified_nameContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

PostgreSQLParser::IndirectionContext* PostgreSQLParser::Qualified_nameContext::indirection() {
  return getRuleContext<PostgreSQLParser::IndirectionContext>(0);
}


size_t PostgreSQLParser::Qualified_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleQualified_name;
}


std::any PostgreSQLParser::Qualified_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitQualified_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Qualified_nameContext* PostgreSQLParser::qualified_name() {
  Qualified_nameContext *_localctx = _tracker.createInstance<Qualified_nameContext>(_ctx, getState());
  enterRule(_localctx, 1380, PostgreSQLParser::RuleQualified_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10296);
    colid();
    setState(10298);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == PostgreSQLParser::OPEN_BRACKET

    || _la == PostgreSQLParser::DOT) {
      setState(10297);
      indirection();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_listContext ------------------------------------------------------------------

PostgreSQLParser::Name_listContext::Name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::NameContext *> PostgreSQLParser::Name_listContext::name() {
  return getRuleContexts<PostgreSQLParser::NameContext>();
}

PostgreSQLParser::NameContext* PostgreSQLParser::Name_listContext::name(size_t i) {
  return getRuleContext<PostgreSQLParser::NameContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Name_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Name_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Name_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleName_list;
}


std::any PostgreSQLParser::Name_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitName_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Name_listContext* PostgreSQLParser::name_list() {
  Name_listContext *_localctx = _tracker.createInstance<Name_listContext>(_ctx, getState());
  enterRule(_localctx, 1382, PostgreSQLParser::RuleName_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10300);
    name();
    setState(10305);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(10301);
      match(PostgreSQLParser::COMMA);
      setState(10302);
      name();
      setState(10307);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameContext ------------------------------------------------------------------

PostgreSQLParser::NameContext::NameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::NameContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}


size_t PostgreSQLParser::NameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleName;
}


std::any PostgreSQLParser::NameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitName(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::NameContext* PostgreSQLParser::name() {
  NameContext *_localctx = _tracker.createInstance<NameContext>(_ctx, getState());
  enterRule(_localctx, 1384, PostgreSQLParser::RuleName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10308);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attr_nameContext ------------------------------------------------------------------

PostgreSQLParser::Attr_nameContext::Attr_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColLabelContext* PostgreSQLParser::Attr_nameContext::colLabel() {
  return getRuleContext<PostgreSQLParser::ColLabelContext>(0);
}


size_t PostgreSQLParser::Attr_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAttr_name;
}


std::any PostgreSQLParser::Attr_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAttr_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Attr_nameContext* PostgreSQLParser::attr_name() {
  Attr_nameContext *_localctx = _tracker.createInstance<Attr_nameContext>(_ctx, getState());
  enterRule(_localctx, 1386, PostgreSQLParser::RuleAttr_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10310);
    colLabel();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_nameContext ------------------------------------------------------------------

PostgreSQLParser::File_nameContext::File_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::SconstContext* PostgreSQLParser::File_nameContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}


size_t PostgreSQLParser::File_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFile_name;
}


std::any PostgreSQLParser::File_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFile_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::File_nameContext* PostgreSQLParser::file_name() {
  File_nameContext *_localctx = _tracker.createInstance<File_nameContext>(_ctx, getState());
  enterRule(_localctx, 1388, PostgreSQLParser::RuleFile_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10312);
    sconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_nameContext ------------------------------------------------------------------

PostgreSQLParser::Func_nameContext::Func_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::Type_function_nameContext* PostgreSQLParser::Func_nameContext::type_function_name() {
  return getRuleContext<PostgreSQLParser::Type_function_nameContext>(0);
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Func_nameContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}

PostgreSQLParser::IndirectionContext* PostgreSQLParser::Func_nameContext::indirection() {
  return getRuleContext<PostgreSQLParser::IndirectionContext>(0);
}


size_t PostgreSQLParser::Func_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFunc_name;
}


std::any PostgreSQLParser::Func_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFunc_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Func_nameContext* PostgreSQLParser::func_name() {
  Func_nameContext *_localctx = _tracker.createInstance<Func_nameContext>(_ctx, getState());
  enterRule(_localctx, 1390, PostgreSQLParser::RuleFunc_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10318);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1031, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(10314);
      type_function_name();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(10315);
      colid();
      setState(10316);
      indirection();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AexprconstContext ------------------------------------------------------------------

PostgreSQLParser::AexprconstContext::AexprconstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::IconstContext* PostgreSQLParser::AexprconstContext::iconst() {
  return getRuleContext<PostgreSQLParser::IconstContext>(0);
}

PostgreSQLParser::FconstContext* PostgreSQLParser::AexprconstContext::fconst() {
  return getRuleContext<PostgreSQLParser::FconstContext>(0);
}

PostgreSQLParser::SconstContext* PostgreSQLParser::AexprconstContext::sconst() {
  return getRuleContext<PostgreSQLParser::SconstContext>(0);
}

PostgreSQLParser::BconstContext* PostgreSQLParser::AexprconstContext::bconst() {
  return getRuleContext<PostgreSQLParser::BconstContext>(0);
}

PostgreSQLParser::XconstContext* PostgreSQLParser::AexprconstContext::xconst() {
  return getRuleContext<PostgreSQLParser::XconstContext>(0);
}

PostgreSQLParser::Func_nameContext* PostgreSQLParser::AexprconstContext::func_name() {
  return getRuleContext<PostgreSQLParser::Func_nameContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AexprconstContext::OPEN_PAREN() {
  return getToken(PostgreSQLParser::OPEN_PAREN, 0);
}

PostgreSQLParser::Func_arg_listContext* PostgreSQLParser::AexprconstContext::func_arg_list() {
  return getRuleContext<PostgreSQLParser::Func_arg_listContext>(0);
}

tree::TerminalNode* PostgreSQLParser::AexprconstContext::CLOSE_PAREN() {
  return getToken(PostgreSQLParser::CLOSE_PAREN, 0);
}

PostgreSQLParser::Sort_clause_Context* PostgreSQLParser::AexprconstContext::sort_clause_() {
  return getRuleContext<PostgreSQLParser::Sort_clause_Context>(0);
}

PostgreSQLParser::ConsttypenameContext* PostgreSQLParser::AexprconstContext::consttypename() {
  return getRuleContext<PostgreSQLParser::ConsttypenameContext>(0);
}

PostgreSQLParser::ConstintervalContext* PostgreSQLParser::AexprconstContext::constinterval() {
  return getRuleContext<PostgreSQLParser::ConstintervalContext>(0);
}

PostgreSQLParser::Interval_Context* PostgreSQLParser::AexprconstContext::interval_() {
  return getRuleContext<PostgreSQLParser::Interval_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::AexprconstContext::TRUE_P() {
  return getToken(PostgreSQLParser::TRUE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AexprconstContext::FALSE_P() {
  return getToken(PostgreSQLParser::FALSE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::AexprconstContext::NULL_P() {
  return getToken(PostgreSQLParser::NULL_P, 0);
}


size_t PostgreSQLParser::AexprconstContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAexprconst;
}


std::any PostgreSQLParser::AexprconstContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAexprconst(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AexprconstContext* PostgreSQLParser::aexprconst() {
  AexprconstContext *_localctx = _tracker.createInstance<AexprconstContext>(_ctx, getState());
  enterRule(_localctx, 1392, PostgreSQLParser::RuleAexprconst);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10355);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1036, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(10320);
      iconst();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(10321);
      fconst();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(10322);
      sconst();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(10323);
      bconst();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(10324);
      xconst();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(10325);
      func_name();
      setState(10335);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case PostgreSQLParser::StringConstant:
        case PostgreSQLParser::UnicodeEscapeStringConstant:
        case PostgreSQLParser::BeginDollarStringConstant:
        case PostgreSQLParser::EscapeStringConstant: {
          setState(10326);
          sconst();
          break;
        }

        case PostgreSQLParser::OPEN_PAREN: {
          setState(10327);
          match(PostgreSQLParser::OPEN_PAREN);
          setState(10328);
          func_arg_list();
          setState(10330);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == PostgreSQLParser::ORDER) {
            setState(10329);
            sort_clause_();
          }
          setState(10332);
          match(PostgreSQLParser::CLOSE_PAREN);
          setState(10333);
          sconst();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(10337);
      consttypename();
      setState(10338);
      sconst();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(10340);
      constinterval();
      setState(10350);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case PostgreSQLParser::StringConstant:
        case PostgreSQLParser::UnicodeEscapeStringConstant:
        case PostgreSQLParser::BeginDollarStringConstant:
        case PostgreSQLParser::EscapeStringConstant: {
          setState(10341);
          sconst();
          setState(10343);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1034, _ctx)) {
          case 1: {
            setState(10342);
            interval_();
            break;
          }

          default:
            break;
          }
          break;
        }

        case PostgreSQLParser::OPEN_PAREN: {
          setState(10345);
          match(PostgreSQLParser::OPEN_PAREN);
          setState(10346);
          iconst();
          setState(10347);
          match(PostgreSQLParser::CLOSE_PAREN);
          setState(10348);
          sconst();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(10352);
      match(PostgreSQLParser::TRUE_P);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(10353);
      match(PostgreSQLParser::FALSE_P);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(10354);
      match(PostgreSQLParser::NULL_P);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XconstContext ------------------------------------------------------------------

PostgreSQLParser::XconstContext::XconstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::XconstContext::HexadecimalStringConstant() {
  return getToken(PostgreSQLParser::HexadecimalStringConstant, 0);
}


size_t PostgreSQLParser::XconstContext::getRuleIndex() const {
  return PostgreSQLParser::RuleXconst;
}


std::any PostgreSQLParser::XconstContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitXconst(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::XconstContext* PostgreSQLParser::xconst() {
  XconstContext *_localctx = _tracker.createInstance<XconstContext>(_ctx, getState());
  enterRule(_localctx, 1394, PostgreSQLParser::RuleXconst);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10357);
    match(PostgreSQLParser::HexadecimalStringConstant);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BconstContext ------------------------------------------------------------------

PostgreSQLParser::BconstContext::BconstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::BconstContext::BinaryStringConstant() {
  return getToken(PostgreSQLParser::BinaryStringConstant, 0);
}


size_t PostgreSQLParser::BconstContext::getRuleIndex() const {
  return PostgreSQLParser::RuleBconst;
}


std::any PostgreSQLParser::BconstContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitBconst(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::BconstContext* PostgreSQLParser::bconst() {
  BconstContext *_localctx = _tracker.createInstance<BconstContext>(_ctx, getState());
  enterRule(_localctx, 1396, PostgreSQLParser::RuleBconst);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10359);
    match(PostgreSQLParser::BinaryStringConstant);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FconstContext ------------------------------------------------------------------

PostgreSQLParser::FconstContext::FconstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::FconstContext::Numeric() {
  return getToken(PostgreSQLParser::Numeric, 0);
}


size_t PostgreSQLParser::FconstContext::getRuleIndex() const {
  return PostgreSQLParser::RuleFconst;
}


std::any PostgreSQLParser::FconstContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitFconst(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::FconstContext* PostgreSQLParser::fconst() {
  FconstContext *_localctx = _tracker.createInstance<FconstContext>(_ctx, getState());
  enterRule(_localctx, 1398, PostgreSQLParser::RuleFconst);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10361);
    match(PostgreSQLParser::Numeric);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IconstContext ------------------------------------------------------------------

PostgreSQLParser::IconstContext::IconstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::IconstContext::Integral() {
  return getToken(PostgreSQLParser::Integral, 0);
}

tree::TerminalNode* PostgreSQLParser::IconstContext::BinaryIntegral() {
  return getToken(PostgreSQLParser::BinaryIntegral, 0);
}

tree::TerminalNode* PostgreSQLParser::IconstContext::OctalIntegral() {
  return getToken(PostgreSQLParser::OctalIntegral, 0);
}

tree::TerminalNode* PostgreSQLParser::IconstContext::HexadecimalIntegral() {
  return getToken(PostgreSQLParser::HexadecimalIntegral, 0);
}


size_t PostgreSQLParser::IconstContext::getRuleIndex() const {
  return PostgreSQLParser::RuleIconst;
}


std::any PostgreSQLParser::IconstContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitIconst(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::IconstContext* PostgreSQLParser::iconst() {
  IconstContext *_localctx = _tracker.createInstance<IconstContext>(_ctx, getState());
  enterRule(_localctx, 1400, PostgreSQLParser::RuleIconst);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10363);
    _la = _input->LA(1);
    if (!(((((_la - 576) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 576)) & 15) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SconstContext ------------------------------------------------------------------

PostgreSQLParser::SconstContext::SconstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::AnysconstContext* PostgreSQLParser::SconstContext::anysconst() {
  return getRuleContext<PostgreSQLParser::AnysconstContext>(0);
}

PostgreSQLParser::Uescape_Context* PostgreSQLParser::SconstContext::uescape_() {
  return getRuleContext<PostgreSQLParser::Uescape_Context>(0);
}


size_t PostgreSQLParser::SconstContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSconst;
}


std::any PostgreSQLParser::SconstContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSconst(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::SconstContext* PostgreSQLParser::sconst() {
  SconstContext *_localctx = _tracker.createInstance<SconstContext>(_ctx, getState());
  enterRule(_localctx, 1402, PostgreSQLParser::RuleSconst);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10365);
    anysconst();
    setState(10367);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1037, _ctx)) {
    case 1: {
      setState(10366);
      uescape_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnysconstContext ------------------------------------------------------------------

PostgreSQLParser::AnysconstContext::AnysconstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::AnysconstContext::StringConstant() {
  return getToken(PostgreSQLParser::StringConstant, 0);
}

tree::TerminalNode* PostgreSQLParser::AnysconstContext::UnicodeEscapeStringConstant() {
  return getToken(PostgreSQLParser::UnicodeEscapeStringConstant, 0);
}

tree::TerminalNode* PostgreSQLParser::AnysconstContext::BeginDollarStringConstant() {
  return getToken(PostgreSQLParser::BeginDollarStringConstant, 0);
}

tree::TerminalNode* PostgreSQLParser::AnysconstContext::EndDollarStringConstant() {
  return getToken(PostgreSQLParser::EndDollarStringConstant, 0);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::AnysconstContext::DollarText() {
  return getTokens(PostgreSQLParser::DollarText);
}

tree::TerminalNode* PostgreSQLParser::AnysconstContext::DollarText(size_t i) {
  return getToken(PostgreSQLParser::DollarText, i);
}

tree::TerminalNode* PostgreSQLParser::AnysconstContext::EscapeStringConstant() {
  return getToken(PostgreSQLParser::EscapeStringConstant, 0);
}


size_t PostgreSQLParser::AnysconstContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAnysconst;
}


std::any PostgreSQLParser::AnysconstContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAnysconst(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::AnysconstContext* PostgreSQLParser::anysconst() {
  AnysconstContext *_localctx = _tracker.createInstance<AnysconstContext>(_ctx, getState());
  enterRule(_localctx, 1404, PostgreSQLParser::RuleAnysconst);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10380);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::StringConstant: {
        enterOuterAlt(_localctx, 1);
        setState(10369);
        match(PostgreSQLParser::StringConstant);
        break;
      }

      case PostgreSQLParser::UnicodeEscapeStringConstant: {
        enterOuterAlt(_localctx, 2);
        setState(10370);
        match(PostgreSQLParser::UnicodeEscapeStringConstant);
        break;
      }

      case PostgreSQLParser::BeginDollarStringConstant: {
        enterOuterAlt(_localctx, 3);
        setState(10371);
        match(PostgreSQLParser::BeginDollarStringConstant);
        setState(10375);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == PostgreSQLParser::DollarText) {
          setState(10372);
          match(PostgreSQLParser::DollarText);
          setState(10377);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(10378);
        match(PostgreSQLParser::EndDollarStringConstant);
        break;
      }

      case PostgreSQLParser::EscapeStringConstant: {
        enterOuterAlt(_localctx, 4);
        setState(10379);
        match(PostgreSQLParser::EscapeStringConstant);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Uescape_Context ------------------------------------------------------------------

PostgreSQLParser::Uescape_Context::Uescape_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Uescape_Context::UESCAPE() {
  return getToken(PostgreSQLParser::UESCAPE, 0);
}

PostgreSQLParser::AnysconstContext* PostgreSQLParser::Uescape_Context::anysconst() {
  return getRuleContext<PostgreSQLParser::AnysconstContext>(0);
}


size_t PostgreSQLParser::Uescape_Context::getRuleIndex() const {
  return PostgreSQLParser::RuleUescape_;
}


std::any PostgreSQLParser::Uescape_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitUescape_(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Uescape_Context* PostgreSQLParser::uescape_() {
  Uescape_Context *_localctx = _tracker.createInstance<Uescape_Context>(_ctx, getState());
  enterRule(_localctx, 1406, PostgreSQLParser::RuleUescape_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10382);
    match(PostgreSQLParser::UESCAPE);
    setState(10383);
    anysconst();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignediconstContext ------------------------------------------------------------------

PostgreSQLParser::SignediconstContext::SignediconstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::IconstContext* PostgreSQLParser::SignediconstContext::iconst() {
  return getRuleContext<PostgreSQLParser::IconstContext>(0);
}

tree::TerminalNode* PostgreSQLParser::SignediconstContext::PLUS() {
  return getToken(PostgreSQLParser::PLUS, 0);
}

tree::TerminalNode* PostgreSQLParser::SignediconstContext::MINUS() {
  return getToken(PostgreSQLParser::MINUS, 0);
}


size_t PostgreSQLParser::SignediconstContext::getRuleIndex() const {
  return PostgreSQLParser::RuleSignediconst;
}


std::any PostgreSQLParser::SignediconstContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitSignediconst(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::SignediconstContext* PostgreSQLParser::signediconst() {
  SignediconstContext *_localctx = _tracker.createInstance<SignediconstContext>(_ctx, getState());
  enterRule(_localctx, 1408, PostgreSQLParser::RuleSignediconst);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10390);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::Integral:
      case PostgreSQLParser::BinaryIntegral:
      case PostgreSQLParser::OctalIntegral:
      case PostgreSQLParser::HexadecimalIntegral: {
        enterOuterAlt(_localctx, 1);
        setState(10385);
        iconst();
        break;
      }

      case PostgreSQLParser::PLUS: {
        enterOuterAlt(_localctx, 2);
        setState(10386);
        match(PostgreSQLParser::PLUS);
        setState(10387);
        iconst();
        break;
      }

      case PostgreSQLParser::MINUS: {
        enterOuterAlt(_localctx, 3);
        setState(10388);
        match(PostgreSQLParser::MINUS);
        setState(10389);
        iconst();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleidContext ------------------------------------------------------------------

PostgreSQLParser::RoleidContext::RoleidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::RolespecContext* PostgreSQLParser::RoleidContext::rolespec() {
  return getRuleContext<PostgreSQLParser::RolespecContext>(0);
}


size_t PostgreSQLParser::RoleidContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRoleid;
}


std::any PostgreSQLParser::RoleidContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRoleid(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RoleidContext* PostgreSQLParser::roleid() {
  RoleidContext *_localctx = _tracker.createInstance<RoleidContext>(_ctx, getState());
  enterRule(_localctx, 1410, PostgreSQLParser::RuleRoleid);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10392);
    rolespec();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RolespecContext ------------------------------------------------------------------

PostgreSQLParser::RolespecContext::RolespecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::NonreservedwordContext* PostgreSQLParser::RolespecContext::nonreservedword() {
  return getRuleContext<PostgreSQLParser::NonreservedwordContext>(0);
}

tree::TerminalNode* PostgreSQLParser::RolespecContext::CURRENT_USER() {
  return getToken(PostgreSQLParser::CURRENT_USER, 0);
}

tree::TerminalNode* PostgreSQLParser::RolespecContext::SESSION_USER() {
  return getToken(PostgreSQLParser::SESSION_USER, 0);
}


size_t PostgreSQLParser::RolespecContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRolespec;
}


std::any PostgreSQLParser::RolespecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRolespec(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::RolespecContext* PostgreSQLParser::rolespec() {
  RolespecContext *_localctx = _tracker.createInstance<RolespecContext>(_ctx, getState());
  enterRule(_localctx, 1412, PostgreSQLParser::RuleRolespec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10397);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT:
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 1);
        setState(10394);
        nonreservedword();
        break;
      }

      case PostgreSQLParser::CURRENT_USER: {
        enterOuterAlt(_localctx, 2);
        setState(10395);
        match(PostgreSQLParser::CURRENT_USER);
        break;
      }

      case PostgreSQLParser::SESSION_USER: {
        enterOuterAlt(_localctx, 3);
        setState(10396);
        match(PostgreSQLParser::SESSION_USER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Role_listContext ------------------------------------------------------------------

PostgreSQLParser::Role_listContext::Role_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<PostgreSQLParser::RolespecContext *> PostgreSQLParser::Role_listContext::rolespec() {
  return getRuleContexts<PostgreSQLParser::RolespecContext>();
}

PostgreSQLParser::RolespecContext* PostgreSQLParser::Role_listContext::rolespec(size_t i) {
  return getRuleContext<PostgreSQLParser::RolespecContext>(i);
}

std::vector<tree::TerminalNode *> PostgreSQLParser::Role_listContext::COMMA() {
  return getTokens(PostgreSQLParser::COMMA);
}

tree::TerminalNode* PostgreSQLParser::Role_listContext::COMMA(size_t i) {
  return getToken(PostgreSQLParser::COMMA, i);
}


size_t PostgreSQLParser::Role_listContext::getRuleIndex() const {
  return PostgreSQLParser::RuleRole_list;
}


std::any PostgreSQLParser::Role_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitRole_list(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Role_listContext* PostgreSQLParser::role_list() {
  Role_listContext *_localctx = _tracker.createInstance<Role_listContext>(_ctx, getState());
  enterRule(_localctx, 1414, PostgreSQLParser::RuleRole_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10399);
    rolespec();
    setState(10404);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == PostgreSQLParser::COMMA) {
      setState(10400);
      match(PostgreSQLParser::COMMA);
      setState(10401);
      rolespec();
      setState(10406);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColidContext ------------------------------------------------------------------

PostgreSQLParser::ColidContext::ColidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::IdentifierContext* PostgreSQLParser::ColidContext::identifier() {
  return getRuleContext<PostgreSQLParser::IdentifierContext>(0);
}

PostgreSQLParser::Unreserved_keywordContext* PostgreSQLParser::ColidContext::unreserved_keyword() {
  return getRuleContext<PostgreSQLParser::Unreserved_keywordContext>(0);
}

PostgreSQLParser::Col_name_keywordContext* PostgreSQLParser::ColidContext::col_name_keyword() {
  return getRuleContext<PostgreSQLParser::Col_name_keywordContext>(0);
}


size_t PostgreSQLParser::ColidContext::getRuleIndex() const {
  return PostgreSQLParser::RuleColid;
}


std::any PostgreSQLParser::ColidContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitColid(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ColidContext* PostgreSQLParser::colid() {
  ColidContext *_localctx = _tracker.createInstance<ColidContext>(_ctx, getState());
  enterRule(_localctx, 1416, PostgreSQLParser::RuleColid);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10410);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 1);
        setState(10407);
        identifier();
        break;
      }

      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT: {
        enterOuterAlt(_localctx, 2);
        setState(10408);
        unreserved_keyword();
        break;
      }

      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZE: {
        enterOuterAlt(_localctx, 3);
        setState(10409);
        col_name_keyword();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_function_nameContext ------------------------------------------------------------------

PostgreSQLParser::Type_function_nameContext::Type_function_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::IdentifierContext* PostgreSQLParser::Type_function_nameContext::identifier() {
  return getRuleContext<PostgreSQLParser::IdentifierContext>(0);
}

PostgreSQLParser::Unreserved_keywordContext* PostgreSQLParser::Type_function_nameContext::unreserved_keyword() {
  return getRuleContext<PostgreSQLParser::Unreserved_keywordContext>(0);
}

PostgreSQLParser::Type_func_name_keywordContext* PostgreSQLParser::Type_function_nameContext::type_func_name_keyword() {
  return getRuleContext<PostgreSQLParser::Type_func_name_keywordContext>(0);
}


size_t PostgreSQLParser::Type_function_nameContext::getRuleIndex() const {
  return PostgreSQLParser::RuleType_function_name;
}


std::any PostgreSQLParser::Type_function_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitType_function_name(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Type_function_nameContext* PostgreSQLParser::type_function_name() {
  Type_function_nameContext *_localctx = _tracker.createInstance<Type_function_nameContext>(_ctx, getState());
  enterRule(_localctx, 1418, PostgreSQLParser::RuleType_function_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10415);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 1);
        setState(10412);
        identifier();
        break;
      }

      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT: {
        enterOuterAlt(_localctx, 2);
        setState(10413);
        unreserved_keyword();
        break;
      }

      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::TABLESAMPLE: {
        enterOuterAlt(_localctx, 3);
        setState(10414);
        type_func_name_keyword();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NonreservedwordContext ------------------------------------------------------------------

PostgreSQLParser::NonreservedwordContext::NonreservedwordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::IdentifierContext* PostgreSQLParser::NonreservedwordContext::identifier() {
  return getRuleContext<PostgreSQLParser::IdentifierContext>(0);
}

PostgreSQLParser::Unreserved_keywordContext* PostgreSQLParser::NonreservedwordContext::unreserved_keyword() {
  return getRuleContext<PostgreSQLParser::Unreserved_keywordContext>(0);
}

PostgreSQLParser::Col_name_keywordContext* PostgreSQLParser::NonreservedwordContext::col_name_keyword() {
  return getRuleContext<PostgreSQLParser::Col_name_keywordContext>(0);
}

PostgreSQLParser::Type_func_name_keywordContext* PostgreSQLParser::NonreservedwordContext::type_func_name_keyword() {
  return getRuleContext<PostgreSQLParser::Type_func_name_keywordContext>(0);
}


size_t PostgreSQLParser::NonreservedwordContext::getRuleIndex() const {
  return PostgreSQLParser::RuleNonreservedword;
}


std::any PostgreSQLParser::NonreservedwordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitNonreservedword(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::NonreservedwordContext* PostgreSQLParser::nonreservedword() {
  NonreservedwordContext *_localctx = _tracker.createInstance<NonreservedwordContext>(_ctx, getState());
  enterRule(_localctx, 1420, PostgreSQLParser::RuleNonreservedword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10421);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 1);
        setState(10417);
        identifier();
        break;
      }

      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT: {
        enterOuterAlt(_localctx, 2);
        setState(10418);
        unreserved_keyword();
        break;
      }

      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZE: {
        enterOuterAlt(_localctx, 3);
        setState(10419);
        col_name_keyword();
        break;
      }

      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::TABLESAMPLE: {
        enterOuterAlt(_localctx, 4);
        setState(10420);
        type_func_name_keyword();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColLabelContext ------------------------------------------------------------------

PostgreSQLParser::ColLabelContext::ColLabelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::IdentifierContext* PostgreSQLParser::ColLabelContext::identifier() {
  return getRuleContext<PostgreSQLParser::IdentifierContext>(0);
}

PostgreSQLParser::Unreserved_keywordContext* PostgreSQLParser::ColLabelContext::unreserved_keyword() {
  return getRuleContext<PostgreSQLParser::Unreserved_keywordContext>(0);
}

PostgreSQLParser::Col_name_keywordContext* PostgreSQLParser::ColLabelContext::col_name_keyword() {
  return getRuleContext<PostgreSQLParser::Col_name_keywordContext>(0);
}

PostgreSQLParser::Type_func_name_keywordContext* PostgreSQLParser::ColLabelContext::type_func_name_keyword() {
  return getRuleContext<PostgreSQLParser::Type_func_name_keywordContext>(0);
}

PostgreSQLParser::Reserved_keywordContext* PostgreSQLParser::ColLabelContext::reserved_keyword() {
  return getRuleContext<PostgreSQLParser::Reserved_keywordContext>(0);
}

tree::TerminalNode* PostgreSQLParser::ColLabelContext::EXIT() {
  return getToken(PostgreSQLParser::EXIT, 0);
}


size_t PostgreSQLParser::ColLabelContext::getRuleIndex() const {
  return PostgreSQLParser::RuleColLabel;
}


std::any PostgreSQLParser::ColLabelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitColLabel(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::ColLabelContext* PostgreSQLParser::colLabel() {
  ColLabelContext *_localctx = _tracker.createInstance<ColLabelContext>(_ctx, getState());
  enterRule(_localctx, 1422, PostgreSQLParser::RuleColLabel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10429);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 1);
        setState(10423);
        identifier();
        break;
      }

      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::OVER:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DAY_P:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::HOUR_P:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINUTE_P:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MONTH_P:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECOND_P:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VARYING:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WITHOUT:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YEAR_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::WITHIN:
      case PostgreSQLParser::FILTER:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT: {
        enterOuterAlt(_localctx, 2);
        setState(10424);
        unreserved_keyword();
        break;
      }

      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::CHAR_P:
      case PostgreSQLParser::CHARACTER:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::PRECISION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZE: {
        enterOuterAlt(_localctx, 3);
        setState(10425);
        col_name_keyword();
        break;
      }

      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::ISNULL:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::NOTNULL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::OVERLAPS:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::TABLESAMPLE: {
        enterOuterAlt(_localctx, 4);
        setState(10426);
        type_func_name_keyword();
        break;
      }

      case PostgreSQLParser::SYSTEM_USER:
      case PostgreSQLParser::ALL:
      case PostgreSQLParser::ANALYSE:
      case PostgreSQLParser::ANALYZE:
      case PostgreSQLParser::AND:
      case PostgreSQLParser::ANY:
      case PostgreSQLParser::ARRAY:
      case PostgreSQLParser::AS:
      case PostgreSQLParser::ASC:
      case PostgreSQLParser::ASYMMETRIC:
      case PostgreSQLParser::BOTH:
      case PostgreSQLParser::CASE:
      case PostgreSQLParser::CAST:
      case PostgreSQLParser::CHECK:
      case PostgreSQLParser::COLLATE:
      case PostgreSQLParser::COLUMN:
      case PostgreSQLParser::CONSTRAINT:
      case PostgreSQLParser::CREATE:
      case PostgreSQLParser::CURRENT_CATALOG:
      case PostgreSQLParser::CURRENT_DATE:
      case PostgreSQLParser::CURRENT_ROLE:
      case PostgreSQLParser::CURRENT_TIME:
      case PostgreSQLParser::CURRENT_TIMESTAMP:
      case PostgreSQLParser::CURRENT_USER:
      case PostgreSQLParser::DEFAULT:
      case PostgreSQLParser::DEFERRABLE:
      case PostgreSQLParser::DESC:
      case PostgreSQLParser::DISTINCT:
      case PostgreSQLParser::DO:
      case PostgreSQLParser::ELSE:
      case PostgreSQLParser::EXCEPT:
      case PostgreSQLParser::FALSE_P:
      case PostgreSQLParser::FETCH:
      case PostgreSQLParser::FOR:
      case PostgreSQLParser::FOREIGN:
      case PostgreSQLParser::FROM:
      case PostgreSQLParser::GRANT:
      case PostgreSQLParser::GROUP_P:
      case PostgreSQLParser::HAVING:
      case PostgreSQLParser::IN_P:
      case PostgreSQLParser::INITIALLY:
      case PostgreSQLParser::INTERSECT:
      case PostgreSQLParser::INTO:
      case PostgreSQLParser::LATERAL_P:
      case PostgreSQLParser::LEADING:
      case PostgreSQLParser::LIMIT:
      case PostgreSQLParser::LOCALTIME:
      case PostgreSQLParser::LOCALTIMESTAMP:
      case PostgreSQLParser::NOT:
      case PostgreSQLParser::NULL_P:
      case PostgreSQLParser::OFFSET:
      case PostgreSQLParser::ON:
      case PostgreSQLParser::ONLY:
      case PostgreSQLParser::OR:
      case PostgreSQLParser::ORDER:
      case PostgreSQLParser::PLACING:
      case PostgreSQLParser::PRIMARY:
      case PostgreSQLParser::REFERENCES:
      case PostgreSQLParser::RETURNING:
      case PostgreSQLParser::SELECT:
      case PostgreSQLParser::SESSION_USER:
      case PostgreSQLParser::SOME:
      case PostgreSQLParser::SYMMETRIC:
      case PostgreSQLParser::TABLE:
      case PostgreSQLParser::THEN:
      case PostgreSQLParser::TO:
      case PostgreSQLParser::TRAILING:
      case PostgreSQLParser::TRUE_P:
      case PostgreSQLParser::UNION:
      case PostgreSQLParser::UNIQUE:
      case PostgreSQLParser::USER:
      case PostgreSQLParser::USING:
      case PostgreSQLParser::VARIADIC:
      case PostgreSQLParser::WHEN:
      case PostgreSQLParser::WHERE:
      case PostgreSQLParser::WINDOW:
      case PostgreSQLParser::WITH:
      case PostgreSQLParser::END_P: {
        enterOuterAlt(_localctx, 5);
        setState(10427);
        reserved_keyword();
        break;
      }

      case PostgreSQLParser::EXIT: {
        enterOuterAlt(_localctx, 6);
        setState(10428);
        match(PostgreSQLParser::EXIT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BareColLabelContext ------------------------------------------------------------------

PostgreSQLParser::BareColLabelContext::BareColLabelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::IdentifierContext* PostgreSQLParser::BareColLabelContext::identifier() {
  return getRuleContext<PostgreSQLParser::IdentifierContext>(0);
}

PostgreSQLParser::Bare_label_keywordContext* PostgreSQLParser::BareColLabelContext::bare_label_keyword() {
  return getRuleContext<PostgreSQLParser::Bare_label_keywordContext>(0);
}


size_t PostgreSQLParser::BareColLabelContext::getRuleIndex() const {
  return PostgreSQLParser::RuleBareColLabel;
}


std::any PostgreSQLParser::BareColLabelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitBareColLabel(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::BareColLabelContext* PostgreSQLParser::bareColLabel() {
  BareColLabelContext *_localctx = _tracker.createInstance<BareColLabelContext>(_ctx, getState());
  enterRule(_localctx, 1424, PostgreSQLParser::RuleBareColLabel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10433);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::Identifier:
      case PostgreSQLParser::QuotedIdentifier:
      case PostgreSQLParser::UnicodeQuotedIdentifier:
      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 1);
        setState(10431);
        identifier();
        break;
      }

      case PostgreSQLParser::JSON:
      case PostgreSQLParser::JSON_ARRAY:
      case PostgreSQLParser::JSON_ARRAYAGG:
      case PostgreSQLParser::JSON_EXISTS:
      case PostgreSQLParser::JSON_OBJECT:
      case PostgreSQLParser::JSON_OBJECTAGG:
      case PostgreSQLParser::JSON_QUERY:
      case PostgreSQLParser::JSON_SCALAR:
      case PostgreSQLParser::JSON_SERIALIZE:
      case PostgreSQLParser::JSON_TABLE:
      case PostgreSQLParser::JSON_VALUE:
      case PostgreSQLParser::MERGE_ACTION:
      case PostgreSQLParser::SYSTEM_USER:
      case PostgreSQLParser::ABSENT:
      case PostgreSQLParser::ASENSITIVE:
      case PostgreSQLParser::ATOMIC:
      case PostgreSQLParser::BREADTH:
      case PostgreSQLParser::COMPRESSION:
      case PostgreSQLParser::CONDITIONAL:
      case PostgreSQLParser::DEPTH:
      case PostgreSQLParser::EMPTY_P:
      case PostgreSQLParser::FINALIZE:
      case PostgreSQLParser::INDENT:
      case PostgreSQLParser::KEEP:
      case PostgreSQLParser::KEYS:
      case PostgreSQLParser::NESTED:
      case PostgreSQLParser::OMIT:
      case PostgreSQLParser::PARAMETER:
      case PostgreSQLParser::PATH:
      case PostgreSQLParser::PLAN:
      case PostgreSQLParser::QUOTES:
      case PostgreSQLParser::SCALAR:
      case PostgreSQLParser::SOURCE:
      case PostgreSQLParser::STRING_P:
      case PostgreSQLParser::TARGET:
      case PostgreSQLParser::UNCONDITIONAL:
      case PostgreSQLParser::PERIOD:
      case PostgreSQLParser::ALL:
      case PostgreSQLParser::ANALYSE:
      case PostgreSQLParser::ANALYZE:
      case PostgreSQLParser::AND:
      case PostgreSQLParser::ANY:
      case PostgreSQLParser::ASC:
      case PostgreSQLParser::ASYMMETRIC:
      case PostgreSQLParser::BOTH:
      case PostgreSQLParser::CASE:
      case PostgreSQLParser::CAST:
      case PostgreSQLParser::CHECK:
      case PostgreSQLParser::COLLATE:
      case PostgreSQLParser::COLUMN:
      case PostgreSQLParser::CONSTRAINT:
      case PostgreSQLParser::CURRENT_CATALOG:
      case PostgreSQLParser::CURRENT_DATE:
      case PostgreSQLParser::CURRENT_ROLE:
      case PostgreSQLParser::CURRENT_TIME:
      case PostgreSQLParser::CURRENT_TIMESTAMP:
      case PostgreSQLParser::CURRENT_USER:
      case PostgreSQLParser::DEFAULT:
      case PostgreSQLParser::DEFERRABLE:
      case PostgreSQLParser::DESC:
      case PostgreSQLParser::DISTINCT:
      case PostgreSQLParser::DO:
      case PostgreSQLParser::ELSE:
      case PostgreSQLParser::FALSE_P:
      case PostgreSQLParser::FOREIGN:
      case PostgreSQLParser::IN_P:
      case PostgreSQLParser::INITIALLY:
      case PostgreSQLParser::LATERAL_P:
      case PostgreSQLParser::LEADING:
      case PostgreSQLParser::LOCALTIME:
      case PostgreSQLParser::LOCALTIMESTAMP:
      case PostgreSQLParser::NOT:
      case PostgreSQLParser::NULL_P:
      case PostgreSQLParser::ONLY:
      case PostgreSQLParser::OR:
      case PostgreSQLParser::PLACING:
      case PostgreSQLParser::PRIMARY:
      case PostgreSQLParser::REFERENCES:
      case PostgreSQLParser::SELECT:
      case PostgreSQLParser::SESSION_USER:
      case PostgreSQLParser::SOME:
      case PostgreSQLParser::SYMMETRIC:
      case PostgreSQLParser::TABLE:
      case PostgreSQLParser::THEN:
      case PostgreSQLParser::TRAILING:
      case PostgreSQLParser::TRUE_P:
      case PostgreSQLParser::UNIQUE:
      case PostgreSQLParser::USER:
      case PostgreSQLParser::USING:
      case PostgreSQLParser::VARIADIC:
      case PostgreSQLParser::WHEN:
      case PostgreSQLParser::AUTHORIZATION:
      case PostgreSQLParser::BINARY:
      case PostgreSQLParser::COLLATION:
      case PostgreSQLParser::CONCURRENTLY:
      case PostgreSQLParser::CROSS:
      case PostgreSQLParser::CURRENT_SCHEMA:
      case PostgreSQLParser::FREEZE:
      case PostgreSQLParser::FULL:
      case PostgreSQLParser::ILIKE:
      case PostgreSQLParser::INNER_P:
      case PostgreSQLParser::IS:
      case PostgreSQLParser::JOIN:
      case PostgreSQLParser::LEFT:
      case PostgreSQLParser::LIKE:
      case PostgreSQLParser::NATURAL:
      case PostgreSQLParser::OUTER_P:
      case PostgreSQLParser::RIGHT:
      case PostgreSQLParser::SIMILAR:
      case PostgreSQLParser::VERBOSE:
      case PostgreSQLParser::ABORT_P:
      case PostgreSQLParser::ABSOLUTE_P:
      case PostgreSQLParser::ACCESS:
      case PostgreSQLParser::ACTION:
      case PostgreSQLParser::ADD_P:
      case PostgreSQLParser::ADMIN:
      case PostgreSQLParser::AFTER:
      case PostgreSQLParser::AGGREGATE:
      case PostgreSQLParser::ALSO:
      case PostgreSQLParser::ALTER:
      case PostgreSQLParser::ALWAYS:
      case PostgreSQLParser::ASSERTION:
      case PostgreSQLParser::ASSIGNMENT:
      case PostgreSQLParser::AT:
      case PostgreSQLParser::ATTRIBUTE:
      case PostgreSQLParser::BACKWARD:
      case PostgreSQLParser::BEFORE:
      case PostgreSQLParser::BEGIN_P:
      case PostgreSQLParser::BY:
      case PostgreSQLParser::CACHE:
      case PostgreSQLParser::CALLED:
      case PostgreSQLParser::CASCADE:
      case PostgreSQLParser::CASCADED:
      case PostgreSQLParser::CATALOG:
      case PostgreSQLParser::CHAIN:
      case PostgreSQLParser::CHARACTERISTICS:
      case PostgreSQLParser::CHECKPOINT:
      case PostgreSQLParser::CLASS:
      case PostgreSQLParser::CLOSE:
      case PostgreSQLParser::CLUSTER:
      case PostgreSQLParser::COMMENT:
      case PostgreSQLParser::COMMENTS:
      case PostgreSQLParser::COMMIT:
      case PostgreSQLParser::COMMITTED:
      case PostgreSQLParser::CONFIGURATION:
      case PostgreSQLParser::CONNECTION:
      case PostgreSQLParser::CONSTRAINTS:
      case PostgreSQLParser::CONTENT_P:
      case PostgreSQLParser::CONTINUE_P:
      case PostgreSQLParser::CONVERSION_P:
      case PostgreSQLParser::COPY:
      case PostgreSQLParser::COST:
      case PostgreSQLParser::CSV:
      case PostgreSQLParser::CURSOR:
      case PostgreSQLParser::CYCLE:
      case PostgreSQLParser::DATA_P:
      case PostgreSQLParser::DATABASE:
      case PostgreSQLParser::DEALLOCATE:
      case PostgreSQLParser::DECLARE:
      case PostgreSQLParser::DEFAULTS:
      case PostgreSQLParser::DEFERRED:
      case PostgreSQLParser::DEFINER:
      case PostgreSQLParser::DELETE_P:
      case PostgreSQLParser::DELIMITER:
      case PostgreSQLParser::DELIMITERS:
      case PostgreSQLParser::DICTIONARY:
      case PostgreSQLParser::DISABLE_P:
      case PostgreSQLParser::DISCARD:
      case PostgreSQLParser::DOCUMENT_P:
      case PostgreSQLParser::DOMAIN_P:
      case PostgreSQLParser::DOUBLE_P:
      case PostgreSQLParser::DROP:
      case PostgreSQLParser::EACH:
      case PostgreSQLParser::ENABLE_P:
      case PostgreSQLParser::ENCODING:
      case PostgreSQLParser::ENCRYPTED:
      case PostgreSQLParser::ENUM_P:
      case PostgreSQLParser::ESCAPE:
      case PostgreSQLParser::EVENT:
      case PostgreSQLParser::EXCLUDE:
      case PostgreSQLParser::EXCLUDING:
      case PostgreSQLParser::EXCLUSIVE:
      case PostgreSQLParser::EXECUTE:
      case PostgreSQLParser::EXPLAIN:
      case PostgreSQLParser::EXTENSION:
      case PostgreSQLParser::EXTERNAL:
      case PostgreSQLParser::FAMILY:
      case PostgreSQLParser::FIRST_P:
      case PostgreSQLParser::FOLLOWING:
      case PostgreSQLParser::FORCE:
      case PostgreSQLParser::FORWARD:
      case PostgreSQLParser::FUNCTION:
      case PostgreSQLParser::FUNCTIONS:
      case PostgreSQLParser::GLOBAL:
      case PostgreSQLParser::GRANTED:
      case PostgreSQLParser::HANDLER:
      case PostgreSQLParser::HEADER_P:
      case PostgreSQLParser::HOLD:
      case PostgreSQLParser::IDENTITY_P:
      case PostgreSQLParser::IF_P:
      case PostgreSQLParser::IMMEDIATE:
      case PostgreSQLParser::IMMUTABLE:
      case PostgreSQLParser::IMPLICIT_P:
      case PostgreSQLParser::INCLUDING:
      case PostgreSQLParser::INCREMENT:
      case PostgreSQLParser::INDEX:
      case PostgreSQLParser::INDEXES:
      case PostgreSQLParser::INHERIT:
      case PostgreSQLParser::INHERITS:
      case PostgreSQLParser::INLINE_P:
      case PostgreSQLParser::INSENSITIVE:
      case PostgreSQLParser::INSERT:
      case PostgreSQLParser::INSTEAD:
      case PostgreSQLParser::INVOKER:
      case PostgreSQLParser::ISOLATION:
      case PostgreSQLParser::KEY:
      case PostgreSQLParser::LABEL:
      case PostgreSQLParser::LANGUAGE:
      case PostgreSQLParser::LARGE_P:
      case PostgreSQLParser::LAST_P:
      case PostgreSQLParser::LEAKPROOF:
      case PostgreSQLParser::LEVEL:
      case PostgreSQLParser::LISTEN:
      case PostgreSQLParser::LOAD:
      case PostgreSQLParser::LOCAL:
      case PostgreSQLParser::LOCATION:
      case PostgreSQLParser::LOCK_P:
      case PostgreSQLParser::MAPPING:
      case PostgreSQLParser::MATCH:
      case PostgreSQLParser::MATCHED:
      case PostgreSQLParser::MATERIALIZED:
      case PostgreSQLParser::MAXVALUE:
      case PostgreSQLParser::MERGE:
      case PostgreSQLParser::MINVALUE:
      case PostgreSQLParser::MODE:
      case PostgreSQLParser::MOVE:
      case PostgreSQLParser::NAME_P:
      case PostgreSQLParser::NAMES:
      case PostgreSQLParser::NEXT:
      case PostgreSQLParser::NO:
      case PostgreSQLParser::NOTHING:
      case PostgreSQLParser::NOTIFY:
      case PostgreSQLParser::NOWAIT:
      case PostgreSQLParser::NULLS_P:
      case PostgreSQLParser::OBJECT_P:
      case PostgreSQLParser::OF:
      case PostgreSQLParser::OFF:
      case PostgreSQLParser::OIDS:
      case PostgreSQLParser::OPERATOR:
      case PostgreSQLParser::OPTION:
      case PostgreSQLParser::OPTIONS:
      case PostgreSQLParser::OWNED:
      case PostgreSQLParser::OWNER:
      case PostgreSQLParser::PARSER:
      case PostgreSQLParser::PARTIAL:
      case PostgreSQLParser::PARTITION:
      case PostgreSQLParser::PASSING:
      case PostgreSQLParser::PASSWORD:
      case PostgreSQLParser::PLANS:
      case PostgreSQLParser::PRECEDING:
      case PostgreSQLParser::PREPARE:
      case PostgreSQLParser::PREPARED:
      case PostgreSQLParser::PRESERVE:
      case PostgreSQLParser::PRIOR:
      case PostgreSQLParser::PRIVILEGES:
      case PostgreSQLParser::PROCEDURAL:
      case PostgreSQLParser::PROCEDURE:
      case PostgreSQLParser::PROGRAM:
      case PostgreSQLParser::QUOTE:
      case PostgreSQLParser::RANGE:
      case PostgreSQLParser::READ:
      case PostgreSQLParser::REASSIGN:
      case PostgreSQLParser::RECURSIVE:
      case PostgreSQLParser::REF:
      case PostgreSQLParser::REFRESH:
      case PostgreSQLParser::REINDEX:
      case PostgreSQLParser::RELATIVE_P:
      case PostgreSQLParser::RELEASE:
      case PostgreSQLParser::RENAME:
      case PostgreSQLParser::REPEATABLE:
      case PostgreSQLParser::REPLACE:
      case PostgreSQLParser::REPLICA:
      case PostgreSQLParser::RESET:
      case PostgreSQLParser::RESTART:
      case PostgreSQLParser::RESTRICT:
      case PostgreSQLParser::RETURNS:
      case PostgreSQLParser::REVOKE:
      case PostgreSQLParser::ROLE:
      case PostgreSQLParser::ROLLBACK:
      case PostgreSQLParser::ROWS:
      case PostgreSQLParser::RULE:
      case PostgreSQLParser::SAVEPOINT:
      case PostgreSQLParser::SCHEMA:
      case PostgreSQLParser::SCROLL:
      case PostgreSQLParser::SEARCH:
      case PostgreSQLParser::SECURITY:
      case PostgreSQLParser::SEQUENCE:
      case PostgreSQLParser::SEQUENCES:
      case PostgreSQLParser::SERIALIZABLE:
      case PostgreSQLParser::SERVER:
      case PostgreSQLParser::SESSION:
      case PostgreSQLParser::SET:
      case PostgreSQLParser::SHARE:
      case PostgreSQLParser::SHOW:
      case PostgreSQLParser::SIMPLE:
      case PostgreSQLParser::SNAPSHOT:
      case PostgreSQLParser::STABLE:
      case PostgreSQLParser::STANDALONE_P:
      case PostgreSQLParser::START:
      case PostgreSQLParser::STATEMENT:
      case PostgreSQLParser::STATISTICS:
      case PostgreSQLParser::STDIN:
      case PostgreSQLParser::STDOUT:
      case PostgreSQLParser::STORAGE:
      case PostgreSQLParser::STRICT_P:
      case PostgreSQLParser::STRIP_P:
      case PostgreSQLParser::SYSID:
      case PostgreSQLParser::SYSTEM_P:
      case PostgreSQLParser::TABLES:
      case PostgreSQLParser::TABLESPACE:
      case PostgreSQLParser::TEMP:
      case PostgreSQLParser::TEMPLATE:
      case PostgreSQLParser::TEMPORARY:
      case PostgreSQLParser::TEXT_P:
      case PostgreSQLParser::TRANSACTION:
      case PostgreSQLParser::TRIGGER:
      case PostgreSQLParser::TRUNCATE:
      case PostgreSQLParser::TRUSTED:
      case PostgreSQLParser::TYPE_P:
      case PostgreSQLParser::TYPES_P:
      case PostgreSQLParser::UNBOUNDED:
      case PostgreSQLParser::UNCOMMITTED:
      case PostgreSQLParser::UNENCRYPTED:
      case PostgreSQLParser::UNKNOWN:
      case PostgreSQLParser::UNLISTEN:
      case PostgreSQLParser::UNLOGGED:
      case PostgreSQLParser::UNTIL:
      case PostgreSQLParser::UPDATE:
      case PostgreSQLParser::VACUUM:
      case PostgreSQLParser::VALID:
      case PostgreSQLParser::VALIDATE:
      case PostgreSQLParser::VALIDATOR:
      case PostgreSQLParser::VERSION_P:
      case PostgreSQLParser::VIEW:
      case PostgreSQLParser::VOLATILE:
      case PostgreSQLParser::WHITESPACE_P:
      case PostgreSQLParser::WORK:
      case PostgreSQLParser::WRAPPER:
      case PostgreSQLParser::WRITE:
      case PostgreSQLParser::XML_P:
      case PostgreSQLParser::YES_P:
      case PostgreSQLParser::ZONE:
      case PostgreSQLParser::BETWEEN:
      case PostgreSQLParser::BIGINT:
      case PostgreSQLParser::BIT:
      case PostgreSQLParser::BOOLEAN_P:
      case PostgreSQLParser::COALESCE:
      case PostgreSQLParser::DEC:
      case PostgreSQLParser::DECIMAL_P:
      case PostgreSQLParser::EXISTS:
      case PostgreSQLParser::EXTRACT:
      case PostgreSQLParser::FLOAT_P:
      case PostgreSQLParser::GREATEST:
      case PostgreSQLParser::INOUT:
      case PostgreSQLParser::INT_P:
      case PostgreSQLParser::INTEGER:
      case PostgreSQLParser::INTERVAL:
      case PostgreSQLParser::LEAST:
      case PostgreSQLParser::NATIONAL:
      case PostgreSQLParser::NCHAR:
      case PostgreSQLParser::NONE:
      case PostgreSQLParser::NULLIF:
      case PostgreSQLParser::NUMERIC:
      case PostgreSQLParser::OVERLAY:
      case PostgreSQLParser::POSITION:
      case PostgreSQLParser::REAL:
      case PostgreSQLParser::ROW:
      case PostgreSQLParser::SETOF:
      case PostgreSQLParser::SMALLINT:
      case PostgreSQLParser::SUBSTRING:
      case PostgreSQLParser::TIME:
      case PostgreSQLParser::TIMESTAMP:
      case PostgreSQLParser::TREAT:
      case PostgreSQLParser::TRIM:
      case PostgreSQLParser::VALUES:
      case PostgreSQLParser::VARCHAR:
      case PostgreSQLParser::XMLATTRIBUTES:
      case PostgreSQLParser::XMLCONCAT:
      case PostgreSQLParser::XMLELEMENT:
      case PostgreSQLParser::XMLEXISTS:
      case PostgreSQLParser::XMLFOREST:
      case PostgreSQLParser::XMLPARSE:
      case PostgreSQLParser::XMLPI:
      case PostgreSQLParser::XMLROOT:
      case PostgreSQLParser::XMLSERIALIZE:
      case PostgreSQLParser::CALL:
      case PostgreSQLParser::CURRENT_P:
      case PostgreSQLParser::ATTACH:
      case PostgreSQLParser::DETACH:
      case PostgreSQLParser::EXPRESSION:
      case PostgreSQLParser::GENERATED:
      case PostgreSQLParser::LOGGED:
      case PostgreSQLParser::STORED:
      case PostgreSQLParser::INCLUDE:
      case PostgreSQLParser::ROUTINE:
      case PostgreSQLParser::TRANSFORM:
      case PostgreSQLParser::IMPORT_P:
      case PostgreSQLParser::POLICY:
      case PostgreSQLParser::METHOD:
      case PostgreSQLParser::REFERENCING:
      case PostgreSQLParser::NEW:
      case PostgreSQLParser::OLD:
      case PostgreSQLParser::VALUE_P:
      case PostgreSQLParser::SUBSCRIPTION:
      case PostgreSQLParser::PUBLICATION:
      case PostgreSQLParser::OUT_P:
      case PostgreSQLParser::END_P:
      case PostgreSQLParser::ROUTINES:
      case PostgreSQLParser::SCHEMAS:
      case PostgreSQLParser::PROCEDURES:
      case PostgreSQLParser::INPUT_P:
      case PostgreSQLParser::SUPPORT:
      case PostgreSQLParser::PARALLEL:
      case PostgreSQLParser::SQL_P:
      case PostgreSQLParser::DEPENDS:
      case PostgreSQLParser::OVERRIDING:
      case PostgreSQLParser::CONFLICT:
      case PostgreSQLParser::SKIP_P:
      case PostgreSQLParser::LOCKED:
      case PostgreSQLParser::TIES:
      case PostgreSQLParser::ROLLUP:
      case PostgreSQLParser::CUBE:
      case PostgreSQLParser::GROUPING:
      case PostgreSQLParser::SETS:
      case PostgreSQLParser::TABLESAMPLE:
      case PostgreSQLParser::ORDINALITY:
      case PostgreSQLParser::XMLTABLE:
      case PostgreSQLParser::COLUMNS:
      case PostgreSQLParser::XMLNAMESPACES:
      case PostgreSQLParser::NORMALIZED:
      case PostgreSQLParser::GROUPS:
      case PostgreSQLParser::OTHERS:
      case PostgreSQLParser::NFC:
      case PostgreSQLParser::NFD:
      case PostgreSQLParser::NFKC:
      case PostgreSQLParser::NFKD:
      case PostgreSQLParser::UESCAPE:
      case PostgreSQLParser::VIEWS:
      case PostgreSQLParser::NORMALIZE:
      case PostgreSQLParser::ERROR:
      case PostgreSQLParser::RETURN:
      case PostgreSQLParser::FORMAT: {
        enterOuterAlt(_localctx, 2);
        setState(10432);
        bare_label_keyword();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unreserved_keywordContext ------------------------------------------------------------------

PostgreSQLParser::Unreserved_keywordContext::Unreserved_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ABORT_P() {
  return getToken(PostgreSQLParser::ABORT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ABSENT() {
  return getToken(PostgreSQLParser::ABSENT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ABSOLUTE_P() {
  return getToken(PostgreSQLParser::ABSOLUTE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ACCESS() {
  return getToken(PostgreSQLParser::ACCESS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ACTION() {
  return getToken(PostgreSQLParser::ACTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ADD_P() {
  return getToken(PostgreSQLParser::ADD_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ADMIN() {
  return getToken(PostgreSQLParser::ADMIN, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::AFTER() {
  return getToken(PostgreSQLParser::AFTER, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::AGGREGATE() {
  return getToken(PostgreSQLParser::AGGREGATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ALSO() {
  return getToken(PostgreSQLParser::ALSO, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ALWAYS() {
  return getToken(PostgreSQLParser::ALWAYS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ASENSITIVE() {
  return getToken(PostgreSQLParser::ASENSITIVE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ASSERTION() {
  return getToken(PostgreSQLParser::ASSERTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ASSIGNMENT() {
  return getToken(PostgreSQLParser::ASSIGNMENT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::AT() {
  return getToken(PostgreSQLParser::AT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ATOMIC() {
  return getToken(PostgreSQLParser::ATOMIC, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ATTACH() {
  return getToken(PostgreSQLParser::ATTACH, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ATTRIBUTE() {
  return getToken(PostgreSQLParser::ATTRIBUTE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::BACKWARD() {
  return getToken(PostgreSQLParser::BACKWARD, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::BEFORE() {
  return getToken(PostgreSQLParser::BEFORE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::BEGIN_P() {
  return getToken(PostgreSQLParser::BEGIN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::BREADTH() {
  return getToken(PostgreSQLParser::BREADTH, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::BY() {
  return getToken(PostgreSQLParser::BY, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CACHE() {
  return getToken(PostgreSQLParser::CACHE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CALL() {
  return getToken(PostgreSQLParser::CALL, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CALLED() {
  return getToken(PostgreSQLParser::CALLED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CASCADE() {
  return getToken(PostgreSQLParser::CASCADE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CASCADED() {
  return getToken(PostgreSQLParser::CASCADED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CATALOG() {
  return getToken(PostgreSQLParser::CATALOG, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CHAIN() {
  return getToken(PostgreSQLParser::CHAIN, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CHARACTERISTICS() {
  return getToken(PostgreSQLParser::CHARACTERISTICS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CHECKPOINT() {
  return getToken(PostgreSQLParser::CHECKPOINT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CLASS() {
  return getToken(PostgreSQLParser::CLASS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CLOSE() {
  return getToken(PostgreSQLParser::CLOSE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CLUSTER() {
  return getToken(PostgreSQLParser::CLUSTER, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::COLUMNS() {
  return getToken(PostgreSQLParser::COLUMNS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::COMMENT() {
  return getToken(PostgreSQLParser::COMMENT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::COMMENTS() {
  return getToken(PostgreSQLParser::COMMENTS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::COMMIT() {
  return getToken(PostgreSQLParser::COMMIT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::COMMITTED() {
  return getToken(PostgreSQLParser::COMMITTED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::COMPRESSION() {
  return getToken(PostgreSQLParser::COMPRESSION, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CONDITIONAL() {
  return getToken(PostgreSQLParser::CONDITIONAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CONFIGURATION() {
  return getToken(PostgreSQLParser::CONFIGURATION, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CONFLICT() {
  return getToken(PostgreSQLParser::CONFLICT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CONNECTION() {
  return getToken(PostgreSQLParser::CONNECTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CONSTRAINTS() {
  return getToken(PostgreSQLParser::CONSTRAINTS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CONTENT_P() {
  return getToken(PostgreSQLParser::CONTENT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CONTINUE_P() {
  return getToken(PostgreSQLParser::CONTINUE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CONVERSION_P() {
  return getToken(PostgreSQLParser::CONVERSION_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::COPY() {
  return getToken(PostgreSQLParser::COPY, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::COST() {
  return getToken(PostgreSQLParser::COST, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CSV() {
  return getToken(PostgreSQLParser::CSV, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CUBE() {
  return getToken(PostgreSQLParser::CUBE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CURRENT_P() {
  return getToken(PostgreSQLParser::CURRENT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CURSOR() {
  return getToken(PostgreSQLParser::CURSOR, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::CYCLE() {
  return getToken(PostgreSQLParser::CYCLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DATA_P() {
  return getToken(PostgreSQLParser::DATA_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DATABASE() {
  return getToken(PostgreSQLParser::DATABASE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DAY_P() {
  return getToken(PostgreSQLParser::DAY_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DEALLOCATE() {
  return getToken(PostgreSQLParser::DEALLOCATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DECLARE() {
  return getToken(PostgreSQLParser::DECLARE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DEFAULTS() {
  return getToken(PostgreSQLParser::DEFAULTS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DEFERRED() {
  return getToken(PostgreSQLParser::DEFERRED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DEFINER() {
  return getToken(PostgreSQLParser::DEFINER, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DELETE_P() {
  return getToken(PostgreSQLParser::DELETE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DELIMITER() {
  return getToken(PostgreSQLParser::DELIMITER, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DELIMITERS() {
  return getToken(PostgreSQLParser::DELIMITERS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DEPENDS() {
  return getToken(PostgreSQLParser::DEPENDS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DEPTH() {
  return getToken(PostgreSQLParser::DEPTH, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DETACH() {
  return getToken(PostgreSQLParser::DETACH, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DICTIONARY() {
  return getToken(PostgreSQLParser::DICTIONARY, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DISABLE_P() {
  return getToken(PostgreSQLParser::DISABLE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DISCARD() {
  return getToken(PostgreSQLParser::DISCARD, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DOCUMENT_P() {
  return getToken(PostgreSQLParser::DOCUMENT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DOMAIN_P() {
  return getToken(PostgreSQLParser::DOMAIN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DOUBLE_P() {
  return getToken(PostgreSQLParser::DOUBLE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::EACH() {
  return getToken(PostgreSQLParser::EACH, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::EMPTY_P() {
  return getToken(PostgreSQLParser::EMPTY_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ENABLE_P() {
  return getToken(PostgreSQLParser::ENABLE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ENCODING() {
  return getToken(PostgreSQLParser::ENCODING, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ENCRYPTED() {
  return getToken(PostgreSQLParser::ENCRYPTED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ENUM_P() {
  return getToken(PostgreSQLParser::ENUM_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ERROR() {
  return getToken(PostgreSQLParser::ERROR, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ESCAPE() {
  return getToken(PostgreSQLParser::ESCAPE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::EVENT() {
  return getToken(PostgreSQLParser::EVENT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::EXCLUDE() {
  return getToken(PostgreSQLParser::EXCLUDE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::EXCLUDING() {
  return getToken(PostgreSQLParser::EXCLUDING, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::EXCLUSIVE() {
  return getToken(PostgreSQLParser::EXCLUSIVE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::EXECUTE() {
  return getToken(PostgreSQLParser::EXECUTE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::EXPLAIN() {
  return getToken(PostgreSQLParser::EXPLAIN, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::EXPRESSION() {
  return getToken(PostgreSQLParser::EXPRESSION, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::EXTENSION() {
  return getToken(PostgreSQLParser::EXTENSION, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::EXTERNAL() {
  return getToken(PostgreSQLParser::EXTERNAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::FAMILY() {
  return getToken(PostgreSQLParser::FAMILY, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::FILTER() {
  return getToken(PostgreSQLParser::FILTER, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::FINALIZE() {
  return getToken(PostgreSQLParser::FINALIZE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::FIRST_P() {
  return getToken(PostgreSQLParser::FIRST_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::FOLLOWING() {
  return getToken(PostgreSQLParser::FOLLOWING, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::FORCE() {
  return getToken(PostgreSQLParser::FORCE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::FORMAT() {
  return getToken(PostgreSQLParser::FORMAT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::FORWARD() {
  return getToken(PostgreSQLParser::FORWARD, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::FUNCTION() {
  return getToken(PostgreSQLParser::FUNCTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::FUNCTIONS() {
  return getToken(PostgreSQLParser::FUNCTIONS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::GENERATED() {
  return getToken(PostgreSQLParser::GENERATED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::GLOBAL() {
  return getToken(PostgreSQLParser::GLOBAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::GRANTED() {
  return getToken(PostgreSQLParser::GRANTED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::GROUPS() {
  return getToken(PostgreSQLParser::GROUPS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::HANDLER() {
  return getToken(PostgreSQLParser::HANDLER, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::HEADER_P() {
  return getToken(PostgreSQLParser::HEADER_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::HOLD() {
  return getToken(PostgreSQLParser::HOLD, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::HOUR_P() {
  return getToken(PostgreSQLParser::HOUR_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::IDENTITY_P() {
  return getToken(PostgreSQLParser::IDENTITY_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::IMMEDIATE() {
  return getToken(PostgreSQLParser::IMMEDIATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::IMMUTABLE() {
  return getToken(PostgreSQLParser::IMMUTABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::IMPLICIT_P() {
  return getToken(PostgreSQLParser::IMPLICIT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::IMPORT_P() {
  return getToken(PostgreSQLParser::IMPORT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::INCLUDE() {
  return getToken(PostgreSQLParser::INCLUDE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::INCLUDING() {
  return getToken(PostgreSQLParser::INCLUDING, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::INCREMENT() {
  return getToken(PostgreSQLParser::INCREMENT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::INDENT() {
  return getToken(PostgreSQLParser::INDENT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::INDEX() {
  return getToken(PostgreSQLParser::INDEX, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::INDEXES() {
  return getToken(PostgreSQLParser::INDEXES, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::INHERIT() {
  return getToken(PostgreSQLParser::INHERIT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::INHERITS() {
  return getToken(PostgreSQLParser::INHERITS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::INLINE_P() {
  return getToken(PostgreSQLParser::INLINE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::INPUT_P() {
  return getToken(PostgreSQLParser::INPUT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::INSENSITIVE() {
  return getToken(PostgreSQLParser::INSENSITIVE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::INSERT() {
  return getToken(PostgreSQLParser::INSERT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::INSTEAD() {
  return getToken(PostgreSQLParser::INSTEAD, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::INVOKER() {
  return getToken(PostgreSQLParser::INVOKER, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ISOLATION() {
  return getToken(PostgreSQLParser::ISOLATION, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::KEEP() {
  return getToken(PostgreSQLParser::KEEP, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::KEY() {
  return getToken(PostgreSQLParser::KEY, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::KEYS() {
  return getToken(PostgreSQLParser::KEYS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::LABEL() {
  return getToken(PostgreSQLParser::LABEL, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::LANGUAGE() {
  return getToken(PostgreSQLParser::LANGUAGE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::LARGE_P() {
  return getToken(PostgreSQLParser::LARGE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::LAST_P() {
  return getToken(PostgreSQLParser::LAST_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::LEAKPROOF() {
  return getToken(PostgreSQLParser::LEAKPROOF, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::LEVEL() {
  return getToken(PostgreSQLParser::LEVEL, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::LISTEN() {
  return getToken(PostgreSQLParser::LISTEN, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::LOAD() {
  return getToken(PostgreSQLParser::LOAD, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::LOCAL() {
  return getToken(PostgreSQLParser::LOCAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::LOCATION() {
  return getToken(PostgreSQLParser::LOCATION, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::LOCK_P() {
  return getToken(PostgreSQLParser::LOCK_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::LOCKED() {
  return getToken(PostgreSQLParser::LOCKED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::LOGGED() {
  return getToken(PostgreSQLParser::LOGGED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::MAPPING() {
  return getToken(PostgreSQLParser::MAPPING, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::MATCH() {
  return getToken(PostgreSQLParser::MATCH, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::MATCHED() {
  return getToken(PostgreSQLParser::MATCHED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::MATERIALIZED() {
  return getToken(PostgreSQLParser::MATERIALIZED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::MAXVALUE() {
  return getToken(PostgreSQLParser::MAXVALUE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::MERGE() {
  return getToken(PostgreSQLParser::MERGE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::METHOD() {
  return getToken(PostgreSQLParser::METHOD, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::MINUTE_P() {
  return getToken(PostgreSQLParser::MINUTE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::MINVALUE() {
  return getToken(PostgreSQLParser::MINVALUE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::MODE() {
  return getToken(PostgreSQLParser::MODE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::MONTH_P() {
  return getToken(PostgreSQLParser::MONTH_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::MOVE() {
  return getToken(PostgreSQLParser::MOVE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::NAME_P() {
  return getToken(PostgreSQLParser::NAME_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::NAMES() {
  return getToken(PostgreSQLParser::NAMES, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::NESTED() {
  return getToken(PostgreSQLParser::NESTED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::NEW() {
  return getToken(PostgreSQLParser::NEW, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::NEXT() {
  return getToken(PostgreSQLParser::NEXT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::NFC() {
  return getToken(PostgreSQLParser::NFC, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::NFD() {
  return getToken(PostgreSQLParser::NFD, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::NFKC() {
  return getToken(PostgreSQLParser::NFKC, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::NFKD() {
  return getToken(PostgreSQLParser::NFKD, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::NO() {
  return getToken(PostgreSQLParser::NO, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::NORMALIZED() {
  return getToken(PostgreSQLParser::NORMALIZED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::NOTHING() {
  return getToken(PostgreSQLParser::NOTHING, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::NOTIFY() {
  return getToken(PostgreSQLParser::NOTIFY, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::NOWAIT() {
  return getToken(PostgreSQLParser::NOWAIT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::NULLS_P() {
  return getToken(PostgreSQLParser::NULLS_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::OBJECT_P() {
  return getToken(PostgreSQLParser::OBJECT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::OF() {
  return getToken(PostgreSQLParser::OF, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::OFF() {
  return getToken(PostgreSQLParser::OFF, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::OIDS() {
  return getToken(PostgreSQLParser::OIDS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::OLD() {
  return getToken(PostgreSQLParser::OLD, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::OMIT() {
  return getToken(PostgreSQLParser::OMIT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::OPTION() {
  return getToken(PostgreSQLParser::OPTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::OPTIONS() {
  return getToken(PostgreSQLParser::OPTIONS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ORDINALITY() {
  return getToken(PostgreSQLParser::ORDINALITY, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::OTHERS() {
  return getToken(PostgreSQLParser::OTHERS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::OVER() {
  return getToken(PostgreSQLParser::OVER, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::OVERRIDING() {
  return getToken(PostgreSQLParser::OVERRIDING, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::OWNED() {
  return getToken(PostgreSQLParser::OWNED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::OWNER() {
  return getToken(PostgreSQLParser::OWNER, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PARALLEL() {
  return getToken(PostgreSQLParser::PARALLEL, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PARAMETER() {
  return getToken(PostgreSQLParser::PARAMETER, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PARSER() {
  return getToken(PostgreSQLParser::PARSER, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PARTIAL() {
  return getToken(PostgreSQLParser::PARTIAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PARTITION() {
  return getToken(PostgreSQLParser::PARTITION, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PASSING() {
  return getToken(PostgreSQLParser::PASSING, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PASSWORD() {
  return getToken(PostgreSQLParser::PASSWORD, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PATH() {
  return getToken(PostgreSQLParser::PATH, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PERIOD() {
  return getToken(PostgreSQLParser::PERIOD, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PLAN() {
  return getToken(PostgreSQLParser::PLAN, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PLANS() {
  return getToken(PostgreSQLParser::PLANS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::POLICY() {
  return getToken(PostgreSQLParser::POLICY, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PRECEDING() {
  return getToken(PostgreSQLParser::PRECEDING, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PREPARE() {
  return getToken(PostgreSQLParser::PREPARE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PREPARED() {
  return getToken(PostgreSQLParser::PREPARED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PRESERVE() {
  return getToken(PostgreSQLParser::PRESERVE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PRIOR() {
  return getToken(PostgreSQLParser::PRIOR, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PRIVILEGES() {
  return getToken(PostgreSQLParser::PRIVILEGES, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PROCEDURAL() {
  return getToken(PostgreSQLParser::PROCEDURAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PROCEDURE() {
  return getToken(PostgreSQLParser::PROCEDURE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PROCEDURES() {
  return getToken(PostgreSQLParser::PROCEDURES, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PROGRAM() {
  return getToken(PostgreSQLParser::PROGRAM, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::PUBLICATION() {
  return getToken(PostgreSQLParser::PUBLICATION, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::QUOTE() {
  return getToken(PostgreSQLParser::QUOTE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::QUOTES() {
  return getToken(PostgreSQLParser::QUOTES, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::RANGE() {
  return getToken(PostgreSQLParser::RANGE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::READ() {
  return getToken(PostgreSQLParser::READ, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::REASSIGN() {
  return getToken(PostgreSQLParser::REASSIGN, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::RECURSIVE() {
  return getToken(PostgreSQLParser::RECURSIVE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::REF() {
  return getToken(PostgreSQLParser::REF, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::REFERENCING() {
  return getToken(PostgreSQLParser::REFERENCING, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::REFRESH() {
  return getToken(PostgreSQLParser::REFRESH, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::REINDEX() {
  return getToken(PostgreSQLParser::REINDEX, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::RELATIVE_P() {
  return getToken(PostgreSQLParser::RELATIVE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::RELEASE() {
  return getToken(PostgreSQLParser::RELEASE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::RENAME() {
  return getToken(PostgreSQLParser::RENAME, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::REPEATABLE() {
  return getToken(PostgreSQLParser::REPEATABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::REPLACE() {
  return getToken(PostgreSQLParser::REPLACE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::REPLICA() {
  return getToken(PostgreSQLParser::REPLICA, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::RESET() {
  return getToken(PostgreSQLParser::RESET, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::RESTART() {
  return getToken(PostgreSQLParser::RESTART, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::RESTRICT() {
  return getToken(PostgreSQLParser::RESTRICT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::RETURN() {
  return getToken(PostgreSQLParser::RETURN, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::RETURNS() {
  return getToken(PostgreSQLParser::RETURNS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::REVOKE() {
  return getToken(PostgreSQLParser::REVOKE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ROLE() {
  return getToken(PostgreSQLParser::ROLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ROLLBACK() {
  return getToken(PostgreSQLParser::ROLLBACK, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ROLLUP() {
  return getToken(PostgreSQLParser::ROLLUP, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ROUTINE() {
  return getToken(PostgreSQLParser::ROUTINE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ROUTINES() {
  return getToken(PostgreSQLParser::ROUTINES, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ROWS() {
  return getToken(PostgreSQLParser::ROWS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::RULE() {
  return getToken(PostgreSQLParser::RULE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SAVEPOINT() {
  return getToken(PostgreSQLParser::SAVEPOINT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SCALAR() {
  return getToken(PostgreSQLParser::SCALAR, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SCHEMA() {
  return getToken(PostgreSQLParser::SCHEMA, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SCHEMAS() {
  return getToken(PostgreSQLParser::SCHEMAS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SCROLL() {
  return getToken(PostgreSQLParser::SCROLL, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SEARCH() {
  return getToken(PostgreSQLParser::SEARCH, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SECOND_P() {
  return getToken(PostgreSQLParser::SECOND_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SECURITY() {
  return getToken(PostgreSQLParser::SECURITY, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SEQUENCE() {
  return getToken(PostgreSQLParser::SEQUENCE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SEQUENCES() {
  return getToken(PostgreSQLParser::SEQUENCES, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SERIALIZABLE() {
  return getToken(PostgreSQLParser::SERIALIZABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SERVER() {
  return getToken(PostgreSQLParser::SERVER, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SESSION() {
  return getToken(PostgreSQLParser::SESSION, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SETS() {
  return getToken(PostgreSQLParser::SETS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SHARE() {
  return getToken(PostgreSQLParser::SHARE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SHOW() {
  return getToken(PostgreSQLParser::SHOW, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SIMPLE() {
  return getToken(PostgreSQLParser::SIMPLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SKIP_P() {
  return getToken(PostgreSQLParser::SKIP_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SNAPSHOT() {
  return getToken(PostgreSQLParser::SNAPSHOT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SOURCE() {
  return getToken(PostgreSQLParser::SOURCE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SQL_P() {
  return getToken(PostgreSQLParser::SQL_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::STABLE() {
  return getToken(PostgreSQLParser::STABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::STANDALONE_P() {
  return getToken(PostgreSQLParser::STANDALONE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::START() {
  return getToken(PostgreSQLParser::START, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::STATEMENT() {
  return getToken(PostgreSQLParser::STATEMENT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::STATISTICS() {
  return getToken(PostgreSQLParser::STATISTICS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::STDIN() {
  return getToken(PostgreSQLParser::STDIN, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::STDOUT() {
  return getToken(PostgreSQLParser::STDOUT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::STORAGE() {
  return getToken(PostgreSQLParser::STORAGE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::STORED() {
  return getToken(PostgreSQLParser::STORED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::STRICT_P() {
  return getToken(PostgreSQLParser::STRICT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::STRING_P() {
  return getToken(PostgreSQLParser::STRING_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::STRIP_P() {
  return getToken(PostgreSQLParser::STRIP_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SUBSCRIPTION() {
  return getToken(PostgreSQLParser::SUBSCRIPTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SUPPORT() {
  return getToken(PostgreSQLParser::SUPPORT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SYSID() {
  return getToken(PostgreSQLParser::SYSID, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::SYSTEM_P() {
  return getToken(PostgreSQLParser::SYSTEM_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::TABLES() {
  return getToken(PostgreSQLParser::TABLES, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::TABLESPACE() {
  return getToken(PostgreSQLParser::TABLESPACE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::TARGET() {
  return getToken(PostgreSQLParser::TARGET, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::TEMP() {
  return getToken(PostgreSQLParser::TEMP, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::TEMPLATE() {
  return getToken(PostgreSQLParser::TEMPLATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::TEMPORARY() {
  return getToken(PostgreSQLParser::TEMPORARY, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::TEXT_P() {
  return getToken(PostgreSQLParser::TEXT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::TIES() {
  return getToken(PostgreSQLParser::TIES, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::TRANSACTION() {
  return getToken(PostgreSQLParser::TRANSACTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::TRANSFORM() {
  return getToken(PostgreSQLParser::TRANSFORM, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::TRIGGER() {
  return getToken(PostgreSQLParser::TRIGGER, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::TRUNCATE() {
  return getToken(PostgreSQLParser::TRUNCATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::TRUSTED() {
  return getToken(PostgreSQLParser::TRUSTED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::TYPES_P() {
  return getToken(PostgreSQLParser::TYPES_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::UESCAPE() {
  return getToken(PostgreSQLParser::UESCAPE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::UNBOUNDED() {
  return getToken(PostgreSQLParser::UNBOUNDED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::UNCOMMITTED() {
  return getToken(PostgreSQLParser::UNCOMMITTED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::UNCONDITIONAL() {
  return getToken(PostgreSQLParser::UNCONDITIONAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::UNENCRYPTED() {
  return getToken(PostgreSQLParser::UNENCRYPTED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::UNKNOWN() {
  return getToken(PostgreSQLParser::UNKNOWN, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::UNLISTEN() {
  return getToken(PostgreSQLParser::UNLISTEN, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::UNLOGGED() {
  return getToken(PostgreSQLParser::UNLOGGED, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::UNTIL() {
  return getToken(PostgreSQLParser::UNTIL, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::UPDATE() {
  return getToken(PostgreSQLParser::UPDATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::VACUUM() {
  return getToken(PostgreSQLParser::VACUUM, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::VALID() {
  return getToken(PostgreSQLParser::VALID, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::VALIDATE() {
  return getToken(PostgreSQLParser::VALIDATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::VALIDATOR() {
  return getToken(PostgreSQLParser::VALIDATOR, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::VALUE_P() {
  return getToken(PostgreSQLParser::VALUE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::VARYING() {
  return getToken(PostgreSQLParser::VARYING, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::VERSION_P() {
  return getToken(PostgreSQLParser::VERSION_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::VIEW() {
  return getToken(PostgreSQLParser::VIEW, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::VIEWS() {
  return getToken(PostgreSQLParser::VIEWS, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::VOLATILE() {
  return getToken(PostgreSQLParser::VOLATILE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::WHITESPACE_P() {
  return getToken(PostgreSQLParser::WHITESPACE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::WITHIN() {
  return getToken(PostgreSQLParser::WITHIN, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::WITHOUT() {
  return getToken(PostgreSQLParser::WITHOUT, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::WORK() {
  return getToken(PostgreSQLParser::WORK, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::WRAPPER() {
  return getToken(PostgreSQLParser::WRAPPER, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::WRITE() {
  return getToken(PostgreSQLParser::WRITE, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::XML_P() {
  return getToken(PostgreSQLParser::XML_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::YEAR_P() {
  return getToken(PostgreSQLParser::YEAR_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::YES_P() {
  return getToken(PostgreSQLParser::YES_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Unreserved_keywordContext::ZONE() {
  return getToken(PostgreSQLParser::ZONE, 0);
}


size_t PostgreSQLParser::Unreserved_keywordContext::getRuleIndex() const {
  return PostgreSQLParser::RuleUnreserved_keyword;
}


std::any PostgreSQLParser::Unreserved_keywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitUnreserved_keyword(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Unreserved_keywordContext* PostgreSQLParser::unreserved_keyword() {
  Unreserved_keywordContext *_localctx = _tracker.createInstance<Unreserved_keywordContext>(_ctx, getState());
  enterRule(_localctx, 1426, PostgreSQLParser::RuleUnreserved_keyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10435);
    _la = _input->LA(1);
    if (!(((((_la - 43) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 43)) & 16777215) != 0) || ((((_la - 162) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 162)) & -31) != 0) || ((((_la - 226) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 226)) & -1) != 0) || ((((_la - 290) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 290)) & -8796093022209) != 0) || ((((_la - 354) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 354)) & -1) != 0) || ((((_la - 471) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 471)) & 360258695689404415) != 0) || _la == PostgreSQLParser::RETURN

    || _la == PostgreSQLParser::FORMAT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Col_name_keywordContext ------------------------------------------------------------------

PostgreSQLParser::Col_name_keywordContext::Col_name_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::BETWEEN() {
  return getToken(PostgreSQLParser::BETWEEN, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::BIGINT() {
  return getToken(PostgreSQLParser::BIGINT, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::BIT() {
  return getToken(PostgreSQLParser::BIT, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::BOOLEAN_P() {
  return getToken(PostgreSQLParser::BOOLEAN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::CHAR_P() {
  return getToken(PostgreSQLParser::CHAR_P, 0);
}

PostgreSQLParser::CharacterContext* PostgreSQLParser::Col_name_keywordContext::character() {
  return getRuleContext<PostgreSQLParser::CharacterContext>(0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::COALESCE() {
  return getToken(PostgreSQLParser::COALESCE, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::DEC() {
  return getToken(PostgreSQLParser::DEC, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::DECIMAL_P() {
  return getToken(PostgreSQLParser::DECIMAL_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::EXTRACT() {
  return getToken(PostgreSQLParser::EXTRACT, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::FLOAT_P() {
  return getToken(PostgreSQLParser::FLOAT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::GREATEST() {
  return getToken(PostgreSQLParser::GREATEST, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::GROUPING() {
  return getToken(PostgreSQLParser::GROUPING, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::INOUT() {
  return getToken(PostgreSQLParser::INOUT, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::INT_P() {
  return getToken(PostgreSQLParser::INT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::INTEGER() {
  return getToken(PostgreSQLParser::INTEGER, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::INTERVAL() {
  return getToken(PostgreSQLParser::INTERVAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::JSON() {
  return getToken(PostgreSQLParser::JSON, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::JSON_ARRAY() {
  return getToken(PostgreSQLParser::JSON_ARRAY, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::JSON_ARRAYAGG() {
  return getToken(PostgreSQLParser::JSON_ARRAYAGG, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::JSON_EXISTS() {
  return getToken(PostgreSQLParser::JSON_EXISTS, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::JSON_OBJECT() {
  return getToken(PostgreSQLParser::JSON_OBJECT, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::JSON_OBJECTAGG() {
  return getToken(PostgreSQLParser::JSON_OBJECTAGG, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::JSON_QUERY() {
  return getToken(PostgreSQLParser::JSON_QUERY, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::JSON_SCALAR() {
  return getToken(PostgreSQLParser::JSON_SCALAR, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::JSON_SERIALIZE() {
  return getToken(PostgreSQLParser::JSON_SERIALIZE, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::JSON_TABLE() {
  return getToken(PostgreSQLParser::JSON_TABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::JSON_VALUE() {
  return getToken(PostgreSQLParser::JSON_VALUE, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::LEAST() {
  return getToken(PostgreSQLParser::LEAST, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::MERGE_ACTION() {
  return getToken(PostgreSQLParser::MERGE_ACTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::NATIONAL() {
  return getToken(PostgreSQLParser::NATIONAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::NCHAR() {
  return getToken(PostgreSQLParser::NCHAR, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::NONE() {
  return getToken(PostgreSQLParser::NONE, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::NORMALIZE() {
  return getToken(PostgreSQLParser::NORMALIZE, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::NULLIF() {
  return getToken(PostgreSQLParser::NULLIF, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::NUMERIC() {
  return getToken(PostgreSQLParser::NUMERIC, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::OUT_P() {
  return getToken(PostgreSQLParser::OUT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::OVERLAY() {
  return getToken(PostgreSQLParser::OVERLAY, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::POSITION() {
  return getToken(PostgreSQLParser::POSITION, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::PRECISION() {
  return getToken(PostgreSQLParser::PRECISION, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::REAL() {
  return getToken(PostgreSQLParser::REAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::ROW() {
  return getToken(PostgreSQLParser::ROW, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::SETOF() {
  return getToken(PostgreSQLParser::SETOF, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::SMALLINT() {
  return getToken(PostgreSQLParser::SMALLINT, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::SUBSTRING() {
  return getToken(PostgreSQLParser::SUBSTRING, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::TIME() {
  return getToken(PostgreSQLParser::TIME, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::TIMESTAMP() {
  return getToken(PostgreSQLParser::TIMESTAMP, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::TREAT() {
  return getToken(PostgreSQLParser::TREAT, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::TRIM() {
  return getToken(PostgreSQLParser::TRIM, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::VALUES() {
  return getToken(PostgreSQLParser::VALUES, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::VARCHAR() {
  return getToken(PostgreSQLParser::VARCHAR, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::XMLATTRIBUTES() {
  return getToken(PostgreSQLParser::XMLATTRIBUTES, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::XMLCONCAT() {
  return getToken(PostgreSQLParser::XMLCONCAT, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::XMLELEMENT() {
  return getToken(PostgreSQLParser::XMLELEMENT, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::XMLEXISTS() {
  return getToken(PostgreSQLParser::XMLEXISTS, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::XMLFOREST() {
  return getToken(PostgreSQLParser::XMLFOREST, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::XMLNAMESPACES() {
  return getToken(PostgreSQLParser::XMLNAMESPACES, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::XMLPARSE() {
  return getToken(PostgreSQLParser::XMLPARSE, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::XMLPI() {
  return getToken(PostgreSQLParser::XMLPI, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::XMLROOT() {
  return getToken(PostgreSQLParser::XMLROOT, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::XMLSERIALIZE() {
  return getToken(PostgreSQLParser::XMLSERIALIZE, 0);
}

tree::TerminalNode* PostgreSQLParser::Col_name_keywordContext::XMLTABLE() {
  return getToken(PostgreSQLParser::XMLTABLE, 0);
}


size_t PostgreSQLParser::Col_name_keywordContext::getRuleIndex() const {
  return PostgreSQLParser::RuleCol_name_keyword;
}


std::any PostgreSQLParser::Col_name_keywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitCol_name_keyword(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Col_name_keywordContext* PostgreSQLParser::col_name_keyword() {
  Col_name_keywordContext *_localctx = _tracker.createInstance<Col_name_keywordContext>(_ctx, getState());
  enterRule(_localctx, 1428, PostgreSQLParser::RuleCol_name_keyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10500);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1048, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(10437);
      match(PostgreSQLParser::BETWEEN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(10438);
      match(PostgreSQLParser::BIGINT);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(10439);
      match(PostgreSQLParser::BIT);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(10440);
      match(PostgreSQLParser::BOOLEAN_P);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(10441);
      match(PostgreSQLParser::CHAR_P);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(10442);
      character();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(10443);
      match(PostgreSQLParser::COALESCE);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(10444);
      match(PostgreSQLParser::DEC);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(10445);
      match(PostgreSQLParser::DECIMAL_P);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(10446);
      match(PostgreSQLParser::EXISTS);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(10447);
      match(PostgreSQLParser::EXTRACT);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(10448);
      match(PostgreSQLParser::FLOAT_P);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(10449);
      match(PostgreSQLParser::GREATEST);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(10450);
      match(PostgreSQLParser::GROUPING);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(10451);
      match(PostgreSQLParser::INOUT);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(10452);
      match(PostgreSQLParser::INT_P);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(10453);
      match(PostgreSQLParser::INTEGER);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(10454);
      match(PostgreSQLParser::INTERVAL);
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(10455);
      match(PostgreSQLParser::JSON);
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(10456);
      match(PostgreSQLParser::JSON_ARRAY);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(10457);
      match(PostgreSQLParser::JSON_ARRAYAGG);
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(10458);
      match(PostgreSQLParser::JSON_EXISTS);
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(10459);
      match(PostgreSQLParser::JSON_OBJECT);
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(10460);
      match(PostgreSQLParser::JSON_OBJECTAGG);
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(10461);
      match(PostgreSQLParser::JSON_QUERY);
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(10462);
      match(PostgreSQLParser::JSON_SCALAR);
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(10463);
      match(PostgreSQLParser::JSON_SERIALIZE);
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(10464);
      match(PostgreSQLParser::JSON_TABLE);
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(10465);
      match(PostgreSQLParser::JSON_VALUE);
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(10466);
      match(PostgreSQLParser::LEAST);
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(10467);
      match(PostgreSQLParser::MERGE_ACTION);
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(10468);
      match(PostgreSQLParser::NATIONAL);
      break;
    }

    case 33: {
      enterOuterAlt(_localctx, 33);
      setState(10469);
      match(PostgreSQLParser::NCHAR);
      break;
    }

    case 34: {
      enterOuterAlt(_localctx, 34);
      setState(10470);
      match(PostgreSQLParser::NONE);
      break;
    }

    case 35: {
      enterOuterAlt(_localctx, 35);
      setState(10471);
      match(PostgreSQLParser::NORMALIZE);
      break;
    }

    case 36: {
      enterOuterAlt(_localctx, 36);
      setState(10472);
      match(PostgreSQLParser::NULLIF);
      break;
    }

    case 37: {
      enterOuterAlt(_localctx, 37);
      setState(10473);
      match(PostgreSQLParser::NUMERIC);
      break;
    }

    case 38: {
      enterOuterAlt(_localctx, 38);
      setState(10474);
      match(PostgreSQLParser::OUT_P);
      break;
    }

    case 39: {
      enterOuterAlt(_localctx, 39);
      setState(10475);
      match(PostgreSQLParser::OVERLAY);
      break;
    }

    case 40: {
      enterOuterAlt(_localctx, 40);
      setState(10476);
      match(PostgreSQLParser::POSITION);
      break;
    }

    case 41: {
      enterOuterAlt(_localctx, 41);
      setState(10477);
      match(PostgreSQLParser::PRECISION);
      break;
    }

    case 42: {
      enterOuterAlt(_localctx, 42);
      setState(10478);
      match(PostgreSQLParser::REAL);
      break;
    }

    case 43: {
      enterOuterAlt(_localctx, 43);
      setState(10479);
      match(PostgreSQLParser::ROW);
      break;
    }

    case 44: {
      enterOuterAlt(_localctx, 44);
      setState(10480);
      match(PostgreSQLParser::SETOF);
      break;
    }

    case 45: {
      enterOuterAlt(_localctx, 45);
      setState(10481);
      match(PostgreSQLParser::SMALLINT);
      break;
    }

    case 46: {
      enterOuterAlt(_localctx, 46);
      setState(10482);
      match(PostgreSQLParser::SUBSTRING);
      break;
    }

    case 47: {
      enterOuterAlt(_localctx, 47);
      setState(10483);
      match(PostgreSQLParser::TIME);
      break;
    }

    case 48: {
      enterOuterAlt(_localctx, 48);
      setState(10484);
      match(PostgreSQLParser::TIMESTAMP);
      break;
    }

    case 49: {
      enterOuterAlt(_localctx, 49);
      setState(10485);
      match(PostgreSQLParser::TREAT);
      break;
    }

    case 50: {
      enterOuterAlt(_localctx, 50);
      setState(10486);
      match(PostgreSQLParser::TRIM);
      break;
    }

    case 51: {
      enterOuterAlt(_localctx, 51);
      setState(10487);
      match(PostgreSQLParser::VALUES);
      break;
    }

    case 52: {
      enterOuterAlt(_localctx, 52);
      setState(10488);
      match(PostgreSQLParser::VARCHAR);
      break;
    }

    case 53: {
      enterOuterAlt(_localctx, 53);
      setState(10489);
      match(PostgreSQLParser::XMLATTRIBUTES);
      break;
    }

    case 54: {
      enterOuterAlt(_localctx, 54);
      setState(10490);
      match(PostgreSQLParser::XMLCONCAT);
      break;
    }

    case 55: {
      enterOuterAlt(_localctx, 55);
      setState(10491);
      match(PostgreSQLParser::XMLELEMENT);
      break;
    }

    case 56: {
      enterOuterAlt(_localctx, 56);
      setState(10492);
      match(PostgreSQLParser::XMLEXISTS);
      break;
    }

    case 57: {
      enterOuterAlt(_localctx, 57);
      setState(10493);
      match(PostgreSQLParser::XMLFOREST);
      break;
    }

    case 58: {
      enterOuterAlt(_localctx, 58);
      setState(10494);
      match(PostgreSQLParser::XMLNAMESPACES);
      break;
    }

    case 59: {
      enterOuterAlt(_localctx, 59);
      setState(10495);
      match(PostgreSQLParser::XMLPARSE);
      break;
    }

    case 60: {
      enterOuterAlt(_localctx, 60);
      setState(10496);
      match(PostgreSQLParser::XMLPI);
      break;
    }

    case 61: {
      enterOuterAlt(_localctx, 61);
      setState(10497);
      match(PostgreSQLParser::XMLROOT);
      break;
    }

    case 62: {
      enterOuterAlt(_localctx, 62);
      setState(10498);
      match(PostgreSQLParser::XMLSERIALIZE);
      break;
    }

    case 63: {
      enterOuterAlt(_localctx, 63);
      setState(10499);
      match(PostgreSQLParser::XMLTABLE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_func_name_keywordContext ------------------------------------------------------------------

PostgreSQLParser::Type_func_name_keywordContext::Type_func_name_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::AUTHORIZATION() {
  return getToken(PostgreSQLParser::AUTHORIZATION, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::BINARY() {
  return getToken(PostgreSQLParser::BINARY, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::COLLATION() {
  return getToken(PostgreSQLParser::COLLATION, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::CONCURRENTLY() {
  return getToken(PostgreSQLParser::CONCURRENTLY, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::CROSS() {
  return getToken(PostgreSQLParser::CROSS, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::CURRENT_SCHEMA() {
  return getToken(PostgreSQLParser::CURRENT_SCHEMA, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::FREEZE() {
  return getToken(PostgreSQLParser::FREEZE, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::FULL() {
  return getToken(PostgreSQLParser::FULL, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::ILIKE() {
  return getToken(PostgreSQLParser::ILIKE, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::INNER_P() {
  return getToken(PostgreSQLParser::INNER_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::IS() {
  return getToken(PostgreSQLParser::IS, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::ISNULL() {
  return getToken(PostgreSQLParser::ISNULL, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::JOIN() {
  return getToken(PostgreSQLParser::JOIN, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::LEFT() {
  return getToken(PostgreSQLParser::LEFT, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::LIKE() {
  return getToken(PostgreSQLParser::LIKE, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::NATURAL() {
  return getToken(PostgreSQLParser::NATURAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::NOTNULL() {
  return getToken(PostgreSQLParser::NOTNULL, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::OUTER_P() {
  return getToken(PostgreSQLParser::OUTER_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::OVERLAPS() {
  return getToken(PostgreSQLParser::OVERLAPS, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::RIGHT() {
  return getToken(PostgreSQLParser::RIGHT, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::SIMILAR() {
  return getToken(PostgreSQLParser::SIMILAR, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::TABLESAMPLE() {
  return getToken(PostgreSQLParser::TABLESAMPLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Type_func_name_keywordContext::VERBOSE() {
  return getToken(PostgreSQLParser::VERBOSE, 0);
}


size_t PostgreSQLParser::Type_func_name_keywordContext::getRuleIndex() const {
  return PostgreSQLParser::RuleType_func_name_keyword;
}


std::any PostgreSQLParser::Type_func_name_keywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitType_func_name_keyword(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Type_func_name_keywordContext* PostgreSQLParser::type_func_name_keyword() {
  Type_func_name_keywordContext *_localctx = _tracker.createInstance<Type_func_name_keywordContext>(_ctx, getState());
  enterRule(_localctx, 1430, PostgreSQLParser::RuleType_func_name_keyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10502);
    _la = _input->LA(1);
    if (!(((((_la - 144) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 144)) & 8126463) != 0) || _la == PostgreSQLParser::TABLESAMPLE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reserved_keywordContext ------------------------------------------------------------------

PostgreSQLParser::Reserved_keywordContext::Reserved_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::ANALYSE() {
  return getToken(PostgreSQLParser::ANALYSE, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::ANALYZE() {
  return getToken(PostgreSQLParser::ANALYZE, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::AND() {
  return getToken(PostgreSQLParser::AND, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::ANY() {
  return getToken(PostgreSQLParser::ANY, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::ARRAY() {
  return getToken(PostgreSQLParser::ARRAY, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::AS() {
  return getToken(PostgreSQLParser::AS, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::ASC() {
  return getToken(PostgreSQLParser::ASC, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::ASYMMETRIC() {
  return getToken(PostgreSQLParser::ASYMMETRIC, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::BOTH() {
  return getToken(PostgreSQLParser::BOTH, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::CASE() {
  return getToken(PostgreSQLParser::CASE, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::CAST() {
  return getToken(PostgreSQLParser::CAST, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::CHECK() {
  return getToken(PostgreSQLParser::CHECK, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::COLLATE() {
  return getToken(PostgreSQLParser::COLLATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::COLUMN() {
  return getToken(PostgreSQLParser::COLUMN, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::CONSTRAINT() {
  return getToken(PostgreSQLParser::CONSTRAINT, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::CREATE() {
  return getToken(PostgreSQLParser::CREATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::CURRENT_CATALOG() {
  return getToken(PostgreSQLParser::CURRENT_CATALOG, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::CURRENT_DATE() {
  return getToken(PostgreSQLParser::CURRENT_DATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::CURRENT_ROLE() {
  return getToken(PostgreSQLParser::CURRENT_ROLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::CURRENT_TIME() {
  return getToken(PostgreSQLParser::CURRENT_TIME, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::CURRENT_TIMESTAMP() {
  return getToken(PostgreSQLParser::CURRENT_TIMESTAMP, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::CURRENT_USER() {
  return getToken(PostgreSQLParser::CURRENT_USER, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::DEFERRABLE() {
  return getToken(PostgreSQLParser::DEFERRABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::DESC() {
  return getToken(PostgreSQLParser::DESC, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::DISTINCT() {
  return getToken(PostgreSQLParser::DISTINCT, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::DO() {
  return getToken(PostgreSQLParser::DO, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::ELSE() {
  return getToken(PostgreSQLParser::ELSE, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::END_P() {
  return getToken(PostgreSQLParser::END_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::EXCEPT() {
  return getToken(PostgreSQLParser::EXCEPT, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::FALSE_P() {
  return getToken(PostgreSQLParser::FALSE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::FETCH() {
  return getToken(PostgreSQLParser::FETCH, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::FOR() {
  return getToken(PostgreSQLParser::FOR, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::FOREIGN() {
  return getToken(PostgreSQLParser::FOREIGN, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::FROM() {
  return getToken(PostgreSQLParser::FROM, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::GRANT() {
  return getToken(PostgreSQLParser::GRANT, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::GROUP_P() {
  return getToken(PostgreSQLParser::GROUP_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::HAVING() {
  return getToken(PostgreSQLParser::HAVING, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::IN_P() {
  return getToken(PostgreSQLParser::IN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::INITIALLY() {
  return getToken(PostgreSQLParser::INITIALLY, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::INTERSECT() {
  return getToken(PostgreSQLParser::INTERSECT, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::INTO() {
  return getToken(PostgreSQLParser::INTO, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::LATERAL_P() {
  return getToken(PostgreSQLParser::LATERAL_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::LEADING() {
  return getToken(PostgreSQLParser::LEADING, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::LIMIT() {
  return getToken(PostgreSQLParser::LIMIT, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::LOCALTIME() {
  return getToken(PostgreSQLParser::LOCALTIME, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::LOCALTIMESTAMP() {
  return getToken(PostgreSQLParser::LOCALTIMESTAMP, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::NULL_P() {
  return getToken(PostgreSQLParser::NULL_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::OFFSET() {
  return getToken(PostgreSQLParser::OFFSET, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::ON() {
  return getToken(PostgreSQLParser::ON, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::ONLY() {
  return getToken(PostgreSQLParser::ONLY, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::OR() {
  return getToken(PostgreSQLParser::OR, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::ORDER() {
  return getToken(PostgreSQLParser::ORDER, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::PLACING() {
  return getToken(PostgreSQLParser::PLACING, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::PRIMARY() {
  return getToken(PostgreSQLParser::PRIMARY, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::REFERENCES() {
  return getToken(PostgreSQLParser::REFERENCES, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::RETURNING() {
  return getToken(PostgreSQLParser::RETURNING, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::SELECT() {
  return getToken(PostgreSQLParser::SELECT, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::SESSION_USER() {
  return getToken(PostgreSQLParser::SESSION_USER, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::SOME() {
  return getToken(PostgreSQLParser::SOME, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::SYMMETRIC() {
  return getToken(PostgreSQLParser::SYMMETRIC, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::SYSTEM_USER() {
  return getToken(PostgreSQLParser::SYSTEM_USER, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::THEN() {
  return getToken(PostgreSQLParser::THEN, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::TO() {
  return getToken(PostgreSQLParser::TO, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::TRAILING() {
  return getToken(PostgreSQLParser::TRAILING, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::TRUE_P() {
  return getToken(PostgreSQLParser::TRUE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::UNION() {
  return getToken(PostgreSQLParser::UNION, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::UNIQUE() {
  return getToken(PostgreSQLParser::UNIQUE, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::USER() {
  return getToken(PostgreSQLParser::USER, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::VARIADIC() {
  return getToken(PostgreSQLParser::VARIADIC, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::WHEN() {
  return getToken(PostgreSQLParser::WHEN, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::WHERE() {
  return getToken(PostgreSQLParser::WHERE, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::WINDOW() {
  return getToken(PostgreSQLParser::WINDOW, 0);
}

tree::TerminalNode* PostgreSQLParser::Reserved_keywordContext::WITH() {
  return getToken(PostgreSQLParser::WITH, 0);
}


size_t PostgreSQLParser::Reserved_keywordContext::getRuleIndex() const {
  return PostgreSQLParser::RuleReserved_keyword;
}


std::any PostgreSQLParser::Reserved_keywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitReserved_keyword(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Reserved_keywordContext* PostgreSQLParser::reserved_keyword() {
  Reserved_keywordContext *_localctx = _tracker.createInstance<Reserved_keywordContext>(_ctx, getState());
  enterRule(_localctx, 1432, PostgreSQLParser::RuleReserved_keyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10504);
    _la = _input->LA(1);
    if (!(((((_la - 42) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 42)) & -67108863) != 0) || ((((_la - 106) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 106)) & 274877906943) != 0) || _la == PostgreSQLParser::END_P)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bare_label_keywordContext ------------------------------------------------------------------

PostgreSQLParser::Bare_label_keywordContext::Bare_label_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ABORT_P() {
  return getToken(PostgreSQLParser::ABORT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ABSENT() {
  return getToken(PostgreSQLParser::ABSENT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ABSOLUTE_P() {
  return getToken(PostgreSQLParser::ABSOLUTE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ACCESS() {
  return getToken(PostgreSQLParser::ACCESS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ACTION() {
  return getToken(PostgreSQLParser::ACTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ADD_P() {
  return getToken(PostgreSQLParser::ADD_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ADMIN() {
  return getToken(PostgreSQLParser::ADMIN, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::AFTER() {
  return getToken(PostgreSQLParser::AFTER, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::AGGREGATE() {
  return getToken(PostgreSQLParser::AGGREGATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ALL() {
  return getToken(PostgreSQLParser::ALL, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ALSO() {
  return getToken(PostgreSQLParser::ALSO, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ALTER() {
  return getToken(PostgreSQLParser::ALTER, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ALWAYS() {
  return getToken(PostgreSQLParser::ALWAYS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ANALYSE() {
  return getToken(PostgreSQLParser::ANALYSE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ANALYZE() {
  return getToken(PostgreSQLParser::ANALYZE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::AND() {
  return getToken(PostgreSQLParser::AND, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ANY() {
  return getToken(PostgreSQLParser::ANY, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ASC() {
  return getToken(PostgreSQLParser::ASC, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ASENSITIVE() {
  return getToken(PostgreSQLParser::ASENSITIVE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ASSERTION() {
  return getToken(PostgreSQLParser::ASSERTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ASSIGNMENT() {
  return getToken(PostgreSQLParser::ASSIGNMENT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ASYMMETRIC() {
  return getToken(PostgreSQLParser::ASYMMETRIC, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::AT() {
  return getToken(PostgreSQLParser::AT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ATOMIC() {
  return getToken(PostgreSQLParser::ATOMIC, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ATTACH() {
  return getToken(PostgreSQLParser::ATTACH, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ATTRIBUTE() {
  return getToken(PostgreSQLParser::ATTRIBUTE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::AUTHORIZATION() {
  return getToken(PostgreSQLParser::AUTHORIZATION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::BACKWARD() {
  return getToken(PostgreSQLParser::BACKWARD, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::BEFORE() {
  return getToken(PostgreSQLParser::BEFORE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::BEGIN_P() {
  return getToken(PostgreSQLParser::BEGIN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::BETWEEN() {
  return getToken(PostgreSQLParser::BETWEEN, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::BIGINT() {
  return getToken(PostgreSQLParser::BIGINT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::BINARY() {
  return getToken(PostgreSQLParser::BINARY, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::BIT() {
  return getToken(PostgreSQLParser::BIT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::BOOLEAN_P() {
  return getToken(PostgreSQLParser::BOOLEAN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::BOTH() {
  return getToken(PostgreSQLParser::BOTH, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::BREADTH() {
  return getToken(PostgreSQLParser::BREADTH, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::BY() {
  return getToken(PostgreSQLParser::BY, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CACHE() {
  return getToken(PostgreSQLParser::CACHE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CALL() {
  return getToken(PostgreSQLParser::CALL, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CALLED() {
  return getToken(PostgreSQLParser::CALLED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CASCADE() {
  return getToken(PostgreSQLParser::CASCADE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CASCADED() {
  return getToken(PostgreSQLParser::CASCADED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CASE() {
  return getToken(PostgreSQLParser::CASE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CAST() {
  return getToken(PostgreSQLParser::CAST, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CATALOG() {
  return getToken(PostgreSQLParser::CATALOG, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CHAIN() {
  return getToken(PostgreSQLParser::CHAIN, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CHARACTERISTICS() {
  return getToken(PostgreSQLParser::CHARACTERISTICS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CHECK() {
  return getToken(PostgreSQLParser::CHECK, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CHECKPOINT() {
  return getToken(PostgreSQLParser::CHECKPOINT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CLASS() {
  return getToken(PostgreSQLParser::CLASS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CLOSE() {
  return getToken(PostgreSQLParser::CLOSE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CLUSTER() {
  return getToken(PostgreSQLParser::CLUSTER, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::COALESCE() {
  return getToken(PostgreSQLParser::COALESCE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::COLLATE() {
  return getToken(PostgreSQLParser::COLLATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::COLLATION() {
  return getToken(PostgreSQLParser::COLLATION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::COLUMN() {
  return getToken(PostgreSQLParser::COLUMN, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::COLUMNS() {
  return getToken(PostgreSQLParser::COLUMNS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::COMMENT() {
  return getToken(PostgreSQLParser::COMMENT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::COMMENTS() {
  return getToken(PostgreSQLParser::COMMENTS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::COMMIT() {
  return getToken(PostgreSQLParser::COMMIT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::COMMITTED() {
  return getToken(PostgreSQLParser::COMMITTED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::COMPRESSION() {
  return getToken(PostgreSQLParser::COMPRESSION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CONCURRENTLY() {
  return getToken(PostgreSQLParser::CONCURRENTLY, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CONDITIONAL() {
  return getToken(PostgreSQLParser::CONDITIONAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CONFIGURATION() {
  return getToken(PostgreSQLParser::CONFIGURATION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CONFLICT() {
  return getToken(PostgreSQLParser::CONFLICT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CONNECTION() {
  return getToken(PostgreSQLParser::CONNECTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CONSTRAINT() {
  return getToken(PostgreSQLParser::CONSTRAINT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CONSTRAINTS() {
  return getToken(PostgreSQLParser::CONSTRAINTS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CONTENT_P() {
  return getToken(PostgreSQLParser::CONTENT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CONTINUE_P() {
  return getToken(PostgreSQLParser::CONTINUE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CONVERSION_P() {
  return getToken(PostgreSQLParser::CONVERSION_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::COPY() {
  return getToken(PostgreSQLParser::COPY, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::COST() {
  return getToken(PostgreSQLParser::COST, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CROSS() {
  return getToken(PostgreSQLParser::CROSS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CSV() {
  return getToken(PostgreSQLParser::CSV, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CUBE() {
  return getToken(PostgreSQLParser::CUBE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CURRENT_CATALOG() {
  return getToken(PostgreSQLParser::CURRENT_CATALOG, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CURRENT_DATE() {
  return getToken(PostgreSQLParser::CURRENT_DATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CURRENT_P() {
  return getToken(PostgreSQLParser::CURRENT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CURRENT_ROLE() {
  return getToken(PostgreSQLParser::CURRENT_ROLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CURRENT_SCHEMA() {
  return getToken(PostgreSQLParser::CURRENT_SCHEMA, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CURRENT_TIME() {
  return getToken(PostgreSQLParser::CURRENT_TIME, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CURRENT_TIMESTAMP() {
  return getToken(PostgreSQLParser::CURRENT_TIMESTAMP, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CURRENT_USER() {
  return getToken(PostgreSQLParser::CURRENT_USER, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CURSOR() {
  return getToken(PostgreSQLParser::CURSOR, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::CYCLE() {
  return getToken(PostgreSQLParser::CYCLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DATA_P() {
  return getToken(PostgreSQLParser::DATA_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DATABASE() {
  return getToken(PostgreSQLParser::DATABASE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DEALLOCATE() {
  return getToken(PostgreSQLParser::DEALLOCATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DEC() {
  return getToken(PostgreSQLParser::DEC, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DECIMAL_P() {
  return getToken(PostgreSQLParser::DECIMAL_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DECLARE() {
  return getToken(PostgreSQLParser::DECLARE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DEFAULT() {
  return getToken(PostgreSQLParser::DEFAULT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DEFAULTS() {
  return getToken(PostgreSQLParser::DEFAULTS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DEFERRABLE() {
  return getToken(PostgreSQLParser::DEFERRABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DEFERRED() {
  return getToken(PostgreSQLParser::DEFERRED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DEFINER() {
  return getToken(PostgreSQLParser::DEFINER, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DELETE_P() {
  return getToken(PostgreSQLParser::DELETE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DELIMITER() {
  return getToken(PostgreSQLParser::DELIMITER, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DELIMITERS() {
  return getToken(PostgreSQLParser::DELIMITERS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DEPENDS() {
  return getToken(PostgreSQLParser::DEPENDS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DEPTH() {
  return getToken(PostgreSQLParser::DEPTH, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DESC() {
  return getToken(PostgreSQLParser::DESC, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DETACH() {
  return getToken(PostgreSQLParser::DETACH, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DICTIONARY() {
  return getToken(PostgreSQLParser::DICTIONARY, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DISABLE_P() {
  return getToken(PostgreSQLParser::DISABLE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DISCARD() {
  return getToken(PostgreSQLParser::DISCARD, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DISTINCT() {
  return getToken(PostgreSQLParser::DISTINCT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DO() {
  return getToken(PostgreSQLParser::DO, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DOCUMENT_P() {
  return getToken(PostgreSQLParser::DOCUMENT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DOMAIN_P() {
  return getToken(PostgreSQLParser::DOMAIN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DOUBLE_P() {
  return getToken(PostgreSQLParser::DOUBLE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::DROP() {
  return getToken(PostgreSQLParser::DROP, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::EACH() {
  return getToken(PostgreSQLParser::EACH, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ELSE() {
  return getToken(PostgreSQLParser::ELSE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::EMPTY_P() {
  return getToken(PostgreSQLParser::EMPTY_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ENABLE_P() {
  return getToken(PostgreSQLParser::ENABLE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ENCODING() {
  return getToken(PostgreSQLParser::ENCODING, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ENCRYPTED() {
  return getToken(PostgreSQLParser::ENCRYPTED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::END_P() {
  return getToken(PostgreSQLParser::END_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ENUM_P() {
  return getToken(PostgreSQLParser::ENUM_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ERROR() {
  return getToken(PostgreSQLParser::ERROR, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ESCAPE() {
  return getToken(PostgreSQLParser::ESCAPE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::EVENT() {
  return getToken(PostgreSQLParser::EVENT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::EXCLUDE() {
  return getToken(PostgreSQLParser::EXCLUDE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::EXCLUDING() {
  return getToken(PostgreSQLParser::EXCLUDING, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::EXCLUSIVE() {
  return getToken(PostgreSQLParser::EXCLUSIVE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::EXECUTE() {
  return getToken(PostgreSQLParser::EXECUTE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::EXISTS() {
  return getToken(PostgreSQLParser::EXISTS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::EXPLAIN() {
  return getToken(PostgreSQLParser::EXPLAIN, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::EXPRESSION() {
  return getToken(PostgreSQLParser::EXPRESSION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::EXTENSION() {
  return getToken(PostgreSQLParser::EXTENSION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::EXTERNAL() {
  return getToken(PostgreSQLParser::EXTERNAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::EXTRACT() {
  return getToken(PostgreSQLParser::EXTRACT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::FALSE_P() {
  return getToken(PostgreSQLParser::FALSE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::FAMILY() {
  return getToken(PostgreSQLParser::FAMILY, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::FINALIZE() {
  return getToken(PostgreSQLParser::FINALIZE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::FIRST_P() {
  return getToken(PostgreSQLParser::FIRST_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::FLOAT_P() {
  return getToken(PostgreSQLParser::FLOAT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::FOLLOWING() {
  return getToken(PostgreSQLParser::FOLLOWING, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::FORCE() {
  return getToken(PostgreSQLParser::FORCE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::FOREIGN() {
  return getToken(PostgreSQLParser::FOREIGN, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::FORMAT() {
  return getToken(PostgreSQLParser::FORMAT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::FORWARD() {
  return getToken(PostgreSQLParser::FORWARD, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::FREEZE() {
  return getToken(PostgreSQLParser::FREEZE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::FULL() {
  return getToken(PostgreSQLParser::FULL, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::FUNCTION() {
  return getToken(PostgreSQLParser::FUNCTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::FUNCTIONS() {
  return getToken(PostgreSQLParser::FUNCTIONS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::GENERATED() {
  return getToken(PostgreSQLParser::GENERATED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::GLOBAL() {
  return getToken(PostgreSQLParser::GLOBAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::GRANTED() {
  return getToken(PostgreSQLParser::GRANTED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::GREATEST() {
  return getToken(PostgreSQLParser::GREATEST, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::GROUPING() {
  return getToken(PostgreSQLParser::GROUPING, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::GROUPS() {
  return getToken(PostgreSQLParser::GROUPS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::HANDLER() {
  return getToken(PostgreSQLParser::HANDLER, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::HEADER_P() {
  return getToken(PostgreSQLParser::HEADER_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::HOLD() {
  return getToken(PostgreSQLParser::HOLD, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::IDENTITY_P() {
  return getToken(PostgreSQLParser::IDENTITY_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::IF_P() {
  return getToken(PostgreSQLParser::IF_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ILIKE() {
  return getToken(PostgreSQLParser::ILIKE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::IMMEDIATE() {
  return getToken(PostgreSQLParser::IMMEDIATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::IMMUTABLE() {
  return getToken(PostgreSQLParser::IMMUTABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::IMPLICIT_P() {
  return getToken(PostgreSQLParser::IMPLICIT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::IMPORT_P() {
  return getToken(PostgreSQLParser::IMPORT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::IN_P() {
  return getToken(PostgreSQLParser::IN_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INCLUDE() {
  return getToken(PostgreSQLParser::INCLUDE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INCLUDING() {
  return getToken(PostgreSQLParser::INCLUDING, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INCREMENT() {
  return getToken(PostgreSQLParser::INCREMENT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INDENT() {
  return getToken(PostgreSQLParser::INDENT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INDEX() {
  return getToken(PostgreSQLParser::INDEX, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INDEXES() {
  return getToken(PostgreSQLParser::INDEXES, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INHERIT() {
  return getToken(PostgreSQLParser::INHERIT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INHERITS() {
  return getToken(PostgreSQLParser::INHERITS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INITIALLY() {
  return getToken(PostgreSQLParser::INITIALLY, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INLINE_P() {
  return getToken(PostgreSQLParser::INLINE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INNER_P() {
  return getToken(PostgreSQLParser::INNER_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INOUT() {
  return getToken(PostgreSQLParser::INOUT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INPUT_P() {
  return getToken(PostgreSQLParser::INPUT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INSENSITIVE() {
  return getToken(PostgreSQLParser::INSENSITIVE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INSERT() {
  return getToken(PostgreSQLParser::INSERT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INSTEAD() {
  return getToken(PostgreSQLParser::INSTEAD, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INT_P() {
  return getToken(PostgreSQLParser::INT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INTEGER() {
  return getToken(PostgreSQLParser::INTEGER, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INTERVAL() {
  return getToken(PostgreSQLParser::INTERVAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::INVOKER() {
  return getToken(PostgreSQLParser::INVOKER, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::IS() {
  return getToken(PostgreSQLParser::IS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ISOLATION() {
  return getToken(PostgreSQLParser::ISOLATION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::JOIN() {
  return getToken(PostgreSQLParser::JOIN, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::JSON() {
  return getToken(PostgreSQLParser::JSON, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::JSON_ARRAY() {
  return getToken(PostgreSQLParser::JSON_ARRAY, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::JSON_ARRAYAGG() {
  return getToken(PostgreSQLParser::JSON_ARRAYAGG, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::JSON_EXISTS() {
  return getToken(PostgreSQLParser::JSON_EXISTS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::JSON_OBJECT() {
  return getToken(PostgreSQLParser::JSON_OBJECT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::JSON_OBJECTAGG() {
  return getToken(PostgreSQLParser::JSON_OBJECTAGG, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::JSON_QUERY() {
  return getToken(PostgreSQLParser::JSON_QUERY, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::JSON_SCALAR() {
  return getToken(PostgreSQLParser::JSON_SCALAR, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::JSON_SERIALIZE() {
  return getToken(PostgreSQLParser::JSON_SERIALIZE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::JSON_TABLE() {
  return getToken(PostgreSQLParser::JSON_TABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::JSON_VALUE() {
  return getToken(PostgreSQLParser::JSON_VALUE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::KEEP() {
  return getToken(PostgreSQLParser::KEEP, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::KEY() {
  return getToken(PostgreSQLParser::KEY, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::KEYS() {
  return getToken(PostgreSQLParser::KEYS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LABEL() {
  return getToken(PostgreSQLParser::LABEL, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LANGUAGE() {
  return getToken(PostgreSQLParser::LANGUAGE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LARGE_P() {
  return getToken(PostgreSQLParser::LARGE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LAST_P() {
  return getToken(PostgreSQLParser::LAST_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LATERAL_P() {
  return getToken(PostgreSQLParser::LATERAL_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LEADING() {
  return getToken(PostgreSQLParser::LEADING, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LEAKPROOF() {
  return getToken(PostgreSQLParser::LEAKPROOF, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LEAST() {
  return getToken(PostgreSQLParser::LEAST, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LEFT() {
  return getToken(PostgreSQLParser::LEFT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LEVEL() {
  return getToken(PostgreSQLParser::LEVEL, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LIKE() {
  return getToken(PostgreSQLParser::LIKE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LISTEN() {
  return getToken(PostgreSQLParser::LISTEN, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LOAD() {
  return getToken(PostgreSQLParser::LOAD, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LOCAL() {
  return getToken(PostgreSQLParser::LOCAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LOCALTIME() {
  return getToken(PostgreSQLParser::LOCALTIME, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LOCALTIMESTAMP() {
  return getToken(PostgreSQLParser::LOCALTIMESTAMP, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LOCATION() {
  return getToken(PostgreSQLParser::LOCATION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LOCK_P() {
  return getToken(PostgreSQLParser::LOCK_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LOCKED() {
  return getToken(PostgreSQLParser::LOCKED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::LOGGED() {
  return getToken(PostgreSQLParser::LOGGED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::MAPPING() {
  return getToken(PostgreSQLParser::MAPPING, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::MATCH() {
  return getToken(PostgreSQLParser::MATCH, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::MATCHED() {
  return getToken(PostgreSQLParser::MATCHED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::MATERIALIZED() {
  return getToken(PostgreSQLParser::MATERIALIZED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::MAXVALUE() {
  return getToken(PostgreSQLParser::MAXVALUE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::MERGE() {
  return getToken(PostgreSQLParser::MERGE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::MERGE_ACTION() {
  return getToken(PostgreSQLParser::MERGE_ACTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::METHOD() {
  return getToken(PostgreSQLParser::METHOD, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::MINVALUE() {
  return getToken(PostgreSQLParser::MINVALUE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::MODE() {
  return getToken(PostgreSQLParser::MODE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::MOVE() {
  return getToken(PostgreSQLParser::MOVE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NAME_P() {
  return getToken(PostgreSQLParser::NAME_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NAMES() {
  return getToken(PostgreSQLParser::NAMES, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NATIONAL() {
  return getToken(PostgreSQLParser::NATIONAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NATURAL() {
  return getToken(PostgreSQLParser::NATURAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NCHAR() {
  return getToken(PostgreSQLParser::NCHAR, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NESTED() {
  return getToken(PostgreSQLParser::NESTED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NEW() {
  return getToken(PostgreSQLParser::NEW, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NEXT() {
  return getToken(PostgreSQLParser::NEXT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NFC() {
  return getToken(PostgreSQLParser::NFC, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NFD() {
  return getToken(PostgreSQLParser::NFD, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NFKC() {
  return getToken(PostgreSQLParser::NFKC, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NFKD() {
  return getToken(PostgreSQLParser::NFKD, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NO() {
  return getToken(PostgreSQLParser::NO, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NONE() {
  return getToken(PostgreSQLParser::NONE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NORMALIZE() {
  return getToken(PostgreSQLParser::NORMALIZE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NORMALIZED() {
  return getToken(PostgreSQLParser::NORMALIZED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NOT() {
  return getToken(PostgreSQLParser::NOT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NOTHING() {
  return getToken(PostgreSQLParser::NOTHING, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NOTIFY() {
  return getToken(PostgreSQLParser::NOTIFY, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NOWAIT() {
  return getToken(PostgreSQLParser::NOWAIT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NULL_P() {
  return getToken(PostgreSQLParser::NULL_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NULLIF() {
  return getToken(PostgreSQLParser::NULLIF, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NULLS_P() {
  return getToken(PostgreSQLParser::NULLS_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::NUMERIC() {
  return getToken(PostgreSQLParser::NUMERIC, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::OBJECT_P() {
  return getToken(PostgreSQLParser::OBJECT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::OF() {
  return getToken(PostgreSQLParser::OF, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::OFF() {
  return getToken(PostgreSQLParser::OFF, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::OIDS() {
  return getToken(PostgreSQLParser::OIDS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::OLD() {
  return getToken(PostgreSQLParser::OLD, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::OMIT() {
  return getToken(PostgreSQLParser::OMIT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ONLY() {
  return getToken(PostgreSQLParser::ONLY, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::OPERATOR() {
  return getToken(PostgreSQLParser::OPERATOR, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::OPTION() {
  return getToken(PostgreSQLParser::OPTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::OPTIONS() {
  return getToken(PostgreSQLParser::OPTIONS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::OR() {
  return getToken(PostgreSQLParser::OR, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ORDINALITY() {
  return getToken(PostgreSQLParser::ORDINALITY, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::OTHERS() {
  return getToken(PostgreSQLParser::OTHERS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::OUT_P() {
  return getToken(PostgreSQLParser::OUT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::OUTER_P() {
  return getToken(PostgreSQLParser::OUTER_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::OVERLAY() {
  return getToken(PostgreSQLParser::OVERLAY, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::OVERRIDING() {
  return getToken(PostgreSQLParser::OVERRIDING, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::OWNED() {
  return getToken(PostgreSQLParser::OWNED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::OWNER() {
  return getToken(PostgreSQLParser::OWNER, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PARALLEL() {
  return getToken(PostgreSQLParser::PARALLEL, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PARAMETER() {
  return getToken(PostgreSQLParser::PARAMETER, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PARSER() {
  return getToken(PostgreSQLParser::PARSER, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PARTIAL() {
  return getToken(PostgreSQLParser::PARTIAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PARTITION() {
  return getToken(PostgreSQLParser::PARTITION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PASSING() {
  return getToken(PostgreSQLParser::PASSING, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PASSWORD() {
  return getToken(PostgreSQLParser::PASSWORD, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PATH() {
  return getToken(PostgreSQLParser::PATH, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PERIOD() {
  return getToken(PostgreSQLParser::PERIOD, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PLACING() {
  return getToken(PostgreSQLParser::PLACING, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PLAN() {
  return getToken(PostgreSQLParser::PLAN, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PLANS() {
  return getToken(PostgreSQLParser::PLANS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::POLICY() {
  return getToken(PostgreSQLParser::POLICY, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::POSITION() {
  return getToken(PostgreSQLParser::POSITION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PRECEDING() {
  return getToken(PostgreSQLParser::PRECEDING, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PREPARE() {
  return getToken(PostgreSQLParser::PREPARE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PREPARED() {
  return getToken(PostgreSQLParser::PREPARED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PRESERVE() {
  return getToken(PostgreSQLParser::PRESERVE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PRIMARY() {
  return getToken(PostgreSQLParser::PRIMARY, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PRIOR() {
  return getToken(PostgreSQLParser::PRIOR, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PRIVILEGES() {
  return getToken(PostgreSQLParser::PRIVILEGES, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PROCEDURAL() {
  return getToken(PostgreSQLParser::PROCEDURAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PROCEDURE() {
  return getToken(PostgreSQLParser::PROCEDURE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PROCEDURES() {
  return getToken(PostgreSQLParser::PROCEDURES, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PROGRAM() {
  return getToken(PostgreSQLParser::PROGRAM, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::PUBLICATION() {
  return getToken(PostgreSQLParser::PUBLICATION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::QUOTE() {
  return getToken(PostgreSQLParser::QUOTE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::QUOTES() {
  return getToken(PostgreSQLParser::QUOTES, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::RANGE() {
  return getToken(PostgreSQLParser::RANGE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::READ() {
  return getToken(PostgreSQLParser::READ, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::REAL() {
  return getToken(PostgreSQLParser::REAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::REASSIGN() {
  return getToken(PostgreSQLParser::REASSIGN, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::RECURSIVE() {
  return getToken(PostgreSQLParser::RECURSIVE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::REF() {
  return getToken(PostgreSQLParser::REF, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::REFERENCES() {
  return getToken(PostgreSQLParser::REFERENCES, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::REFERENCING() {
  return getToken(PostgreSQLParser::REFERENCING, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::REFRESH() {
  return getToken(PostgreSQLParser::REFRESH, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::REINDEX() {
  return getToken(PostgreSQLParser::REINDEX, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::RELATIVE_P() {
  return getToken(PostgreSQLParser::RELATIVE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::RELEASE() {
  return getToken(PostgreSQLParser::RELEASE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::RENAME() {
  return getToken(PostgreSQLParser::RENAME, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::REPEATABLE() {
  return getToken(PostgreSQLParser::REPEATABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::REPLACE() {
  return getToken(PostgreSQLParser::REPLACE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::REPLICA() {
  return getToken(PostgreSQLParser::REPLICA, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::RESET() {
  return getToken(PostgreSQLParser::RESET, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::RESTART() {
  return getToken(PostgreSQLParser::RESTART, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::RESTRICT() {
  return getToken(PostgreSQLParser::RESTRICT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::RETURN() {
  return getToken(PostgreSQLParser::RETURN, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::RETURNS() {
  return getToken(PostgreSQLParser::RETURNS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::REVOKE() {
  return getToken(PostgreSQLParser::REVOKE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::RIGHT() {
  return getToken(PostgreSQLParser::RIGHT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ROLE() {
  return getToken(PostgreSQLParser::ROLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ROLLBACK() {
  return getToken(PostgreSQLParser::ROLLBACK, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ROLLUP() {
  return getToken(PostgreSQLParser::ROLLUP, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ROUTINE() {
  return getToken(PostgreSQLParser::ROUTINE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ROUTINES() {
  return getToken(PostgreSQLParser::ROUTINES, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ROW() {
  return getToken(PostgreSQLParser::ROW, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ROWS() {
  return getToken(PostgreSQLParser::ROWS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::RULE() {
  return getToken(PostgreSQLParser::RULE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SAVEPOINT() {
  return getToken(PostgreSQLParser::SAVEPOINT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SCALAR() {
  return getToken(PostgreSQLParser::SCALAR, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SCHEMA() {
  return getToken(PostgreSQLParser::SCHEMA, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SCHEMAS() {
  return getToken(PostgreSQLParser::SCHEMAS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SCROLL() {
  return getToken(PostgreSQLParser::SCROLL, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SEARCH() {
  return getToken(PostgreSQLParser::SEARCH, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SECURITY() {
  return getToken(PostgreSQLParser::SECURITY, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SELECT() {
  return getToken(PostgreSQLParser::SELECT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SEQUENCE() {
  return getToken(PostgreSQLParser::SEQUENCE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SEQUENCES() {
  return getToken(PostgreSQLParser::SEQUENCES, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SERIALIZABLE() {
  return getToken(PostgreSQLParser::SERIALIZABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SERVER() {
  return getToken(PostgreSQLParser::SERVER, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SESSION() {
  return getToken(PostgreSQLParser::SESSION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SESSION_USER() {
  return getToken(PostgreSQLParser::SESSION_USER, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SET() {
  return getToken(PostgreSQLParser::SET, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SETOF() {
  return getToken(PostgreSQLParser::SETOF, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SETS() {
  return getToken(PostgreSQLParser::SETS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SHARE() {
  return getToken(PostgreSQLParser::SHARE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SHOW() {
  return getToken(PostgreSQLParser::SHOW, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SIMILAR() {
  return getToken(PostgreSQLParser::SIMILAR, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SIMPLE() {
  return getToken(PostgreSQLParser::SIMPLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SKIP_P() {
  return getToken(PostgreSQLParser::SKIP_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SMALLINT() {
  return getToken(PostgreSQLParser::SMALLINT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SNAPSHOT() {
  return getToken(PostgreSQLParser::SNAPSHOT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SOME() {
  return getToken(PostgreSQLParser::SOME, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SOURCE() {
  return getToken(PostgreSQLParser::SOURCE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SQL_P() {
  return getToken(PostgreSQLParser::SQL_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::STABLE() {
  return getToken(PostgreSQLParser::STABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::STANDALONE_P() {
  return getToken(PostgreSQLParser::STANDALONE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::START() {
  return getToken(PostgreSQLParser::START, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::STATEMENT() {
  return getToken(PostgreSQLParser::STATEMENT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::STATISTICS() {
  return getToken(PostgreSQLParser::STATISTICS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::STDIN() {
  return getToken(PostgreSQLParser::STDIN, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::STDOUT() {
  return getToken(PostgreSQLParser::STDOUT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::STORAGE() {
  return getToken(PostgreSQLParser::STORAGE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::STORED() {
  return getToken(PostgreSQLParser::STORED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::STRICT_P() {
  return getToken(PostgreSQLParser::STRICT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::STRING_P() {
  return getToken(PostgreSQLParser::STRING_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::STRIP_P() {
  return getToken(PostgreSQLParser::STRIP_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SUBSCRIPTION() {
  return getToken(PostgreSQLParser::SUBSCRIPTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SUBSTRING() {
  return getToken(PostgreSQLParser::SUBSTRING, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SUPPORT() {
  return getToken(PostgreSQLParser::SUPPORT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SYMMETRIC() {
  return getToken(PostgreSQLParser::SYMMETRIC, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SYSID() {
  return getToken(PostgreSQLParser::SYSID, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SYSTEM_P() {
  return getToken(PostgreSQLParser::SYSTEM_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::SYSTEM_USER() {
  return getToken(PostgreSQLParser::SYSTEM_USER, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TABLE() {
  return getToken(PostgreSQLParser::TABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TABLES() {
  return getToken(PostgreSQLParser::TABLES, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TABLESAMPLE() {
  return getToken(PostgreSQLParser::TABLESAMPLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TABLESPACE() {
  return getToken(PostgreSQLParser::TABLESPACE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TARGET() {
  return getToken(PostgreSQLParser::TARGET, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TEMP() {
  return getToken(PostgreSQLParser::TEMP, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TEMPLATE() {
  return getToken(PostgreSQLParser::TEMPLATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TEMPORARY() {
  return getToken(PostgreSQLParser::TEMPORARY, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TEXT_P() {
  return getToken(PostgreSQLParser::TEXT_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::THEN() {
  return getToken(PostgreSQLParser::THEN, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TIES() {
  return getToken(PostgreSQLParser::TIES, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TIME() {
  return getToken(PostgreSQLParser::TIME, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TIMESTAMP() {
  return getToken(PostgreSQLParser::TIMESTAMP, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TRAILING() {
  return getToken(PostgreSQLParser::TRAILING, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TRANSACTION() {
  return getToken(PostgreSQLParser::TRANSACTION, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TRANSFORM() {
  return getToken(PostgreSQLParser::TRANSFORM, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TREAT() {
  return getToken(PostgreSQLParser::TREAT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TRIGGER() {
  return getToken(PostgreSQLParser::TRIGGER, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TRIM() {
  return getToken(PostgreSQLParser::TRIM, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TRUE_P() {
  return getToken(PostgreSQLParser::TRUE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TRUNCATE() {
  return getToken(PostgreSQLParser::TRUNCATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TRUSTED() {
  return getToken(PostgreSQLParser::TRUSTED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TYPE_P() {
  return getToken(PostgreSQLParser::TYPE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::TYPES_P() {
  return getToken(PostgreSQLParser::TYPES_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::UESCAPE() {
  return getToken(PostgreSQLParser::UESCAPE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::UNBOUNDED() {
  return getToken(PostgreSQLParser::UNBOUNDED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::UNCOMMITTED() {
  return getToken(PostgreSQLParser::UNCOMMITTED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::UNCONDITIONAL() {
  return getToken(PostgreSQLParser::UNCONDITIONAL, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::UNENCRYPTED() {
  return getToken(PostgreSQLParser::UNENCRYPTED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::UNIQUE() {
  return getToken(PostgreSQLParser::UNIQUE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::UNKNOWN() {
  return getToken(PostgreSQLParser::UNKNOWN, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::UNLISTEN() {
  return getToken(PostgreSQLParser::UNLISTEN, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::UNLOGGED() {
  return getToken(PostgreSQLParser::UNLOGGED, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::UNTIL() {
  return getToken(PostgreSQLParser::UNTIL, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::UPDATE() {
  return getToken(PostgreSQLParser::UPDATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::USER() {
  return getToken(PostgreSQLParser::USER, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::USING() {
  return getToken(PostgreSQLParser::USING, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::VACUUM() {
  return getToken(PostgreSQLParser::VACUUM, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::VALID() {
  return getToken(PostgreSQLParser::VALID, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::VALIDATE() {
  return getToken(PostgreSQLParser::VALIDATE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::VALIDATOR() {
  return getToken(PostgreSQLParser::VALIDATOR, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::VALUE_P() {
  return getToken(PostgreSQLParser::VALUE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::VALUES() {
  return getToken(PostgreSQLParser::VALUES, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::VARCHAR() {
  return getToken(PostgreSQLParser::VARCHAR, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::VARIADIC() {
  return getToken(PostgreSQLParser::VARIADIC, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::VERBOSE() {
  return getToken(PostgreSQLParser::VERBOSE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::VERSION_P() {
  return getToken(PostgreSQLParser::VERSION_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::VIEW() {
  return getToken(PostgreSQLParser::VIEW, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::VIEWS() {
  return getToken(PostgreSQLParser::VIEWS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::VOLATILE() {
  return getToken(PostgreSQLParser::VOLATILE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::WHEN() {
  return getToken(PostgreSQLParser::WHEN, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::WHITESPACE_P() {
  return getToken(PostgreSQLParser::WHITESPACE_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::WORK() {
  return getToken(PostgreSQLParser::WORK, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::WRAPPER() {
  return getToken(PostgreSQLParser::WRAPPER, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::WRITE() {
  return getToken(PostgreSQLParser::WRITE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::XML_P() {
  return getToken(PostgreSQLParser::XML_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::XMLATTRIBUTES() {
  return getToken(PostgreSQLParser::XMLATTRIBUTES, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::XMLCONCAT() {
  return getToken(PostgreSQLParser::XMLCONCAT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::XMLELEMENT() {
  return getToken(PostgreSQLParser::XMLELEMENT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::XMLEXISTS() {
  return getToken(PostgreSQLParser::XMLEXISTS, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::XMLFOREST() {
  return getToken(PostgreSQLParser::XMLFOREST, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::XMLNAMESPACES() {
  return getToken(PostgreSQLParser::XMLNAMESPACES, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::XMLPARSE() {
  return getToken(PostgreSQLParser::XMLPARSE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::XMLPI() {
  return getToken(PostgreSQLParser::XMLPI, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::XMLROOT() {
  return getToken(PostgreSQLParser::XMLROOT, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::XMLSERIALIZE() {
  return getToken(PostgreSQLParser::XMLSERIALIZE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::XMLTABLE() {
  return getToken(PostgreSQLParser::XMLTABLE, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::YES_P() {
  return getToken(PostgreSQLParser::YES_P, 0);
}

tree::TerminalNode* PostgreSQLParser::Bare_label_keywordContext::ZONE() {
  return getToken(PostgreSQLParser::ZONE, 0);
}


size_t PostgreSQLParser::Bare_label_keywordContext::getRuleIndex() const {
  return PostgreSQLParser::RuleBare_label_keyword;
}


std::any PostgreSQLParser::Bare_label_keywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitBare_label_keyword(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Bare_label_keywordContext* PostgreSQLParser::bare_label_keyword() {
  Bare_label_keywordContext *_localctx = _tracker.createInstance<Bare_label_keywordContext>(_ctx, getState());
  enterRule(_localctx, 1434, PostgreSQLParser::RuleBare_label_keyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10506);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -1073741824) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -2477318281427420681) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -55968850065) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & -4194305) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & -309237645313) != 0) || ((((_la - 321) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 321)) & -68719480833) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 385)) & -288230789576916993) != 0) || ((((_la - 449) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 449)) & -16257) != 0) || ((((_la - 513) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 513)) & 1100048596939) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Any_identifierContext ------------------------------------------------------------------

PostgreSQLParser::Any_identifierContext::Any_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

PostgreSQLParser::ColidContext* PostgreSQLParser::Any_identifierContext::colid() {
  return getRuleContext<PostgreSQLParser::ColidContext>(0);
}


size_t PostgreSQLParser::Any_identifierContext::getRuleIndex() const {
  return PostgreSQLParser::RuleAny_identifier;
}


std::any PostgreSQLParser::Any_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitAny_identifier(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::Any_identifierContext* PostgreSQLParser::any_identifier() {
  Any_identifierContext *_localctx = _tracker.createInstance<Any_identifierContext>(_ctx, getState());
  enterRule(_localctx, 1436, PostgreSQLParser::RuleAny_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(10508);
    colid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

PostgreSQLParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* PostgreSQLParser::IdentifierContext::Identifier() {
  return getToken(PostgreSQLParser::Identifier, 0);
}

PostgreSQLParser::Uescape_Context* PostgreSQLParser::IdentifierContext::uescape_() {
  return getRuleContext<PostgreSQLParser::Uescape_Context>(0);
}

tree::TerminalNode* PostgreSQLParser::IdentifierContext::QuotedIdentifier() {
  return getToken(PostgreSQLParser::QuotedIdentifier, 0);
}

tree::TerminalNode* PostgreSQLParser::IdentifierContext::UnicodeQuotedIdentifier() {
  return getToken(PostgreSQLParser::UnicodeQuotedIdentifier, 0);
}

tree::TerminalNode* PostgreSQLParser::IdentifierContext::PLSQLVARIABLENAME() {
  return getToken(PostgreSQLParser::PLSQLVARIABLENAME, 0);
}


size_t PostgreSQLParser::IdentifierContext::getRuleIndex() const {
  return PostgreSQLParser::RuleIdentifier;
}


std::any PostgreSQLParser::IdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<PostgreSQLParserVisitor*>(visitor))
    return parserVisitor->visitIdentifier(this);
  else
    return visitor->visitChildren(this);
}

PostgreSQLParser::IdentifierContext* PostgreSQLParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1438, PostgreSQLParser::RuleIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(10517);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case PostgreSQLParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(10510);
        match(PostgreSQLParser::Identifier);
        setState(10512);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1049, _ctx)) {
        case 1: {
          setState(10511);
          uescape_();
          break;
        }

        default:
          break;
        }
        break;
      }

      case PostgreSQLParser::QuotedIdentifier: {
        enterOuterAlt(_localctx, 2);
        setState(10514);
        match(PostgreSQLParser::QuotedIdentifier);
        break;
      }

      case PostgreSQLParser::UnicodeQuotedIdentifier: {
        enterOuterAlt(_localctx, 3);
        setState(10515);
        match(PostgreSQLParser::UnicodeQuotedIdentifier);
        break;
      }

      case PostgreSQLParser::PLSQLVARIABLENAME: {
        enterOuterAlt(_localctx, 4);
        setState(10516);
        match(PostgreSQLParser::PLSQLVARIABLENAME);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool PostgreSQLParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 583: return a_expr_qualSempred(antlrcpp::downCast<A_expr_qualContext *>(context), predicateIndex);
    case 603: return b_exprSempred(antlrcpp::downCast<B_exprContext *>(context), predicateIndex);
    case 666: return json_argumentsSempred(antlrcpp::downCast<Json_argumentsContext *>(context), predicateIndex);
    case 679: return json_name_and_value_listSempred(antlrcpp::downCast<Json_name_and_value_listContext *>(context), predicateIndex);
    case 683: return json_value_expr_listSempred(antlrcpp::downCast<Json_value_expr_listContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool PostgreSQLParser::a_expr_qualSempred(A_expr_qualContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return this->OnlyAcceptableOps();

  default:
    break;
  }
  return true;
}

bool PostgreSQLParser::b_exprSempred(B_exprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return precpred(_ctx, 8);
    case 2: return precpred(_ctx, 7);
    case 3: return precpred(_ctx, 6);
    case 4: return precpred(_ctx, 5);
    case 5: return precpred(_ctx, 4);
    case 6: return precpred(_ctx, 10);
    case 7: return precpred(_ctx, 2);
    case 8: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool PostgreSQLParser::json_argumentsSempred(Json_argumentsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 9: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool PostgreSQLParser::json_name_and_value_listSempred(Json_name_and_value_listContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 10: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool PostgreSQLParser::json_value_expr_listSempred(Json_value_expr_listContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 11: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

void PostgreSQLParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  postgresqlparserParserInitialize();
#else
  ::antlr4::internal::call_once(postgresqlparserParserOnceFlag, postgresqlparserParserInitialize);
#endif
}
